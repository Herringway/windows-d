// Written in the D programming language.

module windows.systemservices;

public import windows.core;
public import windows.automation : BSTR, VARIANT;
public import windows.com : BYTE_BLOB, DWORD_BLOB, FLAGGED_BYTE_BLOB, HRESULT,
                            IUnknown;
public import windows.coreaudio : DDVIDEOPORTCONNECT;
public import windows.dbg : IMAGE_DATA_DIRECTORY, IMAGE_FILE_HEADER, WOW64_LDT_ENTRY;
public import windows.direct3d9 : D3DMATRIX;
public import windows.directdraw : DDPIXELFORMAT, DDSCAPS, DDSURFACEDESC;
public import windows.directshow : DDCOLORKEY;
public import windows.displaydevices : BLENDOBJ, BRUSHOBJ, CLIPOBJ, DDVIDEOPORTCAPS,
                                       DD_BLTDATA, DD_CALLBACKS, DD_DIRECTDRAW_GLOBAL,
                                       DD_DIRECTDRAW_LOCAL, DD_HALINFO,
                                       DD_PALETTECALLBACKS, DD_SURFACECALLBACKS,
                                       DD_SURFACE_LOCAL, DEVINFO, DEVMODEW,
                                       DRIVEROBJ, DRVENABLEDATA, FONTOBJ, GDIINFO,
                                       GLYPHDATA, IFIMETRICS, LINEATTRS, PALOBJ,
                                       PATHOBJ, PDD_GETDRIVERINFO, PERBANDINFO,
                                       POINT, POINTL, RECT, RECTL, SIZE, STROBJ,
                                       SURFOBJ, VIDEOMEMORY, VIDEOMEMORYINFO,
                                       WNDOBJ, XLATEOBJ;
public import windows.dxgi : DXGI_RGBA;
public import windows.filesystem : FILE_ID_128, LPOVERLAPPED_COMPLETION_ROUTINE,
                                   PARTITION_INFORMATION_GPT, PARTITION_STYLE,
                                   RETRIEVAL_POINTERS_BUFFER, SET_PARTITION_INFORMATION,
                                   STORAGE_PROPERTY_ID, STORAGE_PROTOCOL_TYPE,
                                   USN_RECORD_COMMON_HEADER, USN_RECORD_V2,
                                   USN_RECORD_V3, USN_RECORD_V4;
public import windows.gdi : COLORADJUSTMENT, DESIGNVECTOR, HBITMAP, HDC, LOGPALETTE,
                            TRIVERTEX, TTPOLYGONHEADER;
public import windows.kernel : EXCEPTION_ROUTINE, LIST_ENTRY, LUID, SINGLE_LIST_ENTRY;
public import windows.menusandresources : ENUMRESNAMEPROCW;
public import windows.opengl : PIXELFORMATDESCRIPTOR;
public import windows.rpc : RPC_BINDING_VECTOR, RPC_MESSAGE;
public import windows.security : ACE_HEADER, GENERIC_MAPPING, OBJECT_TYPE_LIST,
                                 PRIVILEGE_SET, PROCESS_INFORMATION_CLASS,
                                 SECURITY_IMPERSONATION_LEVEL, SID,
                                 SID_AND_ATTRIBUTES, TOKEN_GROUPS, TOKEN_PRIVILEGES,
                                 TOKEN_USER, UNICODE_STRING;
public import windows.virtualstorage : VIRTUAL_STORAGE_TYPE;
public import windows.windowsandmessaging : HWND, LPARAM;
public import windows.windowscolorsystem : LOGCOLORSPACEW;
public import windows.windowsprogramming : CloseHandle, DEP_SYSTEM_POLICY_TYPE, EventLogHandle,
                                           EventSourceHandle, FILETIME, HKEY,
                                           HeapHandle, IXMLDOMDocument,
                                           LPFIBER_START_ROUTINE, OSVERSIONINFOEXW,
                                           PPS_POST_PROCESS_INIT_ROUTINE,
                                           PROCESSINFOCLASS, PROCESS_CREATION_FLAGS,
                                           PUMS_SCHEDULER_ENTRY_POINT, SYSTEMTIME,
                                           THREADINFOCLASS, THREAD_INFORMATION_CLASS;
public import windows.xps : DEVMODEA;

extern(Windows) @nogc nothrow:


// Enums


enum ConsoleMode : int
{
    ENABLE_ECHO_INPUT                  = 0x00000004,
    ENABLE_INSERT_MODE                 = 0x00000020,
    ENABLE_LINE_INPUT                  = 0x00000002,
    ENABLE_MOUSE_INPUT                 = 0x00000010,
    ENABLE_PROCESSED_INPUT             = 0x00000001,
    ENABLE_QUICK_EDIT_MODE             = 0x00000040,
    ENABLE_WINDOW_INPUT                = 0x00000008,
    ENABLE_VIRTUAL_TERMINAL_INPUT      = 0x00000200,
    ENABLE_PROCESSED_OUTPUT            = 0x00000001,
    ENABLE_WRAP_AT_EOL_OUTPUT          = 0x00000002,
    ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x00000004,
    DISABLE_NEWLINE_AUTO_RETURN        = 0x00000008,
    ENABLE_LVB_GRID_WORLDWIDE          = 0x00000010,
}

alias PAGE_TYPE = uint;
enum : uint
{
    PAGE_NOACCESS          = 0x00000001,
    PAGE_READONLY          = 0x00000002,
    PAGE_READWRITE         = 0x00000004,
    PAGE_WRITECOPY         = 0x00000008,
    PAGE_EXECUTE           = 0x00000010,
    PAGE_EXECUTE_READ      = 0x00000020,
    PAGE_EXECUTE_READWRITE = 0x00000040,
    PAGE_EXECUTE_WRITECOPY = 0x00000080,
    PAGE_GUARD             = 0x00000100,
    PAGE_NOCACHE           = 0x00000200,
    PAGE_WRITECOMBINE      = 0x00000400,
    PAGE_TARGETS_INVALID   = 0x40000000,
    PAGE_TARGETS_NO_UPDATE = 0x40000000,
}

alias PROCESS_ACCESS_RIGHTS = uint;
enum : uint
{
    PROCESS_TERMINATE                 = 0x00000001,
    PROCESS_CREATE_THREAD             = 0x00000002,
    PROCESS_SET_SESSIONID             = 0x00000004,
    PROCESS_VM_OPERATION              = 0x00000008,
    PROCESS_VM_READ                   = 0x00000010,
    PROCESS_VM_WRITE                  = 0x00000020,
    PROCESS_DUP_HANDLE                = 0x00000040,
    PROCESS_CREATE_PROCESS            = 0x00000080,
    PROCESS_SET_QUOTA                 = 0x00000100,
    PROCESS_SET_INFORMATION           = 0x00000200,
    PROCESS_QUERY_INFORMATION         = 0x00000400,
    PROCESS_SUSPEND_RESUME            = 0x00000800,
    PROCESS_QUERY_LIMITED_INFORMATION = 0x00001000,
    PROCESS_SET_LIMITED_INFORMATION   = 0x00002000,
    PROCESS_ALL_ACCESS                = 0x001fffff,
    DELETE                            = 0x00010000,
    READ_CONTROL                      = 0x00020000,
    WRITE_DAC                         = 0x00040000,
    WRITE_OWNER                       = 0x00080000,
    SYNCHRONIZE                       = 0x00100000,
    STANDARD_RIGHTS_REQUIRED          = 0x000f0000,
}

alias JOB_OBJECT_LIMIT = uint;
enum : uint
{
    JOB_OBJECT_LIMIT_WORKINGSET                 = 0x00000001,
    JOB_OBJECT_LIMIT_PROCESS_TIME               = 0x00000002,
    JOB_OBJECT_LIMIT_JOB_TIME                   = 0x00000004,
    JOB_OBJECT_LIMIT_ACTIVE_PROCESS             = 0x00000008,
    JOB_OBJECT_LIMIT_AFFINITY                   = 0x00000010,
    JOB_OBJECT_LIMIT_PRIORITY_CLASS             = 0x00000020,
    JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME          = 0x00000040,
    JOB_OBJECT_LIMIT_SCHEDULING_CLASS           = 0x00000080,
    JOB_OBJECT_LIMIT_PROCESS_MEMORY             = 0x00000100,
    JOB_OBJECT_LIMIT_JOB_MEMORY                 = 0x00000200,
    JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH            = 0x00000200,
    JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400,
    JOB_OBJECT_LIMIT_BREAKAWAY_OK               = 0x00000800,
    JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK        = 0x00001000,
    JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE          = 0x00002000,
    JOB_OBJECT_LIMIT_SUBSET_AFFINITY            = 0x00004000,
    JOB_OBJECT_LIMIT_JOB_MEMORY_LOW             = 0x00008000,
    JOB_OBJECT_LIMIT_JOB_READ_BYTES             = 0x00010000,
    JOB_OBJECT_LIMIT_JOB_WRITE_BYTES            = 0x00020000,
    JOB_OBJECT_LIMIT_RATE_CONTROL               = 0x00040000,
    JOB_OBJECT_LIMIT_CPU_RATE_CONTROL           = 0x00040000,
    JOB_OBJECT_LIMIT_IO_RATE_CONTROL            = 0x00080000,
    JOB_OBJECT_LIMIT_NET_RATE_CONTROL           = 0x00100000,
    JOB_OBJECT_LIMIT_VALID_FLAGS                = 0x0007ffff,
    JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS          = 0x000000ff,
    JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS       = 0x00007fff,
    JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS   = 0x001f8204,
}

alias JOB_OBJECT_UILIMIT = uint;
enum : uint
{
    JOB_OBJECT_UILIMIT_NONE             = 0x00000000,
    JOB_OBJECT_UILIMIT_HANDLES          = 0x00000001,
    JOB_OBJECT_UILIMIT_READCLIPBOARD    = 0x00000002,
    JOB_OBJECT_UILIMIT_WRITECLIPBOARD   = 0x00000004,
    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008,
    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  = 0x00000010,
    JOB_OBJECT_UILIMIT_GLOBALATOMS      = 0x00000020,
    JOB_OBJECT_UILIMIT_DESKTOP          = 0x00000040,
    JOB_OBJECT_UILIMIT_EXITWINDOWS      = 0x00000080,
}

alias JOB_OBJECT_SECURITY = uint;
enum : uint
{
    JOB_OBJECT_SECURITY_NO_ADMIN         = 0x00000001,
    JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x00000002,
    JOB_OBJECT_SECURITY_ONLY_TOKEN       = 0x00000004,
    JOB_OBJECT_SECURITY_FILTER_TOKENS    = 0x00000008,
    JOB_OBJECT_SECURITY_VALID_FLAGS      = 0x0000000f,
}

alias MEMORY_RESOURCE_NOTIFICATION_TYPE = int;
enum : int
{
    LowMemoryResourceNotification  = 0x00000000,
    HighMemoryResourceNotification = 0x00000001,
}

alias OFFER_PRIORITY = int;
enum : int
{
    VmOfferPriorityVeryLow     = 0x00000001,
    VmOfferPriorityLow         = 0x00000002,
    VmOfferPriorityBelowNormal = 0x00000003,
    VmOfferPriorityNormal      = 0x00000004,
}

alias WIN32_MEMORY_INFORMATION_CLASS = int;
enum : int
{
    MemoryRegionInfo = 0x00000000,
}

///Specifies various types of storage media. Parameters and members of type **STORAGE_MEDIA_TYPE** also accept values
///from the [MEDIA_TYPE](ne-winioctl-media_type.md) enumeration type.
alias STORAGE_MEDIA_TYPE = int;
enum : int
{
    ///One of the following tape types: DAT, DDS1, DDS2, and so on.
    DDS_4mm            = 0x00000020,
    ///MiniQIC tape.
    MiniQic            = 0x00000021,
    ///Travan tape (TR-1, TR-2, TR-3, and so on).
    Travan             = 0x00000022,
    ///QIC tape.
    QIC                = 0x00000023,
    ///An 8mm Exabyte metal particle tape.
    MP_8mm             = 0x00000024,
    ///An 8mm Exabyte advanced metal evaporative tape.
    AME_8mm            = 0x00000025,
    ///An 8mm Sony AIT1 tape.
    AIT1_8mm           = 0x00000026,
    ///DLT compact tape (IIIxt or IV).
    DLT                = 0x00000027,
    ///Philips NCTP tape.
    NCTP               = 0x00000028,
    ///IBM 3480 tape.
    IBM_3480           = 0x00000029,
    ///IBM 3490E tape.
    IBM_3490E          = 0x0000002a,
    ///IBM Magstar 3590 tape.
    IBM_Magstar_3590   = 0x0000002b,
    ///IBM Magstar MP tape.
    IBM_Magstar_MP     = 0x0000002c,
    ///STK data D3 tape.
    STK_DATA_D3        = 0x0000002d,
    ///Sony DTF tape.
    SONY_DTF           = 0x0000002e,
    ///A 6mm digital videotape.
    DV_6mm             = 0x0000002f,
    ///Exabyte DMI tape (or compatible).
    DMI                = 0x00000030,
    ///Sony D2S or D2L tape.
    SONY_D2            = 0x00000031,
    ///Cleaner (all drive types that support cleaners).
    CLEANER_CARTRIDGE  = 0x00000032,
    ///CD.
    CD_ROM             = 0x00000033,
    ///CD (write once).
    CD_R               = 0x00000034,
    ///CD (rewriteable).
    CD_RW              = 0x00000035,
    ///DVD.
    DVD_ROM            = 0x00000036,
    ///DVD (write once).
    DVD_R              = 0x00000037,
    ///DVD (rewriteable).
    DVD_RW             = 0x00000038,
    ///Magneto-optical 3.5" (rewriteable).
    MO_3_RW            = 0x00000039,
    ///Magneto-optical 5.25" (write once).
    MO_5_WO            = 0x0000003a,
    ///Magneto-optical 5.25" (rewriteable; not LIMDOW).
    MO_5_RW            = 0x0000003b,
    ///Magneto-optical 5.25" (rewriteable; LIMDOW).
    MO_5_LIMDOW        = 0x0000003c,
    ///Phase change 5.25" (write once)
    PC_5_WO            = 0x0000003d,
    ///Phase change 5.25" (rewriteable)
    PC_5_RW            = 0x0000003e,
    ///Phase change dual (rewriteable)
    PD_5_RW            = 0x0000003f,
    ///Ablative 5.25" (write once).
    ABL_5_WO           = 0x00000040,
    ///Pinnacle Apex 4.6GB (rewriteable)
    PINNACLE_APEX_5_RW = 0x00000041,
    ///Sony 12" (write once).
    SONY_12_WO         = 0x00000042,
    ///Philips/LMS 12" (write once).
    PHILIPS_12_WO      = 0x00000043,
    ///Hitachi 12" (write once)
    HITACHI_12_WO      = 0x00000044,
    ///Cygnet/ATG 12" (write once)
    CYGNET_12_WO       = 0x00000045,
    ///Kodak 14" (write once)
    KODAK_14_WO        = 0x00000046,
    ///MO near field recording (Terastor)
    MO_NFR_525         = 0x00000047,
    ///Nikon 12" (rewriteable).
    NIKON_12_RW        = 0x00000048,
    ///Iomega Zip.
    IOMEGA_ZIP         = 0x00000049,
    ///Iomega Jaz.
    IOMEGA_JAZ         = 0x0000004a,
    ///Syquest EZ135.
    SYQUEST_EZ135      = 0x0000004b,
    ///Syquest EzFlyer.
    SYQUEST_EZFLYER    = 0x0000004c,
    ///Syquest SyJet.
    SYQUEST_SYJET      = 0x0000004d,
    ///Avatar 2.5" floppy.
    AVATAR_F2          = 0x0000004e,
    ///An 8mm Hitachi tape.
    MP2_8mm            = 0x0000004f,
    ///Ampex DST small tape.
    DST_S              = 0x00000050,
    ///Ampex DST medium tape.
    DST_M              = 0x00000051,
    ///Ampex DST large tape.
    DST_L              = 0x00000052,
    ///Ecrix 8mm tape.
    VXATape_1          = 0x00000053,
    ///Ecrix 8mm tape.
    VXATape_2          = 0x00000054,
    STK_9840           = 0x00000055,
    ///LTO Ultrium (IBM, HP, Seagate).
    LTO_Ultrium        = 0x00000056,
    ///LTO Accelis (IBM, HP, Seagate).
    LTO_Accelis        = 0x00000057,
    ///DVD-RAM.
    DVD_RAM            = 0x00000058,
    ///AIT tape (AIT2 or higher).
    AIT_8mm            = 0x00000059,
    ///OnStream ADR1.
    ADR_1              = 0x0000005a,
    ///OnStream ADR2.
    ADR_2              = 0x0000005b,
    ///STK 9940.
    STK_9940           = 0x0000005c,
    ///SAIT tape. **Windows Server 2003:** This is not supported before Windows Server 2003 with SP1.
    SAIT               = 0x0000005d,
    ///Exabyte VXA tape. **Windows Server 2008:** This is not supported before Windows Server 2008.
    VXATape            = 0x0000005e,
}

///Specifies the various types of storage buses.
alias STORAGE_BUS_TYPE = int;
enum : int
{
    ///Unknown bus type.
    BusTypeUnknown           = 0x00000000,
    ///SCSI bus.
    BusTypeScsi              = 0x00000001,
    ///ATAPI bus.
    BusTypeAtapi             = 0x00000002,
    ///ATA bus.
    BusTypeAta               = 0x00000003,
    ///IEEE-1394 bus.
    BusType1394              = 0x00000004,
    ///SSA bus.
    BusTypeSsa               = 0x00000005,
    ///Fibre Channel bus.
    BusTypeFibre             = 0x00000006,
    ///USB bus.
    BusTypeUsb               = 0x00000007,
    ///RAID bus.
    BusTypeRAID              = 0x00000008,
    BusTypeiScsi             = 0x00000009,
    ///Serial Attached SCSI (SAS) bus. **Windows Server 2003:** This is not supported before Windows Server 2003 with
    ///SP1.
    BusTypeSas               = 0x0000000a,
    ///SATA bus. **Windows Server 2003:** This is not supported before Windows Server 2003 with SP1.
    BusTypeSata              = 0x0000000b,
    BusTypeSd                = 0x0000000c,
    BusTypeMmc               = 0x0000000d,
    BusTypeVirtual           = 0x0000000e,
    BusTypeFileBackedVirtual = 0x0000000f,
    BusTypeSpaces            = 0x00000010,
    BusTypeNvme              = 0x00000011,
    BusTypeSCM               = 0x00000012,
    BusTypeUfs               = 0x00000013,
    BusTypeMax               = 0x00000014,
    BusTypeMaxReserved       = 0x0000007f,
}

alias STORAGE_SET_TYPE = int;
enum : int
{
    PropertyStandardSet   = 0x00000000,
    PropertyExistsSet     = 0x00000001,
    PropertySetMaxDefined = 0x00000002,
}

alias STORAGE_IDENTIFIER_CODE_SET = int;
enum : int
{
    StorageIdCodeSetReserved = 0x00000000,
    StorageIdCodeSetBinary   = 0x00000001,
    StorageIdCodeSetAscii    = 0x00000002,
    StorageIdCodeSetUtf8     = 0x00000003,
}

alias STORAGE_IDENTIFIER_TYPE = int;
enum : int
{
    StorageIdTypeVendorSpecific           = 0x00000000,
    StorageIdTypeVendorId                 = 0x00000001,
    StorageIdTypeEUI64                    = 0x00000002,
    StorageIdTypeFCPHName                 = 0x00000003,
    StorageIdTypePortRelative             = 0x00000004,
    StorageIdTypeTargetPortGroup          = 0x00000005,
    StorageIdTypeLogicalUnitGroup         = 0x00000006,
    StorageIdTypeMD5LogicalUnitIdentifier = 0x00000007,
    StorageIdTypeScsiNameString           = 0x00000008,
}

alias STORAGE_ID_NAA_FORMAT = int;
enum : int
{
    StorageIdNAAFormatIEEEExtended            = 0x00000002,
    StorageIdNAAFormatIEEERegistered          = 0x00000003,
    StorageIdNAAFormatIEEEERegisteredExtended = 0x00000005,
}

alias STORAGE_ASSOCIATION_TYPE = int;
enum : int
{
    StorageIdAssocDevice = 0x00000000,
    StorageIdAssocPort   = 0x00000001,
    StorageIdAssocTarget = 0x00000002,
}

alias STORAGE_RPMB_FRAME_TYPE = int;
enum : int
{
    StorageRpmbFrameTypeUnknown  = 0x00000000,
    StorageRpmbFrameTypeStandard = 0x00000001,
    StorageRpmbFrameTypeMax      = 0x00000002,
}

alias STORAGE_CRYPTO_ALGORITHM_ID = int;
enum : int
{
    StorageCryptoAlgorithmUnknown         = 0x00000000,
    StorageCryptoAlgorithmXTSAES          = 0x00000001,
    StorageCryptoAlgorithmBitlockerAESCBC = 0x00000002,
    StorageCryptoAlgorithmAESECB          = 0x00000003,
    StorageCryptoAlgorithmESSIVAESCBC     = 0x00000004,
    StorageCryptoAlgorithmMax             = 0x00000005,
}

alias STORAGE_CRYPTO_KEY_SIZE = int;
enum : int
{
    StorageCryptoKeySizeUnknown = 0x00000000,
    StorageCryptoKeySize128Bits = 0x00000001,
    StorageCryptoKeySize192Bits = 0x00000002,
    StorageCryptoKeySize256Bits = 0x00000003,
    StorageCryptoKeySize512Bits = 0x00000004,
}

alias STORAGE_TIER_MEDIA_TYPE = int;
enum : int
{
    StorageTierMediaTypeUnspecified = 0x00000000,
    StorageTierMediaTypeDisk        = 0x00000001,
    StorageTierMediaTypeSsd         = 0x00000002,
    StorageTierMediaTypeScm         = 0x00000004,
    StorageTierMediaTypeMax         = 0x00000005,
}

alias STORAGE_TIER_CLASS = int;
enum : int
{
    StorageTierClassUnspecified = 0x00000000,
    StorageTierClassCapacity    = 0x00000001,
    StorageTierClassPerformance = 0x00000002,
    StorageTierClassMax         = 0x00000003,
}

alias STORAGE_PROTOCOL_UFS_DATA_TYPE = int;
enum : int
{
    UfsDataTypeUnknown         = 0x00000000,
    UfsDataTypeQueryDescriptor = 0x00000001,
    UfsDataTypeMax             = 0x00000002,
}

alias STORAGE_DISK_HEALTH_STATUS = int;
enum : int
{
    DiskHealthUnknown   = 0x00000000,
    DiskHealthUnhealthy = 0x00000001,
    DiskHealthWarning   = 0x00000002,
    DiskHealthHealthy   = 0x00000003,
    DiskHealthMax       = 0x00000004,
}

alias STORAGE_DISK_OPERATIONAL_STATUS = int;
enum : int
{
    DiskOpStatusNone              = 0x00000000,
    DiskOpStatusUnknown           = 0x00000001,
    DiskOpStatusOk                = 0x00000002,
    DiskOpStatusPredictingFailure = 0x00000003,
    DiskOpStatusInService         = 0x00000004,
    DiskOpStatusHardwareError     = 0x00000005,
    DiskOpStatusNotUsable         = 0x00000006,
    DiskOpStatusTransientError    = 0x00000007,
    DiskOpStatusMissing           = 0x00000008,
}

alias STORAGE_OPERATIONAL_STATUS_REASON = int;
enum : int
{
    DiskOpReasonUnknown                      = 0x00000000,
    DiskOpReasonScsiSenseCode                = 0x00000001,
    DiskOpReasonMedia                        = 0x00000002,
    DiskOpReasonIo                           = 0x00000003,
    DiskOpReasonThresholdExceeded            = 0x00000004,
    DiskOpReasonLostData                     = 0x00000005,
    DiskOpReasonEnergySource                 = 0x00000006,
    DiskOpReasonConfiguration                = 0x00000007,
    DiskOpReasonDeviceController             = 0x00000008,
    DiskOpReasonMediaController              = 0x00000009,
    DiskOpReasonComponent                    = 0x0000000a,
    DiskOpReasonNVDIMM_N                     = 0x0000000b,
    DiskOpReasonBackgroundOperation          = 0x0000000c,
    DiskOpReasonInvalidFirmware              = 0x0000000d,
    DiskOpReasonHealthCheck                  = 0x0000000e,
    DiskOpReasonLostDataPersistence          = 0x0000000f,
    DiskOpReasonDisabledByPlatform           = 0x00000010,
    DiskOpReasonLostWritePersistence         = 0x00000011,
    DiskOpReasonDataPersistenceLossImminent  = 0x00000012,
    DiskOpReasonWritePersistenceLossImminent = 0x00000013,
    DiskOpReasonMax                          = 0x00000014,
}

alias STORAGE_ZONED_DEVICE_TYPES = int;
enum : int
{
    ZonedDeviceTypeUnknown       = 0x00000000,
    ZonedDeviceTypeHostManaged   = 0x00000001,
    ZonedDeviceTypeHostAware     = 0x00000002,
    ZonedDeviceTypeDeviceManaged = 0x00000003,
}

alias STORAGE_ZONE_TYPES = int;
enum : int
{
    ZoneTypeUnknown                  = 0x00000000,
    ZoneTypeConventional             = 0x00000001,
    ZoneTypeSequentialWriteRequired  = 0x00000002,
    ZoneTypeSequentialWritePreferred = 0x00000003,
    ZoneTypeMax                      = 0x00000004,
}

alias STORAGE_ZONES_ATTRIBUTES = int;
enum : int
{
    ZonesAttributeTypeAndLengthMayDifferent       = 0x00000000,
    ZonesAttributeTypeSameLengthSame              = 0x00000001,
    ZonesAttributeTypeSameLastZoneLengthDifferent = 0x00000002,
    ZonesAttributeTypeMayDifferentLengthSame      = 0x00000003,
}

alias STORAGE_ZONE_CONDITION = int;
enum : int
{
    ZoneConditionConventional     = 0x00000000,
    ZoneConditionEmpty            = 0x00000001,
    ZoneConditionImplicitlyOpened = 0x00000002,
    ZoneConditionExplicitlyOpened = 0x00000003,
    ZoneConditionClosed           = 0x00000004,
    ZoneConditionReadOnly         = 0x0000000d,
    ZoneConditionFull             = 0x0000000e,
    ZoneConditionOffline          = 0x0000000f,
}

alias STORAGE_DIAGNOSTIC_LEVEL = int;
enum : int
{
    StorageDiagnosticLevelDefault = 0x00000000,
    StorageDiagnosticLevelMax     = 0x00000001,
}

alias STORAGE_DIAGNOSTIC_TARGET_TYPE = int;
enum : int
{
    StorageDiagnosticTargetTypeUndefined   = 0x00000000,
    StorageDiagnosticTargetTypePort        = 0x00000001,
    StorageDiagnosticTargetTypeMiniport    = 0x00000002,
    StorageDiagnosticTargetTypeHbaFirmware = 0x00000003,
    StorageDiagnosticTargetTypeMax         = 0x00000004,
}

alias DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE = int;
enum : int
{
    DeviceInternalStatusDataRequestTypeUndefined = 0x00000000,
    DeviceCurrentInternalStatusDataHeader        = 0x00000001,
    DeviceCurrentInternalStatusData              = 0x00000002,
}

alias DEVICE_INTERNAL_STATUS_DATA_SET = int;
enum : int
{
    DeviceStatusDataSetUndefined = 0x00000000,
    DeviceStatusDataSet1         = 0x00000001,
    DeviceStatusDataSet2         = 0x00000002,
    DeviceStatusDataSet3         = 0x00000003,
    DeviceStatusDataSet4         = 0x00000004,
    DeviceStatusDataSetMax       = 0x00000005,
}

alias _DEVICEDUMP_COLLECTION_TYPE = int;
enum : int
{
    TCCollectionBugCheck             = 0x00000001,
    TCCollectionApplicationRequested = 0x00000002,
    TCCollectionDeviceRequested      = 0x00000003,
}

alias STORAGE_POWERUP_REASON_TYPE = int;
enum : int
{
    StoragePowerupUnknown         = 0x00000000,
    StoragePowerupIO              = 0x00000001,
    StoragePowerupDeviceAttention = 0x00000002,
}

alias STORAGE_RPMB_COMMAND_TYPE = int;
enum : int
{
    StorRpmbProgramAuthKey                 = 0x00000001,
    StorRpmbQueryWriteCounter              = 0x00000002,
    StorRpmbAuthenticatedWrite             = 0x00000003,
    StorRpmbAuthenticatedRead              = 0x00000004,
    StorRpmbReadResultRequest              = 0x00000005,
    StorRpmbAuthenticatedDeviceConfigWrite = 0x00000006,
    StorRpmbAuthenticatedDeviceConfigRead  = 0x00000007,
}

alias STORAGE_COUNTER_TYPE = int;
enum : int
{
    StorageCounterTypeUnknown                 = 0x00000000,
    StorageCounterTypeTemperatureCelsius      = 0x00000001,
    StorageCounterTypeTemperatureCelsiusMax   = 0x00000002,
    StorageCounterTypeReadErrorsTotal         = 0x00000003,
    StorageCounterTypeReadErrorsCorrected     = 0x00000004,
    StorageCounterTypeReadErrorsUncorrected   = 0x00000005,
    StorageCounterTypeWriteErrorsTotal        = 0x00000006,
    StorageCounterTypeWriteErrorsCorrected    = 0x00000007,
    StorageCounterTypeWriteErrorsUncorrected  = 0x00000008,
    StorageCounterTypeManufactureDate         = 0x00000009,
    StorageCounterTypeStartStopCycleCount     = 0x0000000a,
    StorageCounterTypeStartStopCycleCountMax  = 0x0000000b,
    StorageCounterTypeLoadUnloadCycleCount    = 0x0000000c,
    StorageCounterTypeLoadUnloadCycleCountMax = 0x0000000d,
    StorageCounterTypeWearPercentage          = 0x0000000e,
    StorageCounterTypeWearPercentageWarning   = 0x0000000f,
    StorageCounterTypeWearPercentageMax       = 0x00000010,
    StorageCounterTypePowerOnHours            = 0x00000011,
    StorageCounterTypeReadLatency100NSMax     = 0x00000012,
    StorageCounterTypeWriteLatency100NSMax    = 0x00000013,
    StorageCounterTypeFlushLatency100NSMax    = 0x00000014,
    StorageCounterTypeMax                     = 0x00000015,
}

alias STORAGE_ATTRIBUTE_MGMT_ACTION = int;
enum : int
{
    StorAttributeMgmt_ClearAttribute = 0x00000000,
    StorAttributeMgmt_SetAttribute   = 0x00000001,
    StorAttributeMgmt_ResetAttribute = 0x00000002,
}

alias SCM_REGION_FLAG = int;
enum : int
{
    ScmRegionFlagNone  = 0x00000000,
    ScmRegionFlagLabel = 0x00000001,
}

alias SCM_PD_QUERY_TYPE = int;
enum : int
{
    ScmPhysicalDeviceQuery_Descriptor  = 0x00000000,
    ScmPhysicalDeviceQuery_IsSupported = 0x00000001,
    ScmPhysicalDeviceQuery_Max         = 0x00000002,
}

alias SCM_PD_PROPERTY_ID = int;
enum : int
{
    ScmPhysicalDeviceProperty_DeviceInfo         = 0x00000000,
    ScmPhysicalDeviceProperty_ManagementStatus   = 0x00000001,
    ScmPhysicalDeviceProperty_FirmwareInfo       = 0x00000002,
    ScmPhysicalDeviceProperty_LocationString     = 0x00000003,
    ScmPhysicalDeviceProperty_DeviceSpecificInfo = 0x00000004,
    ScmPhysicalDeviceProperty_DeviceHandle       = 0x00000005,
    ScmPhysicalDeviceProperty_Max                = 0x00000006,
}

alias SCM_PD_HEALTH_STATUS = int;
enum : int
{
    ScmPhysicalDeviceHealth_Unknown   = 0x00000000,
    ScmPhysicalDeviceHealth_Unhealthy = 0x00000001,
    ScmPhysicalDeviceHealth_Warning   = 0x00000002,
    ScmPhysicalDeviceHealth_Healthy   = 0x00000003,
    ScmPhysicalDeviceHealth_Max       = 0x00000004,
}

alias SCM_PD_OPERATIONAL_STATUS = int;
enum : int
{
    ScmPhysicalDeviceOpStatus_Unknown           = 0x00000000,
    ScmPhysicalDeviceOpStatus_Ok                = 0x00000001,
    ScmPhysicalDeviceOpStatus_PredictingFailure = 0x00000002,
    ScmPhysicalDeviceOpStatus_InService         = 0x00000003,
    ScmPhysicalDeviceOpStatus_HardwareError     = 0x00000004,
    ScmPhysicalDeviceOpStatus_NotUsable         = 0x00000005,
    ScmPhysicalDeviceOpStatus_TransientError    = 0x00000006,
    ScmPhysicalDeviceOpStatus_Missing           = 0x00000007,
    ScmPhysicalDeviceOpStatus_Max               = 0x00000008,
}

alias SCM_PD_OPERATIONAL_STATUS_REASON = int;
enum : int
{
    ScmPhysicalDeviceOpReason_Unknown                      = 0x00000000,
    ScmPhysicalDeviceOpReason_Media                        = 0x00000001,
    ScmPhysicalDeviceOpReason_ThresholdExceeded            = 0x00000002,
    ScmPhysicalDeviceOpReason_LostData                     = 0x00000003,
    ScmPhysicalDeviceOpReason_EnergySource                 = 0x00000004,
    ScmPhysicalDeviceOpReason_Configuration                = 0x00000005,
    ScmPhysicalDeviceOpReason_DeviceController             = 0x00000006,
    ScmPhysicalDeviceOpReason_MediaController              = 0x00000007,
    ScmPhysicalDeviceOpReason_Component                    = 0x00000008,
    ScmPhysicalDeviceOpReason_BackgroundOperation          = 0x00000009,
    ScmPhysicalDeviceOpReason_InvalidFirmware              = 0x0000000a,
    ScmPhysicalDeviceOpReason_HealthCheck                  = 0x0000000b,
    ScmPhysicalDeviceOpReason_LostDataPersistence          = 0x0000000c,
    ScmPhysicalDeviceOpReason_DisabledByPlatform           = 0x0000000d,
    ScmPhysicalDeviceOpReason_PermanentError               = 0x0000000e,
    ScmPhysicalDeviceOpReason_LostWritePersistence         = 0x0000000f,
    ScmPhysicalDeviceOpReason_FatalError                   = 0x00000010,
    ScmPhysicalDeviceOpReason_DataPersistenceLossImminent  = 0x00000011,
    ScmPhysicalDeviceOpReason_WritePersistenceLossImminent = 0x00000012,
    ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock     = 0x00000013,
    ScmPhysicalDeviceOpReason_PerformanceDegradation       = 0x00000014,
    ScmPhysicalDeviceOpReason_ExcessiveTemperature         = 0x00000015,
    ScmPhysicalDeviceOpReason_Max                          = 0x00000016,
}

alias SCM_PD_MEDIA_REINITIALIZATION_STATUS = int;
enum : int
{
    ScmPhysicalDeviceReinit_Success        = 0x00000000,
    ScmPhysicalDeviceReinit_RebootNeeded   = 0x00000001,
    ScmPhysicalDeviceReinit_ColdBootNeeded = 0x00000002,
    ScmPhysicalDeviceReinit_Max            = 0x00000003,
}

alias DETECTION_TYPE = int;
enum : int
{
    DetectNone    = 0x00000000,
    DetectInt13   = 0x00000001,
    DetectExInt13 = 0x00000002,
}

alias DISK_CACHE_RETENTION_PRIORITY = int;
enum : int
{
    EqualPriority      = 0x00000000,
    KeepPrefetchedData = 0x00000001,
    KeepReadData       = 0x00000002,
}

alias BIN_TYPES = int;
enum : int
{
    RequestSize     = 0x00000000,
    RequestLocation = 0x00000001,
}

///Specifies the element type of a changer device.
alias ELEMENT_TYPE = int;
enum : int
{
    ///All elements of a changer, including its robotic transport, drives, slots, and insert/eject ports. This value is
    ///valid only with [IOCTL_CHANGER_GET_ELEMENT_STATUS](ni-winioctl-ioctl_changer_get_element_status.md) or
    ///[IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS](ni-winioctl-ioctl_changer_initialize_element_status.md).
    AllElements       = 0x00000000,
    ///Robotic transport element, which is used to move media between insert/eject ports, slots, and drives.
    ChangerTransport  = 0x00000001,
    ///Storage element, which is a slot in the changer in which media is stored when not mounted in a drive.
    ChangerSlot       = 0x00000002,
    ///Insert/eject port, which is a single- or multiple-cartridge access port in some changers. An element is an
    ///insert/eject port only if it is possible to move a piece of media from a slot to the insert/eject port.
    ChangerIEPort     = 0x00000003,
    ///Data transfer element where data can be read from and written to media.
    ChangerDrive      = 0x00000004,
    ///Mechanism that provides access to all media in a changer at one time (as compared to an IEport that provides
    ///access to one or more, but not all, media). For example, a large front door or a magazine that contains all media
    ///in the changer is an element of this type. This value is valid only with
    ///[IOCTL_CHANGER_SET_ACCESS](ni-winioctl-ioctl_changer_set_access.md).
    ChangerDoor       = 0x00000005,
    ///Keypad or other input control on the front panel of a changer. This value is valid only with
    ///[IOCTL_CHANGER_SET_ACCESS](ni-winioctl-ioctl_changer_set_access.md).
    ChangerKeypad     = 0x00000006,
    ChangerMaxElement = 0x00000007,
}

alias CHANGER_DEVICE_PROBLEM_TYPE = int;
enum : int
{
    DeviceProblemNone                 = 0x00000000,
    DeviceProblemHardware             = 0x00000001,
    DeviceProblemCHMError             = 0x00000002,
    DeviceProblemDoorOpen             = 0x00000003,
    DeviceProblemCalibrationError     = 0x00000004,
    DeviceProblemTargetFailure        = 0x00000005,
    DeviceProblemCHMMoveError         = 0x00000006,
    DeviceProblemCHMZeroError         = 0x00000007,
    DeviceProblemCartridgeInsertError = 0x00000008,
    DeviceProblemPositionError        = 0x00000009,
    DeviceProblemSensorError          = 0x0000000a,
    DeviceProblemCartridgeEjectError  = 0x0000000b,
    DeviceProblemGripperError         = 0x0000000c,
    DeviceProblemDriveError           = 0x0000000d,
}

alias SHRINK_VOLUME_REQUEST_TYPES = int;
enum : int
{
    ShrinkPrepare = 0x00000001,
    ShrinkCommit  = 0x00000002,
    ShrinkAbort   = 0x00000003,
}

alias CSVFS_DISK_CONNECTIVITY = int;
enum : int
{
    CsvFsDiskConnectivityNone          = 0x00000000,
    CsvFsDiskConnectivityMdsNodeOnly   = 0x00000001,
    CsvFsDiskConnectivitySubsetOfNodes = 0x00000002,
    CsvFsDiskConnectivityAllNodes      = 0x00000003,
}

alias STORAGE_RESERVE_ID = int;
enum : int
{
    StorageReserveIdNone          = 0x00000000,
    StorageReserveIdHard          = 0x00000001,
    StorageReserveIdSoft          = 0x00000002,
    StorageReserveIdUpdateScratch = 0x00000003,
    StorageReserveIdMax           = 0x00000004,
}

alias QUERY_FILE_LAYOUT_FILTER_TYPE = int;
enum : int
{
    QUERY_FILE_LAYOUT_FILTER_TYPE_NONE               = 0x00000000,
    QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS           = 0x00000001,
    QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID             = 0x00000002,
    QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID = 0x00000003,
    QUERY_FILE_LAYOUT_NUM_FILTER_TYPES               = 0x00000004,
}

alias FILE_STORAGE_TIER_CLASS = int;
enum : int
{
    FileStorageTierClassUnspecified = 0x00000000,
    FileStorageTierClassCapacity    = 0x00000001,
    FileStorageTierClassPerformance = 0x00000002,
    FileStorageTierClassMax         = 0x00000003,
}

alias REFS_SMR_VOLUME_GC_STATE = int;
enum : int
{
    SmrGcStateInactive        = 0x00000000,
    SmrGcStatePaused          = 0x00000001,
    SmrGcStateActive          = 0x00000002,
    SmrGcStateActiveFullSpeed = 0x00000003,
}

alias REFS_SMR_VOLUME_GC_ACTION = int;
enum : int
{
    SmrGcActionStart          = 0x00000001,
    SmrGcActionStartFullSpeed = 0x00000002,
    SmrGcActionPause          = 0x00000003,
    SmrGcActionStop           = 0x00000004,
}

alias REFS_SMR_VOLUME_GC_METHOD = int;
enum : int
{
    SmrGcMethodCompaction  = 0x00000001,
    SmrGcMethodCompression = 0x00000002,
    SmrGcMethodRotation    = 0x00000003,
}

alias VIRTUAL_STORAGE_BEHAVIOR_CODE = int;
enum : int
{
    VirtualStorageBehaviorUndefined         = 0x00000000,
    VirtualStorageBehaviorCacheWriteThrough = 0x00000001,
    VirtualStorageBehaviorCacheWriteBack    = 0x00000002,
}

alias BIDI_TYPE = int;
enum : int
{
    BIDI_NULL   = 0x00000000,
    BIDI_INT    = 0x00000001,
    BIDI_FLOAT  = 0x00000002,
    BIDI_BOOL   = 0x00000003,
    BIDI_STRING = 0x00000004,
    BIDI_TEXT   = 0x00000005,
    BIDI_ENUM   = 0x00000006,
    BIDI_BLOB   = 0x00000007,
}

alias PRINTER_OPTION_FLAGS = int;
enum : int
{
    PRINTER_OPTION_NO_CACHE       = 0x00000001,
    PRINTER_OPTION_CACHE          = 0x00000002,
    PRINTER_OPTION_CLIENT_CHANGE  = 0x00000004,
    PRINTER_OPTION_NO_CLIENT_DATA = 0x00000008,
}

enum EPrintPropertyType : int
{
    kPropertyTypeString              = 0x00000001,
    kPropertyTypeInt32               = 0x00000002,
    kPropertyTypeInt64               = 0x00000003,
    kPropertyTypeByte                = 0x00000004,
    kPropertyTypeTime                = 0x00000005,
    kPropertyTypeDevMode             = 0x00000006,
    kPropertyTypeSD                  = 0x00000007,
    kPropertyTypeNotificationReply   = 0x00000008,
    kPropertyTypeNotificationOptions = 0x00000009,
    kPropertyTypeBuffer              = 0x0000000a,
}

enum EPrintXPSJobProgress : int
{
    kAddingDocumentSequence = 0x00000000,
    kDocumentSequenceAdded  = 0x00000001,
    kAddingFixedDocument    = 0x00000002,
    kFixedDocumentAdded     = 0x00000003,
    kAddingFixedPage        = 0x00000004,
    kFixedPageAdded         = 0x00000005,
    kResourceAdded          = 0x00000006,
    kFontAdded              = 0x00000007,
    kImageAdded             = 0x00000008,
    kXpsDocumentCommitted   = 0x00000009,
}

enum EPrintXPSJobOperation : int
{
    kJobProduction  = 0x00000001,
    kJobConsumption = 0x00000002,
}

alias PRINT_EXECUTION_CONTEXT = int;
enum : int
{
    PRINT_EXECUTION_CONTEXT_APPLICATION            = 0x00000000,
    PRINT_EXECUTION_CONTEXT_SPOOLER_SERVICE        = 0x00000001,
    PRINT_EXECUTION_CONTEXT_SPOOLER_ISOLATION_HOST = 0x00000002,
    PRINT_EXECUTION_CONTEXT_FILTER_PIPELINE        = 0x00000003,
    PRINT_EXECUTION_CONTEXT_WOW64                  = 0x00000004,
}

///Specifies the threading apartment type for a new DispatcherQueueController.
alias DISPATCHERQUEUE_THREAD_APARTMENTTYPE = int;
enum : int
{
    ///No COM threading apartment type specified.
    DQTAT_COM_NONE = 0x00000000,
    ///Specifies an application single-threaded apartment (ASTA) COM threading apartment.
    DQTAT_COM_ASTA = 0x00000001,
    ///Specifies a single-threaded apartment (STA) COM threading apartment.
    DQTAT_COM_STA  = 0x00000002,
}

///Specifies the thread affinity for a new DispatcherQueueController.
alias DISPATCHERQUEUE_THREAD_TYPE = int;
enum : int
{
    ///Specifies that the DispatcherQueueController be created on a dedicated thread. With this option,
    ///CreateDispatcherQueueController creates a thread, the DispatcherQueueController instance, and runs the dispatcher
    ///queue event loop on the newly created thread.
    DQTYPE_THREAD_DEDICATED = 0x00000001,
    ///Specifies that the DispatcherQueueController will be created on the caller's thread.
    DQTYPE_THREAD_CURRENT   = 0x00000002,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of the valid code sets (encodings) of a storage
///identifier.
alias VDS_STORAGE_IDENTIFIER_CODE_SET = int;
enum : int
{
    ///This value is reserved.
    VDSStorageIdCodeSetReserved = 0x00000000,
    ///The storage identifier is encoded as binary data.
    VDSStorageIdCodeSetBinary   = 0x00000001,
    ///The storage identifier is encoded as ASCII data.
    VDSStorageIdCodeSetAscii    = 0x00000002,
    ///The storage identifier is encoded as UTF-8. <b>Windows Vista and Windows Server 2003: </b>Not supported before
    ///Windows Vista with SP1 and Windows Server 2008.
    VDSStorageIdCodeSetUtf8     = 0x00000003,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for a storage identifier.
alias VDS_STORAGE_IDENTIFIER_TYPE = int;
enum : int
{
    ///The storage identifier type is vendor specific.
    VDSStorageIdTypeVendorSpecific           = 0x00000000,
    ///The storage identifier is the same as the vendor identifier.
    VDSStorageIdTypeVendorId                 = 0x00000001,
    ///The storage identifier type follows the IEEE 64-bit Extended Unique Identifier (EUI-64) standard.
    VDSStorageIdTypeEUI64                    = 0x00000002,
    ///The storage identifier type follows the Fibre Channel Physical and Signaling Interface (FC-PH) naming convention.
    VDSStorageIdTypeFCPHName                 = 0x00000003,
    ///<b>VDS 1.1: </b>The storage identifier type is dependent on the port.
    VDSStorageIdTypePortRelative             = 0x00000004,
    VDSStorageIdTypeTargetPortGroup          = 0x00000005,
    VDSStorageIdTypeLogicalUnitGroup         = 0x00000006,
    VDSStorageIdTypeMD5LogicalUnitIdentifier = 0x00000007,
    VDSStorageIdTypeScsiNameString           = 0x00000008,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid bus types of a storage device.
alias VDS_STORAGE_BUS_TYPE = int;
enum : int
{
    ///This value is reserved.
    VDSBusTypeUnknown           = 0x00000000,
    ///The storage bus type is SCSI.
    VDSBusTypeScsi              = 0x00000001,
    ///The storage bus type is ATAPI.
    VDSBusTypeAtapi             = 0x00000002,
    ///The storage bus type is ATA.
    VDSBusTypeAta               = 0x00000003,
    ///The storage bus type is IEEE 1394.
    VDSBusType1394              = 0x00000004,
    ///The storage bus type is SSA.
    VDSBusTypeSsa               = 0x00000005,
    ///The storage bus type is Fibre Channel.
    VDSBusTypeFibre             = 0x00000006,
    ///The storage bus type is USB.
    VDSBusTypeUsb               = 0x00000007,
    ///The storage bus type is RAID.
    VDSBusTypeRAID              = 0x00000008,
    ///The storage bus type is iSCSI.
    VDSBusTypeiScsi             = 0x00000009,
    ///The storage bus type is Serial Attached SCSI (SAS).
    VDSBusTypeSas               = 0x0000000a,
    ///The storage bus type is SATA.
    VDSBusTypeSata              = 0x0000000b,
    ///The storage bus type is Secure Digital (SD). <b>Windows Server 2008, Windows Vista and Windows Server 2003:
    ///</b>Not supported.
    VDSBusTypeSd                = 0x0000000c,
    ///The storage bus type is MultiMedia Card (MMC). <b>Windows Server 2008, Windows Vista and Windows Server 2003:
    ///</b>Not supported.
    VDSBusTypeMmc               = 0x0000000d,
    ///This value is reserved for system use. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not
    ///supported.
    VDSBusTypeMax               = 0x0000000e,
    VDSBusTypeVirtual           = 0x0000000e,
    ///The storage bus type is file-backed virtual. <b>Windows Server 2008, Windows Vista and Windows Server 2003:
    ///</b>Not supported.
    VDSBusTypeFileBackedVirtual = 0x0000000f,
    VDSBusTypeSpaces            = 0x00000010,
    VDSBusTypeNVMe              = 0x00000011,
    VDSBusTypeScm               = 0x00000012,
    VDSBusTypeUfs               = 0x00000013,
    ///The maximum value of the storage bus type range.
    VDSBusTypeMaxReserved       = 0x0000007f,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of the valid address types of a physical
///interconnect.
alias VDS_INTERCONNECT_ADDRESS_TYPE = int;
enum : int
{
    ///This value is reserved.
    VDS_IA_UNKNOWN = 0x00000000,
    ///The address type is FCFS.
    VDS_IA_FCFS    = 0x00000001,
    ///The address type is FCPH.
    VDS_IA_FCPH    = 0x00000002,
    ///The address type is FCPH3.
    VDS_IA_FCPH3   = 0x00000003,
    ///The address type is MAC.
    VDS_IA_MAC     = 0x00000004,
    ///The address type is SCSI.
    VDS_IA_SCSI    = 0x00000005,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types of a VDS object.
alias VDS_OBJECT_TYPE = int;
enum : int
{
    ///This value is reserved.
    VDS_OT_UNKNOWN      = 0x00000000,
    ///The object is a provider.
    VDS_OT_PROVIDER     = 0x00000001,
    ///The object is a disk pack.
    VDS_OT_PACK         = 0x0000000a,
    ///The object is a volume.
    VDS_OT_VOLUME       = 0x0000000b,
    ///The object is a volume plex.
    VDS_OT_VOLUME_PLEX  = 0x0000000c,
    ///The object is a disk.
    VDS_OT_DISK         = 0x0000000d,
    ///The object is a subsystem.
    VDS_OT_SUB_SYSTEM   = 0x0000001e,
    ///The object is a controller.
    VDS_OT_CONTROLLER   = 0x0000001f,
    ///The object is a drive.
    VDS_OT_DRIVE        = 0x00000020,
    ///The object is a LUN.
    VDS_OT_LUN          = 0x00000021,
    ///The object is a LUN plex.
    VDS_OT_LUN_PLEX     = 0x00000022,
    ///The object is a controller port.
    VDS_OT_PORT         = 0x00000023,
    ///The object is an iSCSI portal.
    VDS_OT_PORTAL       = 0x00000024,
    ///The object is an iSCSI target.
    VDS_OT_TARGET       = 0x00000025,
    ///The object is an iSCSI portal group.
    VDS_OT_PORTAL_GROUP = 0x00000026,
    ///The object is a storage pool. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not supported.
    VDS_OT_STORAGE_POOL = 0x00000027,
    ///The object is an HBA port.
    VDS_OT_HBAPORT      = 0x0000005a,
    ///The object is an iSCSI initiator adapter.
    VDS_OT_INIT_ADAPTER = 0x0000005b,
    ///The object is an iSCSI initiator portal.
    VDS_OT_INIT_PORTAL  = 0x0000005c,
    ///This value is reserved.
    VDS_OT_ASYNC        = 0x00000064,
    ///This value is reserved.
    VDS_OT_ENUM         = 0x00000065,
    ///The object is a virtual disk. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not supported.
    VDS_OT_VDISK        = 0x000000c8,
    ///This value is reserved. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not supported.
    VDS_OT_OPEN_VDISK   = 0x000000c9,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for a provider.
alias VDS_PROVIDER_TYPE = int;
enum : int
{
    ///The provider type is unknown.
    VDS_PT_UNKNOWN     = 0x00000000,
    ///The provider is a software provider.
    VDS_PT_SOFTWARE    = 0x00000001,
    ///The provider is a hardware provider.
    VDS_PT_HARDWARE    = 0x00000002,
    ///The provider is a virtual disk provider. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not
    ///supported.
    VDS_PT_VIRTUALDISK = 0x00000003,
    ///This value is reserved for system use. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not
    ///supported.
    VDS_PT_MAX         = 0x00000004,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid flags for a provider object.
alias VDS_PROVIDER_FLAG = int;
enum : int
{
    ///The provider is a dynamic provider. If this flag is set for the provider of a disk, the disk is dynamic.
    VDS_PF_DYNAMIC                         = 0x00000001,
    ///The operating system supplies this hardware provider to manage an internal hardware controller.
    VDS_PF_INTERNAL_HARDWARE_PROVIDER      = 0x00000002,
    ///The provider supports single-disk packs only. Typically, the basic provider sets this flag to simulate a pack
    ///with one disk.
    VDS_PF_ONE_DISK_ONLY_PER_PACK          = 0x00000004,
    ///The provider is a dynamic provider that supports online status for only one pack at a time. <b>Windows Server
    ///2003: </b>Only applies to this release.
    VDS_PF_ONE_PACK_ONLINE_ONLY            = 0x00000008,
    ///All volumes managed by this provider must have contiguous space. This flag applies to basic providers only.
    VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS = 0x00000010,
    ///If this flag is set, VDS sets the <b>VDS_SVF_SUPPORT_DYNAMIC</b> flag in the VDS_SERVICE_PROP structure.
    VDS_PF_SUPPORT_DYNAMIC                 = 0x80000000,
    ///If this flag is set, VDS sets the <b>VDS_SVF_SUPPORT_FAULT_TOLERANT</b> flag in the VDS_SERVICE_PROP structure.
    VDS_PF_SUPPORT_FAULT_TOLERANT          = 0x40000000,
    ///If this flag is set, VDS sets the <b>VDS_SVF_SUPPORT_DYNAMIC_1394</b> flag in the VDS_SERVICE_PROP structure.
    VDS_PF_SUPPORT_DYNAMIC_1394            = 0x20000000,
    ///If this flag is set, VDS sets the <b>VDS_SVF_SUPPORT_MIRROR</b> flag in the VDS_SERVICE_PROP structure.
    ///<b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not supported.
    VDS_PF_SUPPORT_MIRROR                  = 0x00000020,
    ///If this flag is set, VDS sets the <b>VDS_SVF_SUPPORT_RAID5</b> flag in the VDS_SERVICE_PROP structure. <b>Windows
    ///Server 2008, Windows Vista and Windows Server 2003: </b>Not supported.
    VDS_PF_SUPPORT_RAID5                   = 0x00000040,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Not supported. This enumeration is reserved for system use.
alias VDS_RECOVER_ACTION = int;
enum : int
{
    VDS_RA_UNKNOWN = 0x00000000,
    VDS_RA_REFRESH = 0x00000001,
    VDS_RA_RESTART = 0x00000002,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of the valid target types (subjects) of a VDS
///notification.
alias VDS_NOTIFICATION_TARGET_TYPE = int;
enum : int
{
    ///This value is reserved.
    VDS_NTT_UNKNOWN      = 0x00000000,
    ///The target is a disk pack. This value corresponds to the <b>VDS_OT_PACK</b> value in the VDS_OBJECT_TYPE
    ///enumeration.
    VDS_NTT_PACK         = 0x0000000a,
    ///The target is a volume. This value corresponds to the <b>VDS_OT_VOLUME</b> value in the VDS_OBJECT_TYPE
    ///enumeration.
    VDS_NTT_VOLUME       = 0x0000000b,
    ///The target is a disk. This value corresponds to the <b>VDS_OT_DISK</b> value in the VDS_OBJECT_TYPE enumeration.
    VDS_NTT_DISK         = 0x0000000d,
    ///The target is a partition.
    VDS_NTT_PARTITION    = 0x0000003c,
    ///The target is a drive letter.
    VDS_NTT_DRIVE_LETTER = 0x0000003d,
    ///The target is a file system.
    VDS_NTT_FILE_SYSTEM  = 0x0000003e,
    ///The target is a drive letter or volume GUID path.
    VDS_NTT_MOUNT_POINT  = 0x0000003f,
    ///The target is a subsystem. This value corresponds to the <b>VDS_OT_SUB_SYSTEM</b> value in the VDS_OBJECT_TYPE
    ///enumeration.
    VDS_NTT_SUB_SYSTEM   = 0x0000001e,
    ///The target is a controller. This value corresponds to the <b>VDS_OT_CONTROLLER</b> value in the VDS_OBJECT_TYPE
    ///enumeration.
    VDS_NTT_CONTROLLER   = 0x0000001f,
    ///The target is a drive. This value corresponds to the <b>VDS_OT_DRIVE</b> value in the VDS_OBJECT_TYPE
    ///enumeration.
    VDS_NTT_DRIVE        = 0x00000020,
    ///The target is a LUN. This value corresponds to the <b>VDS_OT_LUN</b> value in the VDS_OBJECT_TYPE enumeration.
    VDS_NTT_LUN          = 0x00000021,
    ///The target is a controller port. This value corresponds to the <b>VDS_OT_PORT</b> value in the VDS_OBJECT_TYPE
    ///enumeration. <div class="alert"><b>Note</b> This value is not supported on VDS 1.0.</div> <div> </div>
    VDS_NTT_PORT         = 0x00000023,
    ///The target is an iSCSI portal. This value corresponds to the <b>VDS_OT_PORTAL</b> value in the VDS_OBJECT_TYPE
    ///enumeration. <div class="alert"><b>Note</b> This value is not supported on VDS 1.0.</div> <div> </div>
    VDS_NTT_PORTAL       = 0x00000024,
    ///The target is a target. This value corresponds to the <b>VDS_OT_TARGET</b> value in the VDS_OBJECT_TYPE
    ///enumeration. <div class="alert"><b>Note</b> This value is not supported on VDS 1.0.</div> <div> </div>
    VDS_NTT_TARGET       = 0x00000025,
    ///The target is an iSCSI portal group. This value corresponds to the <b>VDS_PORTAL_GROUP</b> value in the
    ///VDS_OBJECT_TYPE enumeration. <div class="alert"><b>Note</b> This value is not supported on VDS 1.0.</div> <div>
    ///</div>
    VDS_NTT_PORTAL_GROUP = 0x00000026,
    ///This member is not currently used.
    VDS_NTT_SERVICE      = 0x000000c8,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of operations that objects can process.
alias VDS_ASYNC_OUTPUT_TYPE = int;
enum : int
{
    ///The value is reserved.
    VDS_ASYNCOUT_UNKNOWN           = 0x00000000,
    ///The operation returns the IUnknown pointer for the newly created volume object. For operation details, see the
    ///IVdsPack::CreateVolume method.
    VDS_ASYNCOUT_CREATEVOLUME      = 0x00000001,
    ///The operation expands the size of the current volume by adding disk extents to each member of each plex. For
    ///operation details, see the IVdsVolume::Extend method.
    VDS_ASYNCOUT_EXTENDVOLUME      = 0x00000002,
    ///The operation reduces the size of the volume and all plexes and returns the released extents to free space. For
    ///operation details, see the IVdsVolume::Shrink method.
    VDS_ASYNCOUT_SHRINKVOLUME      = 0x00000003,
    ///The operation adds a volume as a plex to the current volume. For operation details, see the IVdsVolume::AddPlex
    ///method.
    VDS_ASYNCOUT_ADDVOLUMEPLEX     = 0x00000004,
    ///The operation returns the IUnknown pointer for the hidden volume object. For operation details, see the
    ///IVdsVolume::BreakPlex method.
    VDS_ASYNCOUT_BREAKVOLUMEPLEX   = 0x00000005,
    ///The operation removes one or more specified plexes from the current volume, releasing the extents. For operation
    ///details, see the IVdsVolume::RemovePlex method.
    VDS_ASYNCOUT_REMOVEVOLUMEPLEX  = 0x00000006,
    ///The operation repairs a fault-tolerant volume plex by moving bad members to good disks. For operation details,
    ///see the IVdsVolumePlex::Repair method.
    VDS_ASYNCOUT_REPAIRVOLUMEPLEX  = 0x00000007,
    ///The operation returns a failing or failed pack to a healthy state, if possible. For operation details, see the
    ///IVdsPack::Recover method.
    VDS_ASYNCOUT_RECOVERPACK       = 0x00000008,
    ///This value is reserved for future use.
    VDS_ASYNCOUT_REPLACEDISK       = 0x00000009,
    ///The operation creates a new partition on a basic disk. For operation details, see the
    ///IVdsAdvancedDisk::CreatePartition method.
    VDS_ASYNCOUT_CREATEPARTITION   = 0x0000000a,
    ///IVdsAdvancedDisk::Clean
    VDS_ASYNCOUT_CLEAN             = 0x0000000b,
    ///The operation returns the IUnknown pointer for the newly created LUN object. For operation details, see the
    ///IVdsSubSystem::CreateLun method.
    VDS_ASYNCOUT_CREATELUN         = 0x00000032,
    ///The operation adds a LUN to the target LUN as a new plex. For operation details, see the IVdsLun::AddPlex method.
    VDS_ASYNCOUT_ADDLUNPLEX        = 0x00000034,
    ///The operation returns the IUnknown pointer for the removed LUN object. For operation details, see the
    ///IVdsLun::RemovePlex method.
    VDS_ASYNCOUT_REMOVELUNPLEX     = 0x00000035,
    ///The operation extends a LUN by a specified number of bytes. For operation details, see the IVdsLun::Extend
    ///method.
    VDS_ASYNCOUT_EXTENDLUN         = 0x00000036,
    ///The operation shrinks a LUN by a specified number of bytes. For operation details, see the IVdsLun::Shrink
    ///method.
    VDS_ASYNCOUT_SHRINKLUN         = 0x00000037,
    ///The operation starts a recovery operation on a LUN. For operation details, see the IVdsLun::Recover method.
    VDS_ASYNCOUT_RECOVERLUN        = 0x00000038,
    ///The operation logs in to a target. For operation details, see the IVdsIscsiInitiatorAdapter::LoginToTarget
    ///method. <b>Windows Server 2003: </b>This flag is not supported before Windows Server 2003 R2.
    VDS_ASYNCOUT_LOGINTOTARGET     = 0x0000003c,
    ///The operation logs out from a target. For operation details, see the IVdsIscsiInitiatorAdapter::LogoutFromTarget
    ///method. <b>Windows Server 2003: </b>This flag is not supported before Windows Server 2003 R2.
    VDS_ASYNCOUT_LOGOUTFROMTARGET  = 0x0000003d,
    ///The operation returns the IUnknown interface pointer for the newly created target object. For operation details,
    ///see the IVdsSubSystemIscsi::CreateTarget method. <b>Windows Server 2003: </b>This flag is not supported before
    ///Windows Server 2003 R2.
    VDS_ASYNCOUT_CREATETARGET      = 0x0000003e,
    ///The operation returns the IUnknown interface pointer for the newly created portal group object. For operation
    ///details, see the IVdsIscsiTarget::CreatePortalGroup method. <b>Windows Server 2003: </b>This flag is not
    ///supported before Windows Server 2003 R2.
    VDS_ASYNCOUT_CREATEPORTALGROUP = 0x0000003f,
    ///The operation deletes a target. For operation details, see the IVdsIscsiTarget::Delete method. <b>Windows Server
    ///2003: </b>This flag is not supported before Windows Server 2003 R2.
    VDS_ASYNCOUT_DELETETARGET      = 0x00000040,
    ///The operation adds a portal to a portal group. For operation details, see the IVdsIscsiPortalGroup::AddPortal
    ///method. <b>Windows Server 2003: </b>This flag is not supported before Windows Server 2003 R2.
    VDS_ASYNCOUT_ADDPORTAL         = 0x00000041,
    ///The operation removes a portal from a portal group. For operation details, see the
    ///IVdsIscsiPortalGroup::RemovePortal method. <b>Windows Server 2003: </b>This flag is not supported before Windows
    ///Server 2003 R2.
    VDS_ASYNCOUT_REMOVEPORTAL      = 0x00000042,
    ///The operation deletes a portal group. For operation details, see the IVdsIscsiPortalGroup::Delete method.
    ///<b>Windows Server 2003: </b>This flag is not supported before Windows Server 2003 R2.
    VDS_ASYNCOUT_DELETEPORTALGROUP = 0x00000043,
    ///The operation formats a volume. For operation details, see the IVdsVolumeMF::Format method.
    VDS_ASYNCOUT_FORMAT            = 0x00000065,
    ///The operation creates a virtual disk. For operation details, see the IVdsVdProvider::CreateVDisk method.
    ///<b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not supported.
    VDS_ASYNCOUT_CREATE_VDISK      = 0x000000c8,
    ///The operation attaches a virtual disk. For operation details, see the IVdsOpenVDisk::Attach method. <b>Windows
    ///Server 2008, Windows Vista and Windows Server 2003: </b>Not supported.
    VDS_ASYNCOUT_ATTACH_VDISK      = 0x000000c9,
    ///The operation compacts a virtual disk to reduce the physical size of the backing file. For operation details, see
    ///the IVdsOpenVDisk::Compact method. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not
    ///supported.
    VDS_ASYNCOUT_COMPACT_VDISK     = 0x000000ca,
    ///The operation merges a child virtual disk with its parents in the differencing chain. For operation details, see
    ///the IVdsOpenVDisk::Merge method. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>Not
    ///supported.
    VDS_ASYNCOUT_MERGE_VDISK       = 0x000000cb,
    ///The operation increases the size of a virtual disk to the maximum available on a fixed-size or expandable disk.
    ///For operation details, see the IVdsOpenVDisk::Expand method. <b>Windows Server 2008, Windows Vista and Windows
    ///Server 2003: </b>Not supported.
    VDS_ASYNCOUT_EXPAND_VDISK      = 0x000000cc,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for an IP address. These values are
///used in the <b>type</b> member of the VDS_IPADDRESS structure.
alias VDS_IPADDRESS_TYPE = int;
enum : int
{
    ///The address is a text address that is either a DNS address, an IPv4 dotted address, or an IPv6 hex address.
    VDS_IPT_TEXT  = 0x00000000,
    ///The address is an IPv4 address in binary format.
    VDS_IPT_IPV4  = 0x00000001,
    ///The address is an IPv6 address in binary format.
    VDS_IPT_IPV6  = 0x00000002,
    ///The address is empty.
    VDS_IPT_EMPTY = 0x00000003,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of health state values for a VDS object.
alias VDS_HEALTH = int;
enum : int
{
    ///The health of the object cannot be determined.
    VDS_H_UNKNOWN                   = 0x00000000,
    ///The object indicates online status. This health state value means that the object is fully operational and is
    ///operating properly, but it does not imply that the object is available for use. For example, if the object is a
    ///disk, the disk is not missing, log and configuration files are synchronized, and the disk is free of I/O errors.
    ///If the object is a LUN or volume, all plexes (mirrored, simple, spanned, and striped) and columns (RAID-5) are
    ///available and free of I/O errors. The status value associated with this health state must not be FAILED, UNKNOWN,
    ///or MISSING.
    VDS_H_HEALTHY                   = 0x00000001,
    ///Either a mirrored LUN or volume is resynching all plexes, or a striped with parity (RAID-5) plex is regenerating
    ///the parity.
    VDS_H_REBUILDING                = 0x00000002,
    ///The object configuration is stale. The status value must not be FAILED or UNKNOWN.
    VDS_H_STALE                     = 0x00000003,
    ///The object is failing, but still working. For example, a LUN or volume with failing health might be producing
    ///occasional input/output errors from which it is still able to recover. The status value must not be FAILED or
    ///UNKNOWN.
    VDS_H_FAILING                   = 0x00000004,
    ///One or more plexes have errors, but the object is working and all plexes are online. This value is valid only for
    ///volumes and LUNs.
    VDS_H_FAILING_REDUNDANCY        = 0x00000005,
    ///One or more plexes have failed, but at least one plex is working. This value is valid only for volumes and LUNs.
    VDS_H_FAILED_REDUNDANCY         = 0x00000006,
    ///The last working plex is failing. This value is valid only for volumes and LUNs.
    VDS_H_FAILED_REDUNDANCY_FAILING = 0x00000007,
    ///The object has failed. Any object with a failed health status also has a failed object status. Therefore, the
    ///status value must be FAILED.
    VDS_H_FAILED                    = 0x00000008,
    ///This value is reserved. Do not use it. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This
    ///value is not supported.
    VDS_H_REPLACED                  = 0x00000009,
    ///The object is not failing, but it is expected to fail according to analysis done on the object's attributes. For
    ///example, a disk may be set to VDS_H_PENDING_FAILURE based on S.M.A.R.T. data. The status value must not be FAILED
    ///or UNKNOWN. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is not supported.
    VDS_H_PENDING_FAILURE           = 0x0000000a,
    ///The object has not completely failed but is experiencing failures. If the object is a subsystem object, the
    ///firmware may be reporting errors, or the drive, controller, port, or path sub-object may have failed or be
    ///failing. If the object is a controller object, the firmware may be reporting errors, or the port or path
    ///sub-object may have failed or be failing. If the object is a storage pool object, one or more drives may have
    ///failed or be failing. The status value must not be UNKNOWN. <b>Windows Server 2008, Windows Vista and Windows
    ///Server 2003: </b>This value is not supported.
    VDS_H_DEGRADED                  = 0x0000000b,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of the valid transition state values for a VDS
///object.
alias VDS_TRANSITION_STATE = int;
enum : int
{
    ///This value is reserved.
    VDS_TS_UNKNOWN     = 0x00000000,
    ///The object is stable. No configuration activity is currently in progress.
    VDS_TS_STABLE      = 0x00000001,
    ///The object is being extended.
    VDS_TS_EXTENDING   = 0x00000002,
    ///The object is being shrunk.
    VDS_TS_SHRINKING   = 0x00000003,
    ///The object is being automagically reconfigured.
    VDS_TS_RECONFIGING = 0x00000004,
    ///The object is being restriped. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_TS_RESTRIPING  = 0x00000005,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for a file system.
alias VDS_FILE_SYSTEM_TYPE = int;
enum : int
{
    ///The file system is unknown. The IVdsVolumeMF::GetFileSystemProperties method returns this value in the
    ///VDS_FILE_SYSTEM_PROP structure for BitLocker-encrypted volumes.
    VDS_FST_UNKNOWN = 0x00000000,
    ///The file system is raw.
    VDS_FST_RAW     = 0x00000001,
    ///The file system is file allocation table (FAT).
    VDS_FST_FAT     = 0x00000002,
    ///The file system is file allocation table for 32-bit computers (FAT32).
    VDS_FST_FAT32   = 0x00000003,
    ///The file system is the NT file system (NTFS).
    VDS_FST_NTFS    = 0x00000004,
    ///The file system is the CD-ROM file system (CDFS).
    VDS_FST_CDFS    = 0x00000005,
    ///The file system is Universal Disk Format (UDF).
    VDS_FST_UDF     = 0x00000006,
    ///The file system is extended file allocation table (exFAT). <b>Windows Server 2008, Windows Vista and Windows
    ///Server 2003: </b>The VDS_FST_EXFAT file type value is not supported.
    VDS_FST_EXFAT   = 0x00000007,
    VDS_FST_CSVFS   = 0x00000008,
    VDS_FST_REFS    = 0x00000009,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for an HBA port. These types
///correspond to the HBA_PORTTYPE values in the HBA API.
alias VDS_HBAPORT_TYPE = int;
enum : int
{
    ///The port type is unknown. HBA_PORTTYPE_UNKNOWN
    VDS_HPT_UNKNOWN    = 0x00000001,
    ///The port type is another (undefined) type. HBA_PORTTYPE_OTHER
    VDS_HPT_OTHER      = 0x00000002,
    ///The port type is not present. HBA_PORTTYPE_NOTPRESENT
    VDS_HPT_NOTPRESENT = 0x00000003,
    ///The port type is a fabric. HBA_PORTTYPE_NPORT
    VDS_HPT_NPORT      = 0x00000005,
    ///The port type is a public loop. HBA_PORTTYPE_NLPORT
    VDS_HPT_NLPORT     = 0x00000006,
    ///The port type is a fabric on a loop. HBA_PORTTYPE_FLPORT
    VDS_HPT_FLPORT     = 0x00000007,
    ///The port type is a fabric port. HBA_PORTTYPE_FPORT
    VDS_HPT_FPORT      = 0x00000008,
    ///The port type is a fabric expansion port.
    VDS_HPT_EPORT      = 0x00000009,
    ///The port type is a generic fabric port.
    VDS_HPT_GPORT      = 0x0000000a,
    ///The port type is a private loop. HBA_PORTTYPE_LPORT
    VDS_HPT_LPORT      = 0x00000014,
    ///The port type is point-to-point. HBA_PORTTYPE_PTP
    VDS_HPT_PTP        = 0x00000015,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid statuses for an HBA port. These values
///are used in the <b>status</b> member of the VDS_HBAPORT_PROP structure. These states correspond to the HBA_PORTSTATE
///values in the HBA API.
alias VDS_HBAPORT_STATUS = int;
enum : int
{
    ///The HBA port status is unknown. HBA_PORTSTATE_UNKNOWN
    VDS_HPS_UNKNOWN     = 0x00000001,
    ///The HBA port is operational. HBA_PORTSTATE_ONLINE
    VDS_HPS_ONLINE      = 0x00000002,
    ///The HBA port has been set offline by a user. HBA_PORTSTATE_OFFLINE
    VDS_HPS_OFFLINE     = 0x00000003,
    ///The HBA port is bypassed. HBA_PORTSTATE_BYPASSED
    VDS_HPS_BYPASSED    = 0x00000004,
    ///The HBA port is in diagnostics mode. HBA_PORTSTATE_DIAGNOSTICS
    VDS_HPS_DIAGNOSTICS = 0x00000005,
    ///The HBA port link is down. HBA_PORTSTATE_LINKDOWN
    VDS_HPS_LINKDOWN    = 0x00000006,
    ///The HBA port has an error. HBA_PORTSTATE_ERROR
    VDS_HPS_ERROR       = 0x00000007,
    ///The HBA port is loopback. HBA_PORTSTATE_LOOPBACK
    VDS_HPS_LOOPBACK    = 0x00000008,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid flags for determining the speeds
///supported by an HBA port. These values are used in the <b>ulPortSpeed</b> member of the VDS_HBAPORT_PROP structure.
alias VDS_HBAPORT_SPEED_FLAG = int;
enum : int
{
    ///The HBA port speed is unknown. The transceiver is incapable of reporting. HBA_PORTSPEED_UNKNOWN
    VDS_HSF_UNKNOWN        = 0x00000000,
    ///The HBA port supports a transfer rate of 1 gigabit per second. HBA_PORTSPEED_1GBIT
    VDS_HSF_1GBIT          = 0x00000001,
    ///The HBA port supports a transfer rate of 2 gigabits per second. HBA_PORTSPEED_2GBIT
    VDS_HSF_2GBIT          = 0x00000002,
    ///The HBA port supports a transfer rate of 10 gigabits per second. HBA_PORTSPEED_10GBIT
    VDS_HSF_10GBIT         = 0x00000004,
    ///The HBA port supports a transfer rate of 4 gigabits per second. HBA_PORTSPEED_4GBIT
    VDS_HSF_4GBIT          = 0x00000008,
    ///The HBA port speed has not been established. HBA_PORTSPEED_NOT_NEGOTIATED
    VDS_HSF_NOT_NEGOTIATED = 0x00008000,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid status values for a port.
alias VDS_PATH_STATUS = int;
enum : int
{
    ///The path status is unknown.
    VDS_MPS_UNKNOWN = 0x00000000,
    ///The path is active.
    VDS_MPS_ONLINE  = 0x00000001,
    ///The path is failed.
    VDS_MPS_FAILED  = 0x00000005,
    ///The path is in standby mode.
    VDS_MPS_STANDBY = 0x00000007,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines a set of valid load balance policies for a path. These
///policies correspond to the definitions in the DSM MOF.
alias VDS_LOADBALANCE_POLICY_ENUM = int;
enum : int
{
    ///The policy is unknown.
    VDS_LBP_UNKNOWN                 = 0x00000000,
    ///The policy uses one primary path with other paths being backup paths.
    VDS_LBP_FAILOVER                = 0x00000001,
    ///The policy uses all paths in round-robin fashion.
    VDS_LBP_ROUND_ROBIN             = 0x00000002,
    ///The policy uses primary paths in round-robin fashion. The backup paths are used if all of the primary paths fail.
    VDS_LBP_ROUND_ROBIN_WITH_SUBSET = 0x00000003,
    ///The policy uses the path with the least number of active requests.
    VDS_LBP_DYN_LEAST_QUEUE_DEPTH   = 0x00000004,
    ///The policy uses the path with the least weight (each path is assigned a weight).
    VDS_LBP_WEIGHTED_PATHS          = 0x00000005,
    ///The policy uses the path with the least blocks.
    VDS_LBP_LEAST_BLOCKS            = 0x00000006,
    ///The policy is a vendor-specific policy.
    VDS_LBP_VENDOR_SPECIFIC         = 0x00000007,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Specifies the set of valid flags for indicating which load balance
///policies a hardware provider supports.
alias VDS_PROVIDER_LBSUPPORT_FLAG = int;
enum : int
{
    ///The provider supports using one primary path with the other paths being backup paths.
    VDS_LBF_FAILOVER                = 0x00000001,
    ///The provider supports using all paths in round robin fashion.
    VDS_LBF_ROUND_ROBIN             = 0x00000002,
    ///The provider supports using primary paths in round robin fashion. The backup paths are used if all of the primary
    ///paths fail.
    VDS_LBF_ROUND_ROBIN_WITH_SUBSET = 0x00000004,
    ///The provider supports using the path with the least number of active requests.
    VDS_LBF_DYN_LEAST_QUEUE_DEPTH   = 0x00000008,
    ///The provider supports using the path with the least weight (each path is assigned a weight).
    VDS_LBF_WEIGHTED_PATHS          = 0x00000010,
    ///The provider supports using the path with the least blocks.
    VDS_LBF_LEAST_BLOCKS            = 0x00000020,
    ///The provider supports a vendor-specific policy.
    VDS_LBF_VENDOR_SPECIFIC         = 0x00000040,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Used to indicate which versions of the VDS interfaces are
///supported.
alias VDS_VERSION_SUPPORT_FLAG = int;
enum : int
{
    ///Indicates that the VDS 1.0 interfaces are supported. VDS 1.0 is supported on Windows Server 2003 and later.
    VDS_VSF_1_0 = 0x00000001,
    ///Indicates that the VDS 1.1 interfaces are supported. VDS 1.1 is supported on Windows Server 2003 R2 and later.
    VDS_VSF_1_1 = 0x00000002,
    ///Indicates that the VDS 2.0 interfaces are supported. VDS 2.0 is supported on Windows Vista and later. <b>Windows
    ///Server 2008, Windows Vista and Windows Server 2003 R2: </b>This value is not supported.
    VDS_VSF_2_0 = 0x00000004,
    ///Indicates that the VDS 2.1 interfaces are supported. VDS 2.1 is supported on Windows Vista with SP1, Windows
    ///Server 2008, and later. <b>Windows Server 2008, Windows Vista and Windows Server 2003 R2: </b>This value is not
    ///supported.
    VDS_VSF_2_1 = 0x00000008,
    ///Indicates that the VDS 3.0 interfaces are supported. VDS 3.0 is supported on Windows 7, Windows Server 2008 R2,
    ///and later. <b>Windows Server 2008, Windows Vista and Windows Server 2003 R2: </b>This value is not supported.
    VDS_VSF_3_0 = 0x00000010,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for a hardware provider. These
///values are used in the <b>type</b> member of the VDS_PATH_INFO structure and are returned in the <i>pType</i>
///parameter of the IVdsHwProviderType::GetProviderType method.
alias VDS_HWPROVIDER_TYPE = int;
enum : int
{
    ///The type is unknown.
    VDS_HWT_UNKNOWN       = 0x00000000,
    ///The type indicates a hardware provider for PCI RAID cards.
    VDS_HWT_PCI_RAID      = 0x00000001,
    ///The type indicates a hardware provider for Fibre Channel storage array networks.
    VDS_HWT_FIBRE_CHANNEL = 0x00000002,
    ///The type indicates a hardware provider for iSCSI storage array networks.
    VDS_HWT_ISCSI         = 0x00000003,
    ///The type indicates a hardware provider for serial attached SCSI (SAS) storage array networks. <b>Windows Server
    ///2008, Windows Vista and Windows Server 2003 R2: </b>This value is not supported until Windows Server 2008 R2 and
    ///Windows 7.
    VDS_HWT_SAS           = 0x00000004,
    ///The type indicates a hybrid hardware provider. A hybrid provider is a provider that manages subsystems that
    ///support multiple interconnect types. This is not a valid value for the <b>type</b> member of the VDS_PATH_INFO
    ///structure. <b>Windows Server 2008, Windows Vista and Windows Server 2003 R2: </b>This value is not supported
    ///until Windows Server 2008 R2 and Windows 7.
    VDS_HWT_HYBRID        = 0x00000005,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for logging into an iSCSI target.
alias VDS_ISCSI_LOGIN_TYPE = int;
enum : int
{
    ///A manual, one-time login is performed.
    VDS_ILT_MANUAL     = 0x00000000,
    ///A persistent login is performed.
    VDS_ILT_PERSISTENT = 0x00000001,
    ///A persistent login is performed such that the target is present at startup.
    VDS_ILT_BOOT       = 0x00000002,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for authentication when logging
///into an iSCSI target.
alias VDS_ISCSI_AUTH_TYPE = int;
enum : int
{
    ///No authentication is performed.
    VDS_IAT_NONE        = 0x00000000,
    ///One-way CHAP authentication is performed (target authenticates initiator). The target CHAP secret must be
    ///specified during login.
    VDS_IAT_CHAP        = 0x00000001,
    ///Mutual CHAP authentication is performed (target authenticates initiator and initiator authenticates target). The
    ///target CHAP secret must be specified and the initiator CHAP secret must also have been set.
    VDS_IAT_MUTUAL_CHAP = 0x00000002,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Not supported. This enumeration is reserved for future use.
alias VDS_ISCSI_IPSEC_FLAG = int;
enum : int
{
    ///This bit must be set for the field to contain significant information.
    VDS_IIF_VALID                    = 0x00000001,
    ///If set, IKE/IPSEC is enabled.
    VDS_IIF_IKE                      = 0x00000002,
    ///If set, negotiate through main mode is enabled.
    VDS_IIF_MAIN_MODE                = 0x00000004,
    ///If set, negotiate through aggressive mode is enabled.
    VDS_IIF_AGGRESSIVE_MODE          = 0x00000008,
    ///If set, perfect forward secrecy is enabled.
    VDS_IIF_PFS_ENABLE               = 0x00000010,
    ///If set, transport mode is preferred.
    VDS_IIF_TRANSPORT_MODE_PREFERRED = 0x00000020,
    ///If set, tunnel mode is preferred.
    VDS_IIF_TUNNEL_MODE_PREFERRED    = 0x00000040,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid flags for specifying iSCSI target login
///options.
alias VDS_ISCSI_LOGIN_FLAG = int;
enum : int
{
    ///Reserved for future use.
    VDS_ILF_REQUIRE_IPSEC     = 0x00000001,
    ///If this flag is set, the login is allowed to proceed and create a new login session even if there is already a
    ///login session to the target. <div class="alert"><b>Note</b> Multipathing software must be present or else data
    ///corruption may occur.</div> <div> </div>
    VDS_ILF_MULTIPATH_ENABLED = 0x00000002,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of object status values for a subsystem.
alias VDS_SUB_SYSTEM_STATUS = int;
enum : int
{
    ///This value is reserved.
    VDS_SSS_UNKNOWN           = 0x00000000,
    ///The subsystem is working properly.
    VDS_SSS_ONLINE            = 0x00000001,
    ///The subsystem is initializing and not yet ready to work.
    VDS_SSS_NOT_READY         = 0x00000002,
    ///The subsystem is unavailable. This value indicates either that the subsystem is disconnected or that it has
    ///failed so severely that it appears to be disconnected.
    VDS_SSS_OFFLINE           = 0x00000004,
    ///The subsystem has failed. This value indicates that the subsystem is not merely disconnected but rather that it
    ///has failed.
    VDS_SSS_FAILED            = 0x00000005,
    ///The subsystem is operating in a degraded state. This means that one or more of the subsystem's subcomponents,
    ///such as disk drives or controllers, are in a failed state. <b>Windows Server 2008, Windows Vista and Windows
    ///Server 2003: </b>This value is not supported.
    VDS_SSS_PARTIALLY_MANAGED = 0x00000009,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid flags for a subsystem object.
alias VDS_SUB_SYSTEM_FLAG = int;
enum : int
{
    ///The subsystem supports LUN masking. This flag applies only to external hardware providers—internal hardware
    ///providers do not support LUN masking.
    VDS_SF_LUN_MASKING_CAPABLE              = 0x00000001,
    ///The provider supports LUNs with more than one plex.
    VDS_SF_LUN_PLEXING_CAPABLE              = 0x00000002,
    ///The provider supports automatic remapping of LUN extents to drive extents.
    VDS_SF_LUN_REMAPPING_CAPABLE            = 0x00000004,
    ///The provider supports the use of drive extents in LUN creation. If this flag is not set, the provider uses only
    ///whole drives to create LUNs.
    VDS_SF_DRIVE_EXTENT_CAPABLE             = 0x00000008,
    ///The provider supports verifying the integrity of the read and write data using a checksum. If this flag is not
    ///set, the provider does not support using a checksum.
    VDS_SF_HARDWARE_CHECKSUM_CAPABLE        = 0x00000010,
    ///The subsystem supports RADIUS.
    VDS_SF_RADIUS_CAPABLE                   = 0x00000020,
    ///The subsystem supports read verification of data that has been written.
    VDS_SF_READ_BACK_VERIFY_CAPABLE         = 0x00000040,
    ///The subsystem supports write-through caching.
    VDS_SF_WRITE_THROUGH_CACHING_CAPABLE    = 0x00000080,
    ///The subsystem supports creation of automagic fault tolerant LUNs.
    VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS     = 0x00000200,
    ///The subsystem supports creation of automagic non-fault tolerant LUNs.
    VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS = 0x00000400,
    ///The subsystem supports creation of simple LUNs.
    VDS_SF_SUPPORTS_SIMPLE_LUNS             = 0x00000800,
    ///The subsystem supports creation of spanned LUNs.
    VDS_SF_SUPPORTS_SPAN_LUNS               = 0x00001000,
    ///The subsystem supports creation of striped LUNs.
    VDS_SF_SUPPORTS_STRIPE_LUNS             = 0x00002000,
    ///The subsystem supports creation of mirrored LUNs.
    VDS_SF_SUPPORTS_MIRROR_LUNS             = 0x00004000,
    ///The subsystem supports creation of striped with parity LUNs.
    VDS_SF_SUPPORTS_PARITY_LUNS             = 0x00008000,
    ///The subsystem supports one-way CHAP authentication.
    VDS_SF_SUPPORTS_AUTH_CHAP               = 0x00010000,
    ///The subsystem supports mutual CHAP authentication.
    VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP        = 0x00020000,
    ///The subsystem supports only simple target configurations and automatically assigns LUNs to targets during LUN
    ///creation. Such a target must be configured with at least one associated portal in the target's portal group. The
    ///provider is responsible for correctly associating portals with the target. A VDS application should not assume
    ///that the subsystem has the ability to create or delete simple targets.
    VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG    = 0x00040000,
    ///The subsystem supports LUN numbering. See the IVdsLunNumber::GetLunNumber method. <b>Windows Server 2008, Windows
    ///Vista and Windows Server 2003: </b>This flag is not supported.
    VDS_SF_SUPPORTS_LUN_NUMBER              = 0x00080000,
    ///The subsystem supports LUNs that use a mirrored cache. See the <b>bUseMirroredCache</b> member of the VDS_HINTS2
    ///structure. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This flag is not supported.
    VDS_SF_SUPPORTS_MIRRORED_CACHE          = 0x00100000,
    ///The subsystem supports read caching on LUNs. See the <b>VDS_LF_READ_CACHE_ENABLED</b> value of the VDS_LUN_FLAG
    ///enumeration and the <b>bReadCachingEnabled</b> member of the VDS_HINTS2 structure. <b>Windows Server 2008,
    ///Windows Vista and Windows Server 2003: </b>This flag is not supported.
    VDS_SF_READ_CACHING_CAPABLE             = 0x00200000,
    ///The subsystem supports write caching on LUNs. See the <b>VDS_LF_WRITE_CACHE_ENABLED</b> value of the VDS_LUN_FLAG
    ///enumeration and the <b>bWriteCachingEnabled</b> member of the VDS_HINTS2 structure. <b>Windows Server 2008,
    ///Windows Vista and Windows Server 2003: </b>This flag is not supported.
    VDS_SF_WRITE_CACHING_CAPABLE            = 0x00400000,
    ///The subsystem supports media scanning on LUNs. See the <b>VDS_LF_MEDIA_SCAN_ENABLED</b> value of the VDS_LUN_FLAG
    ///enumeration and the <b>bMediaScanEnabled</b> member of the VDS_HINTS2 structure. <b>Windows Server 2008, Windows
    ///Vista and Windows Server 2003: </b>This flag is not supported.
    VDS_SF_MEDIA_SCAN_CAPABLE               = 0x00800000,
    ///The subsystem supports consistency checking on LUNs. See the <b>VDS_LF_CONSISTENCY_CHECK_ENABLED</b> value of the
    ///VDS_LUN_FLAG enumeration and the <b>bConsistencyCheckEnabled</b> member of the VDS_HINTS2 structure. <b>Windows
    ///Server 2008, Windows Vista and Windows Server 2003: </b>This flag is not supported.
    VDS_SF_CONSISTENCY_CHECK_CAPABLE        = 0x01000000,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of RAID levels that can be supported by
///subsystems.
alias VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG = int;
enum : int
{
    ///Supports RAID level 2.
    VDS_SF_SUPPORTS_RAID2_LUNS  = 0x00000001,
    ///Supports RAID level 3.
    VDS_SF_SUPPORTS_RAID3_LUNS  = 0x00000002,
    ///Supports RAID level 4.
    VDS_SF_SUPPORTS_RAID4_LUNS  = 0x00000004,
    ///Supports RAID level 5.
    VDS_SF_SUPPORTS_RAID5_LUNS  = 0x00000008,
    ///Supports RAID level 6.
    VDS_SF_SUPPORTS_RAID6_LUNS  = 0x00000010,
    ///Supports RAID level 0+1.
    VDS_SF_SUPPORTS_RAID01_LUNS = 0x00000020,
    ///Supports RAID level 0+3.
    VDS_SF_SUPPORTS_RAID03_LUNS = 0x00000040,
    ///Supports RAID level 0+5.
    VDS_SF_SUPPORTS_RAID05_LUNS = 0x00000080,
    ///Supports RAID level 1+0.
    VDS_SF_SUPPORTS_RAID10_LUNS = 0x00000100,
    ///Supports RAID level 1+5.
    VDS_SF_SUPPORTS_RAID15_LUNS = 0x00000200,
    ///Supports RAID level 3+0.
    VDS_SF_SUPPORTS_RAID30_LUNS = 0x00000400,
    ///Supports RAID level 5+0.
    VDS_SF_SUPPORTS_RAID50_LUNS = 0x00000800,
    ///Supports RAID level 5+1.
    VDS_SF_SUPPORTS_RAID51_LUNS = 0x00001000,
    ///Supports RAID level 5+3.
    VDS_SF_SUPPORTS_RAID53_LUNS = 0x00002000,
    ///Supports RAID level 6+0.
    VDS_SF_SUPPORTS_RAID60_LUNS = 0x00004000,
    ///Supports RAID level 6+1.
    VDS_SF_SUPPORTS_RAID61_LUNS = 0x00008000,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of interconnect types that subsystems can support.
alias VDS_INTERCONNECT_FLAG = int;
enum : int
{
    ///The subsystem supports a PCI RAID interconnect.
    VDS_ITF_PCI_RAID      = 0x00000001,
    ///The subsystem supports a Fibre Channel interconnect.
    VDS_ITF_FIBRE_CHANNEL = 0x00000002,
    ///The subsystem supports an iSCSI interconnect.
    VDS_ITF_ISCSI         = 0x00000004,
    ///The subsystem supports a serial attached iSCSI (SAS) interconnect.
    VDS_ITF_SAS           = 0x00000008,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of object status values for a controller.
alias VDS_CONTROLLER_STATUS = int;
enum : int
{
    ///The status of the controller cannot be determined.
    VDS_CS_UNKNOWN   = 0x00000000,
    ///The controller is physically present and in use. The VDS_HEALTH value associated with this controller status can
    ///be any value except <b>VDS_H_FAILED</b>.
    VDS_CS_ONLINE    = 0x00000001,
    ///The controller is busy. The VDS_HEALTH value can be any value except <b>VDS_H_FAILED</b>.
    VDS_CS_NOT_READY = 0x00000002,
    ///The controller is physically present but not available for use. For example, the controller has been set to the
    ///inactive state. When this controller status is set, a <b>VDS_NF_CONTROLLER_REMOVED</b> notification is sent. The
    ///VDS_HEALTH value can be any value.
    VDS_CS_OFFLINE   = 0x00000004,
    ///The controller has failed. The VDS_HEALTH value should be <b>VDS_H_FAILED</b> or <b>VDS_H_FAILING</b>.
    VDS_CS_FAILED    = 0x00000005,
    ///The controller has been physically unplugged from the subsystem. When this status is set, a
    ///<b>VDS_NF_CONTROLLER_DEPART</b> notification is sent. <b>Windows Server 2008, Windows Vista and Windows Server
    ///2003: </b>This value is not supported.
    VDS_CS_REMOVED   = 0x00000008,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of object status values for a port.
alias VDS_PORT_STATUS = int;
enum : int
{
    ///The status of the port cannot be determined.
    VDS_PRS_UNKNOWN   = 0x00000000,
    ///The port is physically present and in use. The VDS_HEALTH value associated with this port status can be any value
    ///except <b>VDS_H_FAILED</b>.
    VDS_PRS_ONLINE    = 0x00000001,
    ///The port is busy. The VDS_HEALTH value can be any value except <b>VDS_H_FAILED</b>.
    VDS_PRS_NOT_READY = 0x00000002,
    ///Either the port or its controller is physically present but not available for use. For example, the port or its
    ///controller has been set to the inactive state. When this status is set, a <b>VDS_NF_PORT_REMOVED</b> notification
    ///is sent. The VDS_HEALTH value can be any value.
    VDS_PRS_OFFLINE   = 0x00000004,
    ///The port has failed. The VDS_HEALTH value should be <b>VDS_H_FAILED</b> or <b>VDS_H_FAILING</b>.
    VDS_PRS_FAILED    = 0x00000005,
    ///The port's controller has been physically removed from the subsystem. When this status is set, a
    ///<b>VDS_NF_PORT_DEPART</b> notification is sent. <b>Windows Server 2008, Windows Vista and Windows Server 2003:
    ///</b>This value is not supported.
    VDS_PRS_REMOVED   = 0x00000008,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of object status values for a drive.
alias VDS_DRIVE_STATUS = int;
enum : int
{
    ///The status of the drive cannot be determined.
    VDS_DRS_UNKNOWN   = 0x00000000,
    ///The drive is available and in use. The VDS_HEALTH value associated with this drive status can be any value except
    ///<b>VDS_H_FAILED</b>.
    VDS_DRS_ONLINE    = 0x00000001,
    ///The drive is busy. The VDS_HEALTH value can be any value except <b>VDS_H_FAILED</b>.
    VDS_DRS_NOT_READY = 0x00000002,
    ///The drive is physically present but has been removed from its RAID group or storage pool. For example, if the
    ///drive was removed from its RAID group because it failed, the drive status should be <b>VDS_DRS_FAILED</b>. If the
    ///drive was removed as part of rebalancing storage, the drive status should be <b>VDS_DRS_OFFLINE</b>. When this
    ///drive status is set, a <b>VDS_NF_DRIVE_REMOVED</b> notification is sent. The VDS_HEALTH value can be any value.
    VDS_DRS_OFFLINE   = 0x00000004,
    ///The drive has failed. The VDS_HEALTH value should be <b>VDS_H_FAILED</b> or <b>VDS_H_FAILING</b>.
    VDS_DRS_FAILED    = 0x00000005,
    ///The drive has been physically unplugged from the subsystem. When this status is set, a <b>VDS_NF_DRIVE_DEPART</b>
    ///notification is sent. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is not
    ///supported.
    VDS_DRS_REMOVED   = 0x00000008,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid flags for a drive object.
alias VDS_DRIVE_FLAG = int;
enum : int
{
    ///The drive is reserved for use only as a hot spare.
    VDS_DRF_HOTSPARE         = 0x00000001,
    ///The drive is assigned to a RAID group or storage pool. <b>Windows Server 2008, Windows Vista and Windows Server
    ///2003: </b>This value is not supported.
    VDS_DRF_ASSIGNED         = 0x00000002,
    ///The drive is not assigned to a RAID group or storage pool. <b>Windows Server 2008, Windows Vista and Windows
    ///Server 2003: </b>This value is not supported.
    VDS_DRF_UNASSIGNED       = 0x00000004,
    ///The drive is in use as a hot spare. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value
    ///is not supported.
    VDS_DRF_HOTSPARE_IN_USE  = 0x00000008,
    ///The drive is on standby as a hot spare. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This
    ///value is not supported.
    VDS_DRF_HOTSPARE_STANDBY = 0x00000010,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for a LUN.
alias VDS_LUN_TYPE = int;
enum : int
{
    ///This value is reserved.
    VDS_LT_UNKNOWN            = 0x00000000,
    ///The LUN type is default automagic—the provider configures the LUN automatically based on hints. This value is
    ///used as an input parameter only; it is not returned by queries.
    VDS_LT_DEFAULT            = 0x00000001,
    ///The LUN type is fault tolerant automagic—the provider configures the LUN automatically based on hints, but with
    ///the requirement that the resulting LUN is fault tolerant. This value is used as an input parameter only; it is
    ///not returned by queries.
    VDS_LT_FAULT_TOLERANT     = 0x00000002,
    ///The LUN type is non-fault tolerant automagic—the provider configures the LUN automatically based on hints, but
    ///with the requirement that the resulting LUN is non-fault tolerant. This value is used as an input parameter only;
    ///it is not returned by queries.
    VDS_LT_NON_FAULT_TOLERANT = 0x00000003,
    ///The LUN type is simple—it is composed of extents from exactly one drive.
    VDS_LT_SIMPLE             = 0x0000000a,
    ///The LUN's type is spanned—it is composed of extents from more than one drive.
    VDS_LT_SPAN               = 0x0000000b,
    ///The LUN type is striped, which is equivalent to RAID 0.
    VDS_LT_STRIPE             = 0x0000000c,
    ///The LUN type is mirrored, which is equivalent to RAID 1.
    VDS_LT_MIRROR             = 0x0000000d,
    ///The LUN type is striped with parity, which accounts for RAID levels 3, 4, 5, and 6.
    VDS_LT_PARITY             = 0x0000000e,
    ///The LUN type is RAID level 2. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID2              = 0x0000000f,
    ///The LUN type is RAID level 3. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID3              = 0x00000010,
    ///The LUN type is RAID level 4. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID4              = 0x00000011,
    ///The LUN type is RAID level 5. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID5              = 0x00000012,
    ///The LUN type is RAID level 6. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID6              = 0x00000013,
    ///The LUN type is RAID level 0+1. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID01             = 0x00000014,
    ///The LUN type is RAID level 0+3. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID03             = 0x00000015,
    ///The LUN type is RAID level 0+5. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID05             = 0x00000016,
    ///The LUN type is RAID level 1+0. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID10             = 0x00000017,
    ///The LUN type is RAID level 1+5. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID15             = 0x00000018,
    ///The LUN type is RAID level 3+0. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID30             = 0x00000019,
    ///The LUN type is RAID level 5+0. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID50             = 0x0000001a,
    ///The LUN type is RAID level 5+1. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID51             = 0x0000001b,
    ///The LUN type is RAID level 5+3. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID53             = 0x0000001c,
    ///The LUN type is RAID level 6+0. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID60             = 0x0000001d,
    ///The LUN type is RAID level 6+1. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LT_RAID61             = 0x0000001e,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of object status values for a LUN.
alias VDS_LUN_STATUS = int;
enum : int
{
    ///This value is reserved.
    VDS_LS_UNKNOWN   = 0x00000000,
    ///The LUN is available.
    VDS_LS_ONLINE    = 0x00000001,
    ///The LUN is busy.
    VDS_LS_NOT_READY = 0x00000002,
    ///The LUN is unavailable.
    VDS_LS_OFFLINE   = 0x00000004,
    ///The LUN has failed.
    VDS_LS_FAILED    = 0x00000005,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid flags for a LUN object.
alias VDS_LUN_FLAG = int;
enum : int
{
    ///The provider remaps LUN extents to drive extents automatically.
    VDS_LF_LBN_REMAP_ENABLED             = 0x00000001,
    ///The provider verifies writes by readback.
    VDS_LF_READ_BACK_VERIFY_ENABLED      = 0x00000002,
    ///The provider enables write-through caching on the LUN.
    VDS_LF_WRITE_THROUGH_CACHING_ENABLED = 0x00000004,
    ///The provider verifies the integrity of the read and write data using a checksum.
    VDS_LF_HARDWARE_CHECKSUM_ENABLED     = 0x00000008,
    ///Read caching is enabled on the LUN. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value
    ///is not supported.
    VDS_LF_READ_CACHE_ENABLED            = 0x00000010,
    ///Write caching is enabled on the LUN. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This
    ///value is not supported.
    VDS_LF_WRITE_CACHE_ENABLED           = 0x00000020,
    ///Media scanning is enabled on the LUN. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This
    ///value is not supported.
    VDS_LF_MEDIA_SCAN_ENABLED            = 0x00000040,
    ///Consistency checking is enabled on the LUN. <b>Windows Server 2008, Windows Vista and Windows Server 2003:
    ///</b>This value is not supported.
    VDS_LF_CONSISTENCY_CHECK_ENABLED     = 0x00000080,
    ///The LUN is a volume shadow copy LUN. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This
    ///value is not supported.
    VDS_LF_SNAPSHOT                      = 0x00000100,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid types for a LUN plex.
alias VDS_LUN_PLEX_TYPE = int;
enum : int
{
    ///This value is reserved.
    VDS_LPT_UNKNOWN = 0x00000000,
    ///The plex type is simple—it is composed of extents from exactly one drive.
    VDS_LPT_SIMPLE  = 0x0000000a,
    ///The plex type is spanned—it is composed of extents from more than one drive.
    VDS_LPT_SPAN    = 0x0000000b,
    ///The plex type is striped, which is equivalent to RAID 0.
    VDS_LPT_STRIPE  = 0x0000000c,
    ///The plex type is striped with parity, which accounts for RAID levels 3, 4, 5, and 6.
    VDS_LPT_PARITY  = 0x0000000e,
    ///The plex type is RAID level 2. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID2   = 0x0000000f,
    ///The plex type is RAID level 3. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID3   = 0x00000010,
    ///The plex type is RAID level 4. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID4   = 0x00000011,
    ///The plex type is RAID level 5. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID5   = 0x00000012,
    ///The plex type is RAID level 6. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID6   = 0x00000013,
    ///The plex type is RAID level 0+3. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID03  = 0x00000015,
    ///The plex type is RAID level 0+5. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID05  = 0x00000016,
    ///The plex type is RAID level 1+0. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID10  = 0x00000017,
    ///The plex type is RAID level 1+5. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID15  = 0x00000018,
    ///The plex type is RAID level 3+0. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID30  = 0x00000019,
    ///The plex type is RAID level 5+0. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID50  = 0x0000001a,
    ///The plex type is RAID level 5+3. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID53  = 0x0000001c,
    ///The plex type is RAID level 6+0. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is
    ///not supported.
    VDS_LPT_RAID60  = 0x0000001d,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of object status values for a LUN plex.
alias VDS_LUN_PLEX_STATUS = int;
enum : int
{
    ///This value is reserved.
    VDS_LPS_UNKNOWN   = 0x00000000,
    ///The plex is available.
    VDS_LPS_ONLINE    = 0x00000001,
    ///The plex is busy.
    VDS_LPS_NOT_READY = 0x00000002,
    ///The plex is unavailable.
    VDS_LPS_OFFLINE   = 0x00000004,
    ///The plex has failed.
    VDS_LPS_FAILED    = 0x00000005,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid flags for a LUN plex object.
alias VDS_LUN_PLEX_FLAG = int;
enum : int
{
    ///If set, the provider remaps LUN extents to drive extents automatically. This flag corresponds to the
    ///<b>VDS_LF_LBN_REMAP_ENABLED</b> value of the VDS_LUN_FLAG enumeration.
    VDS_LPF_LBN_REMAP_ENABLED = 0x00000001,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid status values for an iSCSI portal.
alias VDS_ISCSI_PORTAL_STATUS = int;
enum : int
{
    ///The status is unknown.
    VDS_IPS_UNKNOWN   = 0x00000000,
    ///The portal is available.
    VDS_IPS_ONLINE    = 0x00000001,
    ///The portal is busy.
    VDS_IPS_NOT_READY = 0x00000002,
    ///The portal is unavailable.
    VDS_IPS_OFFLINE   = 0x00000004,
    ///The portal has failed.
    VDS_IPS_FAILED    = 0x00000005,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of object status values for a storage pool.
alias VDS_STORAGE_POOL_STATUS = int;
enum : int
{
    ///The provider failed to get the storage pool properties or could not access the storage pool.
    VDS_SPS_UNKNOWN   = 0x00000000,
    ///The storage pool is available.
    VDS_SPS_ONLINE    = 0x00000001,
    ///The storage pool is busy.
    VDS_SPS_NOT_READY = 0x00000002,
    ///The storage pool is not available.
    VDS_SPS_OFFLINE   = 0x00000004,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of storage pool types. These values are used in
///the type member of the <b>VDS_STORAGE_POOL_PROP</b> structure.
alias VDS_STORAGE_POOL_TYPE = int;
enum : int
{
    ///The storage pool type is unknown.
    VDS_SPT_UNKNOWN    = 0x00000000,
    ///The storage pool type is primordial.
    VDS_SPT_PRIMORDIAL = 0x00000001,
    ///The storage pool type is concrete (non-primordial).
    VDS_SPT_CONCRETE   = 0x00000002,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set of valid subsystem maintenance operations.
alias VDS_MAINTENANCE_OPERATION = int;
enum : int
{
    ///Blinks a light on a drive.
    BlinkLight = 0x00000001,
    ///Beeps an alarm on a drive.
    BeepAlarm  = 0x00000002,
    ///Slows the spinning of a drive such that the drive enters an idle state. Typically used for the purpose of saving
    ///power.
    SpinDown   = 0x00000003,
    ///Starts the spinning of a drive in preparation for data reads.
    SpinUp     = 0x00000004,
    ///Pings a drive.
    Ping       = 0x00000005,
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the set enumeration values that can be used to specify the
///underlying RAID type of a storage pool. These values are used in the <b>raidType</b> member of the
///VDS_POOL_ATTRIBUTES structure.
alias VDS_RAID_TYPE = int;
enum : int
{
    ///The RAID level is unknown.
    VDS_RT_UNKNOWN = 0x00000000,
    ///RAID level 0.
    VDS_RT_RAID0   = 0x0000000a,
    ///RAID level 1.
    VDS_RT_RAID1   = 0x0000000b,
    ///RAID level 2.
    VDS_RT_RAID2   = 0x0000000c,
    ///RAID level 3.
    VDS_RT_RAID3   = 0x0000000d,
    ///RAID level 4.
    VDS_RT_RAID4   = 0x0000000e,
    ///RAID level 5.
    VDS_RT_RAID5   = 0x0000000f,
    ///RAID level 6.
    VDS_RT_RAID6   = 0x00000010,
    ///RAID level 0+1.
    VDS_RT_RAID01  = 0x00000011,
    ///RAID level 0+3.
    VDS_RT_RAID03  = 0x00000012,
    ///RAID level 0+5.
    VDS_RT_RAID05  = 0x00000013,
    ///RAID level 1+0.
    VDS_RT_RAID10  = 0x00000014,
    ///RAID level 1+5.
    VDS_RT_RAID15  = 0x00000015,
    ///RAID level 3+0.
    VDS_RT_RAID30  = 0x00000016,
    ///RAID level 5+0.
    VDS_RT_RAID50  = 0x00000017,
    ///RAID level 5+1.
    VDS_RT_RAID51  = 0x00000018,
    ///RAID level 5+3.
    VDS_RT_RAID53  = 0x00000019,
    ///RAID level 6+0.
    VDS_RT_RAID60  = 0x0000001a,
    ///RAID level 6+1.
    VDS_RT_RAID61  = 0x0000001b,
}

///The <b>VSS_OBJECT_TYPE</b> enumeration is used by requesters to identify an object as a shadow copy set, shadow copy,
///or provider.
alias VSS_OBJECT_TYPE = int;
enum : int
{
    ///The object type is not known. This indicates an application error.
    VSS_OBJECT_UNKNOWN      = 0x00000000,
    ///The interpretation of this value depends on whether it is used as an input to a VSS method or returned as an
    ///output from a VSS method. When used as an input to a VSS method, it indicates that the method is not restricted
    ///to any particular object type, but should act on all appropriate objects. In this sense, <b>VSS_OBJECT_NONE</b>
    ///can be thought of as a wildcard input. When returned as an output, the object type is not known and means that
    ///there has been an application error.
    VSS_OBJECT_NONE         = 0x00000001,
    ///Shadow copy set.
    VSS_OBJECT_SNAPSHOT_SET = 0x00000002,
    ///Shadow copy.
    VSS_OBJECT_SNAPSHOT     = 0x00000003,
    ///Shadow copy provider.
    VSS_OBJECT_PROVIDER     = 0x00000004,
    ///Reserved value.
    VSS_OBJECT_TYPE_COUNT   = 0x00000005,
}

///The <b>VSS_SNAPSHOT_STATE</b> enumeration is returned by a provider to specify the state of a given shadow copy
///operation.
alias VSS_SNAPSHOT_STATE = int;
enum : int
{
    ///Reserved for system use. Unknown shadow copy state.
    VSS_SS_UNKNOWN                    = 0x00000000,
    ///Reserved for system use. Shadow copy is being prepared.
    VSS_SS_PREPARING                  = 0x00000001,
    ///Reserved for system use. Processing of the shadow copy preparation is in progress.
    VSS_SS_PROCESSING_PREPARE         = 0x00000002,
    ///Reserved for system use. Shadow copy has been prepared.
    VSS_SS_PREPARED                   = 0x00000003,
    ///Reserved for system use. Processing of the shadow copy precommit is in process.
    VSS_SS_PROCESSING_PRECOMMIT       = 0x00000004,
    ///Reserved for system use. Shadow copy is precommitted.
    VSS_SS_PRECOMMITTED               = 0x00000005,
    ///Reserved for system use. Processing of the shadow copy commit is in process.
    VSS_SS_PROCESSING_COMMIT          = 0x00000006,
    ///Reserved for system use. Shadow copy is committed.
    VSS_SS_COMMITTED                  = 0x00000007,
    ///Reserved for system use. Processing of the shadow copy postcommit is in process.
    VSS_SS_PROCESSING_POSTCOMMIT      = 0x00000008,
    ///Reserved for system use. Processing of the shadow copy file commit operation is underway.
    VSS_SS_PROCESSING_PREFINALCOMMIT  = 0x00000009,
    ///Reserved for system use. Processing of the shadow copy file commit operation is done.
    VSS_SS_PREFINALCOMMITTED          = 0x0000000a,
    ///Reserved for system use. Processing of the shadow copy following the final commit and prior to shadow copy create
    ///is underway.
    VSS_SS_PROCESSING_POSTFINALCOMMIT = 0x0000000b,
    ///Shadow copy is created.
    VSS_SS_CREATED                    = 0x0000000c,
    ///Reserved for system use. Shadow copy creation is aborted.
    VSS_SS_ABORTED                    = 0x0000000d,
    ///Reserved for system use. Shadow copy has been deleted.
    VSS_SS_DELETED                    = 0x0000000e,
    VSS_SS_POSTCOMMITTED              = 0x0000000f,
    ///Reserved value.
    VSS_SS_COUNT                      = 0x00000010,
}

///Allows additional attributes to be specified for a shadow copy. The context of a shadow copy (as set by the
///IVssBackupComponents::SetContext method) may be modified by a bitmask that contains a valid combination of
///<b>_VSS_VOLUME_SNAPSHOT_ATTRIBUTES</b> and _VSS_SNAPSHOT_CONTEXT enumeration values.
alias VSS_VOLUME_SNAPSHOT_ATTRIBUTES = int;
enum : int
{
    ///The shadow copy is persistent across reboots. This attribute is automatically set for _VSS_SNAPSHOT_CONTEXT
    ///contexts of <b>VSS_CTX_APP_ROLLBACK</b>, <b>VSS_CTX_CLIENT_ACCESSIBLE</b>,
    ///<b>VSS_CTX_CLIENT_ACCESSIBLE_WRITERS</b>, and <b>VSS_CTX_NAS_ROLLBACK</b>. This attribute should not be used
    ///explicitly by requesters when setting the context of a shadow copy.
    VSS_VOLSNAP_ATTR_PERSISTENT           = 0x00000001,
    ///Auto-recovery is disabled for the shadow copy. A requester can modify a shadow copy context with a bitwise OR of
    ///this attribute. By doing this, the requester instructs VSS to make the shadow copy read-only immediately after it
    ///is created, without allowing writers or other applications to update components in the shadow copy. Disabling
    ///auto-recovery can cause the shadow copy to be in an inconsistent state if any of its components are involved in
    ///transactional database operations, such as transactional read and write operations managed by Transactional NTFS
    ///(TxF). This is because disabling auto-recovery prevents incomplete transactions from being rolled back. Disabling
    ///auto-recovery also prevents writers from excluding files from the shadow copy. When auto-recovery is disabled, a
    ///writer can still call the IVssCreateWriterMetadataEx::AddExcludeFilesFromSnapshot method, but the writer's
    ///CVssWriter::OnPostSnapshot method cannot delete the files from the shadow copy. <b>Windows Server 2003 and
    ///Windows XP: </b>This value is not supported until Windows Vista.
    VSS_VOLSNAP_ATTR_NO_AUTORECOVERY      = 0x00000002,
    ///The specified shadow copy is a client-accessible shadow copy that supports Shadow Copies for Shared Folders, and
    ///should not be exposed. This attribute is automatically set for <b>VSS_CTX_CLIENT_ACCESSIBLE</b> and
    ///<b>VSS_CTX_CLIENT_ACCESSIBLE_WRITERS</b>. This attribute should not be used explicitly by requesters when setting
    ///the context of a shadow copy.
    VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE    = 0x00000004,
    ///The shadow copy is not automatically deleted when the shadow copy requester process ends. The shadow copy can be
    ///deleted only by a call to IVssBackupComponents::DeleteSnapshots. This attribute is automatically set for
    ///_VSS_SNAPSHOT_CONTEXT contexts of <b>VSS_CTX_APP_ROLLBACK</b>, <b>VSS_CTX_CLIENT_ACCESSIBLE</b>,
    ///<b>VSS_CTX_CLIENT_ACCESSIBLE_WRITERS</b>, and <b>VSS_CTX_NAS_ROLLBACK</b>. This attribute should not be used
    ///explicitly by requesters when setting the context of a shadow copy.
    VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE      = 0x00000008,
    ///No writers are involved in creating the shadow copy. This attribute is automatically set for
    ///_VSS_SNAPSHOT_CONTEXT contexts of <b>VSS_CTX_NAS_ROLLBACK</b>, <b>VSS_CTX_FILE_SHARE_BACKUP</b>, and
    ///<b>VSS_CTX_CLIENT_ACCESSIBLE</b>. This attribute should not be used explicitly by requesters when setting the
    ///context of a shadow copy.
    VSS_VOLSNAP_ATTR_NO_WRITERS           = 0x00000010,
    ///The shadow copy is to be transported and therefore should not be surfaced locally. This attribute can be used
    ///explicitly by requesters when setting the context of a shadow copy, if the provider for shadow copy supports
    ///transportable shadow copies. <b>Windows Server 2003, Standard Edition, Windows Server 2003, Web Edition and
    ///Windows XP: </b>This attribute is not supported. All editions of Windows Server 2003 with SP1 support this
    ///attribute. See <a href="/windows/desktop/VSS/importing-transportable-shadow-copied-volumes">Importing
    ///Transportable Shadow Copied Volumes</a> for more information.
    VSS_VOLSNAP_ATTR_TRANSPORTABLE        = 0x00000020,
    ///The shadow copy is not currently exposed. Unless the shadow copy is explicitly exposed or mounted, this attribute
    ///is set for all shadow copies. This attribute should not be used explicitly by requesters when setting the context
    ///of a shadow copy.
    VSS_VOLSNAP_ATTR_NOT_SURFACED         = 0x00000040,
    ///The shadow copy is not transacted. A requester can modify a shadow copy context with a bitwise OR of this
    ///attribute. By doing this, the requester instructs VSS to disable built-in integration between VSS and transaction
    ///and resource managers. Setting this attribute guarantees that the requester will not receive
    ///VSS_E_TRANSACTION_FREEZE_TIMEOUT errors. However, it may cause unwanted consequences, such as the loss of
    ///transactional integrity or even data loss. <b>Windows Server 2003 and Windows XP: </b>This value is not supported
    ///until Windows Vista.
    VSS_VOLSNAP_ATTR_NOT_TRANSACTED       = 0x00000080,
    ///Indicates that a given provider is a hardware provider. This attribute is automatically set for hardware
    ///providers. This enumeration value cannot be used to manually set the context (using the
    ///IVssBackupComponents::SetContext method) of a shadow copy by a bit mask (or bitwise OR) of this enumeration value
    ///and a valid shadow copy context value from _VSS_SNAPSHOT_CONTEXT.
    VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED    = 0x00010000,
    ///Indicates that a given provider uses differential data or a copy-on-write mechanism to implement shadow copies. A
    ///requester can modify a shadow copy context with a bitwise OR of this attribute. By doing this, the requester
    ///instructs providers to create a shadow copy using a differential implementation. If no shadow copy provider
    ///installed on the system supports the requested attributes, a VSS_E_VOLUME_NOT_SUPPORTED error will be returned to
    ///IVssBackupComponents::AddToSnapshotSet.
    VSS_VOLSNAP_ATTR_DIFFERENTIAL         = 0x00020000,
    ///Indicates that a given provider uses a PLEX or mirrored split mechanism to implement shadow copies. A requester
    ///can modify a shadow copy context with a bitwise OR of this attribute. By doing this, the requester instructs the
    ///providers to create a shadow copy using a PLEX implementation. If no shadow copy provider installed on the system
    ///supports the requested attributes, a VSS_E_VOLUME_NOT_SUPPORTED error will be returned to
    ///IVssBackupComponents::AddToSnapshotSet.
    VSS_VOLSNAP_ATTR_PLEX                 = 0x00040000,
    ///The shadow copy of the volume was imported onto this machine using the IVssBackupComponents::ImportSnapshots
    ///method rather than created using the IVssBackupComponents::DoSnapshotSet method. This attribute is automatically
    ///set if a shadow copy is imported. This attribute should not be used explicitly by requesters when setting the
    ///context of a shadow copy.
    VSS_VOLSNAP_ATTR_IMPORTED             = 0x00080000,
    ///The shadow copy is locally exposed. If this bit flag and the VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY bit flag are not
    ///set, the shadow copy is hidden. The attribute is automatically added to a shadow copy context upon calling the
    ///IVssBackupComponents::ExposeSnapshot method to expose a shadow copy locally. This attribute should not be used
    ///explicitly by requesters when setting the context of a shadow copy.
    VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY      = 0x00100000,
    ///The shadow copy is remotely exposed. If this bit flag and the VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY bit flag are not
    ///set, the shadow copy is hidden. The attribute is automatically added to a shadow copy context upon calling the
    ///IVssBackupComponents::ExposeSnapshot method to expose a shadow copy locally. This attribute should not be used
    ///explicitly by requesters when setting the context of a shadow copy.
    VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY     = 0x00200000,
    ///Indicates that the writer will need to auto-recover the component in CVssWriter::OnPostSnapshot. This attribute
    ///should not be used explicitly by requesters when setting the context of a shadow copy.
    VSS_VOLSNAP_ATTR_AUTORECOVER          = 0x00400000,
    ///Indicates that the writer will need to auto-recover the component in CVssWriter::OnPostSnapshot if the shadow
    ///copy is being used for rollback (for data mining, for example). A requester would set this flag in the shadow
    ///copy context to indicate that the shadow copy is being created for a non-backup purpose such as data mining.
    VSS_VOLSNAP_ATTR_ROLLBACK_RECOVERY    = 0x00800000,
    ///Reserved for system use. <b>Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported
    ///until Windows Server 2008.
    VSS_VOLSNAP_ATTR_DELAYED_POSTSNAPSHOT = 0x01000000,
    ///Indicates that TxF recovery should be enforced during shadow copy creation. <b>Windows Vista, Windows Server 2003
    ///and Windows XP: </b>This value is not supported until Windows Server 2008.
    VSS_VOLSNAP_ATTR_TXF_RECOVERY         = 0x02000000,
    VSS_VOLSNAP_ATTR_FILE_SHARE           = 0x04000000,
}

///The <b>_VSS_SNAPSHOT_CONTEXT</b> enumeration enables a requester using IVssBackupComponents::SetContext to specify
///how a shadow copy is to be created, queried, or deleted and the degree of writer involvement.
alias VSS_SNAPSHOT_CONTEXT = int;
enum : int
{
    ///The standard backup context. Specifies an auto-release, nonpersistent shadow copy in which writers are involved
    ///in the creation.
    VSS_CTX_BACKUP                    = 0x00000000,
    ///Specifies an auto-release, nonpersistent shadow copy created without writer involvement.
    VSS_CTX_FILE_SHARE_BACKUP         = 0x00000010,
    ///Specifies a persistent, non-auto-release shadow copy without writer involvement. This context should be used when
    ///there is no need for writer involvement to ensure that files are in a consistent state at the time of the shadow
    ///copy. Lightweight automated file rollback mechanisms or persistent shadow copies of file shares or data volumes
    ///that are not expected to contain any system-related files or databases might run under this context. For example,
    ///a requester could use this context for creating a shadow copy of a NAS volume hosting documents and simple user
    ///shares. Those types of data do not need writer involvement to create a consistent shadow copy.
    VSS_CTX_NAS_ROLLBACK              = 0x00000019,
    ///Specifies a persistent, non-auto-release shadow copy with writer involvement. This context is designed to be used
    ///when writers are needed to ensure that files are in a well-defined state prior to shadow copy. Automated file
    ///rollback mechanisms of system volumes and shadow copies to be used in data mining or restore operations might run
    ///under this context. This context is similar to <b>VSS_CTX_BACKUP</b> but allows a requester more control over the
    ///persistence of the shadow copy.
    VSS_CTX_APP_ROLLBACK              = 0x00000009,
    ///Specifies a read-only, client-accessible shadow copy that supports Shadow Copies for Shared Folders and is
    ///created without writer involvement. Only the system provider (the default provider available on the system) can
    ///create this type of shadow copy. Most requesters will want to use the <b>VSS_CTX_NAS_ROLLBACK</b> context for
    ///persistent, non-auto-release shadow copies without writer involvement.
    VSS_CTX_CLIENT_ACCESSIBLE         = 0x0000001d,
    ///Specifies a read-only, client-accessible shadow copy that is created with writer involvement. Only the system
    ///provider (the default provider available on the system) can create this type of shadow copy. Most requesters will
    ///want to use the <b>VSS_CTX_APP_ROLLBACK</b> context for persistent, non-auto-release shadow copies with writer
    ///involvement. <b>Windows Server 2003 and Windows XP: </b>This context is not supported by Windows Server 2003 and
    ///Windows XP.
    VSS_CTX_CLIENT_ACCESSIBLE_WRITERS = 0x0000000d,
    ///All types of currently live shadow copies are available for administrative operations, such as shadow copy
    ///queries (see IVssBackupComponents::Query). <b>VSS_CTX_ALL</b> is a valid context for all VSS interfaces except
    ///IVssBackupComponents::StartSnapshotSet and IVssBackupComponents::DoSnapshotSet.
    VSS_CTX_ALL                       = 0xffffffff,
}

///Not supported. This enumeration is reserved for future use.
alias VSS_PROVIDER_CAPABILITIES = int;
enum : int
{
    VSS_PRV_CAPABILITY_LEGACY           = 0x00000001,
    VSS_PRV_CAPABILITY_COMPLIANT        = 0x00000002,
    VSS_PRV_CAPABILITY_LUN_REPOINT      = 0x00000004,
    VSS_PRV_CAPABILITY_LUN_RESYNC       = 0x00000008,
    VSS_PRV_CAPABILITY_OFFLINE_CREATION = 0x00000010,
    VSS_PRV_CAPABILITY_MULTIPLE_IMPORT  = 0x00000020,
    VSS_PRV_CAPABILITY_RECYCLING        = 0x00000040,
    VSS_PRV_CAPABILITY_PLEX             = 0x00000080,
    VSS_PRV_CAPABILITY_DIFFERENTIAL     = 0x00000100,
    VSS_PRV_CAPABILITY_CLUSTERED        = 0x00000200,
}

///Defines shadow copy LUN flags.
alias VSS_HARDWARE_OPTIONS = int;
enum : int
{
    ///The shadow copy LUN will be masked from the host.
    VSS_BREAKEX_FLAG_MASK_LUNS                    = 0x00000001,
    ///The shadow copy LUN will be exposed to the host as a read-write volume.
    VSS_BREAKEX_FLAG_MAKE_READ_WRITE              = 0x00000002,
    ///The disk identifiers of all of the shadow copy LUNs will be reverted to that of the original LUNs. However, if
    ///any of the original LUNs are present on the system, the operation will fail and none of the identifiers will be
    ///reverted.
    VSS_BREAKEX_FLAG_REVERT_IDENTITY_ALL          = 0x00000004,
    ///None of the disk identifiers of the shadow copy LUNs will be reverted.
    VSS_BREAKEX_FLAG_REVERT_IDENTITY_NONE         = 0x00000008,
    ///The shadow copy LUNs will be converted permanently to read-write. This flag is set only as a notification for the
    ///provider; no provider action is required. For more information, see the
    ///IVssHardwareSnapshotProviderEx::OnLunStateChange method.
    VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE        = 0x00000100,
    ///The shadow copy LUNs will be converted temporarily to read-write and are about to undergo TxF recovery or VSS
    ///auto-recovery. This flag is set only as a notification for the provider; no provider action is required. For more
    ///information, see the IVssHardwareSnapshotProviderEx::OnLunStateChange method.
    VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY  = 0x00000200,
    ///The shadow copy LUNs have just undergone TxF recovery or VSS auto-recovery and have been converted back to
    ///read-only. This flag is set only as a notification for the provider; no provider action is required. For more
    ///information, see the IVssHardwareSnapshotProviderEx::OnLunStateChange method.
    VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY = 0x00000400,
    ///The provider must mask shadow copy LUNs from this computer. For more information, see the
    ///IVssHardwareSnapshotProviderEx::OnLunStateChange method.
    VSS_ONLUNSTATECHANGE_DO_MASK_LUNS             = 0x00000800,
}

///Used by a requester to specify how a resynchronization operation is to be performed.
alias VSS_RECOVERY_OPTIONS = int;
enum : int
{
    ///After the resynchronization operation is complete, the signature of each target LUN should be identical to that
    ///of the original LUN that was used to create the shadow copy.
    VSS_RECOVERY_REVERT_IDENTITY_ALL = 0x00000100,
    ///Volume safety checks should not be performed.
    VSS_RECOVERY_NO_VOLUME_CHECK     = 0x00000200,
}

///The <b>VSS_WRITER_STATE</b> enumeration indicates the current state of the writer.
alias VSS_WRITER_STATE = int;
enum : int
{
    ///The writer's state is not known. This indicates an error on the part of the writer.
    VSS_WS_UNKNOWN                     = 0x00000000,
    ///The writer has completed processing current shadow copy events and is ready to proceed, or
    ///CVssWriter::OnPrepareSnapshot has not yet been called.
    VSS_WS_STABLE                      = 0x00000001,
    ///The writer is waiting for the freeze state.
    VSS_WS_WAITING_FOR_FREEZE          = 0x00000002,
    ///The writer is waiting for the thaw state.
    VSS_WS_WAITING_FOR_THAW            = 0x00000003,
    ///The writer is waiting for the PostSnapshot state.
    VSS_WS_WAITING_FOR_POST_SNAPSHOT   = 0x00000004,
    ///The writer is waiting for the requester to finish its backup operation.
    VSS_WS_WAITING_FOR_BACKUP_COMPLETE = 0x00000005,
    ///The writer vetoed the shadow copy creation process at the writer identification state.
    VSS_WS_FAILED_AT_IDENTIFY          = 0x00000006,
    ///The writer vetoed the shadow copy creation process during the backup preparation state.
    VSS_WS_FAILED_AT_PREPARE_BACKUP    = 0x00000007,
    ///The writer vetoed the shadow copy creation process during the PrepareForSnapshot state.
    VSS_WS_FAILED_AT_PREPARE_SNAPSHOT  = 0x00000008,
    ///The writer vetoed the shadow copy creation process during the freeze state.
    VSS_WS_FAILED_AT_FREEZE            = 0x00000009,
    ///The writer vetoed the shadow copy creation process during the thaw state.
    VSS_WS_FAILED_AT_THAW              = 0x0000000a,
    ///The writer vetoed the shadow copy creation process during the PostSnapshot state.
    VSS_WS_FAILED_AT_POST_SNAPSHOT     = 0x0000000b,
    ///The shadow copy has been created and the writer failed during the BackupComplete state. A writer should save
    ///information about this failure to the error log. For additional information on logging, see Event and Error
    ///Handling Under VSS.
    VSS_WS_FAILED_AT_BACKUP_COMPLETE   = 0x0000000c,
    ///The writer failed during the PreRestore state.
    VSS_WS_FAILED_AT_PRE_RESTORE       = 0x0000000d,
    ///The writer failed during the PostRestore state.
    VSS_WS_FAILED_AT_POST_RESTORE      = 0x0000000e,
    ///The writer failed during the shutdown of the backup application.
    VSS_WS_FAILED_AT_BACKUPSHUTDOWN    = 0x0000000f,
    ///Reserved value.
    VSS_WS_COUNT                       = 0x00000010,
}

///The <b>VSS_BACKUP_TYPE</b> enumeration indicates the type of backup to be performed using VSS writer/requester
///coordination.
alias VSS_BACKUP_TYPE = int;
enum : int
{
    ///The backup type is not known. This value indicates an application error.
    VSS_BT_UNDEFINED    = 0x00000000,
    ///Full backup: all files, regardless of whether they have been marked as backed up or not, are saved. This is the
    ///default backup type and schema, and all writers support it. Each file's backup history will be updated to reflect
    ///that it was backed up.
    VSS_BT_FULL         = 0x00000001,
    ///Incremental backup: files created or changed since the last full or incremental backup are saved. Files are
    ///marked as having been backed up. A requester can implement this sort of backup on a particular writer only if it
    ///supports the <b>VSS_BS_INCREMENTAL</b> schema. If a requester's backup type is <b>VSS_BT_INCREMENTAL</b> and a
    ///particular writer's backup schema does not support that sort of backup, the requester will always perform a full
    ///(<b>VSS_BT_FULL</b>) backup on that writer's data.
    VSS_BT_INCREMENTAL  = 0x00000002,
    ///Differential backup: files created or changed since the last full backup are saved. Files are not marked as
    ///having been backed up. A requester can implement this sort of backup on a particular writer only if it supports
    ///the <b>VSS_BS_DIFFERENTIAL</b> schema. If a requester's backup type is <b>VSS_BT_DIFFERENTIAL</b> and a
    ///particular writer's backup schema does not support that sort of backup, the requester will always perform a full
    ///(<b>VSS_BT_FULL</b>) backup on that writer's data.
    VSS_BT_DIFFERENTIAL = 0x00000003,
    ///The log file of a writer is to participate in backup or restore operations. A requester can implement this sort
    ///of backup on a particular writer only if it supports the <b>VSS_BS_LOG</b> schema. If a requester's backup type
    ///is <b>VSS_BT_LOG</b> and a particular writer's backup schema does not support that sort of backup, the requester
    ///will always perform a full (<b>VSS_BT_FULL</b>) backup on that writer's data.
    VSS_BT_LOG          = 0x00000004,
    ///Files on disk will be copied to a backup medium regardless of the state of each file's backup history, and the
    ///backup history will not be updated. A requester can implement this sort of backup on a particular writer only if
    ///it supports the <b>VSS_BS_COPY</b> schema. If a requester's backup type is <b>VSS_BT_COPY</b> and a particular
    ///writer's backup schema does not support that sort of backup, the requester will always perform a full
    ///(<b>VSS_BT_FULL</b>) backup on that writer's data.
    VSS_BT_COPY         = 0x00000005,
    ///Backup type that is not full, copy, log, incremental, or differential.
    VSS_BT_OTHER        = 0x00000006,
}

///The <b>VSS_RESTORE_TYPE</b> enumeration is used by a requester to indicate the type of restore operation it is about
///to perform.
alias VSS_RESTORE_TYPE = int;
enum : int
{
    ///No restore type is defined. This is the default restore type. However, writers should treat this restore type as
    ///if it were VSS_RTYPE_BY_COPY. This indicates an error on the part of the requester.
    VSS_RTYPE_UNDEFINED = 0x00000000,
    ///A requester restores backed-up data to the original volume from a backup medium.
    VSS_RTYPE_BY_COPY   = 0x00000001,
    ///A requester does not copy data from a backup medium, but imports a transportable shadow copy and uses this
    ///imported volume for operations such as data mining. <b>Windows Server 2003, Standard Edition and Windows Server
    ///2003, Web Edition: </b>This value is not supported. All editions of Windows Server 2003 with SP1 support this
    ///value.
    VSS_RTYPE_IMPORT    = 0x00000002,
    ///A restore type not currently enumerated. This value indicates an application error.
    VSS_RTYPE_OTHER     = 0x00000003,
}

///The <b>VSS_ROLLFORWARD_TYPE</b> enumeration is used by a requester to indicate the type of roll-forward operation it
///is about to perform.
alias VSS_ROLLFORWARD_TYPE = int;
enum : int
{
    ///No roll-forward type is defined. This indicates an error on the part of the requester.
    VSS_RF_UNDEFINED = 0x00000000,
    ///The roll-forward operation should not roll forward through logs.
    VSS_RF_NONE      = 0x00000001,
    ///The roll-forward operation should roll forward through all logs.
    VSS_RF_ALL       = 0x00000002,
    ///The roll-forward operation should roll forward through logs up to a specified restore point.
    VSS_RF_PARTIAL   = 0x00000003,
}

///The <b>VSS_PROVIDER_TYPE</b> enumeration specifies the provider type.
alias VSS_PROVIDER_TYPE = int;
enum : int
{
    ///The provider type is unknown. This indicates an error in the application or the VSS service, or that no provider
    ///is available.
    VSS_PROV_UNKNOWN   = 0x00000000,
    ///The default provider that ships with Windows.
    VSS_PROV_SYSTEM    = 0x00000001,
    ///A software provider.
    VSS_PROV_SOFTWARE  = 0x00000002,
    ///A hardware provider.
    VSS_PROV_HARDWARE  = 0x00000003,
    ///A file share provider. <b>Windows 7, Windows Server 2008 R2, Windows Vista, Windows Server 2008, Windows XP and
    ///Windows Server 2003: </b>This enumeration value is not supported until Windows 8 and Windows Server 2012.
    VSS_PROV_FILESHARE = 0x00000004,
}

///The <b>VSS_APPLICATION_LEVEL</b> enumeration indicates the application level, the point in the course of the creation
///of a shadow copy that a writer is notified of a freeze. VSS first sends a Freeze event to writers initialized with
///<b>VSS_APP_FRONT_END</b> (called front-end level applications), then to writers initialized with
///<b>VSS_APP_BACK_END</b> (called back-end level applications), and finally to writers initialized with
///<b>VSS_APP_SYSTEM</b> (called system-level applications).
alias VSS_APPLICATION_LEVEL = int;
enum : int
{
    ///The level at which this writer's freeze state will occur is not known. This indicates an application error.
    VSS_APP_UNKNOWN   = 0x00000000,
    ///This writer freeze state will occur at the system application level.
    VSS_APP_SYSTEM    = 0x00000001,
    ///This writer freeze state will occur at the back-end application level.
    VSS_APP_BACK_END  = 0x00000002,
    ///This writer freeze state will occur at the front-end application level.
    VSS_APP_FRONT_END = 0x00000003,
    VSS_APP_SYSTEM_RM = 0x00000004,
    ///This writer freeze state will be determined automatically. This enumeration value is reserved for future use.
    VSS_APP_AUTO      = 0xffffffff,
}

///The <b>VSS_SNAPSHOT_COMPATIBILITY</b> enumeration indicates which volume control or file I/O operations are disabled
///for the volume that has been shadow copied.
alias VSS_SNAPSHOT_COMPATIBILITY = int;
enum : int
{
    ///The provider managing the shadow copies for a specified volume does not support defragmentation operations on
    ///that volume.
    VSS_SC_DISABLE_DEFRAG       = 0x00000001,
    VSS_SC_DISABLE_CONTENTINDEX = 0x00000002,
}

///Specifies the property to be set for a shadow copy.
alias VSS_SNAPSHOT_PROPERTY_ID = int;
enum : int
{
    ///The property is not known. This value indicates an application error.
    VSS_SPROPID_UNKNOWN             = 0x00000000,
    ///The shadow copy identifier. For more information, see the <b>m_SnapshotId</b> member of the VSS_SNAPSHOT_PROP
    ///structure.
    VSS_SPROPID_SNAPSHOT_ID         = 0x00000001,
    ///The shadow copy set identifier. For more information, see the <b>m_SnapshotSetId</b> member of the
    ///VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_SNAPSHOT_SET_ID     = 0x00000002,
    ///The number of volumes included with the shadow copy in the shadow copy set when it was created. For more
    ///information, see the <b>m_lSnapshotsCount</b> member of the VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_SNAPSHOTS_COUNT     = 0x00000003,
    ///Null-terminated wide character string that specifies the name of the device object for the shadow copy of the
    ///volume. For more information, see the <b>m_pwszSnapshotDeviceObject</b> member of the VSS_SNAPSHOT_PROP
    ///structure.
    VSS_SPROPID_SNAPSHOT_DEVICE     = 0x00000004,
    ///A null-terminated wide character string that specifies the name of the original volume. For more information, see
    ///the <b>m_pwszOriginalVolumeName</b> member of the VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_ORIGINAL_VOLUME     = 0x00000005,
    ///A null-terminated wide character string that specifies the name of the machine that contains the original volume.
    ///For more information, see the <b>m_pwszOriginatingMachine</b> member of the VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_ORIGINATING_MACHINE = 0x00000006,
    ///A null-terminated wide character string that specifies the name of the machine that is running the Volume Shadow
    ///Copy Service that created the shadow copy. For more information, see the <b>m_pwszServiceMachine</b> member of
    ///the VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_SERVICE_MACHINE     = 0x00000007,
    ///A null-terminated wide character string that specifies the name of the shadow copy when it is exposed. For more
    ///information, see the <b>m_pwszExposedName</b> member of the VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_EXPOSED_NAME        = 0x00000008,
    ///A null-terminated wide character string that specifies the portion of the volume that is made available when the
    ///shadow copy is exposed as a file share. For more information, see the <b>m_pwszExposedPath</b> member of the
    ///VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_EXPOSED_PATH        = 0x00000009,
    ///The provider identifier. For more information, see the <b>m_ProviderId</b> member of the VSS_SNAPSHOT_PROP
    ///structure.
    VSS_SPROPID_PROVIDER_ID         = 0x0000000a,
    ///A bitmask of _VSS_VOLUME_SNAPSHOT_ATTRIBUTES values that specify the properties of the shadow copy. For more
    ///information, see the <b>m_lSnapshotAttributes</b> member of the VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_SNAPSHOT_ATTRIBUTES = 0x0000000b,
    ///A time stamp that specifies when the shadow copy was created. For more information, see the
    ///<b>m_tsCreationTimestamp</b> member of the VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_CREATION_TIMESTAMP  = 0x0000000c,
    ///The status of the current shadow copy creation operation. For more information, see the <b>m_eStatus</b> member
    ///of the VSS_SNAPSHOT_PROP structure.
    VSS_SPROPID_STATUS              = 0x0000000d,
}

///The <b>VSS_FILE_SPEC_BACKUP_TYPE</b> enumeration is used by writers to indicate their support of certain backup
///operations—such as incremental or differential backup—on the basis of file sets (a specified file or files). File
///sets stored in the Writer Metadata Document are tagged with a bit mask (or bitwise OR) of
///<b>VSS_FILE_SPEC_BACKUP_TYPE</b> values indicating the following: <ul> <li>Whether the writer and the requester have
///to evaluate a given file set for participation in the specified type of backup operations</li> <li>Whether backing up
///the specified file will require a shadow copy</li> </ul>
alias VSS_FILE_SPEC_BACKUP_TYPE = int;
enum : int
{
    ///A file set tagged with this value must be involved in all types of backup operations. A writer tags a file set
    ///with this value to indicate to the requester that it expects a copy of the current version of the file set to be
    ///available following the restore of any backup operation with a VSS_BACKUP_TYPE of <b>VSS_BT_FULL</b>.
    VSS_FSBT_FULL_BACKUP_REQUIRED           = 0x00000001,
    ///A writer tags a file set with this value to indicate to the requester that it expects a copy of the current
    ///version of the file set to be available following the restore of any backup operation with a VSS_BACKUP_TYPE of
    ///<b>VSS_BT_DIFFERENTIAL</b>. This value is not supported for express writers.
    VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED   = 0x00000002,
    ///A writer tags a file set with this value to indicate to the requester that it expects a copy of the current
    ///version of the file set to be available following the restore of any backup operation with a VSS_BACKUP_TYPE of
    ///<b>VSS_BT_INCREMENTAL</b>. This value is not supported for express writers.
    VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED    = 0x00000004,
    ///A writer tags a file set with this value to indicate to the requester that it expects a copy of the current
    ///version of the file set to be available following the restore of any backup operation with a VSS_BACKUP_TYPE of
    ///<b>VSS_BT_LOG</b>. This value is not supported for express writers.
    VSS_FSBT_LOG_BACKUP_REQUIRED            = 0x00000008,
    ///A file set tagged with this value must be backed up from a shadow copy of a volume (and never from the original
    ///volume) when participating in a backup operation with a VSS_BACKUP_TYPE of <b>VSS_BT_FULL</b>.
    VSS_FSBT_FULL_SNAPSHOT_REQUIRED         = 0x00000100,
    ///A file set tagged with this value must be backed up from a shadow copy of a volume (and never from the original
    ///volume) when participating in a backup operation with a VSS_BACKUP_TYPE of <b>VSS_BT_DIFFERENTIAL</b>.
    VSS_FSBT_DIFFERENTIAL_SNAPSHOT_REQUIRED = 0x00000200,
    ///A file set tagged with this value must be backed up from a shadow copy of a volume (and never from the original
    ///volume) when participating in a backup operation with a VSS_BACKUP_TYPE of <b>VSS_BT_INCREMENTAL</b>.
    VSS_FSBT_INCREMENTAL_SNAPSHOT_REQUIRED  = 0x00000400,
    ///A file set tagged with this value must be backed up from a shadow copy of a volume (and never from the original
    ///volume) when participating in a backup operation with a VSS_BACKUP_TYPE of <b>VSS_BT_LOG</b>).
    VSS_FSBT_LOG_SNAPSHOT_REQUIRED          = 0x00000800,
    ///A writer tags a file set with this value to indicate to the requester that they expect the file to be created
    ///during the snapshot sequence.
    VSS_FSBT_CREATED_DURING_BACKUP          = 0x00010000,
    ///The default file backup specification type. A file set tagged with this value must always participate in backup
    ///and restore operations.
    VSS_FSBT_ALL_BACKUP_REQUIRED            = 0x0000000f,
    ///The shadow copy requirement for backup. A file set tagged with this value must always be backed up from a shadow
    ///copy of a volume (and never from the original volume) when participating in a backup operation.
    VSS_FSBT_ALL_SNAPSHOT_REQUIRED          = 0x00000f00,
}

///The <b>VSS_BACKUP_SCHEMA</b> enumeration is used by a writer to indicate the types of backup operations it can
///participate in. The supported kinds of backup are expressed as a bit mask (or bitwise OR) of <b>VSS_BACKUP_SCHEMA</b>
///values.
alias VSS_BACKUP_SCHEMA = int;
enum : int
{
    ///The writer supports a simple full backup and restoration of entire files (as defined by a VSS_BACKUP_TYPE value
    ///of <b>VSS_BT_FULL</b>). This backup scheme can be used as the basis of an incremental or differential backup.
    ///This is the default value.
    VSS_BS_UNDEFINED                          = 0x00000000,
    ///The writer supports differential backups (corresponding to the VSS_BACKUP_TYPE value <b>VSS_BT_DIFFERENTIAL</b>).
    ///Files created or changed since the last full backup are saved. Files are not marked as having been backed up.
    ///This setting does not preclude mixing of incremental and differential backups. This value is not supported for
    ///express writers.
    VSS_BS_DIFFERENTIAL                       = 0x00000001,
    ///The writer supports incremental backups (corresponding to the VSS_BACKUP_TYPE value <b>VSS_BT_INCREMENTAL</b>).
    ///Files created or changed since the last full or incremental backup are saved. Files are marked as having been
    ///backed up. This setting does not preclude mixing of incremental and differential backups. This value is not
    ///supported for express writers.
    VSS_BS_INCREMENTAL                        = 0x00000002,
    ///The writer supports both differential and incremental backup schemas, but only exclusively: for example, you
    ///cannot follow a differential backup with an incremental one. A writer cannot support this schema if it does not
    ///support both incremental and differential schemas (<b>VSS_BS_DIFFERENTIAL</b> | <b>VSS_BS_INCREMENTAL</b>). This
    ///value is not supported for express writers.
    VSS_BS_EXCLUSIVE_INCREMENTAL_DIFFERENTIAL = 0x00000004,
    ///The writer supports backups that involve only the log files it manages (corresponding to a VSS_BACKUP_TYPE value
    ///of <b>VSS_BT_LOG</b>). This schema requires a writer to have added at least one file to at least one component
    ///using the IVssCreateWriterMetadata::AddDataBaseLogFiles method. Requesters retrieve log file information using
    ///the IVssWMComponent::GetDatabaseLogFile method.
    VSS_BS_LOG                                = 0x00000008,
    ///Similar to the default backup schema (<b>VSS_BT_UNDEFINED</b>), the writer supports copy backup operations
    ///(corresponding to <b>VSS_BT_COPY</b>) where file access information (such as information as to when a file was
    ///last backed up) will not be updated either in the writer's own state information or in the file system
    ///information. This type of backup cannot be used as the basis of an incremental or differential backup.
    VSS_BS_COPY                               = 0x00000010,
    ///A writer supports using the VSS time-stamp mechanism when evaluating if a file should be included in differential
    ///or incremental operations (corresponding to <b>VSS_BT_DIFFERENTIAL</b> and <b>VSS_BT_INCREMENTAL</b>,
    ///respectively) using the IVssComponent::GetBackupStamp, IVssComponent::GetPreviousBackupStamp,
    ///IVssComponent::SetBackupStamp, and IVssBackupComponents::SetPreviousBackupStamp methods. A writer cannot support
    ///this schema if it does not support either differential or incremental backup schemas (<b>VSS_BS_DIFFERENTIAL</b>
    ///or <b>VSS_BS_INCREMENTAL</b>). This value is not supported for express writers.
    VSS_BS_TIMESTAMPED                        = 0x00000020,
    ///When implementing incremental or differential backups with differenced files, a writer can provide last
    ///modification time information for files (using IVssComponent::AddDifferencedFilesByLastModifyTime). A requester
    ///then can use IVssComponent::GetDifferencedFile to obtain candidate files and information about their last
    ///modification data. The requester can use this information (along with any records about previous backup
    ///operations it maintains) to decide if a file should be included in incremental and differential backups. This
    ///scheme does not apply to partial file implementations of incremental and differential backup operations. A writer
    ///cannot support this schema if it does not support either incremental or differential backup schemas
    ///(<b>VSS_BS_DIFFERENTIAL</b> or <b>VSS_BS_INCREMENTAL</b>). This value is not supported for express writers.
    VSS_BS_LAST_MODIFY                        = 0x00000040,
    ///Reserved for system use.
    VSS_BS_LSN                                = 0x00000080,
    ///The writer supports a requester changing the target for file restoration using
    ///IVssBackupComponents::AddNewTarget. (See <a
    ///href="/windows/desktop/VSS/non-default-backup-and-restore-locations">Non-Default Backup And Restore Locations</a>
    ///for more information.) This value is not supported for express writers.
    VSS_BS_WRITER_SUPPORTS_NEW_TARGET         = 0x00000100,
    ///The writer supports running multiple writer instances with the same class ID, and it supports a requester moving
    ///a component to a different writer instance at restore time using IVssBackupComponentsEx::SetSelectedForRestoreEx.
    ///This value is not supported for express writers. <b>Windows Server 2003: </b>This value is not supported until
    ///Windows Server 2003 with SP1.
    VSS_BS_WRITER_SUPPORTS_RESTORE_WITH_MOVE  = 0x00000200,
    ///The writer supports backing up data that is part of the system state, but that can also be backed up
    ///independently of the system state. <b>Windows Server 2003: </b>This value is not supported until Windows Vista.
    VSS_BS_INDEPENDENT_SYSTEM_STATE           = 0x00000400,
    ///The writer supports a requester setting a roll-forward restore point using
    ///IVssBackupComponentsEx2::SetRollForward. This value is not supported for express writers. <b>Windows Server 2003:
    ///</b>This value is not supported until Windows Vista.
    VSS_BS_ROLLFORWARD_RESTORE                = 0x00001000,
    ///The writer supports a requester setting a restore name using IVssBackupComponentsEx2::SetRestoreName. This value
    ///is not supported for express writers. <b>Windows Server 2003: </b>This value is not supported until Windows
    ///Vista.
    VSS_BS_RESTORE_RENAME                     = 0x00002000,
    ///The writer supports a requester setting authoritative restore using
    ///IVssBackupComponentsEx2::SetAuthoritativeRestore. This value is not supported for express writers. <b>Windows
    ///Server 2003: </b>This value is not supported until Windows Vista.
    VSS_BS_AUTHORITATIVE_RESTORE              = 0x00004000,
    ///The writer supports multiple unsynchronized restore events. This value is not supported for express writers.
    ///<b>Windows Vista and Windows Server 2003: </b>This value is not supported until Windows Server 2008.
    VSS_BS_WRITER_SUPPORTS_PARALLEL_RESTORES  = 0x00008000,
}

///The <b>VSS_USAGE_TYPE</b> enumeration specifies how the host system uses the data managed by a writer involved in a
///VSS operation.
alias VSS_USAGE_TYPE = int;
enum : int
{
    ///The usage type is not known. This indicates an error on the part of the writer.
    VSS_UT_UNDEFINED           = 0x00000000,
    ///The data stored by the writer is part of the bootable system state.
    VSS_UT_BOOTABLESYSTEMSTATE = 0x00000001,
    ///The writer either stores data used by a system service or is a system service itself.
    VSS_UT_SYSTEMSERVICE       = 0x00000002,
    ///The data is user data.
    VSS_UT_USERDATA            = 0x00000003,
    ///Unclassified data.
    VSS_UT_OTHER               = 0x00000004,
}

///The <b>VSS_SOURCE_TYPE</b> enumeration specifies the type of data that a writer manages.
alias VSS_SOURCE_TYPE = int;
enum : int
{
    ///The source of the data is not known. This indicates a writer error, and the requester should report it.
    VSS_ST_UNDEFINED       = 0x00000000,
    ///The source of the data is a database that supports transactions, such as Microsoft SQL Server.
    VSS_ST_TRANSACTEDDB    = 0x00000001,
    ///The source of the data is a database that does not support transactions.
    VSS_ST_NONTRANSACTEDDB = 0x00000002,
    ///Unclassified source type—data will be in a file group. This is the default source type.
    VSS_ST_OTHER           = 0x00000003,
}

///The <b>VSS_RESTOREMETHOD_ENUM</b> enumeration is used by a writer at backup time to specify through its Writer
///Metadata Document the default file restore method to be used with all the files in all the components it manages. The
///restore method is writer-wide and is also referred to as the original restore target and indicated by a
///VSS_RESTORE_TARGET value of <b>VSS_RT_ORIGINAL</b>.
alias VSS_RESTOREMETHOD_ENUM = int;
enum : int
{
    ///No restore method is defined. This indicates an error on the part of the writer. This value is not supported for
    ///express writers.
    VSS_RME_UNDEFINED                           = 0x00000000,
    ///The requester should restore the files of a selected component or component set only if there are no versions of
    ///those files currently on the disk. Unless alternate location mappings are defined for file restoration, if a
    ///version of any file managed by a selected component or component set is currently on the disk, none of the files
    ///managed by the selected component or component set should be restored. If a file's alternate location mapping is
    ///defined, and a version of the files is present on disk at the original location, files should be written to the
    ///alternate location only if no version of the file exists at the alternate location.
    VSS_RME_RESTORE_IF_NOT_THERE                = 0x00000001,
    ///The requester should restore files of a selected component or component set only if the files currently on the
    ///disk can be overwritten. Unless alternate location mappings are defined for file restoration, if there is a
    ///version of any file that cannot be overwritten of the selected component or component set on the disk, none of
    ///the files managed by the component or component set should be restored. If a file's alternate location mapping is
    ///defined, files should be written to the alternate location.
    VSS_RME_RESTORE_IF_CAN_REPLACE              = 0x00000002,
    ///The requester should perform the restore operation as follows: <ol> <li>Send the PreRestore event and wait for
    ///all writers to process it.</li> <li>Stop the service.</li> <li>Restore the files to their original
    ///locations.</li> <li>Restart the service.</li> <li>Send the PostRestore event and wait for all writers to process
    ///it.</li> </ol> The service to be stopped is specified the writer beforehand when it calls the
    ///IVssCreateWriterMetadata::SetRestoreMethod method. The requester can obtain the name of the service by calling
    ///the IVssExamineWriterMetadata::GetRestoreMethod method. Note that if the writer is hosted in the service that is
    ///being stopped, that writer will not receive the PostRestore event, because the writer instance ID changes when
    ///the service is stopped and restarted.
    VSS_RME_STOP_RESTORE_START                  = 0x00000003,
    ///The requester should restore the files of the selected component or component set to the location specified by
    ///the alternate location mapping specified in the writer component metadata file. (See
    ///IVssCreateWriterMetadata::AddAlternateLocationMapping, IVssComponent::GetAlternateLocationMapping,
    ///IVssExamineWriterMetadata::GetAlternateLocationMapping, and IVssWMFiledesc::GetAlternateLocation.) This value is
    ///not supported for express writers.
    VSS_RME_RESTORE_TO_ALTERNATE_LOCATION       = 0x00000004,
    ///The requester should restore the files of a selected component or component set after the computer is restarted.
    ///The files to be restored should be copied to a temporary location, and the requester should use MoveFileEx with
    ///the <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag to complete the restoration of these files to their proper location
    ///after the computer is restarted.
    VSS_RME_RESTORE_AT_REBOOT                   = 0x00000005,
    ///If possible, the requester should restore the files of the selected component or component set to their correct
    ///location immediately. If there are versions of any of the files managed by the selected component or component
    ///set on the disk that cannot be overwritten, then all the files managed by the selected component or component set
    ///should be restored after the computer is restarted. In this case, files to be restored should be copied to a
    ///temporary location on disk, and the requester should use MoveFileEx with the <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>
    ///flag to complete the restoration of these files to their proper location after the computer is restarted.
    VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE = 0x00000006,
    ///The requester should use a custom restore method to restore the files that are managed by the selected component
    ///or component set. A custom restore may use file retrieval API functions or protocols that are private to a given
    ///writer application. Such a restore need not use the information in the writer component metadata file. (See
    ///Custom Backups and Restores for more information.) This value is not supported for express writers.
    VSS_RME_CUSTOM                              = 0x00000007,
    ///The requester should perform the restore operation as follows: <ol> <li>Send the PreRestore event and wait for
    ///all writers to process it.</li> <li>Restore the files to their original locations.</li> <li>Send the PostRestore
    ///event and wait for all writers to process it.</li> <li>Stop the service.</li> <li>Restart the service.</li> </ol>
    ///The service to be stopped is specified by the writer beforehand when it calls the
    ///IVssCreateWriterMetadata::SetRestoreMethod method. The requester can obtain the name of the service by calling
    ///the IVssExamineWriterMetadata::GetRestoreMethod method.
    VSS_RME_RESTORE_STOP_START                  = 0x00000008,
}

///The <b>VSS_WRITERRESTORE_ENUM</b> numeration is used by a writer to indicate to a requester the conditions under
///which it will handle events generated during a restore operation.
alias VSS_WRITERRESTORE_ENUM = int;
enum : int
{
    ///It is not known whether the writer will perform special operations during the restore operation. This state
    ///indicates a writer error.
    VSS_WRE_UNDEFINED        = 0x00000000,
    ///The writer does not require restore events.
    VSS_WRE_NEVER            = 0x00000001,
    ///Indicates that the writer always expects to handle a PreRestore (CvssWriter::OnPreRestore) event, but expects to
    ///handle a PostRestore event (CvssWriter::OnPostRestore) only if a restore fails when implementing either a
    ///<b>VSS_RME_RESTORE_IF_NOT_THERE</b> or <b>VSS_RME_RESTORE_IF_CAN_REPLACE</b> restore method
    ///(VSS_RESTOREMETHOD_ENUM).
    VSS_WRE_IF_REPLACE_FAILS = 0x00000002,
    ///The writer always performs special operations during the restore operation.
    VSS_WRE_ALWAYS           = 0x00000003,
}

///The <b>VSS_COMPONENT_TYPE</b> enumeration is used by both the requester and the writer to specify the type of
///component being used with a shadow copy backup operation.
alias VSS_COMPONENT_TYPE = int;
enum : int
{
    ///Undefined component type. This value indicates an application error.
    VSS_CT_UNDEFINED = 0x00000000,
    ///Database component.
    VSS_CT_DATABASE  = 0x00000001,
    ///File group component. This is any component other than a database.
    VSS_CT_FILEGROUP = 0x00000002,
}

///The <b>VSS_ALTERNATE_WRITER_STATE</b> enumeration is used to indicate whether a given writer has an associated
///alternate writer. The existence of an alternate writer is set during writer initialization by CVssWriter::Initialize.
///Currently, the only supported value for a method taking a <b>VSS_ALTERNATE_WRITER_STATE</b> argument is
///<b>VSS_AWS_NO_ALTERNATE_WRITER</b>.
alias VSS_ALTERNATE_WRITER_STATE = int;
enum : int
{
    ///No information is available as to the existence of an alternate writer. This value indicates an application
    ///error. This enumeration value is reserved for future use.
    VSS_AWS_UNDEFINED                = 0x00000000,
    ///A given writer does not have an alternate writer.
    VSS_AWS_NO_ALTERNATE_WRITER      = 0x00000001,
    ///An alternate writer exists. This alternate writer runs when the writer is not available. This enumeration value
    ///is reserved for future use.
    VSS_AWS_ALTERNATE_WRITER_EXISTS  = 0x00000002,
    ///The writer in question is an alternate writer. This enumeration value is reserved for future use.
    VSS_AWS_THIS_IS_ALTERNATE_WRITER = 0x00000003,
}

///The <b>VSS_SUBSCRIBE_MASK</b> enumeration is used by a writer when subscribing to the VSS service. It indicates the
///events that the writer is willing to receive.
alias VSS_SUBSCRIBE_MASK = int;
enum : int
{
    ///This enumeration value is reserved for future use. Specifies that the writer expects to be notified after the
    ///shadow copy it is participating in has completed. It will then call CVssWriter::OnPostSnapshot.
    VSS_SM_POST_SNAPSHOT_FLAG  = 0x00000001,
    ///Currently, <b>VSS_SM_BACKUP_EVENTS_FLAG</b> can be used as an argument only when combined through a bitwise OR
    ///with <b>VSS_SM_RESTORE_EVENTS_FLAG</b>. Specifies that the writer can expect to receive the following events:
    ///<ul> <li>A PrepareForSnapshot event when the writer will call CVssWriter::OnPrepareSnapshot.</li> <li>A
    ///PrepareForBackup event when the writer will call CVssWriter::OnPrepareBackup.</li> <li>A Freeze event when the
    ///writer will call CVssWriter::OnFreeze.</li> <li>A BackupComplete event when the writer will call
    ///CVssWriter::OnBackupComplete.</li> <li>A Thaw event when the writer will call CVssWriter::OnThaw.</li> <li>A
    ///PostSnapshot event when the writer will call CVssWriter::OnPostSnapshot.</li> </ul>
    VSS_SM_BACKUP_EVENTS_FLAG  = 0x00000002,
    ///Currently, <b>VSS_SM_RESTORE_EVENTS_FLAG</b> can be used as an argument only when combined through a bitwise OR
    ///with <b>VSS_SM_BACKUP_EVENTS_FLAG</b>. Specifies that the writer can expect to receive the following events: <ul>
    ///<li>A PreRestore event when the writer will call CVssWriter::OnPreRestore.</li> <li>A PostRestore event when the
    ///writer will call CVssWriter::OnPostRestore.</li> </ul>
    VSS_SM_RESTORE_EVENTS_FLAG = 0x00000004,
    ///This enumeration value is reserved for future use.
    VSS_SM_IO_THROTTLING_FLAG  = 0x00000008,
    ///This enumeration value is reserved for future use. Specifies that the writer expects to be notified for all
    ///events.
    VSS_SM_ALL_FLAGS           = 0xffffffff,
}

///The <b>VSS_RESTORE_TARGET</b> enumeration is used by a writer at restore time to indicate how all the files included
///in a selected component, and all the files in any component set it defines, are to be restored. (See <a
///href="/windows/desktop/VSS/working-with-selectability-and-logical-paths">Working with Selectability and Logical
///Paths</a> for information on selecting components.) Setting a restore target modifies or overrides the restore method
///set during backup (see VSS_RESTOREMETHOD_ENUM).
alias VSS_RESTORE_TARGET = int;
enum : int
{
    ///No target is defined. This value indicates an error on the part of the writer. This value is not supported for
    ///express writers.
    VSS_RT_UNDEFINED         = 0x00000000,
    ///This is the default restore target. This value indicates that the restoration of the files included in a selected
    ///component (or the component set defined by that component) should proceed according to the original restore
    ///method specified at backup time by a VSS_RESTOREMETHOD_ENUM value.
    VSS_RT_ORIGINAL          = 0x00000001,
    ///The files are restored to a location determined from an existing alternate location mapping. The restore target
    ///should be set to <b>VSS_RT_ALTERNATE</b> only when alternate location mappings have been set for all the files
    ///managed by a selected component or component set. This value is not supported for express writers.
    VSS_RT_ALTERNATE         = 0x00000002,
    ///Use directed targeting by the writer at restore time to restore a file. Directed targeting allows a writer to
    ///control, on a file-by-file basis, how a file is restored—indicating how much of a file is to be restored and
    ///into which files the backed-up file is to be restored. This value is not supported for express writers.
    VSS_RT_DIRECTED          = 0x00000003,
    ///The files are restored to the location at which they were at backup time, even if the original restore method
    ///that was specified at backup time was <b>VSS_RME_RESTORE_TO_ALTERNATE_LOCATION</b>. <b>Windows Server 2003 and
    ///Windows XP: </b>This value is not supported. This value is not supported for express writers.
    VSS_RT_ORIGINAL_LOCATION = 0x00000004,
}

///The <b>VSS_FILE_RESTORE_STATUS</b> enumeration defines the set of statuses of a file restore operation performed on
///the files managed by a selected component or component set (see <a
///href="/windows/desktop/VSS/working-with-selectability-and-logical-paths">Working with Selectability and Logical
///Paths</a> for information on selecting components).
alias VSS_FILE_RESTORE_STATUS = int;
enum : int
{
    ///The restore state is undefined. This value indicates an error, or indicates that a restore operation has not yet
    ///started. This value is not supported for components that are owned by express writers.
    VSS_RS_UNDEFINED = 0x00000000,
    ///No files were restored. This value indicates an error in restoration that did not leave any restored files on
    ///disk.
    VSS_RS_NONE      = 0x00000001,
    ///All files were restored. This value indicates success and should be set for each component that was restored
    ///successfully.
    VSS_RS_ALL       = 0x00000002,
    ///The restore process failed. This value indicates an error in restoration that did leave some restored files on
    ///disk. This means the components on disk are now corrupt.
    VSS_RS_FAILED    = 0x00000003,
}

///The <b>VSS_COMPONENT_FLAGS</b> enumeration is used by writers to indicate support for auto-recovery. These values are
///used in the <b>dwComponentFlags</b> member of the VSS_COMPONENTINFO structure and the <i>dwComponentFlags</i>
///parameter of the IVssCreateWriterMetadata::AddComponent method.
alias VSS_COMPONENT_FLAGS = int;
enum : int
{
    ///The writer will need write access to this component after the shadow copy has been created. This flag can be used
    ///together with the <b>VSS_VOLSNAP_ATTR_TRANSPORTABLE</b> value of the _VSS_VOLUME_SNAPSHOT_ATTRIBUTES enumeration
    ///if the VSS hardware provider supports LUN masking.<b>Windows Vista and Windows Server 2003 with SP1: </b>This
    ///flag is incompatible with <b>VSS_VOLSNAP_ATTR_TRANSPORTABLE</b>. This flag is not supported for express writers.
    VSS_CF_BACKUP_RECOVERY       = 0x00000001,
    ///If this is a rollback shadow copy (see the <b>VSS_VOLSNAP_ATTR_ROLLBACK_RECOVERY</b> value of the
    ///_VSS_VOLUME_SNAPSHOT_ATTRIBUTES enumeration), the writer for this component will need write access to this
    ///component after the shadow copy has been created. This flag can be used together with the
    ///<b>VSS_VOLSNAP_ATTR_TRANSPORTABLE</b> value of the _VSS_VOLUME_SNAPSHOT_ATTRIBUTES enumeration if the VSS
    ///hardware provider supports LUN masking.<b>Windows Vista and Windows Server 2003 with SP1: </b>This flag is
    ///incompatible with <b>VSS_VOLSNAP_ATTR_TRANSPORTABLE</b>. This flag is not supported for express writers.
    VSS_CF_APP_ROLLBACK_RECOVERY = 0x00000002,
    ///This component is not part of system state. <b>Windows Server 2003 with SP1: </b>This value is not supported
    ///until Windows Vista.
    VSS_CF_NOT_SYSTEM_STATE      = 0x00000004,
}

///The <b>VSS_MGMT_OBJECT_TYPE</b> enumeration type is a discriminant for the VSS_MGMT_OBJECT_UNION union within the
///VSS_MGMT_OBJECT_PROP structure.
alias VSS_MGMT_OBJECT_TYPE = int;
enum : int
{
    ///The object type is unknown.
    VSS_MGMT_OBJECT_UNKNOWN     = 0x00000000,
    ///The object is a volume to be shadow copied.
    VSS_MGMT_OBJECT_VOLUME      = 0x00000001,
    ///The object is a volume to hold a shadow copy storage area.
    VSS_MGMT_OBJECT_DIFF_VOLUME = 0x00000002,
    ///The object is an association between a volume to be shadow copied and a volume to hold the shadow copy storage
    ///area.
    VSS_MGMT_OBJECT_DIFF_AREA   = 0x00000003,
}

///Defines the set of volume shadow copy protection levels.
alias VSS_PROTECTION_LEVEL = int;
enum : int
{
    ///Specifies that I/O to the original volume must be maintained at the expense of shadow copies. This is the default
    ///protection level. Shadow copies might be deleted if both of the following conditions occur: <ul> <li>A write to
    ///the original volume occurs.</li> <li>The integrity of the shadow copy cannot be maintained for some reason, such
    ///as a failure to write to the shadow copy storage area or a failure to allocate sufficient memory.</li> </ul>
    VSS_PROTECTION_LEVEL_ORIGINAL_VOLUME = 0x00000000,
    ///Specifies that shadow copies must be maintained at the expense of I/O to the original volume. This protection
    ///level is called "shadow copy protection mode." All I/O to the original volume will fail if both of the following
    ///conditions occur: <ul> <li>A write to the original volume occurs.</li> <li>The corresponding write to the shadow
    ///copy storage area cannot be completed for some reason, such as a failure to write to the shadow copy storage area
    ///or a failure to allocate sufficient memory.</li> </ul>
    VSS_PROTECTION_LEVEL_SNAPSHOT        = 0x00000001,
}

///Defines the set of shadow copy protection faults. A shadow copy protection fault occurs when the VSS service is
///unable to perform a copy-on-write operation to the shadow copy storage area (also called the diff area).
alias VSS_PROTECTION_FAULT = int;
enum : int
{
    ///No shadow copy protection fault has occurred.
    VSS_PROTECTION_FAULT_NONE                         = 0x00000000,
    ///The volume that contains the shadow copy storage area could not be found. Usually this fault means that the
    ///volume has not yet arrived in the system.
    VSS_PROTECTION_FAULT_DIFF_AREA_MISSING            = 0x00000001,
    ///The volume that contains the shadow copy storage area could not be brought online because an I/O failure
    ///occurred.
    VSS_PROTECTION_FAULT_IO_FAILURE_DURING_ONLINE     = 0x00000002,
    ///The shadow copy metadata for the shadow copy storage area has been corrupted.
    VSS_PROTECTION_FAULT_META_DATA_CORRUPTION         = 0x00000003,
    ///A memory allocation failure occurred. This could be caused by a temporary low-memory condition that does not
    ///happen again after you clear the fault and restart the shadow copy operation.
    VSS_PROTECTION_FAULT_MEMORY_ALLOCATION_FAILURE    = 0x00000004,
    ///A memory mapping failure occurred. This fault could mean that the page file is too small, or it could be caused
    ///by a low-memory condition.
    VSS_PROTECTION_FAULT_MAPPED_MEMORY_FAILURE        = 0x00000005,
    ///A read failure occurred during the copy-on-write operation when data was being copied from the live volume to the
    ///shadow copy storage area volume.
    VSS_PROTECTION_FAULT_COW_READ_FAILURE             = 0x00000006,
    ///A read or write failure occurred during the copy-on-write operation when data was being copied from the live
    ///volume to the shadow copy storage area volume. One possible reason is that the shadow copy storage area volume
    ///has been removed from the system.
    VSS_PROTECTION_FAULT_COW_WRITE_FAILURE            = 0x00000007,
    ///This failure means that either the shadow copy storage area is full or the shadow copy storage area volume is
    ///full. After clearing the protection fault, you can do one of the following: <ul> <li>Delete unused shadow copy
    ///storage areas by calling the IVssDifferentialSoftwareSnapshotMgmt3::DeleteUnusedDiffAreas method.</li>
    ///<li>Increase the shadow copy storage area maximum size for the volume by calling the
    ///IVssDifferentialSoftwareSnapshotMgmt::ChangeDiffAreaMaximumSize method or the
    ///IVssDifferentialSoftwareSnapshotMgmt2::ChangeDiffAreaMaximumSizeEx method.</li> </ul>
    VSS_PROTECTION_FAULT_DIFF_AREA_FULL               = 0x00000008,
    ///The size of the shadow copy storage area could not be increased because there was no longer enough space on the
    ///shadow copy storage area volume.
    VSS_PROTECTION_FAULT_GROW_TOO_SLOW                = 0x00000009,
    ///The size of the shadow copy storage area could not be increased.
    VSS_PROTECTION_FAULT_GROW_FAILED                  = 0x0000000a,
    ///An unexpected error occurred.
    VSS_PROTECTION_FAULT_DESTROY_ALL_SNAPSHOTS        = 0x0000000b,
    ///Either the shadow copy storage area files could not be opened or the shadow copy storage area volume could not be
    ///mounted because of a file system operation failure.
    VSS_PROTECTION_FAULT_FILE_SYSTEM_FAILURE          = 0x0000000c,
    ///A read or write failure occurred on the shadow copy storage area volume.
    VSS_PROTECTION_FAULT_IO_FAILURE                   = 0x0000000d,
    ///The shadow copy storage area volume was removed from the system or could not be accessed for some other reason.
    VSS_PROTECTION_FAULT_DIFF_AREA_REMOVED            = 0x0000000e,
    ///Another application attempted to write to the shadow copy storage area.
    VSS_PROTECTION_FAULT_EXTERNAL_WRITER_TO_DIFF_AREA = 0x0000000f,
    VSS_PROTECTION_FAULT_MOUNT_DURING_CLUSTER_OFFLINE = 0x00000010,
}

alias D3DLIGHTTYPE = int;
enum : int
{
    D3DLIGHT_POINT         = 0x00000001,
    D3DLIGHT_SPOT          = 0x00000002,
    D3DLIGHT_DIRECTIONAL   = 0x00000003,
    D3DLIGHT_PARALLELPOINT = 0x00000004,
    D3DLIGHT_FORCE_DWORD   = 0x7fffffff,
}

alias D3DOPCODE = int;
enum : int
{
    D3DOP_POINT           = 0x00000001,
    D3DOP_LINE            = 0x00000002,
    D3DOP_TRIANGLE        = 0x00000003,
    D3DOP_MATRIXLOAD      = 0x00000004,
    D3DOP_MATRIXMULTIPLY  = 0x00000005,
    D3DOP_STATETRANSFORM  = 0x00000006,
    D3DOP_STATELIGHT      = 0x00000007,
    D3DOP_STATERENDER     = 0x00000008,
    D3DOP_PROCESSVERTICES = 0x00000009,
    D3DOP_TEXTURELOAD     = 0x0000000a,
    D3DOP_EXIT            = 0x0000000b,
    D3DOP_BRANCHFORWARD   = 0x0000000c,
    D3DOP_SPAN            = 0x0000000d,
    D3DOP_SETSTATUS       = 0x0000000e,
    D3DOP_FORCE_DWORD     = 0x7fffffff,
}

alias D3DSHADEMODE = int;
enum : int
{
    D3DSHADE_FLAT        = 0x00000001,
    D3DSHADE_GOURAUD     = 0x00000002,
    D3DSHADE_PHONG       = 0x00000003,
    D3DSHADE_FORCE_DWORD = 0x7fffffff,
}

alias D3DFILLMODE = int;
enum : int
{
    D3DFILL_POINT       = 0x00000001,
    D3DFILL_WIREFRAME   = 0x00000002,
    D3DFILL_SOLID       = 0x00000003,
    D3DFILL_FORCE_DWORD = 0x7fffffff,
}

alias D3DTEXTUREFILTER = int;
enum : int
{
    D3DFILTER_NEAREST          = 0x00000001,
    D3DFILTER_LINEAR           = 0x00000002,
    D3DFILTER_MIPNEAREST       = 0x00000003,
    D3DFILTER_MIPLINEAR        = 0x00000004,
    D3DFILTER_LINEARMIPNEAREST = 0x00000005,
    D3DFILTER_LINEARMIPLINEAR  = 0x00000006,
    D3DFILTER_FORCE_DWORD      = 0x7fffffff,
}

alias D3DBLEND = uint;
enum : uint
{
    D3DBLEND_ZERO            = 0x00000001,
    D3DBLEND_ONE             = 0x00000002,
    D3DBLEND_SRCCOLOR        = 0x00000003,
    D3DBLEND_INVSRCCOLOR     = 0x00000004,
    D3DBLEND_SRCALPHA        = 0x00000005,
    D3DBLEND_INVSRCALPHA     = 0x00000006,
    D3DBLEND_DESTALPHA       = 0x00000007,
    D3DBLEND_INVDESTALPHA    = 0x00000008,
    D3DBLEND_DESTCOLOR       = 0x00000009,
    D3DBLEND_INVDESTCOLOR    = 0x0000000a,
    D3DBLEND_SRCALPHASAT     = 0x0000000b,
    D3DBLEND_BOTHSRCALPHA    = 0x0000000c,
    D3DBLEND_BOTHINVSRCALPHA = 0x0000000d,
    D3DBLEND_FORCE_DWORD     = 0x7fffffff,
}

alias D3DTEXTUREBLEND = int;
enum : int
{
    D3DTBLEND_DECAL         = 0x00000001,
    D3DTBLEND_MODULATE      = 0x00000002,
    D3DTBLEND_DECALALPHA    = 0x00000003,
    D3DTBLEND_MODULATEALPHA = 0x00000004,
    D3DTBLEND_DECALMASK     = 0x00000005,
    D3DTBLEND_MODULATEMASK  = 0x00000006,
    D3DTBLEND_COPY          = 0x00000007,
    D3DTBLEND_ADD           = 0x00000008,
    D3DTBLEND_FORCE_DWORD   = 0x7fffffff,
}

alias D3DTEXTUREADDRESS = int;
enum : int
{
    D3DTADDRESS_WRAP        = 0x00000001,
    D3DTADDRESS_MIRROR      = 0x00000002,
    D3DTADDRESS_CLAMP       = 0x00000003,
    D3DTADDRESS_BORDER      = 0x00000004,
    D3DTADDRESS_FORCE_DWORD = 0x7fffffff,
}

alias D3DCULL = uint;
enum : uint
{
    D3DCULL_NONE        = 0x00000001,
    D3DCULL_CW          = 0x00000002,
    D3DCULL_CCW         = 0x00000003,
    D3DCULL_FORCE_DWORD = 0x7fffffff,
}

alias D3DCMPFUNC = int;
enum : int
{
    D3DCMP_NEVER        = 0x00000001,
    D3DCMP_LESS         = 0x00000002,
    D3DCMP_EQUAL        = 0x00000003,
    D3DCMP_LESSEQUAL    = 0x00000004,
    D3DCMP_GREATER      = 0x00000005,
    D3DCMP_NOTEQUAL     = 0x00000006,
    D3DCMP_GREATEREQUAL = 0x00000007,
    D3DCMP_ALWAYS       = 0x00000008,
    D3DCMP_FORCE_DWORD  = 0x7fffffff,
}

alias D3DSTENCILOP = uint;
enum : uint
{
    D3DSTENCILOP_KEEP        = 0x00000001,
    D3DSTENCILOP_ZERO        = 0x00000002,
    D3DSTENCILOP_REPLACE     = 0x00000003,
    D3DSTENCILOP_INCRSAT     = 0x00000004,
    D3DSTENCILOP_DECRSAT     = 0x00000005,
    D3DSTENCILOP_INVERT      = 0x00000006,
    D3DSTENCILOP_INCR        = 0x00000007,
    D3DSTENCILOP_DECR        = 0x00000008,
    D3DSTENCILOP_FORCE_DWORD = 0x7fffffff,
}

alias D3DFOGMODE = int;
enum : int
{
    D3DFOG_NONE        = 0x00000000,
    D3DFOG_EXP         = 0x00000001,
    D3DFOG_EXP2        = 0x00000002,
    D3DFOG_LINEAR      = 0x00000003,
    D3DFOG_FORCE_DWORD = 0x7fffffff,
}

alias D3DZBUFFERTYPE = int;
enum : int
{
    D3DZB_FALSE       = 0x00000000,
    D3DZB_TRUE        = 0x00000001,
    D3DZB_USEW        = 0x00000002,
    D3DZB_FORCE_DWORD = 0x7fffffff,
}

alias D3DANTIALIASMODE = int;
enum : int
{
    D3DANTIALIAS_NONE            = 0x00000000,
    D3DANTIALIAS_SORTDEPENDENT   = 0x00000001,
    D3DANTIALIAS_SORTINDEPENDENT = 0x00000002,
    D3DANTIALIAS_FORCE_DWORD     = 0x7fffffff,
}

alias D3DVERTEXTYPE = int;
enum : int
{
    D3DVT_VERTEX      = 0x00000001,
    D3DVT_LVERTEX     = 0x00000002,
    D3DVT_TLVERTEX    = 0x00000003,
    D3DVT_FORCE_DWORD = 0x7fffffff,
}

alias D3DPRIMITIVETYPE = int;
enum : int
{
    D3DPT_POINTLIST     = 0x00000001,
    D3DPT_LINELIST      = 0x00000002,
    D3DPT_LINESTRIP     = 0x00000003,
    D3DPT_TRIANGLELIST  = 0x00000004,
    D3DPT_TRIANGLESTRIP = 0x00000005,
    D3DPT_TRIANGLEFAN   = 0x00000006,
    D3DPT_FORCE_DWORD   = 0x7fffffff,
}

alias D3DTRANSFORMSTATETYPE = int;
enum : int
{
    D3DTRANSFORMSTATE_WORLD       = 0x00000001,
    D3DTRANSFORMSTATE_VIEW        = 0x00000002,
    D3DTRANSFORMSTATE_PROJECTION  = 0x00000003,
    D3DTRANSFORMSTATE_WORLD1      = 0x00000004,
    D3DTRANSFORMSTATE_WORLD2      = 0x00000005,
    D3DTRANSFORMSTATE_WORLD3      = 0x00000006,
    D3DTRANSFORMSTATE_TEXTURE0    = 0x00000010,
    D3DTRANSFORMSTATE_TEXTURE1    = 0x00000011,
    D3DTRANSFORMSTATE_TEXTURE2    = 0x00000012,
    D3DTRANSFORMSTATE_TEXTURE3    = 0x00000013,
    D3DTRANSFORMSTATE_TEXTURE4    = 0x00000014,
    D3DTRANSFORMSTATE_TEXTURE5    = 0x00000015,
    D3DTRANSFORMSTATE_TEXTURE6    = 0x00000016,
    D3DTRANSFORMSTATE_TEXTURE7    = 0x00000017,
    D3DTRANSFORMSTATE_FORCE_DWORD = 0x7fffffff,
}

alias D3DLIGHTSTATETYPE = int;
enum : int
{
    D3DLIGHTSTATE_MATERIAL    = 0x00000001,
    D3DLIGHTSTATE_AMBIENT     = 0x00000002,
    D3DLIGHTSTATE_COLORMODEL  = 0x00000003,
    D3DLIGHTSTATE_FOGMODE     = 0x00000004,
    D3DLIGHTSTATE_FOGSTART    = 0x00000005,
    D3DLIGHTSTATE_FOGEND      = 0x00000006,
    D3DLIGHTSTATE_FOGDENSITY  = 0x00000007,
    D3DLIGHTSTATE_COLORVERTEX = 0x00000008,
    D3DLIGHTSTATE_FORCE_DWORD = 0x7fffffff,
}

alias D3DRENDERSTATETYPE = int;
enum : int
{
    D3DRENDERSTATE_ANTIALIAS                  = 0x00000002,
    D3DRENDERSTATE_TEXTUREPERSPECTIVE         = 0x00000004,
    D3DRENDERSTATE_ZENABLE                    = 0x00000007,
    D3DRENDERSTATE_FILLMODE                   = 0x00000008,
    D3DRENDERSTATE_SHADEMODE                  = 0x00000009,
    D3DRENDERSTATE_LINEPATTERN                = 0x0000000a,
    D3DRENDERSTATE_ZWRITEENABLE               = 0x0000000e,
    D3DRENDERSTATE_ALPHATESTENABLE            = 0x0000000f,
    D3DRENDERSTATE_LASTPIXEL                  = 0x00000010,
    D3DRENDERSTATE_SRCBLEND                   = 0x00000013,
    D3DRENDERSTATE_DESTBLEND                  = 0x00000014,
    D3DRENDERSTATE_CULLMODE                   = 0x00000016,
    D3DRENDERSTATE_ZFUNC                      = 0x00000017,
    D3DRENDERSTATE_ALPHAREF                   = 0x00000018,
    D3DRENDERSTATE_ALPHAFUNC                  = 0x00000019,
    D3DRENDERSTATE_DITHERENABLE               = 0x0000001a,
    D3DRENDERSTATE_ALPHABLENDENABLE           = 0x0000001b,
    D3DRENDERSTATE_FOGENABLE                  = 0x0000001c,
    D3DRENDERSTATE_SPECULARENABLE             = 0x0000001d,
    D3DRENDERSTATE_ZVISIBLE                   = 0x0000001e,
    D3DRENDERSTATE_STIPPLEDALPHA              = 0x00000021,
    D3DRENDERSTATE_FOGCOLOR                   = 0x00000022,
    D3DRENDERSTATE_FOGTABLEMODE               = 0x00000023,
    D3DRENDERSTATE_FOGSTART                   = 0x00000024,
    D3DRENDERSTATE_FOGEND                     = 0x00000025,
    D3DRENDERSTATE_FOGDENSITY                 = 0x00000026,
    D3DRENDERSTATE_EDGEANTIALIAS              = 0x00000028,
    D3DRENDERSTATE_COLORKEYENABLE             = 0x00000029,
    D3DRENDERSTATE_ZBIAS                      = 0x0000002f,
    D3DRENDERSTATE_RANGEFOGENABLE             = 0x00000030,
    D3DRENDERSTATE_STENCILENABLE              = 0x00000034,
    D3DRENDERSTATE_STENCILFAIL                = 0x00000035,
    D3DRENDERSTATE_STENCILZFAIL               = 0x00000036,
    D3DRENDERSTATE_STENCILPASS                = 0x00000037,
    D3DRENDERSTATE_STENCILFUNC                = 0x00000038,
    D3DRENDERSTATE_STENCILREF                 = 0x00000039,
    D3DRENDERSTATE_STENCILMASK                = 0x0000003a,
    D3DRENDERSTATE_STENCILWRITEMASK           = 0x0000003b,
    D3DRENDERSTATE_TEXTUREFACTOR              = 0x0000003c,
    D3DRENDERSTATE_WRAP0                      = 0x00000080,
    D3DRENDERSTATE_WRAP1                      = 0x00000081,
    D3DRENDERSTATE_WRAP2                      = 0x00000082,
    D3DRENDERSTATE_WRAP3                      = 0x00000083,
    D3DRENDERSTATE_WRAP4                      = 0x00000084,
    D3DRENDERSTATE_WRAP5                      = 0x00000085,
    D3DRENDERSTATE_WRAP6                      = 0x00000086,
    D3DRENDERSTATE_WRAP7                      = 0x00000087,
    D3DRENDERSTATE_CLIPPING                   = 0x00000088,
    D3DRENDERSTATE_LIGHTING                   = 0x00000089,
    D3DRENDERSTATE_EXTENTS                    = 0x0000008a,
    D3DRENDERSTATE_AMBIENT                    = 0x0000008b,
    D3DRENDERSTATE_FOGVERTEXMODE              = 0x0000008c,
    D3DRENDERSTATE_COLORVERTEX                = 0x0000008d,
    D3DRENDERSTATE_LOCALVIEWER                = 0x0000008e,
    D3DRENDERSTATE_NORMALIZENORMALS           = 0x0000008f,
    D3DRENDERSTATE_COLORKEYBLENDENABLE        = 0x00000090,
    D3DRENDERSTATE_DIFFUSEMATERIALSOURCE      = 0x00000091,
    D3DRENDERSTATE_SPECULARMATERIALSOURCE     = 0x00000092,
    D3DRENDERSTATE_AMBIENTMATERIALSOURCE      = 0x00000093,
    D3DRENDERSTATE_EMISSIVEMATERIALSOURCE     = 0x00000094,
    D3DRENDERSTATE_VERTEXBLEND                = 0x00000097,
    D3DRENDERSTATE_CLIPPLANEENABLE            = 0x00000098,
    D3DRENDERSTATE_TEXTUREHANDLE              = 0x00000001,
    D3DRENDERSTATE_TEXTUREADDRESS             = 0x00000003,
    D3DRENDERSTATE_WRAPU                      = 0x00000005,
    D3DRENDERSTATE_WRAPV                      = 0x00000006,
    D3DRENDERSTATE_MONOENABLE                 = 0x0000000b,
    D3DRENDERSTATE_ROP2                       = 0x0000000c,
    D3DRENDERSTATE_PLANEMASK                  = 0x0000000d,
    D3DRENDERSTATE_TEXTUREMAG                 = 0x00000011,
    D3DRENDERSTATE_TEXTUREMIN                 = 0x00000012,
    D3DRENDERSTATE_TEXTUREMAPBLEND            = 0x00000015,
    D3DRENDERSTATE_SUBPIXEL                   = 0x0000001f,
    D3DRENDERSTATE_SUBPIXELX                  = 0x00000020,
    D3DRENDERSTATE_STIPPLEENABLE              = 0x00000027,
    D3DRENDERSTATE_BORDERCOLOR                = 0x0000002b,
    D3DRENDERSTATE_TEXTUREADDRESSU            = 0x0000002c,
    D3DRENDERSTATE_TEXTUREADDRESSV            = 0x0000002d,
    D3DRENDERSTATE_MIPMAPLODBIAS              = 0x0000002e,
    D3DRENDERSTATE_ANISOTROPY                 = 0x00000031,
    D3DRENDERSTATE_FLUSHBATCH                 = 0x00000032,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT = 0x00000033,
    D3DRENDERSTATE_STIPPLEPATTERN00           = 0x00000040,
    D3DRENDERSTATE_STIPPLEPATTERN01           = 0x00000041,
    D3DRENDERSTATE_STIPPLEPATTERN02           = 0x00000042,
    D3DRENDERSTATE_STIPPLEPATTERN03           = 0x00000043,
    D3DRENDERSTATE_STIPPLEPATTERN04           = 0x00000044,
    D3DRENDERSTATE_STIPPLEPATTERN05           = 0x00000045,
    D3DRENDERSTATE_STIPPLEPATTERN06           = 0x00000046,
    D3DRENDERSTATE_STIPPLEPATTERN07           = 0x00000047,
    D3DRENDERSTATE_STIPPLEPATTERN08           = 0x00000048,
    D3DRENDERSTATE_STIPPLEPATTERN09           = 0x00000049,
    D3DRENDERSTATE_STIPPLEPATTERN10           = 0x0000004a,
    D3DRENDERSTATE_STIPPLEPATTERN11           = 0x0000004b,
    D3DRENDERSTATE_STIPPLEPATTERN12           = 0x0000004c,
    D3DRENDERSTATE_STIPPLEPATTERN13           = 0x0000004d,
    D3DRENDERSTATE_STIPPLEPATTERN14           = 0x0000004e,
    D3DRENDERSTATE_STIPPLEPATTERN15           = 0x0000004f,
    D3DRENDERSTATE_STIPPLEPATTERN16           = 0x00000050,
    D3DRENDERSTATE_STIPPLEPATTERN17           = 0x00000051,
    D3DRENDERSTATE_STIPPLEPATTERN18           = 0x00000052,
    D3DRENDERSTATE_STIPPLEPATTERN19           = 0x00000053,
    D3DRENDERSTATE_STIPPLEPATTERN20           = 0x00000054,
    D3DRENDERSTATE_STIPPLEPATTERN21           = 0x00000055,
    D3DRENDERSTATE_STIPPLEPATTERN22           = 0x00000056,
    D3DRENDERSTATE_STIPPLEPATTERN23           = 0x00000057,
    D3DRENDERSTATE_STIPPLEPATTERN24           = 0x00000058,
    D3DRENDERSTATE_STIPPLEPATTERN25           = 0x00000059,
    D3DRENDERSTATE_STIPPLEPATTERN26           = 0x0000005a,
    D3DRENDERSTATE_STIPPLEPATTERN27           = 0x0000005b,
    D3DRENDERSTATE_STIPPLEPATTERN28           = 0x0000005c,
    D3DRENDERSTATE_STIPPLEPATTERN29           = 0x0000005d,
    D3DRENDERSTATE_STIPPLEPATTERN30           = 0x0000005e,
    D3DRENDERSTATE_STIPPLEPATTERN31           = 0x0000005f,
    D3DRENDERSTATE_FOGTABLESTART              = 0x00000024,
    D3DRENDERSTATE_FOGTABLEEND                = 0x00000025,
    D3DRENDERSTATE_FOGTABLEDENSITY            = 0x00000026,
    D3DRENDERSTATE_FORCE_DWORD                = 0x7fffffff,
}

alias D3DMATERIALCOLORSOURCE = int;
enum : int
{
    D3DMCS_MATERIAL    = 0x00000000,
    D3DMCS_COLOR1      = 0x00000001,
    D3DMCS_COLOR2      = 0x00000002,
    D3DMCS_FORCE_DWORD = 0x7fffffff,
}

alias D3DTEXTURESTAGESTATETYPE = int;
enum : int
{
    D3DTSS_COLOROP               = 0x00000001,
    D3DTSS_COLORARG1             = 0x00000002,
    D3DTSS_COLORARG2             = 0x00000003,
    D3DTSS_ALPHAOP               = 0x00000004,
    D3DTSS_ALPHAARG1             = 0x00000005,
    D3DTSS_ALPHAARG2             = 0x00000006,
    D3DTSS_BUMPENVMAT00          = 0x00000007,
    D3DTSS_BUMPENVMAT01          = 0x00000008,
    D3DTSS_BUMPENVMAT10          = 0x00000009,
    D3DTSS_BUMPENVMAT11          = 0x0000000a,
    D3DTSS_TEXCOORDINDEX         = 0x0000000b,
    D3DTSS_ADDRESS               = 0x0000000c,
    D3DTSS_ADDRESSU              = 0x0000000d,
    D3DTSS_ADDRESSV              = 0x0000000e,
    D3DTSS_BORDERCOLOR           = 0x0000000f,
    D3DTSS_MAGFILTER             = 0x00000010,
    D3DTSS_MINFILTER             = 0x00000011,
    D3DTSS_MIPFILTER             = 0x00000012,
    D3DTSS_MIPMAPLODBIAS         = 0x00000013,
    D3DTSS_MAXMIPLEVEL           = 0x00000014,
    D3DTSS_MAXANISOTROPY         = 0x00000015,
    D3DTSS_BUMPENVLSCALE         = 0x00000016,
    D3DTSS_BUMPENVLOFFSET        = 0x00000017,
    D3DTSS_TEXTURETRANSFORMFLAGS = 0x00000018,
    D3DTSS_FORCE_DWORD           = 0x7fffffff,
}

alias D3DTEXTUREOP = int;
enum : int
{
    D3DTOP_DISABLE                   = 0x00000001,
    D3DTOP_SELECTARG1                = 0x00000002,
    D3DTOP_SELECTARG2                = 0x00000003,
    D3DTOP_MODULATE                  = 0x00000004,
    D3DTOP_MODULATE2X                = 0x00000005,
    D3DTOP_MODULATE4X                = 0x00000006,
    D3DTOP_ADD                       = 0x00000007,
    D3DTOP_ADDSIGNED                 = 0x00000008,
    D3DTOP_ADDSIGNED2X               = 0x00000009,
    D3DTOP_SUBTRACT                  = 0x0000000a,
    D3DTOP_ADDSMOOTH                 = 0x0000000b,
    D3DTOP_BLENDDIFFUSEALPHA         = 0x0000000c,
    D3DTOP_BLENDTEXTUREALPHA         = 0x0000000d,
    D3DTOP_BLENDFACTORALPHA          = 0x0000000e,
    D3DTOP_BLENDTEXTUREALPHAPM       = 0x0000000f,
    D3DTOP_BLENDCURRENTALPHA         = 0x00000010,
    D3DTOP_PREMODULATE               = 0x00000011,
    D3DTOP_MODULATEALPHA_ADDCOLOR    = 0x00000012,
    D3DTOP_MODULATECOLOR_ADDALPHA    = 0x00000013,
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 0x00000014,
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 0x00000015,
    D3DTOP_BUMPENVMAP                = 0x00000016,
    D3DTOP_BUMPENVMAPLUMINANCE       = 0x00000017,
    D3DTOP_DOTPRODUCT3               = 0x00000018,
    D3DTOP_FORCE_DWORD               = 0x7fffffff,
}

alias D3DTEXTUREMAGFILTER = int;
enum : int
{
    D3DTFG_POINT         = 0x00000001,
    D3DTFG_LINEAR        = 0x00000002,
    D3DTFG_FLATCUBIC     = 0x00000003,
    D3DTFG_GAUSSIANCUBIC = 0x00000004,
    D3DTFG_ANISOTROPIC   = 0x00000005,
    D3DTFG_FORCE_DWORD   = 0x7fffffff,
}

alias D3DTEXTUREMINFILTER = int;
enum : int
{
    D3DTFN_POINT       = 0x00000001,
    D3DTFN_LINEAR      = 0x00000002,
    D3DTFN_ANISOTROPIC = 0x00000003,
    D3DTFN_FORCE_DWORD = 0x7fffffff,
}

alias D3DTEXTUREMIPFILTER = int;
enum : int
{
    D3DTFP_NONE        = 0x00000001,
    D3DTFP_POINT       = 0x00000002,
    D3DTFP_LINEAR      = 0x00000003,
    D3DTFP_FORCE_DWORD = 0x7fffffff,
}

alias D3DSTATEBLOCKTYPE = int;
enum : int
{
    D3DSBT_ALL         = 0x00000001,
    D3DSBT_PIXELSTATE  = 0x00000002,
    D3DSBT_VERTEXSTATE = 0x00000003,
    D3DSBT_FORCE_DWORD = 0xffffffff,
}

alias D3DVERTEXBLENDFLAGS = int;
enum : int
{
    D3DVBLEND_DISABLE  = 0x00000000,
    D3DVBLEND_1WEIGHT  = 0x00000001,
    D3DVBLEND_2WEIGHTS = 0x00000002,
    D3DVBLEND_3WEIGHTS = 0x00000003,
}

alias D3DTEXTURETRANSFORMFLAGS = int;
enum : int
{
    D3DTTFF_DISABLE     = 0x00000000,
    D3DTTFF_COUNT1      = 0x00000001,
    D3DTTFF_COUNT2      = 0x00000002,
    D3DTTFF_COUNT3      = 0x00000003,
    D3DTTFF_COUNT4      = 0x00000004,
    D3DTTFF_PROJECTED   = 0x00000100,
    D3DTTFF_FORCE_DWORD = 0x7fffffff,
}

alias D3DNTHAL_DP2OPERATION = int;
enum : int
{
    D3DNTDP2OP_POINTS               = 0x00000001,
    D3DNTDP2OP_INDEXEDLINELIST      = 0x00000002,
    D3DNTDP2OP_INDEXEDTRIANGLELIST  = 0x00000003,
    D3DNTDP2OP_RENDERSTATE          = 0x00000008,
    D3DNTDP2OP_LINELIST             = 0x0000000f,
    D3DNTDP2OP_LINESTRIP            = 0x00000010,
    D3DNTDP2OP_INDEXEDLINESTRIP     = 0x00000011,
    D3DNTDP2OP_TRIANGLELIST         = 0x00000012,
    D3DNTDP2OP_TRIANGLESTRIP        = 0x00000013,
    D3DNTDP2OP_INDEXEDTRIANGLESTRIP = 0x00000014,
    D3DNTDP2OP_TRIANGLEFAN          = 0x00000015,
    D3DNTDP2OP_INDEXEDTRIANGLEFAN   = 0x00000016,
    D3DNTDP2OP_TRIANGLEFAN_IMM      = 0x00000017,
    D3DNTDP2OP_LINELIST_IMM         = 0x00000018,
    D3DNTDP2OP_TEXTURESTAGESTATE    = 0x00000019,
    D3DNTDP2OP_INDEXEDTRIANGLELIST2 = 0x0000001a,
    D3DNTDP2OP_INDEXEDLINELIST2     = 0x0000001b,
    D3DNTDP2OP_VIEWPORTINFO         = 0x0000001c,
    D3DNTDP2OP_WINFO                = 0x0000001d,
    D3DNTDP2OP_SETPALETTE           = 0x0000001e,
    D3DNTDP2OP_UPDATEPALETTE        = 0x0000001f,
    D3DNTDP2OP_ZRANGE               = 0x00000020,
    D3DNTDP2OP_SETMATERIAL          = 0x00000021,
    D3DNTDP2OP_SETLIGHT             = 0x00000022,
    D3DNTDP2OP_CREATELIGHT          = 0x00000023,
    D3DNTDP2OP_SETTRANSFORM         = 0x00000024,
    D3DNTDP2OP_TEXBLT               = 0x00000026,
    D3DNTDP2OP_STATESET             = 0x00000027,
    D3DNTDP2OP_SETPRIORITY          = 0x00000028,
    D3DNTDP2OP_SETRENDERTARGET      = 0x00000029,
    D3DNTDP2OP_CLEAR                = 0x0000002a,
    D3DNTDP2OP_SETTEXLOD            = 0x0000002b,
    D3DNTDP2OP_SETCLIPPLANE         = 0x0000002c,
}

alias ENG_SYSTEM_ATTRIBUTE = int;
enum : int
{
    EngProcessorFeature             = 0x00000001,
    EngNumberOfProcessors           = 0x00000002,
    EngOptimumAvailableUserMemory   = 0x00000003,
    EngOptimumAvailableSystemMemory = 0x00000004,
}

alias ENG_DEVICE_ATTRIBUTE = int;
enum : int
{
    QDA_RESERVED           = 0x00000000,
    QDA_ACCELERATION_LEVEL = 0x00000001,
}

alias DEVPROPSTORE = int;
enum : int
{
    DEVPROP_STORE_SYSTEM = 0x00000000,
    DEVPROP_STORE_USER   = 0x00000001,
}

///Represents the Pulse Width Modulation (PWM) signal level polarity with respect to the duty cycle.
alias PWM_POLARITY = int;
enum : int
{
    ///Active High.
    PWM_ACTIVE_HIGH = 0x00000000,
    ///Active Low.
    PWM_ACTIVE_LOW  = 0x00000001,
}

///Defines values that specify how another enclave must be related to the enclave that calls EnclaveSealData for the
///enclave to unseal the data.
alias ENCLAVE_SEALING_IDENTITY_POLICY = int;
enum : int
{
    ///This value is not valid. Do not use.
    ENCLAVE_IDENTITY_POLICY_SEAL_INVALID           = 0x00000000,
    ///All of the bytes of every image loaded into the unsealing enclave must match the bytes of every image in the
    ///sealing enclave in order for EnclaveSealData to decrypt the data.
    ENCLAVE_IDENTITY_POLICY_SEAL_EXACT_CODE        = 0x00000001,
    ///All of the bytes of the primary image loaded into the unsealing enclave must match the bytes for the primary
    ///image in the sealing enclave in order for EnclaveSealData to decrypt the data.
    ENCLAVE_IDENTITY_POLICY_SEAL_SAME_PRIMARY_CODE = 0x00000002,
    ///The author identifier, family identifier, and image identifier of the primary image of the unsealing enclave must
    ///match the author identifier, family identifier, and image identifier of the primary image of the sealing enclave
    ///in order for EnclaveSealData to decrypt the data. The enclave can be revised by its author as many times as
    ///desired, and the data can be unsealed by any enclave with a primary image retains those same identity values.
    ENCLAVE_IDENTITY_POLICY_SEAL_SAME_IMAGE        = 0x00000003,
    ///The author identifier and family identifier of the primary image of the unsealing enclave must match the author
    ///identifier and family identifier of the primary image of the sealing enclave in order for EnclaveSealData to
    ///decrypt the data. This case permits an enclave to exchange information with any other enclave in the same family
    ENCLAVE_IDENTITY_POLICY_SEAL_SAME_FAMILY       = 0x00000004,
    ///The author identifier of the primary image of the unsealing enclave must match the author identifier of the
    ///primary image of the sealing enclave in order for EnclaveSealData to decrypt the data. This case permits an
    ///enclave to exchange information with any other enclave generated by the same author.
    ENCLAVE_IDENTITY_POLICY_SEAL_SAME_AUTHOR       = 0x00000005,
}

///Indicates the effective power mode the system is running.
alias EFFECTIVE_POWER_MODE = int;
enum : int
{
    ///The system is in battery saver mode.
    EffectivePowerModeBatterySaver    = 0x00000000,
    ///The system is in the better battery effective power mode. <div class="alert"><b>Note</b> For systems using the
    ///legacy high performance overlay, this effective power mode will never be used.</div> <div> </div>
    EffectivePowerModeBetterBattery   = 0x00000001,
    ///The system is in the balanced effective power mode.
    EffectivePowerModeBalanced        = 0x00000002,
    ///The system is in the high performance effective power mode. <div class="alert"><b>Note</b> This effective power
    ///mode is only used for systems using the legacy high performance overlay.</div> <div> </div>
    EffectivePowerModeHighPerformance = 0x00000003,
    ///The system is in the maximum performance effective power mode.
    EffectivePowerModeMaxPerformance  = 0x00000004,
    ///The system is in game mode power mode. <div class="alert"><b>Note</b> This mode is only available with the
    ///EFFECTIVE_POWER_MODE_V2 version of the API </div> <div> </div>
    EffectivePowerModeGameMode        = 0x00000005,
    EffectivePowerModeMixedReality    = 0x00000006,
}

///Enumeration values used by PowerEnumerate and PowerSettingAccessCheck.
alias POWER_DATA_ACCESSOR = int;
enum : int
{
    ///Used with PowerSettingAccessCheck to check for group policy overrides for AC power settings.
    ACCESS_AC_POWER_SETTING_INDEX               = 0x00000000,
    ///Used with PowerSettingAccessCheck to check for group policy overrides for DC power settings.
    ACCESS_DC_POWER_SETTING_INDEX               = 0x00000001,
    ACCESS_FRIENDLY_NAME                        = 0x00000002,
    ACCESS_DESCRIPTION                          = 0x00000003,
    ACCESS_POSSIBLE_POWER_SETTING               = 0x00000004,
    ACCESS_POSSIBLE_POWER_SETTING_FRIENDLY_NAME = 0x00000005,
    ACCESS_POSSIBLE_POWER_SETTING_DESCRIPTION   = 0x00000006,
    ACCESS_DEFAULT_AC_POWER_SETTING             = 0x00000007,
    ACCESS_DEFAULT_DC_POWER_SETTING             = 0x00000008,
    ACCESS_POSSIBLE_VALUE_MIN                   = 0x00000009,
    ACCESS_POSSIBLE_VALUE_MAX                   = 0x0000000a,
    ACCESS_POSSIBLE_VALUE_INCREMENT             = 0x0000000b,
    ACCESS_POSSIBLE_VALUE_UNITS                 = 0x0000000c,
    ACCESS_ICON_RESOURCE                        = 0x0000000d,
    ACCESS_DEFAULT_SECURITY_DESCRIPTOR          = 0x0000000e,
    ACCESS_ATTRIBUTES                           = 0x0000000f,
    ///Used to enumerate power schemes with PowerEnumerate and with PowerSettingAccessCheck to check for restricted
    ///access to specific power schemes.
    ACCESS_SCHEME                               = 0x00000010,
    ///Used to enumerate subgroups with PowerEnumerate.
    ACCESS_SUBGROUP                             = 0x00000011,
    ///Used to enumerate individual power settings with PowerEnumerate.
    ACCESS_INDIVIDUAL_SETTING                   = 0x00000012,
    ///Used with PowerSettingAccessCheck to check for group policy overrides for active power schemes.
    ACCESS_ACTIVE_SCHEME                        = 0x00000013,
    ///Used with PowerSettingAccessCheck to check for restricted access for creating power schemes.
    ACCESS_CREATE_SCHEME                        = 0x00000014,
    ACCESS_AC_POWER_SETTING_MAX                 = 0x00000015,
    ACCESS_DC_POWER_SETTING_MAX                 = 0x00000016,
    ACCESS_AC_POWER_SETTING_MIN                 = 0x00000017,
    ACCESS_DC_POWER_SETTING_MIN                 = 0x00000018,
    ACCESS_PROFILE                              = 0x00000019,
    ACCESS_OVERLAY_SCHEME                       = 0x0000001a,
    ACCESS_ACTIVE_OVERLAY_SCHEME                = 0x0000001b,
}

alias BATTERY_QUERY_INFORMATION_LEVEL = int;
enum : int
{
    BatteryInformation            = 0x00000000,
    BatteryGranularityInformation = 0x00000001,
    BatteryTemperature            = 0x00000002,
    BatteryEstimatedTime          = 0x00000003,
    BatteryDeviceName             = 0x00000004,
    BatteryManufactureDate        = 0x00000005,
    BatteryManufactureName        = 0x00000006,
    BatteryUniqueID               = 0x00000007,
    BatterySerialNumber           = 0x00000008,
}

alias BATTERY_CHARGING_SOURCE_TYPE = int;
enum : int
{
    BatteryChargingSourceType_AC       = 0x00000001,
    BatteryChargingSourceType_USB      = 0x00000002,
    BatteryChargingSourceType_Wireless = 0x00000003,
    BatteryChargingSourceType_Max      = 0x00000004,
}

alias USB_CHARGER_PORT = int;
enum : int
{
    UsbChargerPort_Legacy = 0x00000000,
    UsbChargerPort_TypeC  = 0x00000001,
    UsbChargerPort_Max    = 0x00000002,
}

alias BATTERY_SET_INFORMATION_LEVEL = int;
enum : int
{
    BatteryCriticalBias   = 0x00000000,
    BatteryCharge         = 0x00000001,
    BatteryDischarge      = 0x00000002,
    BatteryChargingSource = 0x00000003,
    BatteryChargerId      = 0x00000004,
    BatteryChargerStatus  = 0x00000005,
}

alias VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE = int;
enum : int
{
    VideoPowerNotifyCallout             = 0x00000001,
    VideoEnumChildPdoNotifyCallout      = 0x00000003,
    VideoFindAdapterCallout             = 0x00000004,
    VideoPnpNotifyCallout               = 0x00000007,
    VideoDxgkDisplaySwitchCallout       = 0x00000008,
    VideoDxgkFindAdapterTdrCallout      = 0x0000000a,
    VideoDxgkHardwareProtectionTeardown = 0x0000000b,
    VideoRepaintDesktop                 = 0x0000000c,
    VideoUpdateCursor                   = 0x0000000d,
    VideoDisableMultiPlaneOverlay       = 0x0000000e,
    VideoDesktopDuplicationChange       = 0x0000000f,
    VideoBlackScreenDiagnostics         = 0x00000010,
}

enum BlackScreenDiagnosticsCalloutParam : int
{
    BlackScreenDiagnosticsData = 0x00000001,
    BlackScreenDisplayRecovery = 0x00000002,
}

alias VIDEO_BANK_TYPE = int;
enum : int
{
    VideoNotBanked    = 0x00000000,
    VideoBanked1RW    = 0x00000001,
    VideoBanked1R1W   = 0x00000002,
    VideoBanked2RW    = 0x00000003,
    NumVideoBankTypes = 0x00000004,
}

alias VIDEO_POWER_STATE = int;
enum : int
{
    VideoPowerUnspecified = 0x00000000,
    VideoPowerOn          = 0x00000001,
    VideoPowerStandBy     = 0x00000002,
    VideoPowerSuspend     = 0x00000003,
    VideoPowerOff         = 0x00000004,
    VideoPowerHibernate   = 0x00000005,
    VideoPowerShutdown    = 0x00000006,
    VideoPowerMaximum     = 0x00000007,
}

alias BRIGHTNESS_INTERFACE_VERSION = int;
enum : int
{
    BRIGHTNESS_INTERFACE_VERSION_1 = 0x00000001,
    BRIGHTNESS_INTERFACE_VERSION_2 = 0x00000002,
    BRIGHTNESS_INTERFACE_VERSION_3 = 0x00000003,
}

alias BACKLIGHT_OPTIMIZATION_LEVEL = int;
enum : int
{
    BacklightOptimizationDisable = 0x00000000,
    BacklightOptimizationDesktop = 0x00000001,
    BacklightOptimizationDynamic = 0x00000002,
    BacklightOptimizationDimmed  = 0x00000003,
    BacklightOptimizationEDR     = 0x00000004,
}

alias COLORSPACE_TRANSFORM_DATA_TYPE = int;
enum : int
{
    COLORSPACE_TRANSFORM_DATA_TYPE_FIXED_POINT = 0x00000000,
    COLORSPACE_TRANSFORM_DATA_TYPE_FLOAT       = 0x00000001,
}

alias COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION = int;
enum : int
{
    COLORSPACE_TRANSFORM_VERSION_DEFAULT       = 0x00000000,
    COLORSPACE_TRANSFORM_VERSION_1             = 0x00000001,
    COLORSPACE_TRANSFORM_VERSION_NOT_SUPPORTED = 0x00000000,
}

alias COLORSPACE_TRANSFORM_TYPE = int;
enum : int
{
    COLORSPACE_TRANSFORM_TYPE_UNINITIALIZED = 0x00000000,
    COLORSPACE_TRANSFORM_TYPE_DEFAULT       = 0x00000001,
    COLORSPACE_TRANSFORM_TYPE_RGB256x3x16   = 0x00000002,
    COLORSPACE_TRANSFORM_TYPE_DXGI_1        = 0x00000003,
    COLORSPACE_TRANSFORM_TYPE_MATRIX_3x4    = 0x00000004,
    COLORSPACE_TRANSFORM_TYPE_MATRIX_V2     = 0x00000005,
}

alias OUTPUT_WIRE_COLOR_SPACE_TYPE = int;
enum : int
{
    OUTPUT_WIRE_COLOR_SPACE_G22_P709              = 0x00000000,
    OUTPUT_WIRE_COLOR_SPACE_RESERVED              = 0x00000004,
    OUTPUT_WIRE_COLOR_SPACE_G2084_P2020           = 0x0000000c,
    OUTPUT_WIRE_COLOR_SPACE_G22_P709_WCG          = 0x0000001e,
    OUTPUT_WIRE_COLOR_SPACE_G22_P2020             = 0x0000001f,
    OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_HDR10PLUS = 0x00000020,
    OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_DVLL      = 0x00000021,
}

alias OUTPUT_COLOR_ENCODING = int;
enum : int
{
    OUTPUT_COLOR_ENCODING_RGB          = 0x00000000,
    OUTPUT_COLOR_ENCODING_YCBCR444     = 0x00000001,
    OUTPUT_COLOR_ENCODING_YCBCR422     = 0x00000002,
    OUTPUT_COLOR_ENCODING_YCBCR420     = 0x00000003,
    OUTPUT_COLOR_ENCODING_INTENSITY    = 0x00000004,
    OUTPUT_COLOR_ENCODING_FORCE_UINT32 = 0xffffffff,
}

alias COLORSPACE_TRANSFORM_STAGE_CONTROL = int;
enum : int
{
    ColorSpaceTransformStageControl_No_Change = 0x00000000,
    ColorSpaceTransformStageControl_Enable    = 0x00000001,
    ColorSpaceTransformStageControl_Bypass    = 0x00000002,
}

alias DSI_CONTROL_TRANSMISSION_MODE = int;
enum : int
{
    DCT_DEFAULT                = 0x00000000,
    DCT_FORCE_LOW_POWER        = 0x00000001,
    DCT_FORCE_HIGH_PERFORMANCE = 0x00000002,
}

///Indicates the state of screen auto-rotation for the system. For example, whether auto-rotation is supported, and
///whether it is enabled by the user. This enum is a bitwise OR of one or more of the following values.
alias AR_STATE = int;
enum : int
{
    ///Auto-rotation is enabled by the user.
    AR_ENABLED       = 0x00000000,
    ///Auto-rotation is disabled by the user.
    AR_DISABLED      = 0x00000001,
    ///Auto-rotation is currently suppressed by one or more process auto-rotation preferences.
    AR_SUPPRESSED    = 0x00000002,
    ///The session is remote, and auto-rotation is temporarily disabled as a result.
    AR_REMOTESESSION = 0x00000004,
    ///The system has multiple monitors attached, and auto-rotation is temporarily disabled as a result.
    AR_MULTIMON      = 0x00000008,
    ///The system does not have an auto-rotation sensor.
    AR_NOSENSOR      = 0x00000010,
    ///Auto-rotation is not supported with the current system configuration.
    AR_NOT_SUPPORTED = 0x00000020,
    ///The device is docked, and auto-rotation is temporarily disabled as a result.
    AR_DOCKED        = 0x00000040,
    AR_LAPTOP        = 0x00000080,
}

///Indicates the screen orientation preference for a desktop app process.
alias ORIENTATION_PREFERENCE = int;
enum : int
{
    ///The process has no device orientation preferences. The system may choose any available setting.
    ORIENTATION_PREFERENCE_NONE              = 0x00000000,
    ///The process represents a desktop app that can be used in landscape mode.
    ORIENTATION_PREFERENCE_LANDSCAPE         = 0x00000001,
    ///The process represents a desktop app that can be used in portrait mode.
    ORIENTATION_PREFERENCE_PORTRAIT          = 0x00000002,
    ///The process represents a desktop app that can be used in flipped landscape mode.
    ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 0x00000004,
    ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED  = 0x00000008,
}

alias ACCESS_REASON_TYPE = int;
enum : int
{
    AccessReasonNone                     = 0x00000000,
    AccessReasonAllowedAce               = 0x00010000,
    AccessReasonDeniedAce                = 0x00020000,
    AccessReasonAllowedParentAce         = 0x00030000,
    AccessReasonDeniedParentAce          = 0x00040000,
    AccessReasonNotGrantedByCape         = 0x00050000,
    AccessReasonNotGrantedByParentCape   = 0x00060000,
    AccessReasonNotGrantedToAppContainer = 0x00070000,
    AccessReasonMissingPrivilege         = 0x00100000,
    AccessReasonFromPrivilege            = 0x00200000,
    AccessReasonIntegrityLevel           = 0x00300000,
    AccessReasonOwnership                = 0x00400000,
    AccessReasonNullDacl                 = 0x00500000,
    AccessReasonEmptyDacl                = 0x00600000,
    AccessReasonNoSD                     = 0x00700000,
    AccessReasonNoGrant                  = 0x00800000,
    AccessReasonTrustLabel               = 0x00900000,
    AccessReasonFilterAce                = 0x00a00000,
}

alias SE_IMAGE_SIGNATURE_TYPE = int;
enum : int
{
    SeImageSignatureNone             = 0x00000000,
    SeImageSignatureEmbedded         = 0x00000001,
    SeImageSignatureCache            = 0x00000002,
    SeImageSignatureCatalogCached    = 0x00000003,
    SeImageSignatureCatalogNotCached = 0x00000004,
    SeImageSignatureCatalogHint      = 0x00000005,
    SeImageSignaturePackageCatalog   = 0x00000006,
}

alias SE_LEARNING_MODE_DATA_TYPE = int;
enum : int
{
    SeLearningModeInvalidType = 0x00000000,
    SeLearningModeSettings    = 0x00000001,
    SeLearningModeMax         = 0x00000002,
}

///Represents the different process mitigation policies.
alias PROCESS_MITIGATION_POLICY = int;
enum : int
{
    ///The data execution prevention (DEP) policy of the process.
    ProcessDEPPolicy                   = 0x00000000,
    ///The Address Space Layout Randomization (ASLR) policy of the process.
    ProcessASLRPolicy                  = 0x00000001,
    ///The policy that turns off the ability of the process to generate dynamic code or modify existing executable code.
    ProcessDynamicCodePolicy           = 0x00000002,
    ///The process will receive a fatal error if it manipulates an invalid handle. Useful for preventing downstream
    ///problems in a process due to handle misuse.
    ProcessStrictHandleCheckPolicy     = 0x00000003,
    ///Disables the ability to use NTUser/GDI functions at the lowest layer.
    ProcessSystemCallDisablePolicy     = 0x00000004,
    ///Returns the mask of valid bits for all the mitigation options on the system. An application can set many
    ///mitigation options without querying the operating system for mitigation options by combining bitwise with the
    ///mask to exclude all non-supported bits at once.
    ProcessMitigationOptionsMask       = 0x00000005,
    ///The policy that prevents some built-in third party extension points from being turned on, which prevents legacy
    ///extension point DLLs from being loaded into the process.
    ProcessExtensionPointDisablePolicy = 0x00000006,
    ///The Control Flow Guard (CFG) policy of the process.
    ProcessControlFlowGuardPolicy      = 0x00000007,
    ///The policy of a process that can restrict image loading to those images that are either signed by Microsoft, by
    ///the Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs (WHQL).
    ProcessSignaturePolicy             = 0x00000008,
    ///The policy that turns off the ability of the process to load non-system fonts.
    ProcessFontDisablePolicy           = 0x00000009,
    ///The policy that turns off the ability of the process to load images from some locations, such a remote devices or
    ///files that have the low mandatory label.
    ProcessImageLoadPolicy             = 0x0000000a,
    ProcessSystemCallFilterPolicy      = 0x0000000b,
    ProcessPayloadRestrictionPolicy    = 0x0000000c,
    ProcessChildProcessPolicy          = 0x0000000d,
    ProcessSideChannelIsolationPolicy  = 0x0000000e,
    ///Windows 10, version 2004 and above: The policy regarding user-mode Hardware-enforced Stack Protection for the
    ///process.
    ProcessUserShadowStackPolicy       = 0x0000000f,
    MaxProcessMitigationPolicy         = 0x00000010,
}

alias JOBOBJECT_RATE_CONTROL_TOLERANCE = int;
enum : int
{
    ToleranceLow    = 0x00000001,
    ToleranceMedium = 0x00000002,
    ToleranceHigh   = 0x00000003,
}

alias JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = int;
enum : int
{
    ToleranceIntervalShort  = 0x00000001,
    ToleranceIntervalMedium = 0x00000002,
    ToleranceIntervalLong   = 0x00000003,
}

///Specifies types of scheduling policies for network rate control.
alias JOB_OBJECT_NET_RATE_CONTROL_FLAGS = int;
enum : int
{
    ///Turns on the control of the network traffic. You must set this value if you also set either
    ///<b>JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH</b> or <b>JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG</b>.
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE        = 0x00000001,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 0x00000002,
    ///Sets the DSCP field in the packet header to the value of the <b>DscpTag</b> member of the
    ///JOBOBJECT_NET_RATE_CONTROL_INFORMATION structure. For information about DSCP, see Differentiated Services.
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG      = 0x00000004,
    ///The combination of all of the valid flags for the JOB_OBJECT_NET_RATE_CONTROL_FLAGS enumeration.
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS   = 0x00000007,
}

alias JOB_OBJECT_IO_RATE_CONTROL_FLAGS = int;
enum : int
{
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE                        = 0x00000001,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME             = 0x00000002,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL         = 0x00000004,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 0x00000008,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS                   = 0x0000000f,
}

alias JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = int;
enum : int
{
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE      = 0x00000001,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE     = 0x00000002,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 0x00000003,
}

alias JOBOBJECTINFOCLASS = int;
enum : int
{
    JobObjectBasicAccountingInformation         = 0x00000001,
    JobObjectBasicLimitInformation              = 0x00000002,
    JobObjectBasicProcessIdList                 = 0x00000003,
    JobObjectBasicUIRestrictions                = 0x00000004,
    JobObjectSecurityLimitInformation           = 0x00000005,
    JobObjectEndOfJobTimeInformation            = 0x00000006,
    JobObjectAssociateCompletionPortInformation = 0x00000007,
    JobObjectBasicAndIoAccountingInformation    = 0x00000008,
    JobObjectExtendedLimitInformation           = 0x00000009,
    JobObjectJobSetInformation                  = 0x0000000a,
    JobObjectGroupInformation                   = 0x0000000b,
    JobObjectNotificationLimitInformation       = 0x0000000c,
    JobObjectLimitViolationInformation          = 0x0000000d,
    JobObjectGroupInformationEx                 = 0x0000000e,
    JobObjectCpuRateControlInformation          = 0x0000000f,
    JobObjectCompletionFilter                   = 0x00000010,
    JobObjectCompletionCounter                  = 0x00000011,
    JobObjectReserved1Information               = 0x00000012,
    JobObjectReserved2Information               = 0x00000013,
    JobObjectReserved3Information               = 0x00000014,
    JobObjectReserved4Information               = 0x00000015,
    JobObjectReserved5Information               = 0x00000016,
    JobObjectReserved6Information               = 0x00000017,
    JobObjectReserved7Information               = 0x00000018,
    JobObjectReserved8Information               = 0x00000019,
    JobObjectReserved9Information               = 0x0000001a,
    JobObjectReserved10Information              = 0x0000001b,
    JobObjectReserved11Information              = 0x0000001c,
    JobObjectReserved12Information              = 0x0000001d,
    JobObjectReserved13Information              = 0x0000001e,
    JobObjectReserved14Information              = 0x0000001f,
    JobObjectNetRateControlInformation          = 0x00000020,
    JobObjectNotificationLimitInformation2      = 0x00000021,
    JobObjectLimitViolationInformation2         = 0x00000022,
    JobObjectCreateSilo                         = 0x00000023,
    JobObjectSiloBasicInformation               = 0x00000024,
    JobObjectReserved15Information              = 0x00000025,
    JobObjectReserved16Information              = 0x00000026,
    JobObjectReserved17Information              = 0x00000027,
    JobObjectReserved18Information              = 0x00000028,
    JobObjectReserved19Information              = 0x00000029,
    JobObjectReserved20Information              = 0x0000002a,
    JobObjectReserved21Information              = 0x0000002b,
    JobObjectReserved22Information              = 0x0000002c,
    JobObjectReserved23Information              = 0x0000002d,
    JobObjectReserved24Information              = 0x0000002e,
    JobObjectReserved25Information              = 0x0000002f,
    MaxJobObjectInfoClass                       = 0x00000030,
}

alias SERVERSILO_STATE = int;
enum : int
{
    SERVERSILO_INITING       = 0x00000000,
    SERVERSILO_STARTED       = 0x00000001,
    SERVERSILO_SHUTTING_DOWN = 0x00000002,
    SERVERSILO_TERMINATING   = 0x00000003,
    SERVERSILO_TERMINATED    = 0x00000004,
}

///Represents the relationship between the processor set identified in the corresponding
///[SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX](./ns-winnt-system_logical_processor_information_ex.md) structure.
alias LOGICAL_PROCESSOR_RELATIONSHIP = int;
enum : int
{
    ///The specified logical processors share a single processor core.
    RelationProcessorCore    = 0x00000000,
    ///The specified logical processors are part of the same NUMA node.
    RelationNumaNode         = 0x00000001,
    ///The specified logical processors share a cache. <b>Windows Server 2003: </b>This value is not supported until
    ///Windows Server 2003 with SP1 and Windows XP Professional x64 Edition.
    RelationCache            = 0x00000002,
    ///The specified logical processors share a physical package (a single package socketed or soldered onto a
    ///motherboard may contain multiple processor cores or threads, each of which is treated as a separate processor by
    ///the operating system). <b>Windows Server 2003: </b>This value is not supported until Windows Server 2003 with SP1
    ///and Windows XP Professional x64 Edition.
    RelationProcessorPackage = 0x00000003,
    ///The specified logical processors share a single processor group. <b>Windows Server 2008, Windows Vista, Windows
    ///Server 2003 and Windows XP Professional x64 Edition: </b>This value is not supported until Windows Server 2008
    ///R2.
    RelationGroup            = 0x00000004,
    ///On input, retrieves information about all possible relationship types. This value is not used on output.
    ///<b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP Professional x64 Edition: </b>This
    ///value is not supported until Windows Server 2008 R2.
    RelationAll              = 0x0000ffff,
}

///Represents the type of processor cache identified in the corresponding CACHE_DESCRIPTOR structure.
alias PROCESSOR_CACHE_TYPE = int;
enum : int
{
    ///The cache is unified.
    CacheUnified     = 0x00000000,
    ///The cache is for processor instructions.
    CacheInstruction = 0x00000001,
    ///The cache is for data.
    CacheData        = 0x00000002,
    ///The cache is for traces.
    CacheTrace       = 0x00000003,
}

alias CPU_SET_INFORMATION_TYPE = int;
enum : int
{
    CpuSetInformation = 0x00000000,
}

///Defines values for extended parameters used for file mapping into an address space.
alias MEM_EXTENDED_PARAMETER_TYPE = int;
enum : int
{
    MemExtendedParameterInvalidType         = 0x00000000,
    ///This extended parameter type is used to specify alignment and virtual address range restrictions for new memory
    ///allocations created by VirtualAlloc2 and MapViewOfFile3.
    MemExtendedParameterAddressRequirements = 0x00000001,
    ///This extended parameter type is used to specify the preferred NUMA node for new memory allocations created by
    ///VirtualAlloc2 and MapViewOfFile3.
    MemExtendedParameterNumaNode            = 0x00000002,
    MemExtendedParameterPartitionHandle     = 0x00000003,
    MemExtendedParameterUserPhysicalHandle  = 0x00000004,
    MemExtendedParameterAttributeFlags      = 0x00000005,
    MemExtendedParameterMax                 = 0x00000006,
}

alias MEM_SECTION_EXTENDED_PARAMETER_TYPE = int;
enum : int
{
    MemSectionExtendedParameterInvalidType       = 0x00000000,
    MemSectionExtendedParameterUserPhysicalFlags = 0x00000001,
    MemSectionExtendedParameterNumaNode          = 0x00000002,
    MemSectionExtendedParameterMax               = 0x00000003,
}

enum SharedVirtualDiskSupportType : int
{
    SharedVirtualDisksUnsupported          = 0x00000000,
    SharedVirtualDisksSupported            = 0x00000001,
    SharedVirtualDiskSnapshotsSupported    = 0x00000003,
    SharedVirtualDiskCDPSnapshotsSupported = 0x00000007,
}

enum SharedVirtualDiskHandleState : int
{
    SharedVirtualDiskHandleStateNone         = 0x00000000,
    SharedVirtualDiskHandleStateFileShared   = 0x00000001,
    SharedVirtualDiskHandleStateHandleShared = 0x00000003,
}

///Defines values that are used to specify system power states.
alias SYSTEM_POWER_STATE = int;
enum : int
{
    ///Unspecified system power state.
    PowerSystemUnspecified = 0x00000000,
    ///Specifies system power state S0.
    PowerSystemWorking     = 0x00000001,
    ///Specifies system power state S1.
    PowerSystemSleeping1   = 0x00000002,
    ///Specifies system power state S2.
    PowerSystemSleeping2   = 0x00000003,
    ///Specifies system power state S3.
    PowerSystemSleeping3   = 0x00000004,
    ///Specifies system power state S4 (HIBERNATE).
    PowerSystemHibernate   = 0x00000005,
    ///Specifies system power state S5 (OFF).
    PowerSystemShutdown    = 0x00000006,
    ///Specifies the maximum enumeration value.
    PowerSystemMaximum     = 0x00000007,
}

///Defines values that are used to specify system power action types.
alias POWER_ACTION = int;
enum : int
{
    ///No system power action.
    PowerActionNone          = 0x00000000,
    ///Reserved; do not use.
    PowerActionReserved      = 0x00000001,
    ///Sleep.
    PowerActionSleep         = 0x00000002,
    ///Hibernate.
    PowerActionHibernate     = 0x00000003,
    ///Shutdown.
    PowerActionShutdown      = 0x00000004,
    ///Shutdown and reset.
    PowerActionShutdownReset = 0x00000005,
    ///Shutdown and power off.
    PowerActionShutdownOff   = 0x00000006,
    ///Warm eject.
    PowerActionWarmEject     = 0x00000007,
    PowerActionDisplayOff    = 0x00000008,
}

alias DEVICE_POWER_STATE = int;
enum : int
{
    PowerDeviceUnspecified = 0x00000000,
    PowerDeviceD0          = 0x00000001,
    PowerDeviceD1          = 0x00000002,
    PowerDeviceD2          = 0x00000003,
    PowerDeviceD3          = 0x00000004,
    PowerDeviceMaximum     = 0x00000005,
}

alias MONITOR_DISPLAY_STATE = int;
enum : int
{
    PowerMonitorOff = 0x00000000,
    PowerMonitorOn  = 0x00000001,
    PowerMonitorDim = 0x00000002,
}

alias USER_ACTIVITY_PRESENCE = int;
enum : int
{
    PowerUserPresent    = 0x00000000,
    PowerUserNotPresent = 0x00000001,
    PowerUserInactive   = 0x00000002,
    PowerUserMaximum    = 0x00000003,
    PowerUserInvalid    = 0x00000003,
}

alias LATENCY_TIME = int;
enum : int
{
    LT_DONT_CARE      = 0x00000000,
    LT_LOWEST_LATENCY = 0x00000001,
}

alias POWER_REQUEST_TYPE = int;
enum : int
{
    PowerRequestDisplayRequired   = 0x00000000,
    PowerRequestSystemRequired    = 0x00000001,
    PowerRequestAwayModeRequired  = 0x00000002,
    PowerRequestExecutionRequired = 0x00000003,
}

alias POWER_INFORMATION_LEVEL = int;
enum : int
{
    SystemPowerPolicyAc                = 0x00000000,
    SystemPowerPolicyDc                = 0x00000001,
    VerifySystemPolicyAc               = 0x00000002,
    VerifySystemPolicyDc               = 0x00000003,
    SystemPowerCapabilities            = 0x00000004,
    SystemBatteryState                 = 0x00000005,
    SystemPowerStateHandler            = 0x00000006,
    ProcessorStateHandler              = 0x00000007,
    SystemPowerPolicyCurrent           = 0x00000008,
    AdministratorPowerPolicy           = 0x00000009,
    SystemReserveHiberFile             = 0x0000000a,
    ProcessorInformation               = 0x0000000b,
    SystemPowerInformation             = 0x0000000c,
    ProcessorStateHandler2             = 0x0000000d,
    LastWakeTime                       = 0x0000000e,
    LastSleepTime                      = 0x0000000f,
    SystemExecutionState               = 0x00000010,
    SystemPowerStateNotifyHandler      = 0x00000011,
    ProcessorPowerPolicyAc             = 0x00000012,
    ProcessorPowerPolicyDc             = 0x00000013,
    VerifyProcessorPowerPolicyAc       = 0x00000014,
    VerifyProcessorPowerPolicyDc       = 0x00000015,
    ProcessorPowerPolicyCurrent        = 0x00000016,
    SystemPowerStateLogging            = 0x00000017,
    SystemPowerLoggingEntry            = 0x00000018,
    SetPowerSettingValue               = 0x00000019,
    NotifyUserPowerSetting             = 0x0000001a,
    PowerInformationLevelUnused0       = 0x0000001b,
    SystemMonitorHiberBootPowerOff     = 0x0000001c,
    SystemVideoState                   = 0x0000001d,
    TraceApplicationPowerMessage       = 0x0000001e,
    TraceApplicationPowerMessageEnd    = 0x0000001f,
    ProcessorPerfStates                = 0x00000020,
    ProcessorIdleStates                = 0x00000021,
    ProcessorCap                       = 0x00000022,
    SystemWakeSource                   = 0x00000023,
    SystemHiberFileInformation         = 0x00000024,
    TraceServicePowerMessage           = 0x00000025,
    ProcessorLoad                      = 0x00000026,
    PowerShutdownNotification          = 0x00000027,
    MonitorCapabilities                = 0x00000028,
    SessionPowerInit                   = 0x00000029,
    SessionDisplayState                = 0x0000002a,
    PowerRequestCreate                 = 0x0000002b,
    PowerRequestAction                 = 0x0000002c,
    GetPowerRequestList                = 0x0000002d,
    ProcessorInformationEx             = 0x0000002e,
    NotifyUserModeLegacyPowerEvent     = 0x0000002f,
    GroupPark                          = 0x00000030,
    ProcessorIdleDomains               = 0x00000031,
    WakeTimerList                      = 0x00000032,
    SystemHiberFileSize                = 0x00000033,
    ProcessorIdleStatesHv              = 0x00000034,
    ProcessorPerfStatesHv              = 0x00000035,
    ProcessorPerfCapHv                 = 0x00000036,
    ProcessorSetIdle                   = 0x00000037,
    LogicalProcessorIdling             = 0x00000038,
    UserPresence                       = 0x00000039,
    PowerSettingNotificationName       = 0x0000003a,
    GetPowerSettingValue               = 0x0000003b,
    IdleResiliency                     = 0x0000003c,
    SessionRITState                    = 0x0000003d,
    SessionConnectNotification         = 0x0000003e,
    SessionPowerCleanup                = 0x0000003f,
    SessionLockState                   = 0x00000040,
    SystemHiberbootState               = 0x00000041,
    PlatformInformation                = 0x00000042,
    PdcInvocation                      = 0x00000043,
    MonitorInvocation                  = 0x00000044,
    FirmwareTableInformationRegistered = 0x00000045,
    SetShutdownSelectedTime            = 0x00000046,
    SuspendResumeInvocation            = 0x00000047,
    PlmPowerRequestCreate              = 0x00000048,
    ScreenOff                          = 0x00000049,
    CsDeviceNotification               = 0x0000004a,
    PlatformRole                       = 0x0000004b,
    LastResumePerformance              = 0x0000004c,
    DisplayBurst                       = 0x0000004d,
    ExitLatencySamplingPercentage      = 0x0000004e,
    RegisterSpmPowerSettings           = 0x0000004f,
    PlatformIdleStates                 = 0x00000050,
    ProcessorIdleVeto                  = 0x00000051,
    PlatformIdleVeto                   = 0x00000052,
    SystemBatteryStatePrecise          = 0x00000053,
    ThermalEvent                       = 0x00000054,
    PowerRequestActionInternal         = 0x00000055,
    BatteryDeviceState                 = 0x00000056,
    PowerInformationInternal           = 0x00000057,
    ThermalStandby                     = 0x00000058,
    SystemHiberFileType                = 0x00000059,
    PhysicalPowerButtonPress           = 0x0000005a,
    QueryPotentialDripsConstraint      = 0x0000005b,
    EnergyTrackerCreate                = 0x0000005c,
    EnergyTrackerQuery                 = 0x0000005d,
    UpdateBlackBoxRecorder             = 0x0000005e,
    SessionAllowExternalDmaDevices     = 0x0000005f,
    PowerInformationLevelMaximum       = 0x00000060,
}

alias POWER_USER_PRESENCE_TYPE = int;
enum : int
{
    UserNotPresent = 0x00000000,
    UserPresent    = 0x00000001,
    UserUnknown    = 0x000000ff,
}

alias POWER_MONITOR_REQUEST_REASON = int;
enum : int
{
    MonitorRequestReasonUnknown                        = 0x00000000,
    MonitorRequestReasonPowerButton                    = 0x00000001,
    MonitorRequestReasonRemoteConnection               = 0x00000002,
    MonitorRequestReasonScMonitorpower                 = 0x00000003,
    MonitorRequestReasonUserInput                      = 0x00000004,
    MonitorRequestReasonAcDcDisplayBurst               = 0x00000005,
    MonitorRequestReasonUserDisplayBurst               = 0x00000006,
    MonitorRequestReasonPoSetSystemState               = 0x00000007,
    MonitorRequestReasonSetThreadExecutionState        = 0x00000008,
    MonitorRequestReasonFullWake                       = 0x00000009,
    MonitorRequestReasonSessionUnlock                  = 0x0000000a,
    MonitorRequestReasonScreenOffRequest               = 0x0000000b,
    MonitorRequestReasonIdleTimeout                    = 0x0000000c,
    MonitorRequestReasonPolicyChange                   = 0x0000000d,
    MonitorRequestReasonSleepButton                    = 0x0000000e,
    MonitorRequestReasonLid                            = 0x0000000f,
    MonitorRequestReasonBatteryCountChange             = 0x00000010,
    MonitorRequestReasonGracePeriod                    = 0x00000011,
    MonitorRequestReasonPnP                            = 0x00000012,
    MonitorRequestReasonDP                             = 0x00000013,
    MonitorRequestReasonSxTransition                   = 0x00000014,
    MonitorRequestReasonSystemIdle                     = 0x00000015,
    MonitorRequestReasonNearProximity                  = 0x00000016,
    MonitorRequestReasonThermalStandby                 = 0x00000017,
    MonitorRequestReasonResumePdc                      = 0x00000018,
    MonitorRequestReasonResumeS4                       = 0x00000019,
    MonitorRequestReasonTerminal                       = 0x0000001a,
    MonitorRequestReasonPdcSignal                      = 0x0000001b,
    MonitorRequestReasonAcDcDisplayBurstSuppressed     = 0x0000001c,
    MonitorRequestReasonSystemStateEntered             = 0x0000001d,
    MonitorRequestReasonWinrt                          = 0x0000001e,
    MonitorRequestReasonUserInputKeyboard              = 0x0000001f,
    MonitorRequestReasonUserInputMouse                 = 0x00000020,
    MonitorRequestReasonUserInputTouch                 = 0x00000021,
    MonitorRequestReasonUserInputPen                   = 0x00000022,
    MonitorRequestReasonUserInputAccelerometer         = 0x00000023,
    MonitorRequestReasonUserInputHid                   = 0x00000024,
    MonitorRequestReasonUserInputPoUserPresent         = 0x00000025,
    MonitorRequestReasonUserInputSessionSwitch         = 0x00000026,
    MonitorRequestReasonUserInputInitialization        = 0x00000027,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = 0x00000028,
    MonitorRequestReasonPdcSignalWindowsMobileShell    = 0x00000029,
    MonitorRequestReasonPdcSignalHeyCortana            = 0x0000002a,
    MonitorRequestReasonPdcSignalHolographicShell      = 0x0000002b,
    MonitorRequestReasonPdcSignalFingerprint           = 0x0000002c,
    MonitorRequestReasonDirectedDrips                  = 0x0000002d,
    MonitorRequestReasonDim                            = 0x0000002e,
    MonitorRequestReasonBuiltinPanel                   = 0x0000002f,
    MonitorRequestReasonDisplayRequiredUnDim           = 0x00000030,
    MonitorRequestReasonBatteryCountChangeSuppressed   = 0x00000031,
    MonitorRequestReasonResumeModernStandby            = 0x00000032,
    MonitorRequestReasonMax                            = 0x00000033,
}

alias POWER_MONITOR_REQUEST_TYPE = int;
enum : int
{
    MonitorRequestTypeOff          = 0x00000000,
    MonitorRequestTypeOnAndPresent = 0x00000001,
    MonitorRequestTypeToggleOn     = 0x00000002,
}

///Used by the <b>GUID_ACDC_POWER_SOURCE</b> power event to indicate the current power source.
alias SYSTEM_POWER_CONDITION = int;
enum : int
{
    ///The computer is powered by an AC power source (or similar, such as a laptop powered by a 12V automotive adapter).
    PoAc               = 0x00000000,
    ///The system is receiving power from built-in batteries.
    PoDc               = 0x00000001,
    ///The computer is powered by a short-term power source such as a UPS device.
    PoHot              = 0x00000002,
    ///Values equal to or greater than this value indicate an out of range value.
    PoConditionMaximum = 0x00000003,
}

///Indicates the OEM's preferred power management profile. These values are read from the Preferred_PM_Profile field of
///the Fixed ACPI Description Table (FADT). These values are returned by the PowerDeterminePlatformRole or
///PowerDeterminePlatformRoleEx function.
alias POWER_PLATFORM_ROLE = int;
enum : int
{
    ///The OEM did not specify a specific role.
    PlatformRoleUnspecified       = 0x00000000,
    ///The OEM specified a desktop role.
    PlatformRoleDesktop           = 0x00000001,
    ///The OEM specified a mobile role (for example, a laptop).
    PlatformRoleMobile            = 0x00000002,
    ///The OEM specified a workstation role.
    PlatformRoleWorkstation       = 0x00000003,
    ///The OEM specified an enterprise server role.
    PlatformRoleEnterpriseServer  = 0x00000004,
    ///The OEM specified a single office/home office (SOHO) server role.
    PlatformRoleSOHOServer        = 0x00000005,
    ///The OEM specified an appliance PC role.
    PlatformRoleAppliancePC       = 0x00000006,
    ///The OEM specified a performance server role.
    PlatformRolePerformanceServer = 0x00000007,
    ///The OEM specified a tablet form factor role. <b>Windows 7, Windows Server 2008 R2, Windows Vista or Windows
    ///Server 2008: </b>In version 1 of this enumeration, this value is equivalent to <b>PlatformRoleMaximum</b>. This
    ///value is supported in version 2 of this enumeration starting with Windows 8 and Windows Server 2012.
    PlatformRoleSlate             = 0x00000008,
    ///Values equal to or greater than this value indicate an out of range value.
    PlatformRoleMaximum           = 0x00000009,
}

alias HIBERFILE_BUCKET_SIZE = int;
enum : int
{
    HiberFileBucket1GB       = 0x00000000,
    HiberFileBucket2GB       = 0x00000001,
    HiberFileBucket4GB       = 0x00000002,
    HiberFileBucket8GB       = 0x00000003,
    HiberFileBucket16GB      = 0x00000004,
    HiberFileBucket32GB      = 0x00000005,
    HiberFileBucketUnlimited = 0x00000006,
    HiberFileBucketMax       = 0x00000007,
}

alias IMAGE_AUX_SYMBOL_TYPE = int;
enum : int
{
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 0x00000001,
}

alias ARM64_FNPDATA_FLAGS = int;
enum : int
{
    PdataRefToFullXdata       = 0x00000000,
    PdataPackedUnwindFunction = 0x00000001,
    PdataPackedUnwindFragment = 0x00000002,
}

alias ARM64_FNPDATA_CR = int;
enum : int
{
    PdataCrUnchained        = 0x00000000,
    PdataCrUnchainedSavedLr = 0x00000001,
    PdataCrChained          = 0x00000003,
}

alias IMPORT_OBJECT_TYPE = int;
enum : int
{
    IMPORT_OBJECT_CODE  = 0x00000000,
    IMPORT_OBJECT_DATA  = 0x00000001,
    IMPORT_OBJECT_CONST = 0x00000002,
}

alias IMPORT_OBJECT_NAME_TYPE = int;
enum : int
{
    IMPORT_OBJECT_ORDINAL         = 0x00000000,
    IMPORT_OBJECT_NAME            = 0x00000001,
    IMPORT_OBJECT_NAME_NO_PREFIX  = 0x00000002,
    IMPORT_OBJECT_NAME_UNDECORATE = 0x00000003,
    IMPORT_OBJECT_NAME_EXPORTAS   = 0x00000004,
}

enum ReplacesCorHdrNumericDefines : int
{
    COMIMAGE_FLAGS_ILONLY                      = 0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED               = 0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY                  = 0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED            = 0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT           = 0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA              = 0x00010000,
    COMIMAGE_FLAGS_32BITPREFERRED              = 0x00020000,
    COR_VERSION_MAJOR_V2                       = 0x00000002,
    COR_VERSION_MAJOR                          = 0x00000002,
    COR_VERSION_MINOR                          = 0x00000005,
    COR_DELETED_NAME_LENGTH                    = 0x00000008,
    COR_VTABLEGAP_NAME_LENGTH                  = 0x00000008,
    NATIVE_TYPE_MAX_CB                         = 0x00000001,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE       = 0x000000ff,
    IMAGE_COR_MIH_METHODRVA                    = 0x00000001,
    IMAGE_COR_MIH_EHRVA                        = 0x00000002,
    IMAGE_COR_MIH_BASICBLOCK                   = 0x00000008,
    COR_VTABLE_32BIT                           = 0x00000001,
    COR_VTABLE_64BIT                           = 0x00000002,
    COR_VTABLE_FROM_UNMANAGED                  = 0x00000004,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 0x00000008,
    COR_VTABLE_CALL_MOST_DERIVED               = 0x00000010,
    IMAGE_COR_EATJ_THUNK_SIZE                  = 0x00000020,
    MAX_CLASS_NAME                             = 0x00000400,
    MAX_PACKAGE_NAME                           = 0x00000400,
}

alias RTL_UMS_THREAD_INFO_CLASS = int;
enum : int
{
    UmsThreadInvalidInfoClass = 0x00000000,
    UmsThreadUserContext      = 0x00000001,
    UmsThreadPriority         = 0x00000002,
    UmsThreadAffinity         = 0x00000003,
    UmsThreadTeb              = 0x00000004,
    UmsThreadIsSuspended      = 0x00000005,
    UmsThreadIsTerminated     = 0x00000006,
    UmsThreadMaxInfoClass     = 0x00000007,
}

alias RTL_UMS_SCHEDULER_REASON = int;
enum : int
{
    UmsSchedulerStartup       = 0x00000000,
    UmsSchedulerThreadBlocked = 0x00000001,
    UmsSchedulerThreadYield   = 0x00000002,
}

alias OS_DEPLOYEMENT_STATE_VALUES = int;
enum : int
{
    OS_DEPLOYMENT_STANDARD = 0x00000001,
    OS_DEPLOYMENT_COMPACT  = 0x00000002,
}

alias IMAGE_POLICY_ENTRY_TYPE = int;
enum : int
{
    ImagePolicyEntryTypeNone          = 0x00000000,
    ImagePolicyEntryTypeBool          = 0x00000001,
    ImagePolicyEntryTypeInt8          = 0x00000002,
    ImagePolicyEntryTypeUInt8         = 0x00000003,
    ImagePolicyEntryTypeInt16         = 0x00000004,
    ImagePolicyEntryTypeUInt16        = 0x00000005,
    ImagePolicyEntryTypeInt32         = 0x00000006,
    ImagePolicyEntryTypeUInt32        = 0x00000007,
    ImagePolicyEntryTypeInt64         = 0x00000008,
    ImagePolicyEntryTypeUInt64        = 0x00000009,
    ImagePolicyEntryTypeAnsiString    = 0x0000000a,
    ImagePolicyEntryTypeUnicodeString = 0x0000000b,
    ImagePolicyEntryTypeOverride      = 0x0000000c,
    ImagePolicyEntryTypeMaximum       = 0x0000000d,
}

alias IMAGE_POLICY_ID = int;
enum : int
{
    ImagePolicyIdNone             = 0x00000000,
    ImagePolicyIdEtw              = 0x00000001,
    ImagePolicyIdDebug            = 0x00000002,
    ImagePolicyIdCrashDump        = 0x00000003,
    ImagePolicyIdCrashDumpKey     = 0x00000004,
    ImagePolicyIdCrashDumpKeyGuid = 0x00000005,
    ImagePolicyIdParentSd         = 0x00000006,
    ImagePolicyIdParentSdRev      = 0x00000007,
    ImagePolicyIdSvn              = 0x00000008,
    ImagePolicyIdDeviceId         = 0x00000009,
    ImagePolicyIdCapability       = 0x0000000a,
    ImagePolicyIdScenarioId       = 0x0000000b,
    ImagePolicyIdMaximum          = 0x0000000c,
}

///Specifies the class of heap information to be set or retrieved.
alias HEAP_INFORMATION_CLASS = int;
enum : int
{
    ///The heap features that are enabled. The available features vary based on operating system. Depending on the
    ///<i>HeapInformation</i> parameter in the HeapQueryInformation or HeapSetInformation functions, specifying this
    ///enumeration value can indicate one of the following features: <ul> <li>A standard heap that does not support
    ///look-aside lists.</li> <li>A heap that supports look-aside lists.</li> <li>A low-fragmentation heap (LFH), which
    ///does not support look-aside lists.</li> </ul> For more information about look-aside lists, see the Remarks
    ///section.
    HeapCompatibilityInformation      = 0x00000000,
    ///The terminate-on-corruption feature. If the heap manager detects an error in any heap used by the process, it
    ///calls the Windows Error Reporting service and terminates the process. After a process enables this feature, it
    ///cannot be disabled.
    HeapEnableTerminationOnCorruption = 0x00000001,
    HeapOptimizeResources             = 0x00000003,
}

alias ACTIVATION_CONTEXT_INFO_CLASS = int;
enum : int
{
    ActivationContextBasicInformation                      = 0x00000001,
    ActivationContextDetailedInformation                   = 0x00000002,
    AssemblyDetailedInformationInActivationContext         = 0x00000003,
    FileInformationInAssemblyOfAssemblyInActivationContext = 0x00000004,
    RunlevelInformationInActivationContext                 = 0x00000005,
    CompatibilityInformationInActivationContext            = 0x00000006,
    ActivationContextManifestResourceName                  = 0x00000007,
    MaxActivationContextInfoClass                          = 0x00000008,
    AssemblyDetailedInformationInActivationContxt          = 0x00000003,
    FileInformationInAssemblyOfAssemblyInActivationContxt  = 0x00000004,
}

alias CM_SERVICE_NODE_TYPE = int;
enum : int
{
    DriverType               = 0x00000001,
    FileSystemType           = 0x00000002,
    Win32ServiceOwnProcess   = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType              = 0x00000004,
    RecognizerType           = 0x00000008,
}

alias CM_SERVICE_LOAD_TYPE = int;
enum : int
{
    BootLoad    = 0x00000000,
    SystemLoad  = 0x00000001,
    AutoLoad    = 0x00000002,
    DemandLoad  = 0x00000003,
    DisableLoad = 0x00000004,
}

alias CM_ERROR_CONTROL_TYPE = int;
enum : int
{
    IgnoreError   = 0x00000000,
    NormalError   = 0x00000001,
    SevereError   = 0x00000002,
    CriticalError = 0x00000003,
}

alias TAPE_DRIVE_PROBLEM_TYPE = int;
enum : int
{
    TapeDriveProblemNone         = 0x00000000,
    TapeDriveReadWriteWarning    = 0x00000001,
    TapeDriveReadWriteError      = 0x00000002,
    TapeDriveReadWarning         = 0x00000003,
    TapeDriveWriteWarning        = 0x00000004,
    TapeDriveReadError           = 0x00000005,
    TapeDriveWriteError          = 0x00000006,
    TapeDriveHardwareError       = 0x00000007,
    TapeDriveUnsupportedMedia    = 0x00000008,
    TapeDriveScsiConnectionError = 0x00000009,
    TapeDriveTimetoClean         = 0x0000000a,
    TapeDriveCleanDriveNow       = 0x0000000b,
    TapeDriveMediaLifeExpired    = 0x0000000c,
    TapeDriveSnappedTape         = 0x0000000d,
}

alias TRANSACTION_STATE = int;
enum : int
{
    TransactionStateNormal          = 0x00000001,
    TransactionStateIndoubt         = 0x00000002,
    TransactionStateCommittedNotify = 0x00000003,
}

alias TRANSACTION_INFORMATION_CLASS = int;
enum : int
{
    TransactionBasicInformation              = 0x00000000,
    TransactionPropertiesInformation         = 0x00000001,
    TransactionEnlistmentInformation         = 0x00000002,
    TransactionSuperiorEnlistmentInformation = 0x00000003,
    TransactionBindInformation               = 0x00000004,
    TransactionDTCPrivateInformation         = 0x00000005,
}

alias TRANSACTIONMANAGER_INFORMATION_CLASS = int;
enum : int
{
    TransactionManagerBasicInformation             = 0x00000000,
    TransactionManagerLogInformation               = 0x00000001,
    TransactionManagerLogPathInformation           = 0x00000002,
    TransactionManagerRecoveryInformation          = 0x00000004,
    TransactionManagerOnlineProbeInformation       = 0x00000003,
    TransactionManagerOldestTransactionInformation = 0x00000005,
}

alias RESOURCEMANAGER_INFORMATION_CLASS = int;
enum : int
{
    ResourceManagerBasicInformation      = 0x00000000,
    ResourceManagerCompletionInformation = 0x00000001,
}

alias ENLISTMENT_INFORMATION_CLASS = int;
enum : int
{
    EnlistmentBasicInformation    = 0x00000000,
    EnlistmentRecoveryInformation = 0x00000001,
    EnlistmentCrmInformation      = 0x00000002,
}

alias KTMOBJECT_TYPE = int;
enum : int
{
    KTMOBJECT_TRANSACTION         = 0x00000000,
    KTMOBJECT_TRANSACTION_MANAGER = 0x00000001,
    KTMOBJECT_RESOURCE_MANAGER    = 0x00000002,
    KTMOBJECT_ENLISTMENT          = 0x00000003,
    KTMOBJECT_INVALID             = 0x00000004,
}

alias TP_CALLBACK_PRIORITY = int;
enum : int
{
    TP_CALLBACK_PRIORITY_HIGH    = 0x00000000,
    TP_CALLBACK_PRIORITY_NORMAL  = 0x00000001,
    TP_CALLBACK_PRIORITY_LOW     = 0x00000002,
    TP_CALLBACK_PRIORITY_INVALID = 0x00000003,
    TP_CALLBACK_PRIORITY_COUNT   = 0x00000003,
}

///Represents the different memory exhaustion types.
alias PROCESS_MEMORY_EXHAUSTION_TYPE = int;
enum : int
{
    ///Anytime memory management fails an allocation due to an inability to commit memory, it will cause the process to
    ///trigger a Windows Error Reporting report and then terminate immediately with <b>STATUS_COMMITMENT_LIMIT</b>. The
    ///failure cannot be caught and handled by the app.
    PMETypeFailFastOnCommitFailure = 0x00000000,
    PMETypeMax                     = 0x00000001,
}

// Constants


enum int TRUE = 0x00000001;
enum ushort RT_CURSOR = 0x0001;

enum : ushort
{
    RT_ICON   = 0x0003,
    RT_MENU   = 0x0004,
    RT_DIALOG = 0x0005,
}

enum : ushort
{
    RT_FONTDIR     = 0x0007,
    RT_FONT        = 0x0008,
    RT_ACCELERATOR = 0x0009,
}

enum ushort RT_MESSAGETABLE = 0x000b;

enum : ushort
{
    RT_GROUP_CURSOR = 0x000c,
    RT_GROUP_ICON   = 0x000e,
}

enum ushort RT_DLGINCLUDE = 0x0011;

enum : ushort
{
    RT_VXD       = 0x0014,
    RT_ANICURSOR = 0x0015,
    RT_ANIICON   = 0x0016,
}

enum ushort RT_MANIFEST = 0x0018;

enum : ushort
{
    ISOLATIONAWARE_MANIFEST_RESOURCE_ID                = 0x0002,
    ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID = 0x0003,
}

enum ushort ISOLATIONPOLICY_BROWSER_MANIFEST_RESOURCE_ID = 0x0005;
enum ushort MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID = 0x0010;

enum : int
{
    SB_HORZ      = 0x00000000,
    SB_VERT      = 0x00000001,
    SB_CTL       = 0x00000002,
    SB_BOTH      = 0x00000003,
    SB_LINEUP    = 0x00000000,
    SB_LINELEFT  = 0x00000000,
    SB_LINEDOWN  = 0x00000001,
    SB_LINERIGHT = 0x00000001,
}

enum : int
{
    SB_PAGELEFT  = 0x00000002,
    SB_PAGEDOWN  = 0x00000003,
    SB_PAGERIGHT = 0x00000003,
}

enum int SB_THUMBTRACK = 0x00000005;

enum : int
{
    SB_LEFT   = 0x00000006,
    SB_BOTTOM = 0x00000007,
}

enum int SB_ENDSCROLL = 0x00000008;
enum int SW_SHOWNORMAL = 0x00000001;

enum : int
{
    SW_SHOWMINIMIZED = 0x00000002,
    SW_SHOWMAXIMIZED = 0x00000003,
}

enum : int
{
    SW_SHOWNOACTIVATE = 0x00000004,
    SW_SHOW           = 0x00000005,
    SW_MINIMIZE       = 0x00000006,
}

enum int SW_SHOWNA = 0x00000008;
enum int SW_SHOWDEFAULT = 0x0000000a;
enum int SW_MAX = 0x0000000b;
enum int SHOW_OPENWINDOW = 0x00000001;
enum int SHOW_FULLSCREEN = 0x00000003;
enum int SW_PARENTCLOSING = 0x00000001;
enum int SW_PARENTOPENING = 0x00000003;

enum : int
{
    AW_HOR_POSITIVE = 0x00000001,
    AW_HOR_NEGATIVE = 0x00000002,
}

enum int AW_VER_NEGATIVE = 0x00000008;

enum : int
{
    AW_HIDE     = 0x00010000,
    AW_ACTIVATE = 0x00020000,
}

enum int AW_BLEND = 0x00080000;
enum int KF_DLGMODE = 0x00000800;
enum int KF_ALTDOWN = 0x00002000;
enum int KF_UP = 0x00008000;
enum int VK_RBUTTON = 0x00000002;
enum int VK_MBUTTON = 0x00000004;
enum int VK_XBUTTON2 = 0x00000006;

enum : int
{
    VK_TAB   = 0x00000009,
    VK_CLEAR = 0x0000000c,
}

enum int VK_SHIFT = 0x00000010;

enum : int
{
    VK_MENU  = 0x00000012,
    VK_PAUSE = 0x00000013,
}

enum : int
{
    VK_KANA    = 0x00000015,
    VK_HANGEUL = 0x00000015,
    VK_HANGUL  = 0x00000015,
}

enum int VK_FINAL = 0x00000018;
enum int VK_KANJI = 0x00000019;
enum int VK_CONVERT = 0x0000001c;
enum int VK_ACCEPT = 0x0000001e;
enum int VK_SPACE = 0x00000020;

enum : int
{
    VK_NEXT  = 0x00000022,
    VK_END   = 0x00000023,
    VK_HOME  = 0x00000024,
    VK_LEFT  = 0x00000025,
    VK_UP    = 0x00000026,
    VK_RIGHT = 0x00000027,
}

enum int VK_SELECT = 0x00000029;
enum int VK_EXECUTE = 0x0000002b;
enum int VK_INSERT = 0x0000002d;

enum : int
{
    VK_HELP  = 0x0000002f,
    VK_LWIN  = 0x0000005b,
    VK_RWIN  = 0x0000005c,
    VK_APPS  = 0x0000005d,
    VK_SLEEP = 0x0000005f,
}

enum : int
{
    VK_NUMPAD1 = 0x00000061,
    VK_NUMPAD2 = 0x00000062,
    VK_NUMPAD3 = 0x00000063,
    VK_NUMPAD4 = 0x00000064,
    VK_NUMPAD5 = 0x00000065,
    VK_NUMPAD6 = 0x00000066,
    VK_NUMPAD7 = 0x00000067,
    VK_NUMPAD8 = 0x00000068,
    VK_NUMPAD9 = 0x00000069,
}

enum : int
{
    VK_ADD       = 0x0000006b,
    VK_SEPARATOR = 0x0000006c,
}

enum int VK_DECIMAL = 0x0000006e;

enum : int
{
    VK_F1                = 0x00000070,
    VK_F2                = 0x00000071,
    VK_F3                = 0x00000072,
    VK_F4                = 0x00000073,
    VK_F5                = 0x00000074,
    VK_F6                = 0x00000075,
    VK_F7                = 0x00000076,
    VK_F8                = 0x00000077,
    VK_F9                = 0x00000078,
    VK_F10               = 0x00000079,
    VK_F11               = 0x0000007a,
    VK_F12               = 0x0000007b,
    VK_F13               = 0x0000007c,
    VK_F14               = 0x0000007d,
    VK_F15               = 0x0000007e,
    VK_F16               = 0x0000007f,
    VK_F17               = 0x00000080,
    VK_F18               = 0x00000081,
    VK_F19               = 0x00000082,
    VK_F20               = 0x00000083,
    VK_F21               = 0x00000084,
    VK_F22               = 0x00000085,
    VK_F23               = 0x00000086,
    VK_F24               = 0x00000087,
    VK_NAVIGATION_VIEW   = 0x00000088,
    VK_NAVIGATION_MENU   = 0x00000089,
    VK_NAVIGATION_UP     = 0x0000008a,
    VK_NAVIGATION_DOWN   = 0x0000008b,
    VK_NAVIGATION_LEFT   = 0x0000008c,
    VK_NAVIGATION_RIGHT  = 0x0000008d,
    VK_NAVIGATION_ACCEPT = 0x0000008e,
    VK_NAVIGATION_CANCEL = 0x0000008f,
}

enum int VK_SCROLL = 0x00000091;

enum : int
{
    VK_OEM_FJ_JISHO   = 0x00000092,
    VK_OEM_FJ_MASSHOU = 0x00000093,
    VK_OEM_FJ_TOUROKU = 0x00000094,
    VK_OEM_FJ_LOYA    = 0x00000095,
    VK_OEM_FJ_ROYA    = 0x00000096,
}

enum int VK_RSHIFT = 0x000000a1;
enum int VK_RCONTROL = 0x000000a3;
enum int VK_RMENU = 0x000000a5;

enum : int
{
    VK_BROWSER_FORWARD   = 0x000000a7,
    VK_BROWSER_REFRESH   = 0x000000a8,
    VK_BROWSER_STOP      = 0x000000a9,
    VK_BROWSER_SEARCH    = 0x000000aa,
    VK_BROWSER_FAVORITES = 0x000000ab,
    VK_BROWSER_HOME      = 0x000000ac,
}

enum : int
{
    VK_VOLUME_DOWN = 0x000000ae,
    VK_VOLUME_UP   = 0x000000af,
}

enum : int
{
    VK_MEDIA_PREV_TRACK = 0x000000b1,
    VK_MEDIA_STOP       = 0x000000b2,
    VK_MEDIA_PLAY_PAUSE = 0x000000b3,
}

enum : int
{
    VK_LAUNCH_MEDIA_SELECT = 0x000000b5,
    VK_LAUNCH_APP1         = 0x000000b6,
    VK_LAUNCH_APP2         = 0x000000b7,
}

enum : int
{
    VK_OEM_PLUS   = 0x000000bb,
    VK_OEM_COMMA  = 0x000000bc,
    VK_OEM_MINUS  = 0x000000bd,
    VK_OEM_PERIOD = 0x000000be,
    VK_OEM_2      = 0x000000bf,
    VK_OEM_3      = 0x000000c0,
}

enum : int
{
    VK_GAMEPAD_B                      = 0x000000c4,
    VK_GAMEPAD_X                      = 0x000000c5,
    VK_GAMEPAD_Y                      = 0x000000c6,
    VK_GAMEPAD_RIGHT_SHOULDER         = 0x000000c7,
    VK_GAMEPAD_LEFT_SHOULDER          = 0x000000c8,
    VK_GAMEPAD_LEFT_TRIGGER           = 0x000000c9,
    VK_GAMEPAD_RIGHT_TRIGGER          = 0x000000ca,
    VK_GAMEPAD_DPAD_UP                = 0x000000cb,
    VK_GAMEPAD_DPAD_DOWN              = 0x000000cc,
    VK_GAMEPAD_DPAD_LEFT              = 0x000000cd,
    VK_GAMEPAD_DPAD_RIGHT             = 0x000000ce,
    VK_GAMEPAD_MENU                   = 0x000000cf,
    VK_GAMEPAD_VIEW                   = 0x000000d0,
    VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON = 0x000000d1,
}

enum : int
{
    VK_GAMEPAD_LEFT_THUMBSTICK_UP    = 0x000000d3,
    VK_GAMEPAD_LEFT_THUMBSTICK_DOWN  = 0x000000d4,
    VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT = 0x000000d5,
    VK_GAMEPAD_LEFT_THUMBSTICK_LEFT  = 0x000000d6,
}

enum : int
{
    VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN  = 0x000000d8,
    VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT = 0x000000d9,
    VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT  = 0x000000da,
}

enum : int
{
    VK_OEM_5   = 0x000000dc,
    VK_OEM_6   = 0x000000dd,
    VK_OEM_7   = 0x000000de,
    VK_OEM_8   = 0x000000df,
    VK_OEM_AX  = 0x000000e1,
    VK_OEM_102 = 0x000000e2,
}

enum int VK_ICO_00 = 0x000000e4;
enum int VK_ICO_CLEAR = 0x000000e6;

enum : int
{
    VK_OEM_RESET   = 0x000000e9,
    VK_OEM_JUMP    = 0x000000ea,
    VK_OEM_PA1     = 0x000000eb,
    VK_OEM_PA2     = 0x000000ec,
    VK_OEM_PA3     = 0x000000ed,
    VK_OEM_WSCTRL  = 0x000000ee,
    VK_OEM_CUSEL   = 0x000000ef,
    VK_OEM_ATTN    = 0x000000f0,
    VK_OEM_FINISH  = 0x000000f1,
    VK_OEM_COPY    = 0x000000f2,
    VK_OEM_AUTO    = 0x000000f3,
    VK_OEM_ENLW    = 0x000000f4,
    VK_OEM_BACKTAB = 0x000000f5,
}

enum int VK_CRSEL = 0x000000f7;
enum int VK_EREOF = 0x000000f9;

enum : int
{
    VK_ZOOM   = 0x000000fb,
    VK_NONAME = 0x000000fc,
}

enum int VK_OEM_CLEAR = 0x000000fe;
enum int WH_MSGFILTER = 0xffffffff;
enum int WH_JOURNALPLAYBACK = 0x00000001;
enum int WH_GETMESSAGE = 0x00000003;

enum : int
{
    WH_CBT          = 0x00000005,
    WH_SYSMSGFILTER = 0x00000006,
}

enum int WH_HARDWARE = 0x00000008;
enum int WH_SHELL = 0x0000000a;
enum int WH_CALLWNDPROCRET = 0x0000000c;
enum int WH_MOUSE_LL = 0x0000000e;
enum int WH_MINHOOK = 0xffffffff;
enum int HC_ACTION = 0x00000000;

enum : int
{
    HC_SKIP     = 0x00000002,
    HC_NOREMOVE = 0x00000003,
    HC_NOREM    = 0x00000003,
}

enum int HC_SYSMODALOFF = 0x00000005;

enum : int
{
    HCBT_MINMAX    = 0x00000001,
    HCBT_QS        = 0x00000002,
    HCBT_CREATEWND = 0x00000003,
}

enum int HCBT_ACTIVATE = 0x00000005;
enum int HCBT_KEYSKIPPED = 0x00000007;
enum int HCBT_SETFOCUS = 0x00000009;
enum int WTS_CONSOLE_DISCONNECT = 0x00000002;
enum int WTS_REMOTE_DISCONNECT = 0x00000004;

enum : int
{
    WTS_SESSION_LOGOFF         = 0x00000006,
    WTS_SESSION_LOCK           = 0x00000007,
    WTS_SESSION_UNLOCK         = 0x00000008,
    WTS_SESSION_REMOTE_CONTROL = 0x00000009,
    WTS_SESSION_CREATE         = 0x0000000a,
    WTS_SESSION_TERMINATE      = 0x0000000b,
}

enum : int
{
    MSGF_MESSAGEBOX = 0x00000001,
    MSGF_MENU       = 0x00000002,
    MSGF_SCROLLBAR  = 0x00000005,
}

enum : int
{
    MSGF_MAX  = 0x00000008,
    MSGF_USER = 0x00001000,
}

enum int HSHELL_WINDOWDESTROYED = 0x00000002;
enum int HSHELL_WINDOWACTIVATED = 0x00000004;

enum : int
{
    HSHELL_REDRAW             = 0x00000006,
    HSHELL_TASKMAN            = 0x00000007,
    HSHELL_LANGUAGE           = 0x00000008,
    HSHELL_SYSMENU            = 0x00000009,
    HSHELL_ENDTASK            = 0x0000000a,
    HSHELL_ACCESSIBILITYSTATE = 0x0000000b,
}

enum : int
{
    HSHELL_WINDOWREPLACED  = 0x0000000d,
    HSHELL_WINDOWREPLACING = 0x0000000e,
}

enum : int
{
    HSHELL_HIGHBIT          = 0x00008000,
    HSHELL_FLASH            = 0x00008006,
    HSHELL_RUDEAPPACTIVATED = 0x00008004,
}

enum : int
{
    APPCOMMAND_BROWSER_FORWARD        = 0x00000002,
    APPCOMMAND_BROWSER_REFRESH        = 0x00000003,
    APPCOMMAND_BROWSER_STOP           = 0x00000004,
    APPCOMMAND_BROWSER_SEARCH         = 0x00000005,
    APPCOMMAND_BROWSER_FAVORITES      = 0x00000006,
    APPCOMMAND_BROWSER_HOME           = 0x00000007,
    APPCOMMAND_VOLUME_MUTE            = 0x00000008,
    APPCOMMAND_VOLUME_DOWN            = 0x00000009,
    APPCOMMAND_VOLUME_UP              = 0x0000000a,
    APPCOMMAND_MEDIA_NEXTTRACK        = 0x0000000b,
    APPCOMMAND_MEDIA_PREVIOUSTRACK    = 0x0000000c,
    APPCOMMAND_MEDIA_STOP             = 0x0000000d,
    APPCOMMAND_MEDIA_PLAY_PAUSE       = 0x0000000e,
    APPCOMMAND_LAUNCH_MAIL            = 0x0000000f,
    APPCOMMAND_LAUNCH_MEDIA_SELECT    = 0x00000010,
    APPCOMMAND_LAUNCH_APP1            = 0x00000011,
    APPCOMMAND_LAUNCH_APP2            = 0x00000012,
    APPCOMMAND_BASS_DOWN              = 0x00000013,
    APPCOMMAND_BASS_BOOST             = 0x00000014,
    APPCOMMAND_BASS_UP                = 0x00000015,
    APPCOMMAND_TREBLE_DOWN            = 0x00000016,
    APPCOMMAND_TREBLE_UP              = 0x00000017,
    APPCOMMAND_MICROPHONE_VOLUME_MUTE = 0x00000018,
    APPCOMMAND_MICROPHONE_VOLUME_DOWN = 0x00000019,
    APPCOMMAND_MICROPHONE_VOLUME_UP   = 0x0000001a,
}

enum : int
{
    APPCOMMAND_FIND                              = 0x0000001c,
    APPCOMMAND_NEW                               = 0x0000001d,
    APPCOMMAND_OPEN                              = 0x0000001e,
    APPCOMMAND_CLOSE                             = 0x0000001f,
    APPCOMMAND_SAVE                              = 0x00000020,
    APPCOMMAND_PRINT                             = 0x00000021,
    APPCOMMAND_UNDO                              = 0x00000022,
    APPCOMMAND_REDO                              = 0x00000023,
    APPCOMMAND_COPY                              = 0x00000024,
    APPCOMMAND_CUT                               = 0x00000025,
    APPCOMMAND_PASTE                             = 0x00000026,
    APPCOMMAND_REPLY_TO_MAIL                     = 0x00000027,
    APPCOMMAND_FORWARD_MAIL                      = 0x00000028,
    APPCOMMAND_SEND_MAIL                         = 0x00000029,
    APPCOMMAND_SPELL_CHECK                       = 0x0000002a,
    APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE = 0x0000002b,
}

enum : int
{
    APPCOMMAND_CORRECTION_LIST    = 0x0000002d,
    APPCOMMAND_MEDIA_PLAY         = 0x0000002e,
    APPCOMMAND_MEDIA_PAUSE        = 0x0000002f,
    APPCOMMAND_MEDIA_RECORD       = 0x00000030,
    APPCOMMAND_MEDIA_FAST_FORWARD = 0x00000031,
    APPCOMMAND_MEDIA_REWIND       = 0x00000032,
    APPCOMMAND_MEDIA_CHANNEL_UP   = 0x00000033,
    APPCOMMAND_MEDIA_CHANNEL_DOWN = 0x00000034,
}

enum int APPCOMMAND_DWM_FLIP3D = 0x00000036;

enum : int
{
    FAPPCOMMAND_KEY  = 0x00000000,
    FAPPCOMMAND_OEM  = 0x00001000,
    FAPPCOMMAND_MASK = 0x0000f000,
}

enum : int
{
    LLKHF_INJECTED          = 0x00000010,
    LLKHF_ALTDOWN           = 0x00000020,
    LLKHF_UP                = 0x00000080,
    LLKHF_LOWER_IL_INJECTED = 0x00000002,
}

enum int LLMHF_LOWER_IL_INJECTED = 0x00000002;
enum int HKL_NEXT = 0x00000001;
enum int KLF_SUBSTITUTE_OK = 0x00000002;
enum int KLF_REPLACELANG = 0x00000010;
enum int KLF_SETFORPROCESS = 0x00000100;
enum int KLF_RESET = 0x40000000;

enum : int
{
    INPUTLANGCHANGE_FORWARD  = 0x00000002,
    INPUTLANGCHANGE_BACKWARD = 0x00000004,
}

enum int GMMP_USE_DISPLAY_POINTS = 0x00000001;

enum : int
{
    DESKTOP_READOBJECTS     = 0x00000001,
    DESKTOP_CREATEWINDOW    = 0x00000002,
    DESKTOP_CREATEMENU      = 0x00000004,
    DESKTOP_HOOKCONTROL     = 0x00000008,
    DESKTOP_JOURNALRECORD   = 0x00000010,
    DESKTOP_JOURNALPLAYBACK = 0x00000020,
}

enum int DESKTOP_WRITEOBJECTS = 0x00000080;
enum int DF_ALLOWOTHERACCOUNTHOOK = 0x00000001;
enum int WINSTA_READATTRIBUTES = 0x00000002;
enum int WINSTA_CREATEDESKTOP = 0x00000008;
enum int WINSTA_ACCESSGLOBALATOMS = 0x00000020;

enum : int
{
    WINSTA_ENUMERATE  = 0x00000100,
    WINSTA_READSCREEN = 0x00000200,
    WINSTA_ALL_ACCESS = 0x0000037f,
}

enum int WSF_VISIBLE = 0x00000001;

enum : int
{
    UOI_NAME     = 0x00000002,
    UOI_TYPE     = 0x00000003,
    UOI_USER_SID = 0x00000004,
}

enum : int
{
    UOI_IO                              = 0x00000006,
    UOI_TIMERPROC_EXCEPTION_SUPPRESSION = 0x00000007,
}

enum int GWL_HINSTANCE = 0xfffffffa;

enum : int
{
    GWL_STYLE   = 0xfffffff0,
    GWL_EXSTYLE = 0xffffffec,
}

enum : int
{
    GWL_ID          = 0xfffffff4,
    GWLP_WNDPROC    = 0xfffffffc,
    GWLP_HINSTANCE  = 0xfffffffa,
    GWLP_HWNDPARENT = 0xfffffff8,
}

enum int GWLP_ID = 0xfffffff4;
enum int GCL_HBRBACKGROUND = 0xfffffff6;

enum : int
{
    GCL_HICON   = 0xfffffff2,
    GCL_HMODULE = 0xfffffff0,
}

enum int GCL_CBCLSEXTRA = 0xffffffec;
enum int GCL_STYLE = 0xffffffe6;
enum int GCL_HICONSM = 0xffffffde;
enum int GCLP_HBRBACKGROUND = 0xfffffff6;

enum : int
{
    GCLP_HICON   = 0xfffffff2,
    GCLP_HMODULE = 0xfffffff0,
    GCLP_WNDPROC = 0xffffffe8,
    GCLP_HICONSM = 0xffffffde,
}

enum int WM_CREATE = 0x00000001;

enum : int
{
    WM_MOVE     = 0x00000003,
    WM_SIZE     = 0x00000005,
    WM_ACTIVATE = 0x00000006,
}

enum int WA_ACTIVE = 0x00000001;
enum int WM_SETFOCUS = 0x00000007;
enum int WM_ENABLE = 0x0000000a;
enum int WM_SETTEXT = 0x0000000c;
enum int WM_GETTEXTLENGTH = 0x0000000e;
enum int WM_CLOSE = 0x00000010;
enum int WM_QUERYOPEN = 0x00000013;

enum : int
{
    WM_QUIT       = 0x00000012,
    WM_ERASEBKGND = 0x00000014,
}

enum int WM_SHOWWINDOW = 0x00000018;
enum int WM_SETTINGCHANGE = 0x0000001a;
enum int WM_ACTIVATEAPP = 0x0000001c;
enum int WM_TIMECHANGE = 0x0000001e;
enum int WM_SETCURSOR = 0x00000020;
enum int WM_CHILDACTIVATE = 0x00000022;
enum int WM_GETMINMAXINFO = 0x00000024;
enum int WM_ICONERASEBKGND = 0x00000027;
enum int WM_SPOOLERSTATUS = 0x0000002a;
enum int WM_MEASUREITEM = 0x0000002c;
enum int WM_VKEYTOITEM = 0x0000002e;
enum int WM_SETFONT = 0x00000030;
enum int WM_SETHOTKEY = 0x00000032;
enum int WM_QUERYDRAGICON = 0x00000037;
enum int WM_GETOBJECT = 0x0000003d;
enum int WM_COMMNOTIFY = 0x00000044;
enum int WM_WINDOWPOSCHANGED = 0x00000047;

enum : int
{
    PWR_OK             = 0x00000001,
    PWR_FAIL           = 0xffffffff,
    PWR_SUSPENDREQUEST = 0x00000001,
    PWR_SUSPENDRESUME  = 0x00000002,
}

enum int WM_COPYDATA = 0x0000004a;
enum int WM_NOTIFY = 0x0000004e;
enum int WM_INPUTLANGCHANGE = 0x00000051;

enum : int
{
    WM_HELP        = 0x00000053,
    WM_USERCHANGED = 0x00000054,
}

enum : int
{
    NFR_ANSI    = 0x00000001,
    NFR_UNICODE = 0x00000002,
}

enum int NF_REQUERY = 0x00000004;

enum : int
{
    WM_STYLECHANGING = 0x0000007c,
    WM_STYLECHANGED  = 0x0000007d,
}

enum int WM_GETICON = 0x0000007f;

enum : int
{
    WM_NCCREATE   = 0x00000081,
    WM_NCDESTROY  = 0x00000082,
    WM_NCCALCSIZE = 0x00000083,
}

enum : int
{
    WM_NCPAINT    = 0x00000085,
    WM_NCACTIVATE = 0x00000086,
}

enum int WM_SYNCPAINT = 0x00000088;

enum : int
{
    WM_NCLBUTTONDOWN   = 0x000000a1,
    WM_NCLBUTTONUP     = 0x000000a2,
    WM_NCLBUTTONDBLCLK = 0x000000a3,
}

enum : int
{
    WM_NCRBUTTONUP     = 0x000000a5,
    WM_NCRBUTTONDBLCLK = 0x000000a6,
}

enum : int
{
    WM_NCMBUTTONUP     = 0x000000a8,
    WM_NCMBUTTONDBLCLK = 0x000000a9,
}

enum : int
{
    WM_NCXBUTTONUP     = 0x000000ac,
    WM_NCXBUTTONDBLCLK = 0x000000ad,
}

enum int WM_INPUT = 0x000000ff;

enum : int
{
    WM_KEYDOWN = 0x00000100,
    WM_KEYUP   = 0x00000101,
}

enum int WM_DEADCHAR = 0x00000103;

enum : int
{
    WM_SYSKEYUP    = 0x00000105,
    WM_SYSCHAR     = 0x00000106,
    WM_SYSDEADCHAR = 0x00000107,
}

enum int WM_KEYLAST = 0x00000109;
enum int WM_IME_STARTCOMPOSITION = 0x0000010d;
enum int WM_IME_COMPOSITION = 0x0000010f;
enum int WM_INITDIALOG = 0x00000110;
enum int WM_SYSCOMMAND = 0x00000112;
enum int WM_HSCROLL = 0x00000114;

enum : int
{
    WM_INITMENU      = 0x00000116,
    WM_INITMENUPOPUP = 0x00000117,
}

enum int WM_GESTURENOTIFY = 0x0000011a;
enum int WM_MENUCHAR = 0x00000120;

enum : int
{
    WM_MENURBUTTONUP = 0x00000122,
    WM_MENUDRAG      = 0x00000123,
    WM_MENUGETOBJECT = 0x00000124,
}

enum int WM_MENUCOMMAND = 0x00000126;
enum int WM_UPDATEUISTATE = 0x00000128;

enum : int
{
    UIS_SET        = 0x00000001,
    UIS_CLEAR      = 0x00000002,
    UIS_INITIALIZE = 0x00000003,
}

enum int UISF_HIDEACCEL = 0x00000002;

enum : int
{
    WM_CTLCOLORMSGBOX    = 0x00000132,
    WM_CTLCOLOREDIT      = 0x00000133,
    WM_CTLCOLORLISTBOX   = 0x00000134,
    WM_CTLCOLORBTN       = 0x00000135,
    WM_CTLCOLORDLG       = 0x00000136,
    WM_CTLCOLORSCROLLBAR = 0x00000137,
    WM_CTLCOLORSTATIC    = 0x00000138,
}

enum : int
{
    WM_MOUSEFIRST = 0x00000200,
    WM_MOUSEMOVE  = 0x00000200,
}

enum : int
{
    WM_LBUTTONUP     = 0x00000202,
    WM_LBUTTONDBLCLK = 0x00000203,
}

enum : int
{
    WM_RBUTTONUP     = 0x00000205,
    WM_RBUTTONDBLCLK = 0x00000206,
}

enum : int
{
    WM_MBUTTONUP     = 0x00000208,
    WM_MBUTTONDBLCLK = 0x00000209,
}

enum : int
{
    WM_XBUTTONDOWN   = 0x0000020b,
    WM_XBUTTONUP     = 0x0000020c,
    WM_XBUTTONDBLCLK = 0x0000020d,
}

enum int WM_MOUSELAST = 0x0000020e;
enum uint WHEEL_PAGESCROLL = 0xffffffff;
enum int XBUTTON2 = 0x00000002;
enum int WM_ENTERMENULOOP = 0x00000211;
enum int WM_NEXTMENU = 0x00000213;
enum int WM_CAPTURECHANGED = 0x00000215;
enum int WM_POWERBROADCAST = 0x00000218;

enum : int
{
    PBT_APMQUERYSTANDBY       = 0x00000001,
    PBT_APMQUERYSUSPENDFAILED = 0x00000002,
    PBT_APMQUERYSTANDBYFAILED = 0x00000003,
}

enum : int
{
    PBT_APMSTANDBY        = 0x00000005,
    PBT_APMRESUMECRITICAL = 0x00000006,
    PBT_APMRESUMESUSPEND  = 0x00000007,
    PBT_APMRESUMESTANDBY  = 0x00000008,
}

enum : int
{
    PBT_APMBATTERYLOW        = 0x00000009,
    PBT_APMPOWERSTATUSCHANGE = 0x0000000a,
}

enum int PBT_APMRESUMEAUTOMATIC = 0x00000012;
enum int WM_DEVICECHANGE = 0x00000219;

enum : int
{
    WM_MDIDESTROY     = 0x00000221,
    WM_MDIACTIVATE    = 0x00000222,
    WM_MDIRESTORE     = 0x00000223,
    WM_MDINEXT        = 0x00000224,
    WM_MDIMAXIMIZE    = 0x00000225,
    WM_MDITILE        = 0x00000226,
    WM_MDICASCADE     = 0x00000227,
    WM_MDIICONARRANGE = 0x00000228,
}

enum int WM_MDISETMENU = 0x00000230;
enum int WM_EXITSIZEMOVE = 0x00000232;
enum int WM_MDIREFRESHMENU = 0x00000234;

enum : int
{
    WM_POINTERDEVICEINRANGE    = 0x00000239,
    WM_POINTERDEVICEOUTOFRANGE = 0x0000023a,
}

enum : int
{
    WM_NCPOINTERUPDATE = 0x00000241,
    WM_NCPOINTERDOWN   = 0x00000242,
    WM_NCPOINTERUP     = 0x00000243,
}

enum : int
{
    WM_POINTERDOWN           = 0x00000246,
    WM_POINTERUP             = 0x00000247,
    WM_POINTERENTER          = 0x00000249,
    WM_POINTERLEAVE          = 0x0000024a,
    WM_POINTERACTIVATE       = 0x0000024b,
    WM_POINTERCAPTURECHANGED = 0x0000024c,
}

enum : int
{
    WM_POINTERWHEEL  = 0x0000024e,
    WM_POINTERHWHEEL = 0x0000024f,
}

enum : int
{
    WM_POINTERROUTEDTO       = 0x00000251,
    WM_POINTERROUTEDAWAY     = 0x00000252,
    WM_POINTERROUTEDRELEASED = 0x00000253,
}

enum : int
{
    WM_IME_NOTIFY          = 0x00000282,
    WM_IME_CONTROL         = 0x00000283,
    WM_IME_COMPOSITIONFULL = 0x00000284,
}

enum : int
{
    WM_IME_CHAR    = 0x00000286,
    WM_IME_REQUEST = 0x00000288,
    WM_IME_KEYDOWN = 0x00000290,
    WM_IME_KEYUP   = 0x00000291,
}

enum int WM_MOUSELEAVE = 0x000002a3;
enum int WM_NCMOUSELEAVE = 0x000002a2;

enum : int
{
    WM_TABLET_FIRST = 0x000002c0,
    WM_TABLET_LAST  = 0x000002df,
}

enum : int
{
    WM_DPICHANGED_BEFOREPARENT = 0x000002e2,
    WM_DPICHANGED_AFTERPARENT  = 0x000002e3,
}

enum : int
{
    WM_CUT   = 0x00000300,
    WM_COPY  = 0x00000301,
    WM_PASTE = 0x00000302,
}

enum : int
{
    WM_UNDO             = 0x00000304,
    WM_RENDERFORMAT     = 0x00000305,
    WM_RENDERALLFORMATS = 0x00000306,
}

enum int WM_DRAWCLIPBOARD = 0x00000308;
enum int WM_VSCROLLCLIPBOARD = 0x0000030a;
enum int WM_ASKCBFORMATNAME = 0x0000030c;
enum int WM_HSCROLLCLIPBOARD = 0x0000030e;

enum : int
{
    WM_PALETTEISCHANGING = 0x00000310,
    WM_PALETTECHANGED    = 0x00000311,
}

enum : int
{
    WM_PRINT       = 0x00000317,
    WM_PRINTCLIENT = 0x00000318,
}

enum int WM_THEMECHANGED = 0x0000031a;
enum int WM_DWMCOMPOSITIONCHANGED = 0x0000031e;
enum int WM_DWMCOLORIZATIONCOLORCHANGED = 0x00000320;

enum : int
{
    WM_DWMSENDICONICTHUMBNAIL         = 0x00000323,
    WM_DWMSENDICONICLIVEPREVIEWBITMAP = 0x00000326,
}

enum : int
{
    WM_HANDHELDFIRST = 0x00000358,
    WM_HANDHELDLAST  = 0x0000035f,
}

enum int WM_AFXLAST = 0x0000037f;
enum int WM_PENWINLAST = 0x0000038f;
enum int WM_USER = 0x00000400;

enum : int
{
    WMSZ_RIGHT    = 0x00000002,
    WMSZ_TOP      = 0x00000003,
    WMSZ_TOPLEFT  = 0x00000004,
    WMSZ_TOPRIGHT = 0x00000005,
}

enum : int
{
    WMSZ_BOTTOMLEFT  = 0x00000007,
    WMSZ_BOTTOMRIGHT = 0x00000008,
}

enum int HTTRANSPARENT = 0xffffffff;
enum int HTCLIENT = 0x00000001;
enum int HTSYSMENU = 0x00000003;
enum int HTSIZE = 0x00000004;
enum int HTHSCROLL = 0x00000006;
enum int HTMINBUTTON = 0x00000008;
enum int HTLEFT = 0x0000000a;

enum : int
{
    HTTOP      = 0x0000000c,
    HTTOPLEFT  = 0x0000000d,
    HTTOPRIGHT = 0x0000000e,
}

enum : int
{
    HTBOTTOMLEFT  = 0x00000010,
    HTBOTTOMRIGHT = 0x00000011,
}

enum int HTREDUCE = 0x00000008;

enum : int
{
    HTSIZEFIRST = 0x0000000a,
    HTSIZELAST  = 0x00000011,
}

enum int HTCLOSE = 0x00000014;

enum : int
{
    SMTO_NORMAL      = 0x00000000,
    SMTO_BLOCK       = 0x00000001,
    SMTO_ABORTIFHUNG = 0x00000002,
}

enum int SMTO_ERRORONEXIT = 0x00000020;
enum int MA_ACTIVATEANDEAT = 0x00000002;
enum int MA_NOACTIVATEANDEAT = 0x00000004;

enum : int
{
    ICON_BIG    = 0x00000001,
    ICON_SMALL2 = 0x00000002,
}

enum : int
{
    SIZE_MINIMIZED = 0x00000001,
    SIZE_MAXIMIZED = 0x00000002,
    SIZE_MAXSHOW   = 0x00000003,
    SIZE_MAXHIDE   = 0x00000004,
}

enum int SIZEICONIC = 0x00000001;

enum : int
{
    SIZEZOOMSHOW = 0x00000003,
    SIZEZOOMHIDE = 0x00000004,
}

enum : int
{
    WVR_ALIGNLEFT   = 0x00000020,
    WVR_ALIGNBOTTOM = 0x00000040,
    WVR_ALIGNRIGHT  = 0x00000080,
}

enum int WVR_VREDRAW = 0x00000200;
enum int WVR_VALIDRECTS = 0x00000400;
enum int MK_RBUTTON = 0x00000002;
enum int MK_CONTROL = 0x00000008;

enum : int
{
    MK_XBUTTON1 = 0x00000020,
    MK_XBUTTON2 = 0x00000040,
}

enum : uint
{
    TME_LEAVE     = 0x00000002,
    TME_NONCLIENT = 0x00000010,
}

enum uint TME_CANCEL = 0x80000000;
enum uint WS_OVERLAPPED = 0x00000000;
enum uint WS_CHILD = 0x40000000;
enum uint WS_VISIBLE = 0x10000000;

enum : uint
{
    WS_CLIPSIBLINGS = 0x04000000,
    WS_CLIPCHILDREN = 0x02000000,
}

enum uint WS_CAPTION = 0x00c00000;
enum uint WS_DLGFRAME = 0x00400000;
enum uint WS_HSCROLL = 0x00100000;
enum uint WS_THICKFRAME = 0x00040000;
enum uint WS_TABSTOP = 0x00010000;
enum uint WS_MAXIMIZEBOX = 0x00010000;
enum uint WS_ICONIC = 0x20000000;
enum uint WS_TILEDWINDOW = 0x00cf0000;
enum uint WS_POPUPWINDOW = 0x80880000;
enum int WS_EX_DLGMODALFRAME = 0x00000001;

enum : int
{
    WS_EX_TOPMOST     = 0x00000008,
    WS_EX_ACCEPTFILES = 0x00000010,
}

enum : int
{
    WS_EX_MDICHILD   = 0x00000040,
    WS_EX_TOOLWINDOW = 0x00000080,
}

enum : int
{
    WS_EX_CLIENTEDGE  = 0x00000200,
    WS_EX_CONTEXTHELP = 0x00000400,
}

enum : int
{
    WS_EX_LEFT       = 0x00000000,
    WS_EX_RTLREADING = 0x00002000,
}

enum int WS_EX_LEFTSCROLLBAR = 0x00004000;
enum int WS_EX_CONTROLPARENT = 0x00010000;
enum int WS_EX_APPWINDOW = 0x00040000;
enum int WS_EX_PALETTEWINDOW = 0x00000188;
enum int WS_EX_NOREDIRECTIONBITMAP = 0x00200000;
enum int WS_EX_COMPOSITED = 0x02000000;
enum int CS_VREDRAW = 0x00000001;
enum int CS_DBLCLKS = 0x00000008;
enum int CS_CLASSDC = 0x00000040;
enum int CS_NOCLOSE = 0x00000200;

enum : int
{
    CS_BYTEALIGNCLIENT = 0x00001000,
    CS_BYTEALIGNWINDOW = 0x00002000,
}

enum : int
{
    CS_IME        = 0x00010000,
    CS_DROPSHADOW = 0x00020000,
}

enum int PRF_NONCLIENT = 0x00000002;
enum int PRF_ERASEBKGND = 0x00000008;
enum int PRF_OWNED = 0x00000020;
enum int BDR_SUNKENOUTER = 0x00000002;
enum int BDR_SUNKENINNER = 0x00000008;

enum : int
{
    BDR_INNER  = 0x0000000c,
    BDR_RAISED = 0x00000005,
}

enum : int
{
    EDGE_RAISED = 0x00000005,
    EDGE_SUNKEN = 0x0000000a,
    EDGE_ETCHED = 0x00000006,
    EDGE_BUMP   = 0x00000009,
}

enum : int
{
    BF_TOP   = 0x00000002,
    BF_RIGHT = 0x00000004,
}

enum : int
{
    BF_TOPLEFT  = 0x00000003,
    BF_TOPRIGHT = 0x00000006,
}

enum int BF_BOTTOMRIGHT = 0x0000000c;

enum : int
{
    BF_DIAGONAL                = 0x00000010,
    BF_DIAGONAL_ENDTOPRIGHT    = 0x00000016,
    BF_DIAGONAL_ENDTOPLEFT     = 0x00000013,
    BF_DIAGONAL_ENDBOTTOMLEFT  = 0x00000019,
    BF_DIAGONAL_ENDBOTTOMRIGHT = 0x0000001c,
}

enum : int
{
    BF_SOFT   = 0x00001000,
    BF_ADJUST = 0x00002000,
}

enum int BF_MONO = 0x00008000;

enum : int
{
    DFC_MENU   = 0x00000002,
    DFC_SCROLL = 0x00000003,
}

enum int DFC_POPUPMENU = 0x00000005;

enum : int
{
    DFCS_CAPTIONMIN     = 0x00000001,
    DFCS_CAPTIONMAX     = 0x00000002,
    DFCS_CAPTIONRESTORE = 0x00000003,
    DFCS_CAPTIONHELP    = 0x00000004,
}

enum : int
{
    DFCS_MENUCHECK      = 0x00000001,
    DFCS_MENUBULLET     = 0x00000002,
    DFCS_MENUARROWRIGHT = 0x00000004,
}

enum : int
{
    DFCS_SCROLLDOWN          = 0x00000001,
    DFCS_SCROLLLEFT          = 0x00000002,
    DFCS_SCROLLRIGHT         = 0x00000003,
    DFCS_SCROLLCOMBOBOX      = 0x00000005,
    DFCS_SCROLLSIZEGRIP      = 0x00000008,
    DFCS_SCROLLSIZEGRIPRIGHT = 0x00000010,
}

enum : int
{
    DFCS_BUTTONRADIOIMAGE = 0x00000001,
    DFCS_BUTTONRADIOMASK  = 0x00000002,
    DFCS_BUTTONRADIO      = 0x00000004,
    DFCS_BUTTON3STATE     = 0x00000008,
    DFCS_BUTTONPUSH       = 0x00000010,
}

enum : int
{
    DFCS_PUSHED      = 0x00000200,
    DFCS_CHECKED     = 0x00000400,
    DFCS_TRANSPARENT = 0x00000800,
}

enum int DFCS_ADJUSTRECT = 0x00002000;
enum int DFCS_MONO = 0x00008000;
enum int DC_SMALLCAP = 0x00000002;

enum : int
{
    DC_TEXT     = 0x00000008,
    DC_INBUTTON = 0x00000010,
}

enum int DC_BUTTONS = 0x00001000;
enum int IDANI_CAPTION = 0x00000003;
enum int CF_BITMAP = 0x00000002;

enum : int
{
    CF_SYLK    = 0x00000004,
    CF_DIF     = 0x00000005,
    CF_TIFF    = 0x00000006,
    CF_OEMTEXT = 0x00000007,
}

enum int CF_PALETTE = 0x00000009;

enum : int
{
    CF_RIFF        = 0x0000000b,
    CF_WAVE        = 0x0000000c,
    CF_UNICODETEXT = 0x0000000d,
}

enum int CF_HDROP = 0x0000000f;
enum int CF_DIBV5 = 0x00000011;
enum int CF_OWNERDISPLAY = 0x00000080;

enum : int
{
    CF_DSPBITMAP       = 0x00000082,
    CF_DSPMETAFILEPICT = 0x00000083,
}

enum : int
{
    CF_PRIVATEFIRST = 0x00000200,
    CF_PRIVATELAST  = 0x000002ff,
}

enum int CF_GDIOBJLAST = 0x000003ff;
enum int FNOINVERT = 0x00000002;
enum int FCONTROL = 0x00000008;
enum int WPF_SETMINPOSITION = 0x00000001;
enum int WPF_ASYNCWINDOWPLACEMENT = 0x00000004;
enum int ODT_LISTBOX = 0x00000002;
enum int ODT_BUTTON = 0x00000004;
enum int ODA_DRAWENTIRE = 0x00000001;
enum int ODA_FOCUS = 0x00000004;
enum int ODS_GRAYED = 0x00000002;
enum int ODS_CHECKED = 0x00000008;
enum int ODS_DEFAULT = 0x00000020;
enum int ODS_HOTLIGHT = 0x00000040;

enum : int
{
    ODS_NOACCEL     = 0x00000100,
    ODS_NOFOCUSRECT = 0x00000200,
}

enum int PM_REMOVE = 0x00000001;

enum : int
{
    PM_QS_INPUT       = 0x1c070000,
    PM_QS_POSTMESSAGE = 0x00980000,
    PM_QS_PAINT       = 0x00200000,
    PM_QS_SENDMESSAGE = 0x00400000,
}

enum int MOD_CONTROL = 0x00000002;

enum : int
{
    MOD_WIN      = 0x00000008,
    MOD_NOREPEAT = 0x00004000,
}

enum int IDHOT_SNAPDESKTOP = 0xfffffffe;

enum : uint
{
    ENDSESSION_CRITICAL = 0x40000000,
    ENDSESSION_LOGOFF   = 0x80000000,
}

enum int EWX_SHUTDOWN = 0x00000001;

enum : int
{
    EWX_FORCE    = 0x00000004,
    EWX_POWEROFF = 0x00000008,
}

enum int EWX_QUICKRESOLVE = 0x00000020;
enum int EWX_HYBRID_SHUTDOWN = 0x00400000;
enum int EWX_ARSO = 0x04000000;

enum : int
{
    BSM_VXDS      = 0x00000001,
    BSM_NETDRIVER = 0x00000002,
}

enum int BSM_APPLICATIONS = 0x00000008;

enum : int
{
    BSF_QUERY             = 0x00000001,
    BSF_IGNORECURRENTTASK = 0x00000002,
}

enum int BSF_NOHANG = 0x00000008;
enum int BSF_FORCEIFHUNG = 0x00000020;
enum int BSF_ALLOWSFW = 0x00000080;
enum int BSF_RETURNHDESK = 0x00000200;
enum int BROADCAST_QUERY_DENY = 0x424d5144;

enum : int
{
    DEVICE_NOTIFY_SERVICE_HANDLE        = 0x00000001,
    DEVICE_NOTIFY_ALL_INTERFACE_CLASSES = 0x00000004,
}

enum HWND HWND_MESSAGE = HWND(0xfffffffd);

enum : int
{
    ISMEX_SEND     = 0x00000001,
    ISMEX_NOTIFY   = 0x00000002,
    ISMEX_CALLBACK = 0x00000004,
    ISMEX_REPLIED  = 0x00000008,
}

enum HWND HWND_DESKTOP = HWND(0x00000000);
enum int PW_RENDERFULLCONTENT = 0x00000002;
enum int LWA_ALPHA = 0x00000002;

enum : int
{
    ULW_ALPHA  = 0x00000002,
    ULW_OPAQUE = 0x00000004,
}

enum : int
{
    FLASHW_STOP      = 0x00000000,
    FLASHW_CAPTION   = 0x00000001,
    FLASHW_TRAY      = 0x00000002,
    FLASHW_ALL       = 0x00000003,
    FLASHW_TIMER     = 0x00000004,
    FLASHW_TIMERNOFG = 0x0000000c,
}

enum int WDA_MONITOR = 0x00000001;

enum : int
{
    SWP_NOSIZE     = 0x00000001,
    SWP_NOMOVE     = 0x00000002,
    SWP_NOZORDER   = 0x00000004,
    SWP_NOREDRAW   = 0x00000008,
    SWP_NOACTIVATE = 0x00000010,
}

enum int SWP_SHOWWINDOW = 0x00000040;

enum : int
{
    SWP_NOCOPYBITS    = 0x00000100,
    SWP_NOOWNERZORDER = 0x00000200,
}

enum int SWP_DRAWFRAME = 0x00000020;
enum int SWP_DEFERERASE = 0x00002000;

enum : HWND
{
    HWND_TOP       = HWND(0x00000000),
    HWND_BOTTOM    = HWND(0x00000001),
    HWND_TOPMOST   = HWND(0xffffffff),
    HWND_NOTOPMOST = HWND(0xfffffffe),
}

enum : int
{
    KEYEVENTF_EXTENDEDKEY = 0x00000001,
    KEYEVENTF_KEYUP       = 0x00000002,
    KEYEVENTF_UNICODE     = 0x00000004,
    KEYEVENTF_SCANCODE    = 0x00000008,
}

enum : int
{
    MOUSEEVENTF_LEFTDOWN        = 0x00000002,
    MOUSEEVENTF_LEFTUP          = 0x00000004,
    MOUSEEVENTF_RIGHTDOWN       = 0x00000008,
    MOUSEEVENTF_RIGHTUP         = 0x00000010,
    MOUSEEVENTF_MIDDLEDOWN      = 0x00000020,
    MOUSEEVENTF_MIDDLEUP        = 0x00000040,
    MOUSEEVENTF_XDOWN           = 0x00000080,
    MOUSEEVENTF_XUP             = 0x00000100,
    MOUSEEVENTF_WHEEL           = 0x00000800,
    MOUSEEVENTF_HWHEEL          = 0x00001000,
    MOUSEEVENTF_MOVE_NOCOALESCE = 0x00002000,
    MOUSEEVENTF_VIRTUALDESK     = 0x00004000,
    MOUSEEVENTF_ABSOLUTE        = 0x00008000,
}

enum : int
{
    INPUT_KEYBOARD = 0x00000001,
    INPUT_HARDWARE = 0x00000002,
}

enum : int
{
    TOUCHEVENTF_DOWN       = 0x00000002,
    TOUCHEVENTF_UP         = 0x00000004,
    TOUCHEVENTF_INRANGE    = 0x00000008,
    TOUCHEVENTF_PRIMARY    = 0x00000010,
    TOUCHEVENTF_NOCOALESCE = 0x00000020,
    TOUCHEVENTF_PEN        = 0x00000040,
    TOUCHEVENTF_PALM       = 0x00000080,
}

enum : int
{
    TOUCHINPUTMASKF_EXTRAINFO   = 0x00000002,
    TOUCHINPUTMASKF_CONTACTAREA = 0x00000004,
}

enum int TWF_WANTPALM = 0x00000002;

enum : int
{
    POINTER_FLAG_NEW            = 0x00000001,
    POINTER_FLAG_INRANGE        = 0x00000002,
    POINTER_FLAG_INCONTACT      = 0x00000004,
    POINTER_FLAG_FIRSTBUTTON    = 0x00000010,
    POINTER_FLAG_SECONDBUTTON   = 0x00000020,
    POINTER_FLAG_THIRDBUTTON    = 0x00000040,
    POINTER_FLAG_FOURTHBUTTON   = 0x00000080,
    POINTER_FLAG_FIFTHBUTTON    = 0x00000100,
    POINTER_FLAG_PRIMARY        = 0x00002000,
    POINTER_FLAG_CONFIDENCE     = 0x00004000,
    POINTER_FLAG_CANCELED       = 0x00008000,
    POINTER_FLAG_DOWN           = 0x00010000,
    POINTER_FLAG_UPDATE         = 0x00020000,
    POINTER_FLAG_UP             = 0x00040000,
    POINTER_FLAG_WHEEL          = 0x00080000,
    POINTER_FLAG_HWHEEL         = 0x00100000,
    POINTER_FLAG_CAPTURECHANGED = 0x00200000,
    POINTER_FLAG_HASTRANSFORM   = 0x00400000,
}

enum int POINTER_MOD_CTRL = 0x00000008;

enum : int
{
    TOUCH_MASK_NONE        = 0x00000000,
    TOUCH_MASK_CONTACTAREA = 0x00000001,
    TOUCH_MASK_ORIENTATION = 0x00000002,
    TOUCH_MASK_PRESSURE    = 0x00000004,
}

enum : int
{
    PEN_FLAG_BARREL   = 0x00000001,
    PEN_FLAG_INVERTED = 0x00000002,
    PEN_FLAG_ERASER   = 0x00000004,
}

enum : int
{
    PEN_MASK_PRESSURE = 0x00000001,
    PEN_MASK_ROTATION = 0x00000002,
    PEN_MASK_TILT_X   = 0x00000004,
    PEN_MASK_TILT_Y   = 0x00000008,
}

enum : int
{
    POINTER_MESSAGE_FLAG_INRANGE      = 0x00000002,
    POINTER_MESSAGE_FLAG_INCONTACT    = 0x00000004,
    POINTER_MESSAGE_FLAG_FIRSTBUTTON  = 0x00000010,
    POINTER_MESSAGE_FLAG_SECONDBUTTON = 0x00000020,
    POINTER_MESSAGE_FLAG_THIRDBUTTON  = 0x00000040,
    POINTER_MESSAGE_FLAG_FOURTHBUTTON = 0x00000080,
    POINTER_MESSAGE_FLAG_FIFTHBUTTON  = 0x00000100,
    POINTER_MESSAGE_FLAG_PRIMARY      = 0x00002000,
    POINTER_MESSAGE_FLAG_CONFIDENCE   = 0x00004000,
    POINTER_MESSAGE_FLAG_CANCELED     = 0x00008000,
}

enum int PA_NOACTIVATE = 0x00000003;

enum : int
{
    TOUCH_FEEDBACK_DEFAULT  = 0x00000001,
    TOUCH_FEEDBACK_INDIRECT = 0x00000002,
    TOUCH_FEEDBACK_NONE     = 0x00000003,
}

enum : int
{
    TOUCH_HIT_TESTING_CLIENT             = 0x00000001,
    TOUCH_HIT_TESTING_NONE               = 0x00000002,
    TOUCH_HIT_TESTING_PROXIMITY_CLOSEST  = 0x00000000,
    TOUCH_HIT_TESTING_PROXIMITY_FARTHEST = 0x00000fff,
}

enum : int
{
    MAPVK_VK_TO_VSC    = 0x00000000,
    MAPVK_VSC_TO_VK    = 0x00000001,
    MAPVK_VK_TO_CHAR   = 0x00000002,
    MAPVK_VSC_TO_VK_EX = 0x00000003,
}

enum : int
{
    MWMO_WAITALL   = 0x00000001,
    MWMO_ALERTABLE = 0x00000002,
}

enum : int
{
    QS_KEY         = 0x00000001,
    QS_MOUSEMOVE   = 0x00000002,
    QS_MOUSEBUTTON = 0x00000004,
}

enum int QS_TIMER = 0x00000010;
enum int QS_SENDMESSAGE = 0x00000040;
enum int QS_ALLPOSTMESSAGE = 0x00000100;
enum int QS_TOUCH = 0x00000800;
enum int QS_MOUSE = 0x00000006;

enum : int
{
    QS_ALLEVENTS = 0x00001cbf,
    QS_ALLINPUT  = 0x00001cff,
}

enum int USER_TIMER_MINIMUM = 0x0000000a;
enum uint TIMERV_NO_COALESCING = 0xffffffff;
enum uint TIMERV_COALESCING_MAX = 0x7ffffff5;
enum int SM_CYSCREEN = 0x00000001;

enum : int
{
    SM_CYHSCROLL = 0x00000003,
    SM_CYCAPTION = 0x00000004,
}

enum int SM_CYBORDER = 0x00000006;
enum int SM_CYDLGFRAME = 0x00000008;

enum : int
{
    SM_CXHTHUMB = 0x0000000a,
    SM_CXICON   = 0x0000000b,
    SM_CYICON   = 0x0000000c,
    SM_CXCURSOR = 0x0000000d,
}

enum : int
{
    SM_CYMENU       = 0x0000000f,
    SM_CXFULLSCREEN = 0x00000010,
}

enum int SM_CYKANJIWINDOW = 0x00000012;
enum int SM_CYVSCROLL = 0x00000014;
enum int SM_DEBUG = 0x00000016;

enum : int
{
    SM_RESERVED1 = 0x00000018,
    SM_RESERVED2 = 0x00000019,
    SM_RESERVED3 = 0x0000001a,
    SM_RESERVED4 = 0x0000001b,
}

enum : int
{
    SM_CYMIN   = 0x0000001d,
    SM_CXSIZE  = 0x0000001e,
    SM_CYSIZE  = 0x0000001f,
    SM_CXFRAME = 0x00000020,
}

enum int SM_CXMINTRACK = 0x00000022;
enum int SM_CXDOUBLECLK = 0x00000024;
enum int SM_CXICONSPACING = 0x00000026;
enum int SM_MENUDROPALIGNMENT = 0x00000028;
enum int SM_DBCSENABLED = 0x0000002a;
enum int SM_CXFIXEDFRAME = 0x00000007;
enum int SM_CXSIZEFRAME = 0x00000020;
enum int SM_SECURE = 0x0000002c;

enum : int
{
    SM_CYEDGE       = 0x0000002e,
    SM_CXMINSPACING = 0x0000002f,
}

enum int SM_CXSMICON = 0x00000031;
enum int SM_CYSMCAPTION = 0x00000033;
enum int SM_CYSMSIZE = 0x00000035;
enum int SM_CYMENUSIZE = 0x00000037;
enum int SM_CXMINIMIZED = 0x00000039;
enum int SM_CXMAXTRACK = 0x0000003b;
enum int SM_CXMAXIMIZED = 0x0000003d;
enum int SM_NETWORK = 0x0000003f;

enum : int
{
    SM_CXDRAG = 0x00000044,
    SM_CYDRAG = 0x00000045,
}

enum int SM_CXMENUCHECK = 0x00000047;
enum int SM_SLOWMACHINE = 0x00000049;
enum int SM_MOUSEWHEELPRESENT = 0x0000004b;
enum int SM_YVIRTUALSCREEN = 0x0000004d;
enum int SM_CYVIRTUALSCREEN = 0x0000004f;
enum int SM_SAMEDISPLAYFORMAT = 0x00000051;
enum int SM_CXFOCUSBORDER = 0x00000053;
enum int SM_TABLETPC = 0x00000056;
enum int SM_STARTER = 0x00000058;
enum int SM_MOUSEHORIZONTALWHEELPRESENT = 0x0000005b;
enum int SM_DIGITIZER = 0x0000005e;
enum int SM_CMETRICS = 0x00000061;
enum int SM_SHUTTINGDOWN = 0x00002000;
enum int SM_CARETBLINKINGENABLED = 0x00002002;
enum int SM_SYSTEMDOCKED = 0x00002004;
enum int MNC_IGNORE = 0x00000000;
enum int MNC_EXECUTE = 0x00000002;
enum uint MNS_NOCHECK = 0x80000000;
enum uint MNS_DRAGDROP = 0x20000000;
enum uint MNS_NOTIFYBYPOS = 0x08000000;
enum uint MIM_MAXHEIGHT = 0x00000001;
enum uint MIM_HELPID = 0x00000004;

enum : uint
{
    MIM_STYLE           = 0x00000010,
    MIM_APPLYTOSUBMENUS = 0x80000000,
}

enum int MND_ENDMENU = 0x00000001;
enum int MNGOF_BOTTOMGAP = 0x00000002;
enum int MNGO_NOERROR = 0x00000001;

enum : int
{
    MIIM_ID         = 0x00000002,
    MIIM_SUBMENU    = 0x00000004,
    MIIM_CHECKMARKS = 0x00000008,
}

enum : int
{
    MIIM_DATA   = 0x00000020,
    MIIM_STRING = 0x00000040,
    MIIM_BITMAP = 0x00000080,
    MIIM_FTYPE  = 0x00000100,
}

enum : HBITMAP
{
    HBMMENU_SYSTEM          = HBITMAP(0x00000001),
    HBMMENU_MBAR_RESTORE    = HBITMAP(0x00000002),
    HBMMENU_MBAR_MINIMIZE   = HBITMAP(0x00000003),
    HBMMENU_MBAR_CLOSE      = HBITMAP(0x00000005),
    HBMMENU_MBAR_CLOSE_D    = HBITMAP(0x00000006),
    HBMMENU_MBAR_MINIMIZE_D = HBITMAP(0x00000007),
}

enum : HBITMAP
{
    HBMMENU_POPUP_RESTORE  = HBITMAP(0x00000009),
    HBMMENU_POPUP_MAXIMIZE = HBITMAP(0x0000000a),
    HBMMENU_POPUP_MINIMIZE = HBITMAP(0x0000000b),
}

enum int TPM_RIGHTBUTTON = 0x00000002;
enum int TPM_CENTERALIGN = 0x00000004;
enum int TPM_TOPALIGN = 0x00000000;
enum int TPM_BOTTOMALIGN = 0x00000020;
enum int TPM_VERTICAL = 0x00000040;

enum : int
{
    TPM_RETURNCMD = 0x00000100,
    TPM_RECURSE   = 0x00000001,
}

enum int TPM_HORNEGANIMATION = 0x00000800;
enum int TPM_VERNEGANIMATION = 0x00002000;
enum int TPM_LAYOUTRTL = 0x00008000;
enum int DOF_EXECUTABLE = 0x00008001;
enum int DOF_DIRECTORY = 0x00008003;
enum int DOF_PROGMAN = 0x00000001;
enum int DO_DROPFILE = 0x454c4946;

enum : int
{
    DT_TOP    = 0x00000000,
    DT_LEFT   = 0x00000000,
    DT_CENTER = 0x00000001,
}

enum int DT_VCENTER = 0x00000004;
enum int DT_WORDBREAK = 0x00000010;
enum int DT_EXPANDTABS = 0x00000040;
enum int DT_NOCLIP = 0x00000100;
enum int DT_CALCRECT = 0x00000400;
enum int DT_INTERNAL = 0x00001000;
enum int DT_PATH_ELLIPSIS = 0x00004000;
enum int DT_MODIFYSTRING = 0x00010000;
enum int DT_WORD_ELLIPSIS = 0x00040000;
enum int DT_HIDEPREFIX = 0x00100000;
enum int DST_COMPLEX = 0x00000000;
enum int DST_PREFIXTEXT = 0x00000002;
enum int DST_BITMAP = 0x00000004;

enum : int
{
    DSS_UNION    = 0x00000010,
    DSS_DISABLED = 0x00000020,
}

enum int DSS_HIDEPREFIX = 0x00000200;
enum int DSS_RIGHT = 0x00008000;

enum : int
{
    LSFW_LOCK   = 0x00000001,
    LSFW_UNLOCK = 0x00000002,
}

enum : int
{
    DCX_CACHE        = 0x00000002,
    DCX_NORESETATTRS = 0x00000004,
}

enum int DCX_CLIPSIBLINGS = 0x00000010;
enum int DCX_EXCLUDERGN = 0x00000040;
enum int DCX_EXCLUDEUPDATE = 0x00000100;
enum int DCX_LOCKWINDOWUPDATE = 0x00000400;

enum : int
{
    RDW_INVALIDATE    = 0x00000001,
    RDW_INTERNALPAINT = 0x00000002,
}

enum int RDW_VALIDATE = 0x00000008;

enum : int
{
    RDW_NOERASE    = 0x00000020,
    RDW_NOCHILDREN = 0x00000040,
}

enum int RDW_UPDATENOW = 0x00000100;

enum : int
{
    RDW_FRAME   = 0x00000400,
    RDW_NOFRAME = 0x00000800,
}

enum int SW_INVALIDATE = 0x00000002;
enum int SW_SMOOTHSCROLL = 0x00000010;

enum : int
{
    ESB_DISABLE_BOTH  = 0x00000003,
    ESB_DISABLE_LEFT  = 0x00000001,
    ESB_DISABLE_RIGHT = 0x00000002,
    ESB_DISABLE_UP    = 0x00000001,
    ESB_DISABLE_DOWN  = 0x00000002,
    ESB_DISABLE_LTUP  = 0x00000001,
    ESB_DISABLE_RTDN  = 0x00000002,
}

enum int HELPINFO_MENUITEM = 0x00000002;
enum int MB_OKCANCEL = 0x00000001;

enum : int
{
    MB_YESNOCANCEL = 0x00000003,
    MB_YESNO       = 0x00000004,
}

enum int MB_CANCELTRYCONTINUE = 0x00000006;

enum : int
{
    MB_ICONQUESTION    = 0x00000020,
    MB_ICONEXCLAMATION = 0x00000030,
}

enum int MB_USERICON = 0x00000080;

enum : int
{
    MB_ICONERROR       = 0x00000010,
    MB_ICONINFORMATION = 0x00000040,
}

enum : int
{
    MB_DEFBUTTON1 = 0x00000000,
    MB_DEFBUTTON2 = 0x00000100,
    MB_DEFBUTTON3 = 0x00000200,
    MB_DEFBUTTON4 = 0x00000300,
}

enum int MB_SYSTEMMODAL = 0x00001000;

enum : int
{
    MB_HELP    = 0x00004000,
    MB_NOFOCUS = 0x00008000,
}

enum int MB_DEFAULT_DESKTOP_ONLY = 0x00020000;

enum : int
{
    MB_RIGHT      = 0x00080000,
    MB_RTLREADING = 0x00100000,
}

enum int MB_SERVICE_NOTIFICATION_NT3X = 0x00040000;
enum int MB_ICONMASK = 0x000000f0;
enum int MB_MODEMASK = 0x00003000;

enum : int
{
    CWP_ALL             = 0x00000000,
    CWP_SKIPINVISIBLE   = 0x00000001,
    CWP_SKIPDISABLED    = 0x00000002,
    CWP_SKIPTRANSPARENT = 0x00000004,
}

enum : int
{
    CTLCOLOR_EDIT      = 0x00000001,
    CTLCOLOR_LISTBOX   = 0x00000002,
    CTLCOLOR_BTN       = 0x00000003,
    CTLCOLOR_DLG       = 0x00000004,
    CTLCOLOR_SCROLLBAR = 0x00000005,
    CTLCOLOR_STATIC    = 0x00000006,
    CTLCOLOR_MAX       = 0x00000007,
}

enum int COLOR_BACKGROUND = 0x00000001;
enum int COLOR_INACTIVECAPTION = 0x00000003;

enum : int
{
    COLOR_WINDOW      = 0x00000005,
    COLOR_WINDOWFRAME = 0x00000006,
}

enum int COLOR_WINDOWTEXT = 0x00000008;
enum int COLOR_ACTIVEBORDER = 0x0000000a;
enum int COLOR_APPWORKSPACE = 0x0000000c;
enum int COLOR_HIGHLIGHTTEXT = 0x0000000e;
enum int COLOR_BTNSHADOW = 0x00000010;

enum : int
{
    COLOR_BTNTEXT             = 0x00000012,
    COLOR_INACTIVECAPTIONTEXT = 0x00000013,
}

enum : int
{
    COLOR_3DDKSHADOW              = 0x00000015,
    COLOR_3DLIGHT                 = 0x00000016,
    COLOR_INFOTEXT                = 0x00000017,
    COLOR_INFOBK                  = 0x00000018,
    COLOR_HOTLIGHT                = 0x0000001a,
    COLOR_GRADIENTACTIVECAPTION   = 0x0000001b,
    COLOR_GRADIENTINACTIVECAPTION = 0x0000001c,
}

enum : int
{
    COLOR_MENUBAR     = 0x0000001e,
    COLOR_DESKTOP     = 0x00000001,
    COLOR_3DFACE      = 0x0000000f,
    COLOR_3DSHADOW    = 0x00000010,
    COLOR_3DHIGHLIGHT = 0x00000014,
    COLOR_3DHILIGHT   = 0x00000014,
}

enum : int
{
    GW_HWNDFIRST = 0x00000000,
    GW_HWNDLAST  = 0x00000001,
    GW_HWNDNEXT  = 0x00000002,
    GW_HWNDPREV  = 0x00000003,
}

enum int GW_CHILD = 0x00000005;
enum int GW_MAX = 0x00000006;
enum int MF_CHANGE = 0x00000080;
enum int MF_DELETE = 0x00000200;

enum : int
{
    MF_BYCOMMAND  = 0x00000000,
    MF_BYPOSITION = 0x00000400,
}

enum int MF_ENABLED = 0x00000000;
enum int MF_DISABLED = 0x00000002;
enum int MF_CHECKED = 0x00000008;
enum int MF_STRING = 0x00000000;
enum int MF_OWNERDRAW = 0x00000100;

enum : int
{
    MF_MENUBARBREAK = 0x00000020,
    MF_MENUBREAK    = 0x00000040,
}

enum int MF_HILITE = 0x00000080;
enum int MF_SYSMENU = 0x00002000;
enum int MF_RIGHTJUSTIFY = 0x00004000;
enum int MF_END = 0x00000080;
enum int MFT_BITMAP = 0x00000004;
enum int MFT_MENUBREAK = 0x00000040;
enum int MFT_RADIOCHECK = 0x00000200;

enum : int
{
    MFT_RIGHTORDER   = 0x00002000,
    MFT_RIGHTJUSTIFY = 0x00004000,
}

enum int MFS_DISABLED = 0x00000003;
enum int MFS_HILITE = 0x00000080;

enum : int
{
    MFS_UNCHECKED = 0x00000000,
    MFS_UNHILITE  = 0x00000000,
}

enum : int
{
    SC_SIZE     = 0x0000f000,
    SC_MOVE     = 0x0000f010,
    SC_MINIMIZE = 0x0000f020,
}

enum int SC_NEXTWINDOW = 0x0000f040;
enum int SC_CLOSE = 0x0000f060;
enum int SC_HSCROLL = 0x0000f080;
enum int SC_KEYMENU = 0x0000f100;
enum int SC_RESTORE = 0x0000f120;
enum int SC_SCREENSAVE = 0x0000f140;
enum int SC_DEFAULT = 0x0000f160;
enum int SC_CONTEXTHELP = 0x0000f180;
enum int SCF_ISSECURE = 0x00000001;
enum int SC_ZOOM = 0x0000f030;

enum : ushort
{
    IDC_IBEAM   = 0x7f01,
    IDC_WAIT    = 0x7f02,
    IDC_CROSS   = 0x7f03,
    IDC_UPARROW = 0x7f04,
}

enum : ushort
{
    deprecated("use IDC_ARROW") 
    IDC_ICON     = 0x7f81,
    IDC_SIZENWSE = 0x7f82,
    IDC_SIZENESW = 0x7f83,
    IDC_SIZEWE   = 0x7f84,
    IDC_SIZENS   = 0x7f85,
    IDC_SIZEALL  = 0x7f86,
}

enum ushort IDC_HAND = 0x7f89;

enum : int
{
    IDC_HELP   = 0x00007f8b,
    IDC_PIN    = 0x00007f9f,
    IDC_PERSON = 0x00007fa0,
}

enum : int
{
    IMAGE_ICON        = 0x00000001,
    IMAGE_CURSOR      = 0x00000002,
    IMAGE_ENHMETAFILE = 0x00000003,
}

enum int LR_MONOCHROME = 0x00000001;

enum : int
{
    LR_COPYRETURNORG = 0x00000004,
    LR_COPYDELETEORG = 0x00000008,
}

enum int LR_LOADTRANSPARENT = 0x00000020;
enum int LR_VGACOLOR = 0x00000080;
enum int LR_CREATEDIBSECTION = 0x00002000;
enum int LR_SHARED = 0x00008000;
enum int RES_CURSOR = 0x00000002;
enum int OBM_UPARROW = 0x00007ff1;
enum int OBM_RGARROW = 0x00007fef;
enum int OBM_REDUCE = 0x00007fed;

enum : int
{
    OBM_RESTORE = 0x00007feb,
    OBM_REDUCED = 0x00007fea,
}

enum int OBM_RESTORED = 0x00007fe8;
enum int OBM_DNARROWD = 0x00007fe6;
enum int OBM_LFARROWD = 0x00007fe4;

enum : int
{
    OBM_COMBO    = 0x00007fe2,
    OBM_UPARROWI = 0x00007fe1,
}

enum int OBM_RGARROWI = 0x00007fdf;
enum int OBM_OLD_CLOSE = 0x00007fff;

enum : int
{
    OBM_OLD_UPARROW = 0x00007ffd,
    OBM_OLD_DNARROW = 0x00007ffc,
    OBM_OLD_RGARROW = 0x00007ffb,
    OBM_OLD_LFARROW = 0x00007ffa,
}

enum : int
{
    OBM_CHECK      = 0x00007ff8,
    OBM_CHECKBOXES = 0x00007ff7,
}

enum : int
{
    OBM_OLD_REDUCE  = 0x00007ff5,
    OBM_OLD_ZOOM    = 0x00007ff4,
    OBM_OLD_RESTORE = 0x00007ff3,
}

enum : int
{
    OCR_IBEAM    = 0x00007f01,
    OCR_WAIT     = 0x00007f02,
    OCR_CROSS    = 0x00007f03,
    OCR_UP       = 0x00007f04,
    deprecated("use OCR_SIZEALL") 
    OCR_SIZE     = 0x00007f80,
    deprecated("use OCR_NORMAL") 
    OCR_ICON     = 0x00007f81,
    OCR_SIZENWSE = 0x00007f82,
    OCR_SIZENESW = 0x00007f83,
    OCR_SIZEWE   = 0x00007f84,
    OCR_SIZENS   = 0x00007f85,
    OCR_SIZEALL  = 0x00007f86,
}

enum : int
{
    OCR_NO          = 0x00007f88,
    OCR_HAND        = 0x00007f89,
    OCR_APPSTARTING = 0x00007f8a,
}

enum : int
{
    OIC_HAND    = 0x00007f01,
    OIC_QUES    = 0x00007f02,
    OIC_BANG    = 0x00007f03,
    OIC_NOTE    = 0x00007f04,
    OIC_WINLOGO = 0x00007f05,
    OIC_WARNING = 0x00007f03,
}

enum int OIC_INFORMATION = 0x00007f04;
enum int ORD_LANGDRIVER = 0x00000001;

enum : ushort
{
    IDI_HAND     = 0x7f01,
    IDI_QUESTION = 0x7f02,
}

enum ushort IDI_ASTERISK = 0x7f04;
enum ushort IDI_SHIELD = 0x7f06;

enum : ushort
{
    IDI_ERROR       = 0x7f01,
    IDI_INFORMATION = 0x7f04,
}

enum int IDCANCEL = 0x00000002;
enum int IDRETRY = 0x00000004;
enum int IDYES = 0x00000006;
enum int IDCLOSE = 0x00000008;
enum int IDTRYAGAIN = 0x0000000a;
enum int IDTIMEOUT = 0x00007d00;
enum int ES_CENTER = 0x00000001;
enum int ES_MULTILINE = 0x00000004;
enum int ES_LOWERCASE = 0x00000010;

enum : int
{
    ES_AUTOVSCROLL = 0x00000040,
    ES_AUTOHSCROLL = 0x00000080,
}

enum int ES_OEMCONVERT = 0x00000400;
enum int ES_WANTRETURN = 0x00001000;
enum int EN_SETFOCUS = 0x00000100;
enum int EN_CHANGE = 0x00000300;
enum int EN_ERRSPACE = 0x00000500;
enum int EN_HSCROLL = 0x00000601;

enum : int
{
    EN_ALIGN_LTR_EC = 0x00000700,
    EN_ALIGN_RTL_EC = 0x00000701,
}

enum int EN_AFTER_PASTE = 0x00000801;
enum int EC_RIGHTMARGIN = 0x00000002;
enum int EMSIS_COMPOSITIONSTRING = 0x00000001;
enum int EIMES_CANCELCOMPSTRINFOCUS = 0x00000002;
enum int EM_GETSEL = 0x000000b0;
enum int EM_GETRECT = 0x000000b2;
enum int EM_SETRECTNP = 0x000000b4;
enum int EM_LINESCROLL = 0x000000b6;
enum int EM_GETMODIFY = 0x000000b8;
enum int EM_GETLINECOUNT = 0x000000ba;
enum int EM_SETHANDLE = 0x000000bc;
enum int EM_GETTHUMB = 0x000000be;
enum int EM_REPLACESEL = 0x000000c2;
enum int EM_LIMITTEXT = 0x000000c5;

enum : int
{
    EM_UNDO     = 0x000000c7,
    EM_FMTLINES = 0x000000c8,
}

enum : int
{
    EM_SETTABSTOPS     = 0x000000cb,
    EM_SETPASSWORDCHAR = 0x000000cc,
}

enum int EM_GETFIRSTVISIBLELINE = 0x000000ce;
enum int EM_SETWORDBREAKPROC = 0x000000d0;
enum int EM_GETPASSWORDCHAR = 0x000000d2;
enum int EM_GETMARGINS = 0x000000d4;
enum int EM_GETLIMITTEXT = 0x000000d5;
enum int EM_CHARFROMPOS = 0x000000d7;
enum int EM_GETIMESTATUS = 0x000000d9;

enum : int
{
    WB_LEFT  = 0x00000000,
    WB_RIGHT = 0x00000001,
}

enum int BS_PUSHBUTTON = 0x00000000;
enum int BS_CHECKBOX = 0x00000002;
enum int BS_RADIOBUTTON = 0x00000004;
enum int BS_AUTO3STATE = 0x00000006;
enum int BS_USERBUTTON = 0x00000008;
enum int BS_PUSHBOX = 0x0000000a;
enum int BS_TYPEMASK = 0x0000000f;

enum : int
{
    BS_TEXT   = 0x00000000,
    BS_ICON   = 0x00000040,
    BS_BITMAP = 0x00000080,
}

enum int BS_RIGHT = 0x00000200;

enum : int
{
    BS_TOP    = 0x00000400,
    BS_BOTTOM = 0x00000800,
}

enum int BS_PUSHLIKE = 0x00001000;
enum int BS_NOTIFY = 0x00004000;
enum int BS_RIGHTBUTTON = 0x00000020;
enum int BN_PAINT = 0x00000001;
enum int BN_UNHILITE = 0x00000003;
enum int BN_DOUBLECLICKED = 0x00000005;
enum int BN_UNPUSHED = 0x00000003;
enum int BN_SETFOCUS = 0x00000006;
enum int BM_GETCHECK = 0x000000f0;
enum int BM_GETSTATE = 0x000000f2;
enum int BM_SETSTYLE = 0x000000f4;
enum int BM_GETIMAGE = 0x000000f6;
enum int BM_SETDONTCLICK = 0x000000f8;
enum int BST_CHECKED = 0x00000001;
enum int BST_PUSHED = 0x00000004;

enum : int
{
    SS_LEFT   = 0x00000000,
    SS_CENTER = 0x00000001,
}

enum : int
{
    SS_ICON      = 0x00000003,
    SS_BLACKRECT = 0x00000004,
}

enum int SS_WHITERECT = 0x00000006;
enum int SS_GRAYFRAME = 0x00000008;
enum int SS_USERITEM = 0x0000000a;
enum int SS_LEFTNOWORDWRAP = 0x0000000c;
enum int SS_BITMAP = 0x0000000e;

enum : int
{
    SS_ETCHEDHORZ  = 0x00000010,
    SS_ETCHEDVERT  = 0x00000011,
    SS_ETCHEDFRAME = 0x00000012,
}

enum int SS_REALSIZECONTROL = 0x00000040;
enum int SS_NOTIFY = 0x00000100;
enum int SS_RIGHTJUST = 0x00000400;
enum int SS_SUNKEN = 0x00001000;
enum int SS_ENDELLIPSIS = 0x00004000;
enum int SS_WORDELLIPSIS = 0x0000c000;
enum int STM_SETICON = 0x00000170;
enum int STM_SETIMAGE = 0x00000172;
enum int STN_CLICKED = 0x00000000;
enum int STN_ENABLE = 0x00000002;
enum int STM_MSGMAX = 0x00000174;
enum int DWL_MSGRESULT = 0x00000000;
enum int DWL_USER = 0x00000008;

enum : int
{
    DDL_READWRITE = 0x00000000,
    DDL_READONLY  = 0x00000001,
}

enum int DDL_SYSTEM = 0x00000004;
enum int DDL_ARCHIVE = 0x00000020;
enum int DDL_DRIVES = 0x00004000;
enum int DS_ABSALIGN = 0x00000001;
enum int DS_LOCALEDIT = 0x00000020;
enum int DS_MODALFRAME = 0x00000080;
enum int DS_SETFOREGROUND = 0x00000200;
enum int DS_FIXEDSYS = 0x00000008;
enum int DS_CONTROL = 0x00000400;
enum int DS_CENTERMOUSE = 0x00001000;
enum int DS_SHELLFONT = 0x00000048;
enum int DM_GETDEFID = 0x00000400;
enum int DM_REPOSITION = 0x00000402;

enum : int
{
    DLGC_WANTARROWS  = 0x00000001,
    DLGC_WANTTAB     = 0x00000002,
    DLGC_WANTALLKEYS = 0x00000004,
    DLGC_WANTMESSAGE = 0x00000004,
}

enum int DLGC_DEFPUSHBUTTON = 0x00000010;
enum int DLGC_RADIOBUTTON = 0x00000040;

enum : int
{
    DLGC_STATIC = 0x00000100,
    DLGC_BUTTON = 0x00002000,
}

enum : int
{
    LB_OKAY     = 0x00000000,
    LB_ERR      = 0xffffffff,
    LB_ERRSPACE = 0xfffffffe,
}

enum int LBN_SELCHANGE = 0x00000001;

enum : int
{
    LBN_SELCANCEL = 0x00000003,
    LBN_SETFOCUS  = 0x00000004,
}

enum int LB_ADDSTRING = 0x00000180;
enum int LB_DELETESTRING = 0x00000182;
enum int LB_RESETCONTENT = 0x00000184;
enum int LB_SETCURSEL = 0x00000186;

enum : int
{
    LB_GETCURSEL  = 0x00000188,
    LB_GETTEXT    = 0x00000189,
    LB_GETTEXTLEN = 0x0000018a,
    LB_GETCOUNT   = 0x0000018b,
}

enum : int
{
    LB_DIR         = 0x0000018d,
    LB_GETTOPINDEX = 0x0000018e,
}

enum : int
{
    LB_GETSELCOUNT = 0x00000190,
    LB_GETSELITEMS = 0x00000191,
}

enum int LB_GETHORIZONTALEXTENT = 0x00000193;
enum int LB_SETCOLUMNWIDTH = 0x00000195;
enum int LB_SETTOPINDEX = 0x00000197;
enum int LB_GETITEMDATA = 0x00000199;
enum int LB_SELITEMRANGE = 0x0000019b;
enum int LB_GETANCHORINDEX = 0x0000019d;
enum int LB_GETCARETINDEX = 0x0000019f;
enum int LB_GETITEMHEIGHT = 0x000001a1;
enum int LB_SETLOCALE = 0x000001a5;
enum int LB_SETCOUNT = 0x000001a7;
enum int LB_ITEMFROMPOINT = 0x000001a9;
enum int LB_GETLISTBOXINFO = 0x000001b2;
enum uint LBS_NOTIFY = 0x00000001;
enum uint LBS_NOREDRAW = 0x00000004;

enum : uint
{
    LBS_OWNERDRAWFIXED    = 0x00000010,
    LBS_OWNERDRAWVARIABLE = 0x00000020,
}

enum uint LBS_USETABSTOPS = 0x00000080;
enum uint LBS_MULTICOLUMN = 0x00000200;
enum uint LBS_EXTENDEDSEL = 0x00000800;

enum : uint
{
    LBS_NODATA   = 0x00002000,
    LBS_NOSEL    = 0x00004000,
    LBS_COMBOBOX = 0x00008000,
}

enum : int
{
    CB_OKAY     = 0x00000000,
    CB_ERR      = 0xffffffff,
    CB_ERRSPACE = 0xfffffffe,
}

enum int CBN_SELCHANGE = 0x00000001;
enum int CBN_SETFOCUS = 0x00000003;

enum : int
{
    CBN_EDITCHANGE = 0x00000005,
    CBN_EDITUPDATE = 0x00000006,
}

enum int CBN_CLOSEUP = 0x00000008;
enum int CBN_SELENDCANCEL = 0x0000000a;

enum : int
{
    CBS_DROPDOWN     = 0x00000002,
    CBS_DROPDOWNLIST = 0x00000003,
}

enum int CBS_OWNERDRAWVARIABLE = 0x00000020;
enum int CBS_OEMCONVERT = 0x00000080;
enum int CBS_HASSTRINGS = 0x00000200;
enum int CBS_DISABLENOSCROLL = 0x00000800;
enum int CBS_LOWERCASE = 0x00004000;
enum int CB_LIMITTEXT = 0x00000141;
enum int CB_ADDSTRING = 0x00000143;

enum : int
{
    CB_DIR          = 0x00000145,
    CB_GETCOUNT     = 0x00000146,
    CB_GETCURSEL    = 0x00000147,
    CB_GETLBTEXT    = 0x00000148,
    CB_GETLBTEXTLEN = 0x00000149,
}

enum int CB_RESETCONTENT = 0x0000014b;
enum int CB_SELECTSTRING = 0x0000014d;
enum int CB_SHOWDROPDOWN = 0x0000014f;
enum int CB_SETITEMDATA = 0x00000151;
enum int CB_SETITEMHEIGHT = 0x00000153;
enum int CB_SETEXTENDEDUI = 0x00000155;
enum int CB_GETDROPPEDSTATE = 0x00000157;
enum int CB_SETLOCALE = 0x00000159;
enum int CB_GETTOPINDEX = 0x0000015b;
enum int CB_GETHORIZONTALEXTENT = 0x0000015d;
enum int CB_GETDROPPEDWIDTH = 0x0000015f;
enum int CB_INITSTORAGE = 0x00000161;
enum int CB_GETCOMBOBOXINFO = 0x00000164;

enum : int
{
    SBS_HORZ     = 0x00000000,
    SBS_VERT     = 0x00000001,
    SBS_TOPALIGN = 0x00000002,
}

enum int SBS_BOTTOMALIGN = 0x00000004;

enum : int
{
    SBS_SIZEBOXTOPLEFTALIGN     = 0x00000002,
    SBS_SIZEBOXBOTTOMRIGHTALIGN = 0x00000004,
    SBS_SIZEBOX                 = 0x00000008,
    SBS_SIZEGRIP                = 0x00000010,
}

enum int SBM_GETPOS = 0x000000e1;
enum int SBM_SETRANGEREDRAW = 0x000000e6;
enum int SBM_ENABLE_ARROWS = 0x000000e4;

enum : int
{
    SBM_GETSCROLLINFO    = 0x000000ea,
    SBM_GETSCROLLBARINFO = 0x000000eb,
}

enum : int
{
    SIF_PAGE            = 0x00000002,
    SIF_POS             = 0x00000004,
    SIF_DISABLENOSCROLL = 0x00000008,
}

enum int SIF_ALL = 0x00000017;

enum : int
{
    MDITILE_VERTICAL     = 0x00000000,
    MDITILE_HORIZONTAL   = 0x00000001,
    MDITILE_SKIPDISABLED = 0x00000002,
}

enum : int
{
    HELP_CONTEXT  = 0x00000001,
    HELP_QUIT     = 0x00000002,
    HELP_INDEX    = 0x00000003,
    HELP_CONTENTS = 0x00000003,
}

enum : int
{
    HELP_SETINDEX    = 0x00000005,
    HELP_SETCONTENTS = 0x00000005,
}

enum int HELP_FORCEFILE = 0x00000009;

enum : int
{
    HELP_COMMAND    = 0x00000102,
    HELP_PARTIALKEY = 0x00000105,
}

enum int HELP_SETWINPOS = 0x00000203;

enum : int
{
    HELP_FINDER       = 0x0000000b,
    HELP_WM_HELP      = 0x0000000c,
    HELP_SETPOPUP_POS = 0x0000000d,
}

enum : int
{
    HELP_TCARD_DATA         = 0x00000010,
    HELP_TCARD_OTHER_CALLER = 0x00000011,
}

enum int IDH_MISSING_CONTEXT = 0x00006f19;

enum : int
{
    IDH_OK     = 0x00006f1b,
    IDH_CANCEL = 0x00006f1c,
}

enum int GR_GDIOBJECTS = 0x00000000;
enum int GR_GDIOBJECTS_PEAK = 0x00000002;
enum int GR_GLOBAL = 0xfffffffe;
enum int SPI_SETBEEP = 0x00000002;
enum int SPI_SETMOUSE = 0x00000004;
enum int SPI_SETBORDER = 0x00000006;
enum int SPI_SETKEYBOARDSPEED = 0x0000000b;
enum int SPI_ICONHORIZONTALSPACING = 0x0000000d;
enum int SPI_SETSCREENSAVETIMEOUT = 0x0000000f;
enum int SPI_SETSCREENSAVEACTIVE = 0x00000011;
enum int SPI_SETGRIDGRANULARITY = 0x00000013;
enum int SPI_SETDESKPATTERN = 0x00000015;
enum int SPI_SETKEYBOARDDELAY = 0x00000017;
enum int SPI_GETICONTITLEWRAP = 0x00000019;
enum int SPI_GETMENUDROPALIGNMENT = 0x0000001b;

enum : int
{
    SPI_SETDOUBLECLKWIDTH  = 0x0000001d,
    SPI_SETDOUBLECLKHEIGHT = 0x0000001e,
}

enum int SPI_SETDOUBLECLICKTIME = 0x00000020;
enum int SPI_SETICONTITLELOGFONT = 0x00000022;
enum int SPI_SETFASTTASKSWITCH = 0x00000024;
enum int SPI_GETDRAGFULLWINDOWS = 0x00000026;
enum int SPI_SETNONCLIENTMETRICS = 0x0000002a;
enum int SPI_SETMINIMIZEDMETRICS = 0x0000002c;
enum int SPI_SETICONMETRICS = 0x0000002e;
enum int SPI_GETWORKAREA = 0x00000030;
enum int SPI_GETHIGHCONTRAST = 0x00000042;
enum int SPI_GETKEYBOARDPREF = 0x00000044;
enum int SPI_GETSCREENREADER = 0x00000046;
enum int SPI_GETANIMATION = 0x00000048;
enum int SPI_GETFONTSMOOTHING = 0x0000004a;

enum : int
{
    SPI_SETDRAGWIDTH  = 0x0000004c,
    SPI_SETDRAGHEIGHT = 0x0000004d,
    SPI_SETHANDHELD   = 0x0000004e,
}

enum int SPI_GETPOWEROFFTIMEOUT = 0x00000050;
enum int SPI_SETPOWEROFFTIMEOUT = 0x00000052;
enum int SPI_GETPOWEROFFACTIVE = 0x00000054;
enum int SPI_SETPOWEROFFACTIVE = 0x00000056;
enum int SPI_SETICONS = 0x00000058;
enum int SPI_SETDEFAULTINPUTLANG = 0x0000005a;
enum int SPI_GETWINDOWSEXTENSION = 0x0000005c;
enum int SPI_GETMOUSETRAILS = 0x0000005e;
enum int SPI_SCREENSAVERRUNNING = 0x00000061;
enum int SPI_SETFILTERKEYS = 0x00000033;
enum int SPI_SETTOGGLEKEYS = 0x00000035;
enum int SPI_SETMOUSEKEYS = 0x00000037;
enum int SPI_SETSHOWSOUNDS = 0x00000039;
enum int SPI_SETSTICKYKEYS = 0x0000003b;
enum int SPI_SETACCESSTIMEOUT = 0x0000003d;
enum int SPI_SETSERIALKEYS = 0x0000003f;
enum int SPI_SETSOUNDSENTRY = 0x00000041;
enum int SPI_SETSNAPTODEFBUTTON = 0x00000060;
enum int SPI_SETMOUSEHOVERWIDTH = 0x00000063;
enum int SPI_SETMOUSEHOVERHEIGHT = 0x00000065;
enum int SPI_SETMOUSEHOVERTIME = 0x00000067;
enum int SPI_SETWHEELSCROLLLINES = 0x00000069;
enum int SPI_SETMENUSHOWDELAY = 0x0000006b;
enum int SPI_SETWHEELSCROLLCHARS = 0x0000006d;
enum int SPI_SETSHOWIMEUI = 0x0000006f;
enum int SPI_SETMOUSESPEED = 0x00000071;
enum int SPI_GETDESKWALLPAPER = 0x00000073;
enum int SPI_SETAUDIODESCRIPTION = 0x00000075;
enum int SPI_SETSCREENSAVESECURE = 0x00000077;
enum int SPI_SETHUNGAPPTIMEOUT = 0x00000079;
enum int SPI_SETWAITTOKILLTIMEOUT = 0x0000007b;
enum int SPI_SETWAITTOKILLSERVICETIMEOUT = 0x0000007d;
enum int SPI_SETMOUSEDOCKTHRESHOLD = 0x0000007f;
enum int SPI_SETPENDOCKTHRESHOLD = 0x00000081;
enum int SPI_SETWINARRANGING = 0x00000083;
enum int SPI_SETMOUSEDRAGOUTTHRESHOLD = 0x00000085;
enum int SPI_SETPENDRAGOUTTHRESHOLD = 0x00000087;
enum int SPI_SETMOUSESIDEMOVETHRESHOLD = 0x00000089;
enum int SPI_SETPENSIDEMOVETHRESHOLD = 0x0000008b;
enum int SPI_SETDRAGFROMMAXIMIZE = 0x0000008d;
enum int SPI_SETSNAPSIZING = 0x0000008f;
enum int SPI_SETDOCKMOVING = 0x00000091;

enum : int
{
    TOUCHPREDICTIONPARAMETERS_DEFAULT_LATENCY          = 0x00000008,
    TOUCHPREDICTIONPARAMETERS_DEFAULT_SAMPLETIME       = 0x00000008,
    TOUCHPREDICTIONPARAMETERS_DEFAULT_USE_HW_TIMESTAMP = 0x00000001,
}

enum : float
{
    TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MIN           = 0x1.ccccccp-1,
    TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MAX           = 0x1.ff7ceep-1,
    TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_LEARNING_RATE = 0x1.0624dep-10,
    TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_EXPO_SMOOTH_ALPHA    = 0x1.fae148p-1,
}

enum int SPI_SETTOUCHPREDICTIONPARAMETERS = 0x0000009d;
enum int MIN_LOGICALDPIOVERRIDE = 0xfffffffe;
enum int SPI_SETLOGICALDPIOVERRIDE = 0x0000009f;
enum int SPI_SETMENURECT = 0x000000a3;
enum int SPI_SETACTIVEWINDOWTRACKING = 0x00001001;
enum int SPI_SETMENUANIMATION = 0x00001003;
enum int SPI_SETCOMBOBOXANIMATION = 0x00001005;
enum int SPI_SETLISTBOXSMOOTHSCROLLING = 0x00001007;
enum int SPI_SETGRADIENTCAPTIONS = 0x00001009;
enum int SPI_SETKEYBOARDCUES = 0x0000100b;
enum int SPI_SETMENUUNDERLINES = 0x0000100b;
enum int SPI_SETACTIVEWNDTRKZORDER = 0x0000100d;
enum int SPI_SETHOTTRACKING = 0x0000100f;
enum int SPI_SETMENUFADE = 0x00001013;
enum int SPI_SETSELECTIONFADE = 0x00001015;
enum int SPI_SETTOOLTIPANIMATION = 0x00001017;
enum int SPI_SETTOOLTIPFADE = 0x00001019;
enum int SPI_SETCURSORSHADOW = 0x0000101b;
enum int SPI_SETMOUSESONAR = 0x0000101d;
enum int SPI_SETMOUSECLICKLOCK = 0x0000101f;
enum int SPI_SETMOUSEVANISH = 0x00001021;
enum int SPI_SETFLATMENU = 0x00001023;
enum int SPI_SETDROPSHADOW = 0x00001025;
enum int SPI_SETBLOCKSENDINPUTRESETS = 0x00001027;
enum int SPI_SETUIEFFECTS = 0x0000103f;
enum int SPI_SETDISABLEOVERLAPPEDCONTENT = 0x00001041;
enum int SPI_SETCLIENTAREAANIMATION = 0x00001043;
enum int SPI_SETCLEARTYPE = 0x00001049;
enum int SPI_SETSPEECHRECOGNITION = 0x0000104b;
enum int SPI_SETCARETBROWSING = 0x0000104d;
enum int SPI_SETTHREADLOCALINPUTSETTINGS = 0x0000104f;
enum int SPI_SETSYSTEMLANGUAGEBAR = 0x00001051;
enum int SPI_SETFOREGROUNDLOCKTIMEOUT = 0x00002001;
enum int SPI_SETACTIVEWNDTRKTIMEOUT = 0x00002003;
enum int SPI_SETFOREGROUNDFLASHCOUNT = 0x00002005;
enum int SPI_SETCARETWIDTH = 0x00002007;
enum int SPI_SETMOUSECLICKLOCKTIME = 0x00002009;
enum int SPI_SETFONTSMOOTHINGTYPE = 0x0000200b;
enum int FE_FONTSMOOTHINGCLEARTYPE = 0x00000002;
enum int SPI_SETFONTSMOOTHINGCONTRAST = 0x0000200d;
enum int SPI_SETFOCUSBORDERWIDTH = 0x0000200f;
enum int SPI_SETFOCUSBORDERHEIGHT = 0x00002011;
enum int SPI_SETFONTSMOOTHINGORIENTATION = 0x00002013;
enum int FE_FONTSMOOTHINGORIENTATIONRGB = 0x00000001;
enum int SPI_SETMINIMUMHITRADIUS = 0x00002015;
enum int SPI_SETMESSAGEDURATION = 0x00002017;
enum int SPI_SETCONTACTVISUALIZATION = 0x00002019;

enum : int
{
    CONTACTVISUALIZATION_ON               = 0x00000001,
    CONTACTVISUALIZATION_PRESENTATIONMODE = 0x00000002,
}

enum int SPI_SETGESTUREVISUALIZATION = 0x0000201b;

enum : int
{
    GESTUREVISUALIZATION_ON           = 0x0000001f,
    GESTUREVISUALIZATION_TAP          = 0x00000001,
    GESTUREVISUALIZATION_DOUBLETAP    = 0x00000002,
    GESTUREVISUALIZATION_PRESSANDTAP  = 0x00000004,
    GESTUREVISUALIZATION_PRESSANDHOLD = 0x00000008,
    GESTUREVISUALIZATION_RIGHTTAP     = 0x00000010,
}

enum int SPI_SETMOUSEWHEELROUTING = 0x0000201d;

enum : int
{
    MOUSEWHEEL_ROUTING_HYBRID    = 0x00000001,
    MOUSEWHEEL_ROUTING_MOUSE_POS = 0x00000002,
}

enum int SPI_SETPENVISUALIZATION = 0x0000201f;

enum : int
{
    PENVISUALIZATION_OFF       = 0x00000000,
    PENVISUALIZATION_TAP       = 0x00000001,
    PENVISUALIZATION_DOUBLETAP = 0x00000002,
    PENVISUALIZATION_CURSOR    = 0x00000020,
}

enum int SPI_SETPENARBITRATIONTYPE = 0x00002021;

enum : int
{
    PENARBITRATIONTYPE_WIN8 = 0x00000001,
    PENARBITRATIONTYPE_FIS  = 0x00000002,
    PENARBITRATIONTYPE_SPT  = 0x00000003,
    PENARBITRATIONTYPE_MAX  = 0x00000004,
}

enum int SPI_SETCARETTIMEOUT = 0x00002023;
enum int SPI_SETHANDEDNESS = 0x00002025;

enum : int
{
    SPIF_SENDWININICHANGE = 0x00000002,
    SPIF_SENDCHANGE       = 0x00000002,
}

enum : int
{
    ARW_BOTTOMLEFT  = 0x00000000,
    ARW_BOTTOMRIGHT = 0x00000001,
}

enum int ARW_TOPRIGHT = 0x00000003;

enum : int
{
    ARW_STARTRIGHT = 0x00000001,
    ARW_STARTTOP   = 0x00000002,
}

enum : int
{
    ARW_RIGHT = 0x00000000,
    ARW_UP    = 0x00000004,
    ARW_DOWN  = 0x00000004,
    ARW_HIDE  = 0x00000008,
}

enum int SERKF_AVAILABLE = 0x00000002;
enum int HCF_HIGHCONTRASTON = 0x00000001;
enum int HCF_HOTKEYACTIVE = 0x00000004;
enum int HCF_HOTKEYSOUND = 0x00000010;
enum int HCF_HOTKEYAVAILABLE = 0x00000040;
enum int HCF_DEFAULTDESKTOP = 0x00000200;
enum int CDS_UPDATEREGISTRY = 0x00000001;
enum int CDS_FULLSCREEN = 0x00000004;
enum int CDS_SET_PRIMARY = 0x00000010;
enum int CDS_ENABLE_UNSAFE_MODES = 0x00000100;

enum : int
{
    CDS_RESET    = 0x40000000,
    CDS_RESET_EX = 0x20000000,
}

enum : int
{
    DISP_CHANGE_SUCCESSFUL  = 0x00000000,
    DISP_CHANGE_RESTART     = 0x00000001,
    DISP_CHANGE_FAILED      = 0xffffffff,
    DISP_CHANGE_BADMODE     = 0xfffffffe,
    DISP_CHANGE_NOTUPDATED  = 0xfffffffd,
    DISP_CHANGE_BADFLAGS    = 0xfffffffc,
    DISP_CHANGE_BADPARAM    = 0xfffffffb,
    DISP_CHANGE_BADDUALVIEW = 0xfffffffa,
}

enum uint ENUM_REGISTRY_SETTINGS = 0xfffffffe;
enum int EDS_ROTATEDMODE = 0x00000004;
enum int FKF_FILTERKEYSON = 0x00000001;
enum int FKF_HOTKEYACTIVE = 0x00000004;
enum int FKF_HOTKEYSOUND = 0x00000010;
enum int FKF_CLICKON = 0x00000040;
enum uint SKF_AVAILABLE = 0x00000002;
enum uint SKF_CONFIRMHOTKEY = 0x00000008;
enum uint SKF_INDICATOR = 0x00000020;

enum : uint
{
    SKF_TRISTATE   = 0x00000080,
    SKF_TWOKEYSOFF = 0x00000100,
}

enum uint SKF_LCTLLATCHED = 0x04000000;
enum uint SKF_RALTLATCHED = 0x20000000;
enum uint SKF_RSHIFTLATCHED = 0x02000000;
enum uint SKF_RWINLATCHED = 0x80000000;
enum uint SKF_LCTLLOCKED = 0x00040000;
enum uint SKF_RALTLOCKED = 0x00200000;
enum uint SKF_RSHIFTLOCKED = 0x00020000;
enum uint SKF_RWINLOCKED = 0x00800000;
enum uint MKF_AVAILABLE = 0x00000002;
enum uint MKF_CONFIRMHOTKEY = 0x00000008;
enum uint MKF_INDICATOR = 0x00000020;
enum uint MKF_REPLACENUMBERS = 0x00000080;
enum uint MKF_RIGHTBUTTONSEL = 0x20000000;
enum uint MKF_RIGHTBUTTONDOWN = 0x02000000;
enum int ATF_TIMEOUTON = 0x00000001;

enum : int
{
    SSGF_NONE    = 0x00000000,
    SSGF_DISPLAY = 0x00000003,
}

enum : int
{
    SSTF_CHARS   = 0x00000001,
    SSTF_BORDER  = 0x00000002,
    SSTF_DISPLAY = 0x00000003,
}

enum : int
{
    SSWF_TITLE   = 0x00000001,
    SSWF_WINDOW  = 0x00000002,
    SSWF_DISPLAY = 0x00000003,
    SSWF_CUSTOM  = 0x00000004,
}

enum int SSF_AVAILABLE = 0x00000002;
enum int TKF_TOGGLEKEYSON = 0x00000001;
enum int TKF_HOTKEYACTIVE = 0x00000004;
enum int TKF_HOTKEYSOUND = 0x00000010;

enum : int
{
    SLE_ERROR      = 0x00000001,
    SLE_MINORERROR = 0x00000002,
}

enum : int
{
    MONITOR_DEFAULTTONULL    = 0x00000000,
    MONITOR_DEFAULTTOPRIMARY = 0x00000001,
    MONITOR_DEFAULTTONEAREST = 0x00000002,
}

enum int CCHDEVICENAME = 0x00000020;

enum : int
{
    WINEVENT_SKIPOWNTHREAD  = 0x00000001,
    WINEVENT_SKIPOWNPROCESS = 0x00000002,
}

enum int CHILDID_SELF = 0x00000000;
enum int INDEXID_CONTAINER = 0x00000000;

enum : int
{
    OBJID_SYSMENU           = 0xffffffff,
    OBJID_TITLEBAR          = 0xfffffffe,
    OBJID_MENU              = 0xfffffffd,
    OBJID_CLIENT            = 0xfffffffc,
    OBJID_VSCROLL           = 0xfffffffb,
    OBJID_HSCROLL           = 0xfffffffa,
    OBJID_SIZEGRIP          = 0xfffffff9,
    OBJID_CARET             = 0xfffffff8,
    OBJID_CURSOR            = 0xfffffff7,
    OBJID_ALERT             = 0xfffffff6,
    OBJID_SOUND             = 0xfffffff5,
    OBJID_QUERYCLASSNAMEIDX = 0xfffffff4,
}

enum : int
{
    EVENT_MIN                           = 0x00000001,
    EVENT_MAX                           = 0x7fffffff,
    EVENT_SYSTEM_SOUND                  = 0x00000001,
    EVENT_SYSTEM_ALERT                  = 0x00000002,
    EVENT_SYSTEM_FOREGROUND             = 0x00000003,
    EVENT_SYSTEM_MENUSTART              = 0x00000004,
    EVENT_SYSTEM_MENUEND                = 0x00000005,
    EVENT_SYSTEM_MENUPOPUPSTART         = 0x00000006,
    EVENT_SYSTEM_MENUPOPUPEND           = 0x00000007,
    EVENT_SYSTEM_CAPTURESTART           = 0x00000008,
    EVENT_SYSTEM_CAPTUREEND             = 0x00000009,
    EVENT_SYSTEM_MOVESIZESTART          = 0x0000000a,
    EVENT_SYSTEM_MOVESIZEEND            = 0x0000000b,
    EVENT_SYSTEM_CONTEXTHELPSTART       = 0x0000000c,
    EVENT_SYSTEM_CONTEXTHELPEND         = 0x0000000d,
    EVENT_SYSTEM_DRAGDROPSTART          = 0x0000000e,
    EVENT_SYSTEM_DRAGDROPEND            = 0x0000000f,
    EVENT_SYSTEM_DIALOGSTART            = 0x00000010,
    EVENT_SYSTEM_DIALOGEND              = 0x00000011,
    EVENT_SYSTEM_SCROLLINGSTART         = 0x00000012,
    EVENT_SYSTEM_SCROLLINGEND           = 0x00000013,
    EVENT_SYSTEM_SWITCHSTART            = 0x00000014,
    EVENT_SYSTEM_SWITCHEND              = 0x00000015,
    EVENT_SYSTEM_MINIMIZESTART          = 0x00000016,
    EVENT_SYSTEM_MINIMIZEEND            = 0x00000017,
    EVENT_SYSTEM_DESKTOPSWITCH          = 0x00000020,
    EVENT_SYSTEM_SWITCHER_APPGRABBED    = 0x00000024,
    EVENT_SYSTEM_SWITCHER_APPOVERTARGET = 0x00000025,
    EVENT_SYSTEM_SWITCHER_APPDROPPED    = 0x00000026,
    EVENT_SYSTEM_SWITCHER_CANCELLED     = 0x00000027,
    EVENT_SYSTEM_IME_KEY_NOTIFICATION   = 0x00000029,
}

enum : int
{
    EVENT_OEM_DEFINED_START = 0x00000101,
    EVENT_OEM_DEFINED_END   = 0x000001ff,
}

enum : int
{
    EVENT_UIA_EVENTID_END  = 0x00004eff,
    EVENT_UIA_PROPID_START = 0x00007500,
    EVENT_UIA_PROPID_END   = 0x000075ff,
}

enum : int
{
    EVENT_CONSOLE_UPDATE_REGION     = 0x00004002,
    EVENT_CONSOLE_UPDATE_SIMPLE     = 0x00004003,
    EVENT_CONSOLE_UPDATE_SCROLL     = 0x00004004,
    EVENT_CONSOLE_LAYOUT            = 0x00004005,
    EVENT_CONSOLE_START_APPLICATION = 0x00004006,
    EVENT_CONSOLE_END_APPLICATION   = 0x00004007,
}

enum : int
{
    CONSOLE_CARET_SELECTION = 0x00000001,
    CONSOLE_CARET_VISIBLE   = 0x00000002,
}

enum : int
{
    EVENT_OBJECT_CREATE               = 0x00008000,
    EVENT_OBJECT_DESTROY              = 0x00008001,
    EVENT_OBJECT_SHOW                 = 0x00008002,
    EVENT_OBJECT_HIDE                 = 0x00008003,
    EVENT_OBJECT_REORDER              = 0x00008004,
    EVENT_OBJECT_FOCUS                = 0x00008005,
    EVENT_OBJECT_SELECTION            = 0x00008006,
    EVENT_OBJECT_SELECTIONADD         = 0x00008007,
    EVENT_OBJECT_SELECTIONREMOVE      = 0x00008008,
    EVENT_OBJECT_SELECTIONWITHIN      = 0x00008009,
    EVENT_OBJECT_STATECHANGE          = 0x0000800a,
    EVENT_OBJECT_LOCATIONCHANGE       = 0x0000800b,
    EVENT_OBJECT_NAMECHANGE           = 0x0000800c,
    EVENT_OBJECT_DESCRIPTIONCHANGE    = 0x0000800d,
    EVENT_OBJECT_VALUECHANGE          = 0x0000800e,
    EVENT_OBJECT_PARENTCHANGE         = 0x0000800f,
    EVENT_OBJECT_HELPCHANGE           = 0x00008010,
    EVENT_OBJECT_DEFACTIONCHANGE      = 0x00008011,
    EVENT_OBJECT_ACCELERATORCHANGE    = 0x00008012,
    EVENT_OBJECT_INVOKED              = 0x00008013,
    EVENT_OBJECT_TEXTSELECTIONCHANGED = 0x00008014,
}

enum int EVENT_SYSTEM_ARRANGMENTPREVIEW = 0x00008016;

enum : int
{
    EVENT_OBJECT_UNCLOAKED                = 0x00008018,
    EVENT_OBJECT_LIVEREGIONCHANGED        = 0x00008019,
    EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED = 0x00008020,
}

enum : int
{
    EVENT_OBJECT_DRAGCANCEL                       = 0x00008022,
    EVENT_OBJECT_DRAGCOMPLETE                     = 0x00008023,
    EVENT_OBJECT_DRAGENTER                        = 0x00008024,
    EVENT_OBJECT_DRAGLEAVE                        = 0x00008025,
    EVENT_OBJECT_DRAGDROPPED                      = 0x00008026,
    EVENT_OBJECT_IME_SHOW                         = 0x00008027,
    EVENT_OBJECT_IME_HIDE                         = 0x00008028,
    EVENT_OBJECT_IME_CHANGE                       = 0x00008029,
    EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED = 0x00008030,
}

enum : int
{
    EVENT_AIA_START = 0x0000a000,
    EVENT_AIA_END   = 0x0000afff,
}

enum : int
{
    SOUND_SYSTEM_SHUTDOWN    = 0x00000002,
    SOUND_SYSTEM_BEEP        = 0x00000003,
    SOUND_SYSTEM_ERROR       = 0x00000004,
    SOUND_SYSTEM_QUESTION    = 0x00000005,
    SOUND_SYSTEM_WARNING     = 0x00000006,
    SOUND_SYSTEM_INFORMATION = 0x00000007,
    SOUND_SYSTEM_MAXIMIZE    = 0x00000008,
    SOUND_SYSTEM_MINIMIZE    = 0x00000009,
    SOUND_SYSTEM_RESTOREUP   = 0x0000000a,
    SOUND_SYSTEM_RESTOREDOWN = 0x0000000b,
    SOUND_SYSTEM_APPSTART    = 0x0000000c,
    SOUND_SYSTEM_FAULT       = 0x0000000d,
    SOUND_SYSTEM_APPEND      = 0x0000000e,
    SOUND_SYSTEM_MENUCOMMAND = 0x0000000f,
    SOUND_SYSTEM_MENUPOPUP   = 0x00000010,
}

enum : int
{
    ALERT_SYSTEM_INFORMATIONAL = 0x00000001,
    ALERT_SYSTEM_WARNING       = 0x00000002,
    ALERT_SYSTEM_ERROR         = 0x00000003,
    ALERT_SYSTEM_QUERY         = 0x00000004,
    ALERT_SYSTEM_CRITICAL      = 0x00000005,
}

enum int GUI_CARETBLINKING = 0x00000001;
enum int GUI_INMENUMODE = 0x00000004;
enum int GUI_POPUPMENUMODE = 0x00000010;
enum int USER_DEFAULT_SCREEN_DPI = 0x00000060;

enum : int
{
    STATE_SYSTEM_SELECTED        = 0x00000002,
    STATE_SYSTEM_FOCUSED         = 0x00000004,
    STATE_SYSTEM_PRESSED         = 0x00000008,
    STATE_SYSTEM_CHECKED         = 0x00000010,
    STATE_SYSTEM_MIXED           = 0x00000020,
    STATE_SYSTEM_INDETERMINATE   = 0x00000020,
    STATE_SYSTEM_READONLY        = 0x00000040,
    STATE_SYSTEM_HOTTRACKED      = 0x00000080,
    STATE_SYSTEM_DEFAULT         = 0x00000100,
    STATE_SYSTEM_EXPANDED        = 0x00000200,
    STATE_SYSTEM_COLLAPSED       = 0x00000400,
    STATE_SYSTEM_BUSY            = 0x00000800,
    STATE_SYSTEM_FLOATING        = 0x00001000,
    STATE_SYSTEM_MARQUEED        = 0x00002000,
    STATE_SYSTEM_ANIMATED        = 0x00004000,
    STATE_SYSTEM_INVISIBLE       = 0x00008000,
    STATE_SYSTEM_OFFSCREEN       = 0x00010000,
    STATE_SYSTEM_SIZEABLE        = 0x00020000,
    STATE_SYSTEM_MOVEABLE        = 0x00040000,
    STATE_SYSTEM_SELFVOICING     = 0x00080000,
    STATE_SYSTEM_FOCUSABLE       = 0x00100000,
    STATE_SYSTEM_SELECTABLE      = 0x00200000,
    STATE_SYSTEM_LINKED          = 0x00400000,
    STATE_SYSTEM_TRAVERSED       = 0x00800000,
    STATE_SYSTEM_MULTISELECTABLE = 0x01000000,
    STATE_SYSTEM_EXTSELECTABLE   = 0x02000000,
    STATE_SYSTEM_ALERT_LOW       = 0x04000000,
    STATE_SYSTEM_ALERT_MEDIUM    = 0x08000000,
    STATE_SYSTEM_ALERT_HIGH      = 0x10000000,
    STATE_SYSTEM_PROTECTED       = 0x20000000,
    STATE_SYSTEM_VALID           = 0x3fffffff,
}

enum int CCHILDREN_SCROLLBAR = 0x00000005;
enum int CURSOR_SUPPRESSED = 0x00000002;
enum int GA_PARENT = 0x00000001;
enum int GA_ROOTOWNER = 0x00000003;
enum int RIM_INPUTSINK = 0x00000001;

enum : int
{
    RIM_TYPEKEYBOARD = 0x00000001,
    RIM_TYPEHID      = 0x00000002,
    RIM_TYPEMAX      = 0x00000002,
}

enum int RI_MOUSE_LEFT_BUTTON_UP = 0x00000002;
enum int RI_MOUSE_RIGHT_BUTTON_UP = 0x00000008;
enum int RI_MOUSE_MIDDLE_BUTTON_UP = 0x00000020;

enum : int
{
    RI_MOUSE_BUTTON_1_UP   = 0x00000002,
    RI_MOUSE_BUTTON_2_DOWN = 0x00000004,
    RI_MOUSE_BUTTON_2_UP   = 0x00000008,
    RI_MOUSE_BUTTON_3_DOWN = 0x00000010,
    RI_MOUSE_BUTTON_3_UP   = 0x00000020,
    RI_MOUSE_BUTTON_4_DOWN = 0x00000040,
    RI_MOUSE_BUTTON_4_UP   = 0x00000080,
    RI_MOUSE_BUTTON_5_DOWN = 0x00000100,
    RI_MOUSE_BUTTON_5_UP   = 0x00000200,
    RI_MOUSE_WHEEL         = 0x00000400,
    RI_MOUSE_HWHEEL        = 0x00000800,
}

enum int MOUSE_MOVE_ABSOLUTE = 0x00000001;
enum int MOUSE_ATTRIBUTES_CHANGED = 0x00000004;
enum int KEYBOARD_OVERRUN_MAKE_CODE = 0x000000ff;

enum : int
{
    RI_KEY_BREAK           = 0x00000001,
    RI_KEY_E0              = 0x00000002,
    RI_KEY_E1              = 0x00000004,
    RI_KEY_TERMSRV_SET_LED = 0x00000008,
    RI_KEY_TERMSRV_SHADOW  = 0x00000010,
}

enum int RID_HEADER = 0x10000005;

enum : int
{
    RIDI_DEVICENAME = 0x20000007,
    RIDI_DEVICEINFO = 0x2000000b,
}

enum : int
{
    RIDEV_EXCLUDE   = 0x00000010,
    RIDEV_PAGEONLY  = 0x00000020,
    RIDEV_NOLEGACY  = 0x00000030,
    RIDEV_INPUTSINK = 0x00000100,
}

enum int RIDEV_NOHOTKEYS = 0x00000200;
enum int RIDEV_EXINPUTSINK = 0x00001000;
enum int RIDEV_EXMODEMASK = 0x000000f0;
enum int GIDC_REMOVAL = 0x00000002;
enum int PDC_ARRIVAL = 0x00000001;

enum : int
{
    PDC_ORIENTATION_0   = 0x00000004,
    PDC_ORIENTATION_90  = 0x00000008,
    PDC_ORIENTATION_180 = 0x00000010,
    PDC_ORIENTATION_270 = 0x00000020,
}

enum int PDC_MODE_CENTERED = 0x00000080;
enum int PDC_RESOLUTION = 0x00000200;
enum int PDC_MODE_ASPECTRATIOPRESERVED = 0x00000800;

enum : int
{
    MSGFLT_REMOVE                       = 0x00000002,
    MSGFLTINFO_NONE                     = 0x00000000,
    MSGFLTINFO_ALREADYALLOWED_FORWND    = 0x00000001,
    MSGFLTINFO_ALREADYDISALLOWED_FORWND = 0x00000002,
}

enum : int
{
    MSGFLT_RESET    = 0x00000000,
    MSGFLT_ALLOW    = 0x00000001,
    MSGFLT_DISALLOW = 0x00000002,
}

enum int GF_INERTIA = 0x00000002;

enum : int
{
    GID_BEGIN  = 0x00000001,
    GID_END    = 0x00000002,
    GID_ZOOM   = 0x00000003,
    GID_PAN    = 0x00000004,
    GID_ROTATE = 0x00000005,
}

enum int GID_PRESSANDTAP = 0x00000007;
enum int GC_ALLGESTURES = 0x00000001;

enum : int
{
    GC_PAN                                 = 0x00000001,
    GC_PAN_WITH_SINGLE_FINGER_VERTICALLY   = 0x00000002,
    GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY = 0x00000004,
}

enum int GC_PAN_WITH_INERTIA = 0x00000010;
enum int GC_TWOFINGERTAP = 0x00000001;
enum int GC_ROLLOVER = 0x00000001;
enum int NID_INTEGRATED_TOUCH = 0x00000001;
enum int NID_INTEGRATED_PEN = 0x00000004;
enum int NID_MULTI_INPUT = 0x00000040;
enum int MAX_STR_BLOCKREASON = 0x00000100;
enum uint INFINITE = 0xffffffff;

enum : int
{
    FACILITY_RPC                = 0x00000001,
    FACILITY_DISPATCH           = 0x00000002,
    FACILITY_STORAGE            = 0x00000003,
    FACILITY_ITF                = 0x00000004,
    FACILITY_WIN32              = 0x00000007,
    FACILITY_WINDOWS            = 0x00000008,
    FACILITY_SSPI               = 0x00000009,
    FACILITY_SECURITY           = 0x00000009,
    FACILITY_CONTROL            = 0x0000000a,
    FACILITY_CERT               = 0x0000000b,
    FACILITY_INTERNET           = 0x0000000c,
    FACILITY_MEDIASERVER        = 0x0000000d,
    FACILITY_MSMQ               = 0x0000000e,
    FACILITY_SETUPAPI           = 0x0000000f,
    FACILITY_SCARD              = 0x00000010,
    FACILITY_COMPLUS            = 0x00000011,
    FACILITY_AAF                = 0x00000012,
    FACILITY_URT                = 0x00000013,
    FACILITY_ACS                = 0x00000014,
    FACILITY_DPLAY              = 0x00000015,
    FACILITY_UMI                = 0x00000016,
    FACILITY_SXS                = 0x00000017,
    FACILITY_WINDOWS_CE         = 0x00000018,
    FACILITY_HTTP               = 0x00000019,
    FACILITY_USERMODE_COMMONLOG = 0x0000001a,
}

enum int FACILITY_USERMODE_FILTER_MANAGER = 0x0000001f;

enum : int
{
    FACILITY_CONFIGURATION    = 0x00000021,
    FACILITY_WIA              = 0x00000021,
    FACILITY_STATE_MANAGEMENT = 0x00000022,
}

enum : int
{
    FACILITY_WINDOWSUPDATE    = 0x00000024,
    FACILITY_DIRECTORYSERVICE = 0x00000025,
}

enum : int
{
    FACILITY_SHELL               = 0x00000027,
    FACILITY_NAP                 = 0x00000027,
    FACILITY_TPM_SERVICES        = 0x00000028,
    FACILITY_TPM_SOFTWARE        = 0x00000029,
    FACILITY_UI                  = 0x0000002a,
    FACILITY_XAML                = 0x0000002b,
    FACILITY_ACTION_QUEUE        = 0x0000002c,
    FACILITY_PLA                 = 0x00000030,
    FACILITY_WINDOWS_SETUP       = 0x00000030,
    FACILITY_FVE                 = 0x00000031,
    FACILITY_FWP                 = 0x00000032,
    FACILITY_WINRM               = 0x00000033,
    FACILITY_NDIS                = 0x00000034,
    FACILITY_USERMODE_HYPERVISOR = 0x00000035,
}

enum : int
{
    FACILITY_USERMODE_VIRTUALIZATION = 0x00000037,
    FACILITY_USERMODE_VOLMGR         = 0x00000038,
}

enum : int
{
    FACILITY_USERMODE_VHD     = 0x0000003a,
    FACILITY_USERMODE_HNS     = 0x0000003b,
    FACILITY_SDIAG            = 0x0000003c,
    FACILITY_WEBSERVICES      = 0x0000003d,
    FACILITY_WINPE            = 0x0000003d,
    FACILITY_WPN              = 0x0000003e,
    FACILITY_WINDOWS_STORE    = 0x0000003f,
    FACILITY_INPUT            = 0x00000040,
    FACILITY_QUIC             = 0x00000041,
    FACILITY_EAP              = 0x00000042,
    FACILITY_WINDOWS_DEFENDER = 0x00000050,
}

enum : int
{
    FACILITY_XPS             = 0x00000052,
    FACILITY_MBN             = 0x00000054,
    FACILITY_POWERSHELL      = 0x00000054,
    FACILITY_RAS             = 0x00000053,
    FACILITY_P2P_INT         = 0x00000062,
    FACILITY_P2P             = 0x00000063,
    FACILITY_DAF             = 0x00000064,
    FACILITY_BLUETOOTH_ATT   = 0x00000065,
    FACILITY_AUDIO           = 0x00000066,
    FACILITY_STATEREPOSITORY = 0x00000067,
}

enum : int
{
    FACILITY_SCRIPT           = 0x00000070,
    FACILITY_PARSE            = 0x00000071,
    FACILITY_BLB              = 0x00000078,
    FACILITY_BLB_CLI          = 0x00000079,
    FACILITY_WSBAPP           = 0x0000007a,
    FACILITY_BLBUI            = 0x00000080,
    FACILITY_USN              = 0x00000081,
    FACILITY_USERMODE_VOLSNAP = 0x00000082,
}

enum : int
{
    FACILITY_WSB_ONLINE          = 0x00000085,
    FACILITY_ONLINE_ID           = 0x00000086,
    FACILITY_DEVICE_UPDATE_AGENT = 0x00000087,
}

enum : int
{
    FACILITY_DLS                   = 0x00000099,
    FACILITY_DELIVERY_OPTIMIZATION = 0x000000d0,
}

enum : int
{
    FACILITY_USER_MODE_SECURITY_CORE = 0x000000e8,
    FACILITY_USERMODE_LICENSING      = 0x000000ea,
}

enum : int
{
    FACILITY_DEBUGGERS                                = 0x000000b0,
    FACILITY_SPP                                      = 0x00000100,
    FACILITY_RESTORE                                  = 0x00000100,
    FACILITY_DMSERVER                                 = 0x00000100,
    FACILITY_DEPLOYMENT_SERVICES_SERVER               = 0x00000101,
    FACILITY_DEPLOYMENT_SERVICES_IMAGING              = 0x00000102,
    FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT           = 0x00000103,
    FACILITY_DEPLOYMENT_SERVICES_UTIL                 = 0x00000104,
    FACILITY_DEPLOYMENT_SERVICES_BINLSVC              = 0x00000105,
    FACILITY_DEPLOYMENT_SERVICES_PXE                  = 0x00000107,
    FACILITY_DEPLOYMENT_SERVICES_TFTP                 = 0x00000108,
    FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = 0x00000110,
    FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING  = 0x00000116,
    FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER     = 0x00000121,
    FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT     = 0x00000122,
    FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER     = 0x00000125,
}

enum int FACILITY_AUDIOSTREAMING = 0x00000446;

enum : int
{
    FACILITY_ACCELERATOR      = 0x00000600,
    FACILITY_WMAAECMA         = 0x000007cc,
    FACILITY_DIRECTMUSIC      = 0x00000878,
    FACILITY_DIRECT3D10       = 0x00000879,
    FACILITY_DXGI             = 0x0000087a,
    FACILITY_DXGI_DDI         = 0x0000087b,
    FACILITY_DIRECT3D11       = 0x0000087c,
    FACILITY_DIRECT3D11_DEBUG = 0x0000087d,
    FACILITY_DIRECT3D12       = 0x0000087e,
    FACILITY_DIRECT3D12_DEBUG = 0x0000087f,
}

enum : int
{
    FACILITY_LEAP                = 0x00000888,
    FACILITY_AUDCLNT             = 0x00000889,
    FACILITY_WINCODEC_DWRITE_DWM = 0x00000898,
    FACILITY_WINML               = 0x00000890,
    FACILITY_DIRECT2D            = 0x00000899,
    FACILITY_DEFRAG              = 0x00000900,
    FACILITY_USERMODE_SDBUS      = 0x00000901,
}

enum : int
{
    FACILITY_PIDGENX    = 0x00000a01,
    FACILITY_EAS        = 0x00000055,
    FACILITY_WEB        = 0x00000375,
    FACILITY_WEB_SOCKET = 0x00000376,
    FACILITY_MOBILE     = 0x00000701,
    FACILITY_SQLITE     = 0x000007af,
    FACILITY_UTC        = 0x000007c5,
    FACILITY_WEP        = 0x00000801,
    FACILITY_SYNCENGINE = 0x00000802,
    FACILITY_XBOX       = 0x00000923,
    FACILITY_GAME       = 0x00000924,
    FACILITY_PIX        = 0x00000abc,
}

enum int NO_ERROR = 0x00000000;
enum int ERROR_INVALID_FUNCTION = 0x00000001;
enum int ERROR_PATH_NOT_FOUND = 0x00000003;
enum int ERROR_ACCESS_DENIED = 0x00000005;
enum int ERROR_ARENA_TRASHED = 0x00000007;
enum int ERROR_INVALID_BLOCK = 0x00000009;
enum int ERROR_BAD_FORMAT = 0x0000000b;
enum int ERROR_INVALID_DATA = 0x0000000d;
enum int ERROR_INVALID_DRIVE = 0x0000000f;
enum int ERROR_NOT_SAME_DEVICE = 0x00000011;
enum int ERROR_WRITE_PROTECT = 0x00000013;
enum int ERROR_NOT_READY = 0x00000015;

enum : int
{
    ERROR_CRC        = 0x00000017,
    ERROR_BAD_LENGTH = 0x00000018,
}

enum int ERROR_NOT_DOS_DISK = 0x0000001a;
enum int ERROR_OUT_OF_PAPER = 0x0000001c;
enum int ERROR_READ_FAULT = 0x0000001e;
enum int ERROR_SHARING_VIOLATION = 0x00000020;
enum int ERROR_WRONG_DISK = 0x00000022;

enum : int
{
    ERROR_HANDLE_EOF       = 0x00000026,
    ERROR_HANDLE_DISK_FULL = 0x00000027,
}

enum int ERROR_REM_NOT_LIST = 0x00000033;
enum int ERROR_BAD_NETPATH = 0x00000035;
enum int ERROR_DEV_NOT_EXIST = 0x00000037;
enum int ERROR_ADAP_HDW_ERR = 0x00000039;
enum int ERROR_UNEXP_NET_ERR = 0x0000003b;
enum int ERROR_PRINTQ_FULL = 0x0000003d;
enum int ERROR_PRINT_CANCELLED = 0x0000003f;
enum int ERROR_NETWORK_ACCESS_DENIED = 0x00000041;
enum int ERROR_BAD_NET_NAME = 0x00000043;
enum int ERROR_TOO_MANY_SESS = 0x00000045;

enum : int
{
    ERROR_REQ_NOT_ACCEP = 0x00000047,
    ERROR_REDIR_PAUSED  = 0x00000048,
}

enum int ERROR_CANNOT_MAKE = 0x00000052;
enum int ERROR_OUT_OF_STRUCTURES = 0x00000054;

enum : int
{
    ERROR_INVALID_PASSWORD  = 0x00000056,
    ERROR_INVALID_PARAMETER = 0x00000057,
}

enum int ERROR_NO_PROC_SLOTS = 0x00000059;
enum int ERROR_EXCL_SEM_ALREADY_OWNED = 0x00000065;
enum int ERROR_TOO_MANY_SEM_REQUESTS = 0x00000067;

enum : int
{
    ERROR_SEM_OWNER_DIED = 0x00000069,
    ERROR_SEM_USER_LIMIT = 0x0000006a,
}

enum int ERROR_DRIVE_LOCKED = 0x0000006c;
enum int ERROR_OPEN_FAILED = 0x0000006e;
enum int ERROR_DISK_FULL = 0x00000070;

enum : int
{
    ERROR_INVALID_TARGET_HANDLE = 0x00000072,
    ERROR_INVALID_CATEGORY      = 0x00000075,
    ERROR_INVALID_VERIFY_SWITCH = 0x00000076,
}

enum int ERROR_CALL_NOT_IMPLEMENTED = 0x00000078;
enum int ERROR_INSUFFICIENT_BUFFER = 0x0000007a;
enum int ERROR_INVALID_LEVEL = 0x0000007c;
enum int ERROR_MOD_NOT_FOUND = 0x0000007e;
enum int ERROR_WAIT_NO_CHILDREN = 0x00000080;
enum int ERROR_DIRECT_ACCESS_HANDLE = 0x00000082;
enum int ERROR_SEEK_ON_DEVICE = 0x00000084;

enum : int
{
    ERROR_IS_JOINED  = 0x00000086,
    ERROR_IS_SUBSTED = 0x00000087,
}

enum int ERROR_NOT_SUBSTED = 0x00000089;
enum int ERROR_SUBST_TO_SUBST = 0x0000008b;
enum int ERROR_SUBST_TO_JOIN = 0x0000008d;
enum int ERROR_SAME_DRIVE = 0x0000008f;
enum int ERROR_DIR_NOT_EMPTY = 0x00000091;
enum int ERROR_IS_JOIN_PATH = 0x00000093;
enum int ERROR_IS_SUBST_TARGET = 0x00000095;
enum int ERROR_INVALID_EVENT_COUNT = 0x00000097;
enum int ERROR_INVALID_LIST_FORMAT = 0x00000099;
enum int ERROR_TOO_MANY_TCBS = 0x0000009b;
enum int ERROR_DISCARDED = 0x0000009d;

enum : int
{
    ERROR_BAD_THREADID_ADDR = 0x0000009f,
    ERROR_BAD_ARGUMENTS     = 0x000000a0,
    ERROR_BAD_PATHNAME      = 0x000000a1,
}

enum int ERROR_MAX_THRDS_REACHED = 0x000000a4;

enum : int
{
    ERROR_BUSY                       = 0x000000aa,
    ERROR_DEVICE_SUPPORT_IN_PROGRESS = 0x000000ab,
}

enum int ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 0x000000ae;
enum int ERROR_INVALID_ORDINAL = 0x000000b6;
enum int ERROR_INVALID_FLAG_NUMBER = 0x000000ba;

enum : int
{
    ERROR_INVALID_STARTING_CODESEG = 0x000000bc,
    ERROR_INVALID_STACKSEG         = 0x000000bd,
    ERROR_INVALID_MODULETYPE       = 0x000000be,
    ERROR_INVALID_EXE_SIGNATURE    = 0x000000bf,
}

enum int ERROR_BAD_EXE_FORMAT = 0x000000c1;
enum int ERROR_INVALID_MINALLOCSIZE = 0x000000c3;
enum int ERROR_IOPL_NOT_ENABLED = 0x000000c5;
enum int ERROR_AUTODATASEG_EXCEEDS_64k = 0x000000c7;
enum int ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 0x000000c9;
enum int ERROR_ENVVAR_NOT_FOUND = 0x000000cb;
enum int ERROR_FILENAME_EXCED_RANGE = 0x000000ce;
enum int ERROR_META_EXPANSION_TOO_LONG = 0x000000d0;
enum int ERROR_THREAD_1_INACTIVE = 0x000000d2;
enum int ERROR_TOO_MANY_MODULES = 0x000000d6;
enum int ERROR_EXE_MACHINE_TYPE_MISMATCH = 0x000000d8;
enum int ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = 0x000000da;
enum int ERROR_CHECKOUT_REQUIRED = 0x000000dd;
enum int ERROR_FILE_TOO_LARGE = 0x000000df;

enum : int
{
    ERROR_VIRUS_INFECTED = 0x000000e1,
    ERROR_VIRUS_DELETED  = 0x000000e2,
}

enum : int
{
    ERROR_BAD_PIPE  = 0x000000e6,
    ERROR_PIPE_BUSY = 0x000000e7,
}

enum int ERROR_PIPE_NOT_CONNECTED = 0x000000e9;
enum int ERROR_NO_WORK_DONE = 0x000000eb;
enum int ERROR_INVALID_EA_NAME = 0x000000fe;
enum int WAIT_TIMEOUT = 0x00000102;
enum int ERROR_CANNOT_COPY = 0x0000010a;

enum : int
{
    ERROR_EAS_DIDNT_FIT   = 0x00000113,
    ERROR_EA_FILE_CORRUPT = 0x00000114,
    ERROR_EA_TABLE_FULL   = 0x00000115,
}

enum int ERROR_EAS_NOT_SUPPORTED = 0x0000011a;
enum int ERROR_TOO_MANY_POSTS = 0x0000012a;
enum int ERROR_OPLOCK_NOT_GRANTED = 0x0000012c;
enum int ERROR_DISK_TOO_FRAGMENTED = 0x0000012e;
enum int ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 0x00000130;
enum int ERROR_SECURITY_STREAM_IS_INCONSISTENT = 0x00000132;
enum int ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = 0x00000134;
enum int ERROR_INVALID_EXCEPTION_HANDLER = 0x00000136;
enum int ERROR_NO_RANGES_PROCESSED = 0x00000138;
enum int ERROR_DISK_RESOURCES_EXHAUSTED = 0x0000013a;
enum int ERROR_DEVICE_FEATURE_NOT_SUPPORTED = 0x0000013c;
enum int ERROR_SCOPE_NOT_FOUND = 0x0000013e;
enum int ERROR_INVALID_CAP = 0x00000140;
enum int ERROR_DEVICE_NO_RESOURCES = 0x00000142;
enum int ERROR_INTERMIXED_KERNEL_EA_OPERATION = 0x00000144;
enum int ERROR_OFFSET_ALIGNMENT_VIOLATION = 0x00000147;
enum int ERROR_OPERATION_IN_PROGRESS = 0x00000149;
enum int ERROR_TOO_MANY_DESCRIPTORS = 0x0000014b;
enum int ERROR_NOT_REDUNDANT_STORAGE = 0x0000014d;
enum int ERROR_COMPRESSED_FILE_NOT_SUPPORTED = 0x0000014f;
enum int ERROR_NOT_READ_FROM_COPY = 0x00000151;
enum int ERROR_FT_DI_SCAN_REQUIRED = 0x00000153;
enum int ERROR_INVALID_PEP_INFO_VERSION = 0x00000155;
enum int ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN = 0x00000157;
enum int ERROR_STORAGE_TOPOLOGY_ID_MISMATCH = 0x00000159;
enum int ERROR_BLOCK_TOO_MANY_REFERENCES = 0x0000015b;
enum int ERROR_ENCLAVE_FAILURE = 0x0000015d;

enum : int
{
    ERROR_FAIL_SHUTDOWN = 0x0000015f,
    ERROR_FAIL_RESTART  = 0x00000160,
}

enum int ERROR_NETWORK_ACCESS_DENIED_EDP = 0x00000162;
enum int ERROR_EDP_POLICY_DENIES_OPERATION = 0x00000164;
enum int ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT = 0x00000166;
enum int ERROR_NOT_SUPPORTED_ON_DAX = 0x00000168;

enum : int
{
    ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING            = 0x0000016a,
    ERROR_CLOUD_FILE_METADATA_CORRUPT                = 0x0000016b,
    ERROR_CLOUD_FILE_METADATA_TOO_LARGE              = 0x0000016c,
    ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE         = 0x0000016d,
    ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH = 0x0000016e,
}

enum int ERROR_STORAGE_LOST_DATA_PERSISTENCE = 0x00000170;

enum : int
{
    ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT = 0x00000172,
    ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY             = 0x00000173,
    ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN = 0x00000174,
}

enum : int
{
    ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS        = 0x00000176,
    ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED = 0x00000177,
}

enum : int
{
    ERROR_CLOUD_FILE_NOT_IN_SYNC             = 0x00000179,
    ERROR_CLOUD_FILE_ALREADY_CONNECTED       = 0x0000017a,
    ERROR_CLOUD_FILE_NOT_SUPPORTED           = 0x0000017b,
    ERROR_CLOUD_FILE_INVALID_REQUEST         = 0x0000017c,
    ERROR_CLOUD_FILE_READ_ONLY_VOLUME        = 0x0000017d,
    ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY = 0x0000017e,
    ERROR_CLOUD_FILE_VALIDATION_FAILED       = 0x0000017f,
}

enum int ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION = 0x00000181;

enum : int
{
    ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES = 0x00000183,
    ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE    = 0x00000184,
    ERROR_CLOUD_FILE_UNSUCCESSFUL           = 0x00000185,
    ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT    = 0x00000186,
    ERROR_CLOUD_FILE_IN_USE                 = 0x00000187,
    ERROR_CLOUD_FILE_PINNED                 = 0x00000188,
    ERROR_CLOUD_FILE_REQUEST_ABORTED        = 0x00000189,
    ERROR_CLOUD_FILE_PROPERTY_CORRUPT       = 0x0000018a,
    ERROR_CLOUD_FILE_ACCESS_DENIED          = 0x0000018b,
    ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS = 0x0000018c,
    ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT = 0x0000018d,
    ERROR_CLOUD_FILE_REQUEST_CANCELED       = 0x0000018e,
}

enum : int
{
    ERROR_THREAD_MODE_ALREADY_BACKGROUND = 0x00000190,
    ERROR_THREAD_MODE_NOT_BACKGROUND     = 0x00000191,
}

enum int ERROR_PROCESS_MODE_NOT_BACKGROUND = 0x00000193;
enum int ERROR_NOT_A_CLOUD_SYNC_ROOT = 0x00000195;
enum int ERROR_VOLUME_NOT_CLUSTER_ALIGNED = 0x00000197;
enum int ERROR_APPX_FILE_NOT_ENCRYPTED = 0x00000199;

enum : int
{
    ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET = 0x0000019b,
    ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE  = 0x0000019c,
    ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER  = 0x0000019d,
}

enum int ERROR_FT_READ_FAILURE = 0x0000019f;

enum : int
{
    ERROR_STORAGE_RESERVE_DOES_NOT_EXIST = 0x000001a1,
    ERROR_STORAGE_RESERVE_ALREADY_EXISTS = 0x000001a2,
    ERROR_STORAGE_RESERVE_NOT_EMPTY      = 0x000001a3,
}

enum int ERROR_NOT_DAX_MAPPABLE = 0x000001a5;
enum int ERROR_DPL_NOT_SUPPORTED_FOR_USER = 0x000001a7;
enum int ERROR_FILE_NOT_SUPPORTED = 0x000001a9;
enum int ERROR_NO_TASK_QUEUE = 0x000001ab;
enum int ERROR_NOT_SUPPORTED_WITH_BTT = 0x000001ad;
enum int ERROR_ENCRYPTING_METADATA_DISALLOWED = 0x000001af;
enum int ERROR_NO_SUCH_DEVICE = 0x000001b1;

enum : int
{
    ERROR_FILE_SNAP_IN_PROGRESS                = 0x000001b3,
    ERROR_FILE_SNAP_USER_SECTION_NOT_SUPPORTED = 0x000001b4,
}

enum : int
{
    ERROR_FILE_SNAP_IO_NOT_COORDINATED = 0x000001b6,
    ERROR_FILE_SNAP_UNEXPECTED_ERROR   = 0x000001b7,
    ERROR_FILE_SNAP_INVALID_PARAMETER  = 0x000001b8,
}

enum int ERROR_CASE_SENSITIVE_PATH = 0x000001ba;

enum : int
{
    ERROR_CAPAUTHZ_NOT_DEVUNLOCKED          = 0x000001c2,
    ERROR_CAPAUTHZ_CHANGE_TYPE              = 0x000001c3,
    ERROR_CAPAUTHZ_NOT_PROVISIONED          = 0x000001c4,
    ERROR_CAPAUTHZ_NOT_AUTHORIZED           = 0x000001c5,
    ERROR_CAPAUTHZ_NO_POLICY                = 0x000001c6,
    ERROR_CAPAUTHZ_DB_CORRUPTED             = 0x000001c7,
    ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG     = 0x000001c8,
    ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY      = 0x000001c9,
    ERROR_CAPAUTHZ_SCCD_PARSE_ERROR         = 0x000001ca,
    ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED   = 0x000001cb,
    ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH = 0x000001cc,
}

enum : int
{
    ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT   = 0x000001e1,
    ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT = 0x000001e2,
}

enum int ERROR_INVALID_ADDRESS = 0x000001e7;
enum int ERROR_PARTITION_TERMINATING = 0x000004a0;
enum int ERROR_ARITHMETIC_OVERFLOW = 0x00000216;
enum int ERROR_PIPE_LISTENING = 0x00000218;
enum int ERROR_ABIOS_ERROR = 0x0000021a;
enum int ERROR_WX86_ERROR = 0x0000021c;

enum : int
{
    ERROR_UNWIND    = 0x0000021e,
    ERROR_BAD_STACK = 0x0000021f,
}

enum int ERROR_INVALID_PORT_ATTRIBUTES = 0x00000221;
enum int ERROR_INVALID_QUOTA_LOWER = 0x00000223;
enum int ERROR_INSTRUCTION_MISALIGNMENT = 0x00000225;
enum int ERROR_PROFILING_NOT_STOPPED = 0x00000227;
enum int ERROR_PROFILING_AT_LIMIT = 0x00000229;
enum int ERROR_CANT_TERMINATE_SELF = 0x0000022b;

enum : int
{
    ERROR_UNEXPECTED_MM_MAP_ERROR  = 0x0000022d,
    ERROR_UNEXPECTED_MM_EXTEND_ERR = 0x0000022e,
}

enum int ERROR_NO_GUID_TRANSLATION = 0x00000230;

enum : int
{
    ERROR_INVALID_LDT_OFFSET     = 0x00000233,
    ERROR_INVALID_LDT_DESCRIPTOR = 0x00000234,
}

enum int ERROR_THREAD_NOT_IN_PROCESS = 0x00000236;
enum int ERROR_LOGON_SERVER_CONFLICT = 0x00000238;
enum int ERROR_NET_OPEN_FAILED = 0x0000023a;
enum int ERROR_CONTROL_C_EXIT = 0x0000023c;
enum int ERROR_UNHANDLED_EXCEPTION = 0x0000023e;
enum int ERROR_PAGEFILE_CREATE_FAILED = 0x00000240;
enum int ERROR_NO_PAGEFILE = 0x00000242;
enum int ERROR_NO_EVENT_PAIR = 0x00000244;
enum int ERROR_ILLEGAL_CHARACTER = 0x00000246;
enum int ERROR_FLOPPY_VOLUME = 0x00000248;
enum int ERROR_BACKUP_CONTROLLER = 0x0000024a;
enum int ERROR_FS_DRIVER_REQUIRED = 0x0000024c;
enum int ERROR_DEBUG_ATTACH_FAILED = 0x0000024e;
enum int ERROR_DATA_NOT_ACCEPTED = 0x00000250;
enum int ERROR_DRIVER_CANCEL_TIMEOUT = 0x00000252;
enum int ERROR_LOST_WRITEBEHIND_DATA = 0x00000254;
enum int ERROR_NOT_TINY_STREAM = 0x00000256;
enum int ERROR_CONVERT_TO_LARGE = 0x00000258;
enum int ERROR_ALLOCATE_BUCKET = 0x0000025a;
enum int ERROR_INVALID_VARIANT = 0x0000025c;
enum int ERROR_AUDIT_FAILED = 0x0000025e;
enum int ERROR_INSUFFICIENT_LOGON_INFO = 0x00000260;
enum int ERROR_BAD_SERVICE_ENTRYPOINT = 0x00000262;
enum int ERROR_IP_ADDRESS_CONFLICT2 = 0x00000264;
enum int ERROR_NO_CALLBACK_ACTIVE = 0x00000266;

enum : int
{
    ERROR_PWD_TOO_RECENT       = 0x00000268,
    ERROR_PWD_HISTORY_CONFLICT = 0x00000269,
}

enum : int
{
    ERROR_INVALID_HW_PROFILE           = 0x0000026b,
    ERROR_INVALID_PLUGPLAY_DEVICE_PATH = 0x0000026c,
}

enum int ERROR_EVALUATION_EXPIRATION = 0x0000026e;
enum int ERROR_DLL_INIT_FAILED_LOGOFF = 0x00000270;
enum int ERROR_NO_MORE_MATCHES = 0x00000272;
enum int ERROR_SERVER_SID_MISMATCH = 0x00000274;

enum : int
{
    ERROR_FLOAT_MULTIPLE_FAULTS = 0x00000276,
    ERROR_FLOAT_MULTIPLE_TRAPS  = 0x00000277,
}

enum int ERROR_DRIVER_FAILED_SLEEP = 0x00000279;
enum int ERROR_COMMITMENT_MINIMUM = 0x0000027b;
enum int ERROR_SYSTEM_IMAGE_BAD_SIGNATURE = 0x0000027d;
enum int ERROR_INSUFFICIENT_POWER = 0x0000027f;
enum int ERROR_SYSTEM_SHUTDOWN = 0x00000281;
enum int ERROR_DS_VERSION_CHECK_FAILURE = 0x00000283;
enum int ERROR_NOT_SAFE_MODE_DRIVER = 0x00000286;
enum int ERROR_DEVICE_ENUMERATION_ERROR = 0x00000288;
enum int ERROR_INVALID_DEVICE_OBJECT_PARAMETER = 0x0000028a;
enum int ERROR_DRIVER_DATABASE_ERROR = 0x0000028c;
enum int ERROR_DRIVER_FAILED_PRIOR_UNLOAD = 0x0000028e;
enum int ERROR_HIBERNATION_FAILURE = 0x00000290;
enum int ERROR_FILE_SYSTEM_LIMITATION = 0x00000299;
enum int ERROR_ACPI_ERROR = 0x0000029d;

enum : int
{
    ERROR_PNP_BAD_MPS_TABLE      = 0x0000029f,
    ERROR_PNP_TRANSLATION_FAILED = 0x000002a0,
}

enum int ERROR_PNP_INVALID_ID = 0x000002a2;
enum int ERROR_HANDLES_CLOSED = 0x000002a4;
enum int ERROR_RXACT_COMMIT_NECESSARY = 0x000002a6;
enum int ERROR_GUID_SUBSTITUTION_MADE = 0x000002a8;

enum : int
{
    ERROR_LONGJUMP              = 0x000002aa,
    ERROR_PLUGPLAY_QUERY_VETOED = 0x000002ab,
}

enum int ERROR_REGISTRY_HIVE_RECOVERED = 0x000002ad;
enum int ERROR_DLL_MIGHT_BE_INCOMPATIBLE = 0x000002af;

enum : int
{
    ERROR_DBG_REPLY_LATER              = 0x000002b1,
    ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE = 0x000002b2,
}

enum int ERROR_DBG_TERMINATE_PROCESS = 0x000002b4;
enum int ERROR_DBG_PRINTEXCEPTION_C = 0x000002b6;

enum : int
{
    ERROR_DBG_CONTROL_BREAK     = 0x000002b8,
    ERROR_DBG_COMMAND_EXCEPTION = 0x000002b9,
}

enum int ERROR_THREAD_WAS_SUSPENDED = 0x000002bb;
enum int ERROR_RXACT_STATE_CREATED = 0x000002bd;
enum int ERROR_BAD_CURRENT_DIRECTORY = 0x000002bf;
enum int ERROR_FT_WRITE_RECOVERY = 0x000002c1;

enum : int
{
    ERROR_RECEIVE_PARTIAL           = 0x000002c3,
    ERROR_RECEIVE_EXPEDITED         = 0x000002c4,
    ERROR_RECEIVE_PARTIAL_EXPEDITED = 0x000002c5,
}

enum int ERROR_EVENT_PENDING = 0x000002c7;
enum int ERROR_FATAL_APP_EXIT = 0x000002c9;
enum int ERROR_WAS_UNLOCKED = 0x000002cb;
enum int ERROR_WAS_LOCKED = 0x000002cd;
enum int ERROR_ALREADY_WIN32 = 0x000002cf;
enum int ERROR_NO_YIELD_PERFORMED = 0x000002d1;
enum int ERROR_ARBITRATION_UNHANDLED = 0x000002d3;
enum int ERROR_MP_PROCESSOR_MISMATCH = 0x000002d5;
enum int ERROR_RESUME_HIBERNATION = 0x000002d7;
enum int ERROR_DRIVERS_LEAKING_LOCKED_PAGES = 0x000002d9;

enum : int
{
    ERROR_WAIT_1            = 0x000002db,
    ERROR_WAIT_2            = 0x000002dc,
    ERROR_WAIT_3            = 0x000002dd,
    ERROR_WAIT_63           = 0x000002de,
    ERROR_ABANDONED_WAIT_0  = 0x000002df,
    ERROR_ABANDONED_WAIT_63 = 0x000002e0,
}

enum int ERROR_KERNEL_APC = 0x000002e2;
enum int ERROR_ELEVATION_REQUIRED = 0x000002e4;
enum int ERROR_OPLOCK_BREAK_IN_PROGRESS = 0x000002e6;
enum int ERROR_RXACT_COMMITTED = 0x000002e8;
enum int ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED = 0x000002ea;

enum : int
{
    ERROR_PAGE_FAULT_DEMAND_ZERO   = 0x000002ec,
    ERROR_PAGE_FAULT_COPY_ON_WRITE = 0x000002ed,
    ERROR_PAGE_FAULT_GUARD_PAGE    = 0x000002ee,
    ERROR_PAGE_FAULT_PAGING_FILE   = 0x000002ef,
}

enum int ERROR_CRASH_DUMP = 0x000002f1;
enum int ERROR_REPARSE_OBJECT = 0x000002f3;
enum int ERROR_TRANSLATION_COMPLETE = 0x000002f5;

enum : int
{
    ERROR_PROCESS_NOT_IN_JOB = 0x000002f7,
    ERROR_PROCESS_IN_JOB     = 0x000002f8,
}

enum int ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY = 0x000002fa;
enum int ERROR_INTERRUPT_STILL_CONNECTED = 0x000002fc;
enum int ERROR_DBG_EXCEPTION_HANDLED = 0x000002fe;
enum int ERROR_CALLBACK_POP_STACK = 0x00000300;

enum : int
{
    ERROR_CANTFETCHBACKWARDS  = 0x00000302,
    ERROR_CANTSCROLLBACKWARDS = 0x00000303,
}

enum int ERROR_BAD_ACCESSOR_FLAGS = 0x00000305;
enum int ERROR_NOT_CAPABLE = 0x00000307;
enum int ERROR_VERSION_PARSE_ERROR = 0x00000309;
enum int ERROR_MEMORY_HARDWARE = 0x0000030b;
enum int ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 0x0000030d;
enum int ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = 0x0000030f;

enum : int
{
    ERROR_ACCESS_AUDIT_BY_POLICY                = 0x00000311,
    ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 0x00000312,
}

enum : int
{
    ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = 0x00000314,
    ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = 0x00000315,
    ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR     = 0x00000316,
}

enum : int
{
    ERROR_DISK_REPAIR_REDIRECTED   = 0x00000318,
    ERROR_DISK_REPAIR_UNSUCCESSFUL = 0x00000319,
}

enum : int
{
    ERROR_CORRUPT_LOG_CORRUPTED    = 0x0000031b,
    ERROR_CORRUPT_LOG_UNAVAILABLE  = 0x0000031c,
    ERROR_CORRUPT_LOG_DELETED_FULL = 0x0000031d,
    ERROR_CORRUPT_LOG_CLEARED      = 0x0000031e,
}

enum int ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE = 0x00000320;
enum int ERROR_CANNOT_BREAK_OPLOCK = 0x00000322;
enum int ERROR_NO_ACE_CONDITION = 0x00000324;
enum int ERROR_FILE_HANDLE_REVOKED = 0x00000326;
enum int ERROR_ENCRYPTED_IO_NOT_POSSIBLE = 0x00000328;
enum int ERROR_QUOTA_ACTIVITY = 0x0000032a;
enum int ERROR_CALLBACK_INVOKE_INLINE = 0x0000032c;

enum : int
{
    ERROR_ENCLAVE_NOT_TERMINATED = 0x0000032e,
    ERROR_ENCLAVE_VIOLATION      = 0x0000032f,
}

enum int ERROR_OPERATION_ABORTED = 0x000003e3;
enum int ERROR_IO_PENDING = 0x000003e5;

enum : int
{
    ERROR_SWAPERROR      = 0x000003e7,
    ERROR_STACK_OVERFLOW = 0x000003e9,
}

enum int ERROR_CAN_NOT_COMPLETE = 0x000003eb;
enum int ERROR_UNRECOGNIZED_VOLUME = 0x000003ed;
enum int ERROR_FULLSCREEN_MODE = 0x000003ef;

enum : int
{
    ERROR_BADDB     = 0x000003f1,
    ERROR_BADKEY    = 0x000003f2,
    ERROR_CANTOPEN  = 0x000003f3,
    ERROR_CANTREAD  = 0x000003f4,
    ERROR_CANTWRITE = 0x000003f5,
}

enum : int
{
    ERROR_REGISTRY_CORRUPT   = 0x000003f7,
    ERROR_REGISTRY_IO_FAILED = 0x000003f8,
}

enum int ERROR_KEY_DELETED = 0x000003fa;
enum int ERROR_KEY_HAS_CHILDREN = 0x000003fc;
enum int ERROR_NOTIFY_ENUM_DIR = 0x000003fe;
enum int ERROR_INVALID_SERVICE_CONTROL = 0x0000041c;

enum : int
{
    ERROR_SERVICE_NO_THREAD       = 0x0000041e,
    ERROR_SERVICE_DATABASE_LOCKED = 0x0000041f,
    ERROR_SERVICE_ALREADY_RUNNING = 0x00000420,
}

enum int ERROR_SERVICE_DISABLED = 0x00000422;

enum : int
{
    ERROR_SERVICE_DOES_NOT_EXIST     = 0x00000424,
    ERROR_SERVICE_CANNOT_ACCEPT_CTRL = 0x00000425,
    ERROR_SERVICE_NOT_ACTIVE         = 0x00000426,
}

enum int ERROR_EXCEPTION_IN_SERVICE = 0x00000428;
enum int ERROR_SERVICE_SPECIFIC_ERROR = 0x0000042a;

enum : int
{
    ERROR_SERVICE_DEPENDENCY_FAIL = 0x0000042c,
    ERROR_SERVICE_LOGON_FAILED    = 0x0000042d,
    ERROR_SERVICE_START_HANG      = 0x0000042e,
}

enum : int
{
    ERROR_SERVICE_MARKED_FOR_DELETE = 0x00000430,
    ERROR_SERVICE_EXISTS            = 0x00000431,
}

enum int ERROR_SERVICE_DEPENDENCY_DELETED = 0x00000433;
enum int ERROR_SERVICE_NEVER_STARTED = 0x00000435;
enum int ERROR_DIFFERENT_SERVICE_ACCOUNT = 0x00000437;
enum int ERROR_CANNOT_DETECT_PROCESS_ABORT = 0x00000439;
enum int ERROR_SERVICE_NOT_IN_EXE = 0x0000043b;
enum int ERROR_END_OF_MEDIA = 0x0000044c;
enum int ERROR_BEGINNING_OF_MEDIA = 0x0000044e;
enum int ERROR_NO_DATA_DETECTED = 0x00000450;
enum int ERROR_INVALID_BLOCK_LENGTH = 0x00000452;

enum : int
{
    ERROR_UNABLE_TO_LOCK_MEDIA   = 0x00000454,
    ERROR_UNABLE_TO_UNLOAD_MEDIA = 0x00000455,
}

enum int ERROR_BUS_RESET = 0x00000457;
enum int ERROR_NO_UNICODE_TRANSLATION = 0x00000459;
enum int ERROR_SHUTDOWN_IN_PROGRESS = 0x0000045b;
enum int ERROR_IO_DEVICE = 0x0000045d;

enum : int
{
    ERROR_IRQ_BUSY    = 0x0000045f,
    ERROR_MORE_WRITES = 0x00000460,
}

enum : int
{
    ERROR_FLOPPY_ID_MARK_NOT_FOUND = 0x00000462,
    ERROR_FLOPPY_WRONG_CYLINDER    = 0x00000463,
    ERROR_FLOPPY_UNKNOWN_ERROR     = 0x00000464,
    ERROR_FLOPPY_BAD_REGISTERS     = 0x00000465,
}

enum : int
{
    ERROR_DISK_OPERATION_FAILED = 0x00000467,
    ERROR_DISK_RESET_FAILED     = 0x00000468,
}

enum int ERROR_NOT_ENOUGH_SERVER_MEMORY = 0x0000046a;
enum int ERROR_MAPPED_ALIGNMENT = 0x0000046c;
enum int ERROR_SET_POWER_STATE_FAILED = 0x00000475;
enum int ERROR_OLD_WIN_VERSION = 0x0000047e;
enum int ERROR_SINGLE_INSTANCE_APP = 0x00000480;
enum int ERROR_INVALID_DLL = 0x00000482;

enum : int
{
    ERROR_DDE_FAIL      = 0x00000484,
    ERROR_DLL_NOT_FOUND = 0x00000485,
}

enum int ERROR_MESSAGE_SYNC_ONLY = 0x00000487;
enum int ERROR_DESTINATION_ELEMENT_FULL = 0x00000489;
enum int ERROR_MAGAZINE_NOT_PRESENT = 0x0000048b;

enum : int
{
    ERROR_DEVICE_REQUIRES_CLEANING = 0x0000048d,
    ERROR_DEVICE_DOOR_OPEN         = 0x0000048e,
    ERROR_DEVICE_NOT_CONNECTED     = 0x0000048f,
}

enum : int
{
    ERROR_NO_MATCH      = 0x00000491,
    ERROR_SET_NOT_FOUND = 0x00000492,
}

enum int ERROR_NO_TRACKING_SERVICE = 0x00000494;

enum : int
{
    ERROR_UNABLE_TO_REMOVE_REPLACED    = 0x00000497,
    ERROR_UNABLE_TO_MOVE_REPLACEMENT   = 0x00000498,
    ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 = 0x00000499,
}

enum int ERROR_JOURNAL_NOT_ACTIVE = 0x0000049b;
enum int ERROR_JOURNAL_ENTRY_DELETED = 0x0000049d;
enum int ERROR_SHUTDOWN_USERS_LOGGED_ON = 0x000004a7;
enum int ERROR_CONNECTION_UNAVAIL = 0x000004b1;
enum int ERROR_NO_NET_OR_BAD_PATH = 0x000004b3;
enum int ERROR_CANNOT_OPEN_PROFILE = 0x000004b5;
enum int ERROR_NOT_CONTAINER = 0x000004b7;

enum : int
{
    ERROR_INVALID_GROUPNAME    = 0x000004b9,
    ERROR_INVALID_COMPUTERNAME = 0x000004ba,
    ERROR_INVALID_EVENTNAME    = 0x000004bb,
    ERROR_INVALID_DOMAINNAME   = 0x000004bc,
    ERROR_INVALID_SERVICENAME  = 0x000004bd,
    ERROR_INVALID_NETNAME      = 0x000004be,
    ERROR_INVALID_SHARENAME    = 0x000004bf,
    ERROR_INVALID_PASSWORDNAME = 0x000004c0,
    ERROR_INVALID_MESSAGENAME  = 0x000004c1,
    ERROR_INVALID_MESSAGEDEST  = 0x000004c2,
}

enum int ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = 0x000004c4;
enum int ERROR_NO_NETWORK = 0x000004c6;
enum int ERROR_USER_MAPPED_FILE = 0x000004c8;
enum int ERROR_GRACEFUL_DISCONNECT = 0x000004ca;
enum int ERROR_ADDRESS_NOT_ASSOCIATED = 0x000004cc;
enum int ERROR_CONNECTION_ACTIVE = 0x000004ce;
enum int ERROR_HOST_UNREACHABLE = 0x000004d0;
enum int ERROR_PORT_UNREACHABLE = 0x000004d2;
enum int ERROR_CONNECTION_ABORTED = 0x000004d4;
enum int ERROR_CONNECTION_COUNT_LIMIT = 0x000004d6;
enum int ERROR_LOGIN_WKSTA_RESTRICTION = 0x000004d8;
enum int ERROR_ALREADY_REGISTERED = 0x000004da;

enum : int
{
    ERROR_NOT_AUTHENTICATED = 0x000004dc,
    ERROR_NOT_LOGGED_ON     = 0x000004dd,
}

enum int ERROR_ALREADY_INITIALIZED = 0x000004df;
enum int ERROR_NO_SUCH_SITE = 0x000004e1;
enum int ERROR_ONLY_IF_CONNECTED = 0x000004e3;
enum int ERROR_BAD_USER_PROFILE = 0x000004e5;
enum int ERROR_SERVER_SHUTDOWN_IN_PROGRESS = 0x000004e7;

enum : int
{
    ERROR_NON_ACCOUNT_SID = 0x000004e9,
    ERROR_NON_DOMAIN_SID  = 0x000004ea,
}

enum int ERROR_ACCESS_DISABLED_BY_POLICY = 0x000004ec;
enum int ERROR_CSCSHARE_OFFLINE = 0x000004ee;
enum int ERROR_SMARTCARD_SUBSYSTEM_FAILURE = 0x000004f0;
enum int ERROR_MACHINE_LOCKED = 0x000004f7;
enum int ERROR_CALLBACK_SUPPLIED_INVALID_DATA = 0x000004f9;
enum int ERROR_DRIVER_BLOCKED = 0x000004fb;

enum : int
{
    ERROR_ACCESS_DISABLED_WEBBLADE        = 0x000004fd,
    ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER = 0x000004fe,
}

enum : int
{
    ERROR_ALREADY_FIBER  = 0x00000500,
    ERROR_ALREADY_THREAD = 0x00000501,
}

enum int ERROR_PARAMETER_QUOTA_EXCEEDED = 0x00000503;
enum int ERROR_DELAY_LOAD_FAILED = 0x00000505;
enum int ERROR_UNIDENTIFIED_ERROR = 0x00000507;
enum int ERROR_BEYOND_VDL = 0x00000509;
enum int ERROR_DRIVER_PROCESS_TERMINATED = 0x0000050b;
enum int ERROR_PROCESS_IS_PROTECTED = 0x0000050d;
enum int ERROR_DISK_QUOTA_EXCEEDED = 0x0000050f;
enum int ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE = 0x00000511;
enum int ERROR_INVALID_LABEL = 0x00000513;
enum int ERROR_SOME_NOT_MAPPED = 0x00000515;
enum int ERROR_LOCAL_USER_SESSION_KEY = 0x00000517;
enum int ERROR_UNKNOWN_REVISION = 0x00000519;

enum : int
{
    ERROR_INVALID_OWNER         = 0x0000051b,
    ERROR_INVALID_PRIMARY_GROUP = 0x0000051c,
}

enum int ERROR_CANT_DISABLE_MANDATORY = 0x0000051e;

enum : int
{
    ERROR_NO_SUCH_LOGON_SESSION = 0x00000520,
    ERROR_NO_SUCH_PRIVILEGE     = 0x00000521,
}

enum int ERROR_INVALID_ACCOUNT_NAME = 0x00000523;
enum int ERROR_NO_SUCH_USER = 0x00000525;
enum int ERROR_NO_SUCH_GROUP = 0x00000527;
enum int ERROR_MEMBER_NOT_IN_GROUP = 0x00000529;
enum int ERROR_WRONG_PASSWORD = 0x0000052b;
enum int ERROR_PASSWORD_RESTRICTION = 0x0000052d;
enum int ERROR_ACCOUNT_RESTRICTION = 0x0000052f;
enum int ERROR_INVALID_WORKSTATION = 0x00000531;
enum int ERROR_ACCOUNT_DISABLED = 0x00000533;
enum int ERROR_TOO_MANY_LUIDS_REQUESTED = 0x00000535;

enum : int
{
    ERROR_INVALID_SUB_AUTHORITY  = 0x00000537,
    ERROR_INVALID_ACL            = 0x00000538,
    ERROR_INVALID_SID            = 0x00000539,
    ERROR_INVALID_SECURITY_DESCR = 0x0000053a,
}

enum : int
{
    ERROR_SERVER_DISABLED     = 0x0000053d,
    ERROR_SERVER_NOT_DISABLED = 0x0000053e,
}

enum int ERROR_ALLOTTED_SPACE_EXCEEDED = 0x00000540;
enum int ERROR_BAD_IMPERSONATION_LEVEL = 0x00000542;
enum int ERROR_BAD_VALIDATION_CLASS = 0x00000544;
enum int ERROR_NO_SECURITY_ON_OBJECT = 0x00000546;

enum : int
{
    ERROR_INVALID_SERVER_STATE = 0x00000548,
    ERROR_INVALID_DOMAIN_STATE = 0x00000549,
    ERROR_INVALID_DOMAIN_ROLE  = 0x0000054a,
}

enum : int
{
    ERROR_DOMAIN_EXISTS         = 0x0000054c,
    ERROR_DOMAIN_LIMIT_EXCEEDED = 0x0000054d,
}

enum int ERROR_INTERNAL_ERROR = 0x0000054f;
enum int ERROR_BAD_DESCRIPTOR_FORMAT = 0x00000551;
enum int ERROR_LOGON_SESSION_EXISTS = 0x00000553;
enum int ERROR_BAD_LOGON_SESSION_STATE = 0x00000555;
enum int ERROR_INVALID_LOGON_TYPE = 0x00000557;

enum : int
{
    ERROR_RXACT_INVALID_STATE  = 0x00000559,
    ERROR_RXACT_COMMIT_FAILURE = 0x0000055a,
}

enum : int
{
    ERROR_SPECIAL_GROUP = 0x0000055c,
    ERROR_SPECIAL_USER  = 0x0000055d,
}

enum int ERROR_TOKEN_ALREADY_IN_USE = 0x0000055f;

enum : int
{
    ERROR_MEMBER_NOT_IN_ALIAS = 0x00000561,
    ERROR_MEMBER_IN_ALIAS     = 0x00000562,
}

enum int ERROR_LOGON_NOT_GRANTED = 0x00000564;
enum int ERROR_SECRET_TOO_LONG = 0x00000566;
enum int ERROR_TOO_MANY_CONTEXT_IDS = 0x00000568;
enum int ERROR_NT_CROSS_ENCRYPTION_REQUIRED = 0x0000056a;
enum int ERROR_INVALID_MEMBER = 0x0000056c;
enum int ERROR_LM_CROSS_ENCRYPTION_REQUIRED = 0x0000056e;
enum int ERROR_FILE_CORRUPT = 0x00000570;
enum int ERROR_NO_USER_SESSION_KEY = 0x00000572;
enum int ERROR_WRONG_TARGET_NAME = 0x00000574;
enum int ERROR_TIME_SKEW = 0x00000576;

enum : int
{
    ERROR_INVALID_WINDOW_HANDLE = 0x00000578,
    ERROR_INVALID_MENU_HANDLE   = 0x00000579,
    ERROR_INVALID_CURSOR_HANDLE = 0x0000057a,
    ERROR_INVALID_ACCEL_HANDLE  = 0x0000057b,
    ERROR_INVALID_HOOK_HANDLE   = 0x0000057c,
    ERROR_INVALID_DWP_HANDLE    = 0x0000057d,
}

enum int ERROR_CANNOT_FIND_WND_CLASS = 0x0000057f;
enum int ERROR_HOTKEY_ALREADY_REGISTERED = 0x00000581;

enum : int
{
    ERROR_CLASS_DOES_NOT_EXIST = 0x00000583,
    ERROR_CLASS_HAS_WINDOWS    = 0x00000584,
}

enum int ERROR_INVALID_ICON_HANDLE = 0x00000586;
enum int ERROR_LISTBOX_ID_NOT_FOUND = 0x00000588;
enum int ERROR_CLIPBOARD_NOT_OPEN = 0x0000058a;
enum int ERROR_WINDOW_NOT_DIALOG = 0x0000058c;
enum int ERROR_INVALID_COMBOBOX_MESSAGE = 0x0000058e;
enum int ERROR_INVALID_EDIT_HEIGHT = 0x00000590;

enum : int
{
    ERROR_INVALID_HOOK_FILTER = 0x00000592,
    ERROR_INVALID_FILTER_PROC = 0x00000593,
}

enum int ERROR_GLOBAL_ONLY_HOOK = 0x00000595;
enum int ERROR_HOOK_NOT_INSTALLED = 0x00000597;
enum int ERROR_SETCOUNT_ON_BAD_LB = 0x00000599;
enum int ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = 0x0000059b;
enum int ERROR_NO_SYSTEM_MENU = 0x0000059d;
enum int ERROR_INVALID_SPI_VALUE = 0x0000059f;
enum int ERROR_HWNDS_HAVE_DIFF_PARENT = 0x000005a1;

enum : int
{
    ERROR_INVALID_GW_COMMAND = 0x000005a3,
    ERROR_INVALID_THREAD_ID  = 0x000005a4,
}

enum int ERROR_POPUP_ALREADY_ACTIVE = 0x000005a6;

enum : int
{
    ERROR_INVALID_SCROLLBAR_RANGE = 0x000005a8,
    ERROR_INVALID_SHOWWIN_COMMAND = 0x000005a9,
}

enum int ERROR_NONPAGED_SYSTEM_RESOURCES = 0x000005ab;
enum int ERROR_WORKING_SET_QUOTA = 0x000005ad;
enum int ERROR_COMMITMENT_LIMIT = 0x000005af;
enum int ERROR_INVALID_KEYBOARD_HANDLE = 0x000005b1;
enum int ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = 0x000005b3;
enum int ERROR_INVALID_MONITOR_HANDLE = 0x000005b5;

enum : int
{
    ERROR_SYMLINK_CLASS_DISABLED = 0x000005b7,
    ERROR_SYMLINK_NOT_SUPPORTED  = 0x000005b8,
}

enum int ERROR_XMLDSIG_ERROR = 0x000005ba;
enum int ERROR_WRONG_COMPARTMENT = 0x000005bc;
enum int ERROR_NO_NVRAM_RESOURCES = 0x000005be;

enum : int
{
    ERROR_EVENTLOG_FILE_CORRUPT = 0x000005dc,
    ERROR_EVENTLOG_CANT_START   = 0x000005dd,
}

enum int ERROR_EVENTLOG_FILE_CHANGED = 0x000005df;
enum int ERROR_JOB_NO_CONTAINER = 0x000005e1;
enum int ERROR_INVALID_TASK_INDEX = 0x0000060f;

enum : int
{
    ERROR_INSTALL_SERVICE_FAILURE = 0x00000641,
    ERROR_INSTALL_USEREXIT        = 0x00000642,
    ERROR_INSTALL_FAILURE         = 0x00000643,
    ERROR_INSTALL_SUSPEND         = 0x00000644,
}

enum : int
{
    ERROR_UNKNOWN_FEATURE   = 0x00000646,
    ERROR_UNKNOWN_COMPONENT = 0x00000647,
    ERROR_UNKNOWN_PROPERTY  = 0x00000648,
}

enum int ERROR_BAD_CONFIGURATION = 0x0000064a;

enum : int
{
    ERROR_INSTALL_SOURCE_ABSENT   = 0x0000064c,
    ERROR_INSTALL_PACKAGE_VERSION = 0x0000064d,
}

enum int ERROR_BAD_QUERY_SYNTAX = 0x0000064f;
enum int ERROR_DEVICE_REMOVED = 0x00000651;

enum : int
{
    ERROR_INSTALL_PACKAGE_OPEN_FAILED  = 0x00000653,
    ERROR_INSTALL_PACKAGE_INVALID      = 0x00000654,
    ERROR_INSTALL_UI_FAILURE           = 0x00000655,
    ERROR_INSTALL_LOG_FAILURE          = 0x00000656,
    ERROR_INSTALL_LANGUAGE_UNSUPPORTED = 0x00000657,
    ERROR_INSTALL_TRANSFORM_FAILURE    = 0x00000658,
    ERROR_INSTALL_PACKAGE_REJECTED     = 0x00000659,
}

enum int ERROR_FUNCTION_FAILED = 0x0000065b;
enum int ERROR_DATATYPE_MISMATCH = 0x0000065d;
enum int ERROR_CREATE_FAILED = 0x0000065f;

enum : int
{
    ERROR_INSTALL_PLATFORM_UNSUPPORTED = 0x00000661,
    ERROR_INSTALL_NOTUSED              = 0x00000662,
}

enum : int
{
    ERROR_PATCH_PACKAGE_INVALID     = 0x00000664,
    ERROR_PATCH_PACKAGE_UNSUPPORTED = 0x00000665,
}

enum int ERROR_INVALID_COMMAND_LINE = 0x00000667;
enum int ERROR_SUCCESS_REBOOT_INITIATED = 0x00000669;
enum int ERROR_PATCH_PACKAGE_REJECTED = 0x0000066b;
enum int ERROR_INSTALL_REMOTE_PROHIBITED = 0x0000066d;
enum int ERROR_UNKNOWN_PATCH = 0x0000066f;
enum int ERROR_PATCH_REMOVAL_DISALLOWED = 0x00000671;
enum int ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT = 0x00000673;
enum int ERROR_FAIL_FAST_EXCEPTION = 0x00000675;
enum int ERROR_DYNAMIC_CODE_BLOCKED = 0x00000677;
enum int ERROR_STRICT_CFG_VIOLATION = 0x00000679;
enum int ERROR_CROSS_PARTITION_VIOLATION = 0x0000067d;
enum int RPC_S_INVALID_STRING_BINDING = 0x000006a4;
enum int RPC_S_INVALID_BINDING = 0x000006a6;

enum : int
{
    RPC_S_INVALID_RPC_PROTSEQ     = 0x000006a8,
    RPC_S_INVALID_STRING_UUID     = 0x000006a9,
    RPC_S_INVALID_ENDPOINT_FORMAT = 0x000006aa,
    RPC_S_INVALID_NET_ADDR        = 0x000006ab,
}

enum int RPC_S_INVALID_TIMEOUT = 0x000006ad;
enum int RPC_S_ALREADY_REGISTERED = 0x000006af;
enum int RPC_S_ALREADY_LISTENING = 0x000006b1;
enum int RPC_S_NOT_LISTENING = 0x000006b3;
enum int RPC_S_UNKNOWN_IF = 0x000006b5;
enum int RPC_S_NO_PROTSEQS = 0x000006b7;
enum int RPC_S_OUT_OF_RESOURCES = 0x000006b9;
enum int RPC_S_SERVER_TOO_BUSY = 0x000006bb;
enum int RPC_S_NO_CALL_ACTIVE = 0x000006bd;
enum int RPC_S_CALL_FAILED_DNE = 0x000006bf;
enum int RPC_S_PROXY_ACCESS_DENIED = 0x000006c1;
enum int RPC_S_UNSUPPORTED_TYPE = 0x000006c4;
enum int RPC_S_INVALID_BOUND = 0x000006c6;
enum int RPC_S_INVALID_NAME_SYNTAX = 0x000006c8;
enum int RPC_S_UUID_NO_ADDRESS = 0x000006cb;
enum int RPC_S_UNKNOWN_AUTHN_TYPE = 0x000006cd;
enum int RPC_S_STRING_TOO_LONG = 0x000006cf;
enum int RPC_S_PROCNUM_OUT_OF_RANGE = 0x000006d1;

enum : int
{
    RPC_S_UNKNOWN_AUTHN_SERVICE = 0x000006d3,
    RPC_S_UNKNOWN_AUTHN_LEVEL   = 0x000006d4,
}

enum int RPC_S_UNKNOWN_AUTHZ_SERVICE = 0x000006d6;
enum int EPT_S_CANT_PERFORM_OP = 0x000006d8;
enum int RPC_S_NOTHING_TO_EXPORT = 0x000006da;
enum int RPC_S_INVALID_VERS_OPTION = 0x000006dc;
enum int RPC_S_NOT_ALL_OBJS_UNEXPORTED = 0x000006de;

enum : int
{
    RPC_S_ENTRY_ALREADY_EXISTS = 0x000006e0,
    RPC_S_ENTRY_NOT_FOUND      = 0x000006e1,
}

enum int RPC_S_INVALID_NAF_ID = 0x000006e3;
enum int RPC_S_NO_CONTEXT_AVAILABLE = 0x000006e5;
enum int RPC_S_ZERO_DIVIDE = 0x000006e7;

enum : int
{
    RPC_S_FP_DIV_ZERO  = 0x000006e9,
    RPC_S_FP_UNDERFLOW = 0x000006ea,
    RPC_S_FP_OVERFLOW  = 0x000006eb,
}

enum : int
{
    RPC_X_SS_CHAR_TRANS_OPEN_FAIL  = 0x000006ed,
    RPC_X_SS_CHAR_TRANS_SHORT_FILE = 0x000006ee,
}

enum int RPC_X_SS_CONTEXT_DAMAGED = 0x000006f1;
enum int RPC_X_SS_CANNOT_GET_CALL_HANDLE = 0x000006f3;
enum int RPC_X_ENUM_VALUE_OUT_OF_RANGE = 0x000006f5;
enum int RPC_X_BAD_STUB_DATA = 0x000006f7;
enum int ERROR_UNRECOGNIZED_MEDIA = 0x000006f9;
enum int ERROR_NO_TRUST_SAM_ACCOUNT = 0x000006fb;
enum int ERROR_TRUSTED_RELATIONSHIP_FAILURE = 0x000006fd;
enum int RPC_S_CALL_IN_PROGRESS = 0x000006ff;
enum int ERROR_ACCOUNT_EXPIRED = 0x00000701;
enum int ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = 0x00000703;

enum : int
{
    ERROR_UNKNOWN_PRINTER_DRIVER = 0x00000705,
    ERROR_UNKNOWN_PRINTPROCESSOR = 0x00000706,
}

enum : int
{
    ERROR_INVALID_PRIORITY     = 0x00000708,
    ERROR_INVALID_PRINTER_NAME = 0x00000709,
}

enum : int
{
    ERROR_INVALID_PRINTER_COMMAND = 0x0000070b,
    ERROR_INVALID_DATATYPE        = 0x0000070c,
    ERROR_INVALID_ENVIRONMENT     = 0x0000070d,
}

enum int ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 0x0000070f;
enum int ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = 0x00000711;
enum int ERROR_SERVER_HAS_OPEN_HANDLES = 0x00000713;

enum : int
{
    ERROR_RESOURCE_TYPE_NOT_FOUND = 0x00000715,
    ERROR_RESOURCE_NAME_NOT_FOUND = 0x00000716,
    ERROR_RESOURCE_LANG_NOT_FOUND = 0x00000717,
}

enum int RPC_S_NO_INTERFACES = 0x00000719;
enum int RPC_S_BINDING_INCOMPLETE = 0x0000071b;
enum int RPC_S_UNSUPPORTED_AUTHN_LEVEL = 0x0000071d;
enum int RPC_S_NOT_RPC_ERROR = 0x0000071f;
enum int RPC_S_SEC_PKG_ERROR = 0x00000721;
enum int RPC_X_INVALID_ES_ACTION = 0x00000723;
enum int RPC_X_WRONG_STUB_VERSION = 0x00000725;

enum : int
{
    RPC_X_WRONG_PIPE_ORDER   = 0x00000727,
    RPC_X_WRONG_PIPE_VERSION = 0x00000728,
}

enum int RPC_S_DO_NOT_DISTURB = 0x0000072a;
enum int RPC_S_SYSTEM_HANDLE_TYPE_MISMATCH = 0x0000072c;
enum int EPT_S_CANT_CREATE = 0x0000076b;

enum : int
{
    ERROR_INVALID_TIME      = 0x0000076d,
    ERROR_INVALID_FORM_NAME = 0x0000076e,
    ERROR_INVALID_FORM_SIZE = 0x0000076f,
}

enum int ERROR_PRINTER_DELETED = 0x00000771;
enum int ERROR_PASSWORD_MUST_CHANGE = 0x00000773;
enum int ERROR_ACCOUNT_LOCKED_OUT = 0x00000775;

enum : int
{
    OR_INVALID_OID = 0x00000777,
    OR_INVALID_SET = 0x00000778,
}

enum : int
{
    RPC_S_INVALID_ASYNC_HANDLE = 0x0000077a,
    RPC_S_INVALID_ASYNC_CALL   = 0x0000077b,
}

enum : int
{
    RPC_X_PIPE_DISCIPLINE_ERROR = 0x0000077d,
    RPC_X_PIPE_EMPTY            = 0x0000077e,
}

enum : int
{
    ERROR_CANT_ACCESS_FILE      = 0x00000780,
    ERROR_CANT_RESOLVE_FILENAME = 0x00000781,
}

enum int RPC_S_NOT_ALL_OBJS_EXPORTED = 0x00000783;
enum int RPC_S_PROFILE_NOT_ADDED = 0x00000785;
enum int RPC_S_PRF_ELT_NOT_REMOVED = 0x00000787;
enum int RPC_S_GRP_ELT_NOT_REMOVED = 0x00000789;
enum int ERROR_CONTEXT_EXPIRED = 0x0000078b;
enum int ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED = 0x0000078d;
enum int ERROR_AUTHENTICATION_FIREWALL_FAILED = 0x0000078f;
enum int ERROR_NTLM_BLOCKED = 0x00000791;
enum int ERROR_LOST_MODE_LOGON_RESTRICTION = 0x00000793;
enum int ERROR_BAD_DRIVER = 0x000007d1;
enum int ERROR_METAFILE_NOT_SUPPORTED = 0x000007d3;
enum int ERROR_CLIPPING_NOT_SUPPORTED = 0x000007d5;
enum int ERROR_INVALID_PROFILE = 0x000007db;
enum int ERROR_TAG_NOT_PRESENT = 0x000007dd;

enum : int
{
    ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE = 0x000007df,
    ERROR_PROFILE_NOT_FOUND                  = 0x000007e0,
}

enum int ERROR_ICM_NOT_ENABLED = 0x000007e2;
enum int ERROR_INVALID_TRANSFORM = 0x000007e4;
enum int ERROR_INVALID_COLORINDEX = 0x000007e6;

enum : int
{
    ERROR_CONNECTED_OTHER_PASSWORD         = 0x0000083c,
    ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT = 0x0000083d,
}

enum int ERROR_NOT_CONNECTED = 0x000008ca;
enum int ERROR_ACTIVE_CONNECTIONS = 0x00000962;
enum int ERROR_UNKNOWN_PRINT_MONITOR = 0x00000bb8;
enum int ERROR_SPOOL_FILE_NOT_FOUND = 0x00000bba;
enum int ERROR_SPL_NO_ADDJOB = 0x00000bbc;
enum int ERROR_PRINT_MONITOR_ALREADY_INSTALLED = 0x00000bbe;

enum : int
{
    ERROR_PRINT_MONITOR_IN_USE    = 0x00000bc0,
    ERROR_PRINTER_HAS_JOBS_QUEUED = 0x00000bc1,
}

enum int ERROR_SUCCESS_RESTART_REQUIRED = 0x00000bc3;

enum : int
{
    ERROR_PRINTER_DRIVER_WARNED         = 0x00000bc5,
    ERROR_PRINTER_DRIVER_BLOCKED        = 0x00000bc6,
    ERROR_PRINTER_DRIVER_PACKAGE_IN_USE = 0x00000bc7,
}

enum : int
{
    ERROR_FAIL_REBOOT_REQUIRED  = 0x00000bc9,
    ERROR_FAIL_REBOOT_INITIATED = 0x00000bca,
}

enum int ERROR_PRINT_JOB_RESTART_REQUIRED = 0x00000bcc;
enum int ERROR_PRINTER_NOT_SHAREABLE = 0x00000bce;
enum int ERROR_APPEXEC_CONDITION_NOT_SATISFIED = 0x00000bf4;
enum int ERROR_APPEXEC_INVALID_HOST_GENERATION = 0x00000bf6;

enum : int
{
    ERROR_APPEXEC_INVALID_HOST_STATE = 0x00000bf8,
    ERROR_APPEXEC_NO_DONOR           = 0x00000bf9,
    ERROR_APPEXEC_HOST_ID_MISMATCH   = 0x00000bfa,
    ERROR_APPEXEC_UNKNOWN_USER       = 0x00000bfb,
}

enum int ERROR_WINS_INTERNAL = 0x00000fa0;
enum int ERROR_STATIC_INIT = 0x00000fa2;
enum int ERROR_FULL_BACKUP = 0x00000fa4;
enum int ERROR_RPL_NOT_ALLOWED = 0x00000fa6;
enum int PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO = 0x00000fd3;

enum : int
{
    PEERDIST_ERROR_NO_MORE               = 0x00000fd5,
    PEERDIST_ERROR_NOT_INITIALIZED       = 0x00000fd6,
    PEERDIST_ERROR_ALREADY_INITIALIZED   = 0x00000fd7,
    PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS  = 0x00000fd8,
    PEERDIST_ERROR_INVALIDATED           = 0x00000fd9,
    PEERDIST_ERROR_ALREADY_EXISTS        = 0x00000fda,
    PEERDIST_ERROR_OPERATION_NOTFOUND    = 0x00000fdb,
    PEERDIST_ERROR_ALREADY_COMPLETED     = 0x00000fdc,
    PEERDIST_ERROR_OUT_OF_BOUNDS         = 0x00000fdd,
    PEERDIST_ERROR_VERSION_UNSUPPORTED   = 0x00000fde,
    PEERDIST_ERROR_INVALID_CONFIGURATION = 0x00000fdf,
    PEERDIST_ERROR_NOT_LICENSED          = 0x00000fe0,
    PEERDIST_ERROR_SERVICE_UNAVAILABLE   = 0x00000fe1,
    PEERDIST_ERROR_TRUST_FAILURE         = 0x00000fe2,
}

enum : int
{
    ERROR_WMI_GUID_NOT_FOUND     = 0x00001068,
    ERROR_WMI_INSTANCE_NOT_FOUND = 0x00001069,
}

enum : int
{
    ERROR_WMI_TRY_AGAIN               = 0x0000106b,
    ERROR_WMI_DP_NOT_FOUND            = 0x0000106c,
    ERROR_WMI_UNRESOLVED_INSTANCE_REF = 0x0000106d,
}

enum int ERROR_WMI_GUID_DISCONNECTED = 0x0000106f;

enum : int
{
    ERROR_WMI_DP_FAILED       = 0x00001071,
    ERROR_WMI_INVALID_MOF     = 0x00001072,
    ERROR_WMI_INVALID_REGINFO = 0x00001073,
}

enum : int
{
    ERROR_WMI_READ_ONLY   = 0x00001075,
    ERROR_WMI_SET_FAILURE = 0x00001076,
}

enum int ERROR_APPCONTAINER_REQUIRED = 0x0000109b;

enum : int
{
    ERROR_INVALID_PACKAGE_SID_LENGTH = 0x0000109d,
    ERROR_INVALID_MEDIA              = 0x000010cc,
    ERROR_INVALID_LIBRARY            = 0x000010cd,
    ERROR_INVALID_MEDIA_POOL         = 0x000010ce,
}

enum int ERROR_MEDIA_OFFLINE = 0x000010d0;

enum : int
{
    ERROR_EMPTY     = 0x000010d2,
    ERROR_NOT_EMPTY = 0x000010d3,
}

enum int ERROR_RESOURCE_DISABLED = 0x000010d5;
enum int ERROR_UNABLE_TO_CLEAN = 0x000010d7;

enum : int
{
    ERROR_DATABASE_FAILURE = 0x000010d9,
    ERROR_DATABASE_FULL    = 0x000010da,
}

enum int ERROR_RESOURCE_NOT_PRESENT = 0x000010dc;
enum int ERROR_MEDIA_NOT_AVAILABLE = 0x000010de;
enum int ERROR_REQUEST_REFUSED = 0x000010e0;
enum int ERROR_LIBRARY_FULL = 0x000010e2;

enum : int
{
    ERROR_UNABLE_TO_LOAD_MEDIUM         = 0x000010e4,
    ERROR_UNABLE_TO_INVENTORY_DRIVE     = 0x000010e5,
    ERROR_UNABLE_TO_INVENTORY_SLOT      = 0x000010e6,
    ERROR_UNABLE_TO_INVENTORY_TRANSPORT = 0x000010e7,
}

enum int ERROR_CONTROLLING_IEPORT = 0x000010e9;

enum : int
{
    ERROR_CLEANER_SLOT_SET        = 0x000010eb,
    ERROR_CLEANER_SLOT_NOT_SET    = 0x000010ec,
    ERROR_CLEANER_CARTRIDGE_SPENT = 0x000010ed,
}

enum int ERROR_CANT_DELETE_LAST_ITEM = 0x000010ef;
enum int ERROR_VOLUME_CONTAINS_SYS_FILES = 0x000010f1;
enum int ERROR_NO_SUPPORTING_DRIVES = 0x000010f3;
enum int ERROR_IEPORT_FULL = 0x000010f5;

enum : int
{
    ERROR_REMOTE_STORAGE_NOT_ACTIVE  = 0x000010ff,
    ERROR_REMOTE_STORAGE_MEDIA_ERROR = 0x00001100,
}

enum int ERROR_REPARSE_ATTRIBUTE_CONFLICT = 0x00001127;

enum : int
{
    ERROR_REPARSE_TAG_INVALID       = 0x00001129,
    ERROR_REPARSE_TAG_MISMATCH      = 0x0000112a,
    ERROR_REPARSE_POINT_ENCOUNTERED = 0x0000112b,
}

enum : int
{
    ERROR_APP_DATA_EXPIRED         = 0x00001131,
    ERROR_APP_DATA_CORRUPT         = 0x00001132,
    ERROR_APP_DATA_LIMIT_EXCEEDED  = 0x00001133,
    ERROR_APP_DATA_REBOOT_REQUIRED = 0x00001134,
}

enum : int
{
    ERROR_SECUREBOOT_POLICY_VIOLATION                   = 0x00001145,
    ERROR_SECUREBOOT_INVALID_POLICY                     = 0x00001146,
    ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND         = 0x00001147,
    ERROR_SECUREBOOT_POLICY_NOT_SIGNED                  = 0x00001148,
    ERROR_SECUREBOOT_NOT_ENABLED                        = 0x00001149,
    ERROR_SECUREBOOT_FILE_REPLACED                      = 0x0000114a,
    ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED              = 0x0000114b,
    ERROR_SECUREBOOT_POLICY_UNKNOWN                     = 0x0000114c,
    ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION = 0x0000114d,
}

enum : int
{
    ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED     = 0x0000114f,
    ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH      = 0x00001150,
    ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING = 0x00001151,
}

enum int ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY = 0x00001153;
enum int ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = 0x00001159;
enum int ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = 0x0000115b;
enum int ERROR_SMR_GARBAGE_COLLECTION_REQUIRED = 0x0000115d;
enum int ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT = 0x0000115f;
enum int ERROR_VOLUME_NOT_SIS_ENABLED = 0x00001194;

enum : int
{
    ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION                   = 0x000011c7,
    ERROR_SYSTEM_INTEGRITY_INVALID_POLICY                     = 0x000011c8,
    ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED                  = 0x000011c9,
    ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES                  = 0x000011ca,
    ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED = 0x000011cb,
}

enum int ERROR_VSM_DMA_PROTECTION_NOT_IN_USE = 0x000011d1;

enum : int
{
    ERROR_PLATFORM_MANIFEST_INVALID                = 0x000011db,
    ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED    = 0x000011dc,
    ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED = 0x000011dd,
    ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND    = 0x000011de,
    ERROR_PLATFORM_MANIFEST_NOT_ACTIVE             = 0x000011df,
    ERROR_PLATFORM_MANIFEST_NOT_SIGNED             = 0x000011e0,
}

enum : int
{
    ERROR_DEPENDENCY_NOT_FOUND      = 0x0000138a,
    ERROR_DEPENDENCY_ALREADY_EXISTS = 0x0000138b,
}

enum int ERROR_HOST_NODE_NOT_AVAILABLE = 0x0000138d;
enum int ERROR_RESOURCE_NOT_FOUND = 0x0000138f;
enum int ERROR_CANT_EVICT_ACTIVE_NODE = 0x00001391;
enum int ERROR_OBJECT_IN_LIST = 0x00001393;

enum : int
{
    ERROR_GROUP_NOT_FOUND  = 0x00001395,
    ERROR_GROUP_NOT_ONLINE = 0x00001396,
}

enum int ERROR_HOST_NODE_NOT_GROUP_OWNER = 0x00001398;
enum int ERROR_RESMON_ONLINE_FAILED = 0x0000139a;
enum int ERROR_QUORUM_RESOURCE = 0x0000139c;
enum int ERROR_CLUSTER_SHUTTING_DOWN = 0x0000139e;
enum int ERROR_RESOURCE_PROPERTIES_STORED = 0x000013a0;
enum int ERROR_CORE_RESOURCE = 0x000013a2;
enum int ERROR_QUORUMLOG_OPEN_FAILED = 0x000013a4;

enum : int
{
    ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE = 0x000013a6,
    ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE        = 0x000013a7,
    ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND     = 0x000013a8,
    ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE       = 0x000013a9,
}

enum int ERROR_NETWORK_NOT_AVAILABLE = 0x000013ab;
enum int ERROR_ALL_NODES_NOT_AVAILABLE = 0x000013ad;

enum : int
{
    ERROR_CLUSTER_INVALID_NODE           = 0x000013af,
    ERROR_CLUSTER_NODE_EXISTS            = 0x000013b0,
    ERROR_CLUSTER_JOIN_IN_PROGRESS       = 0x000013b1,
    ERROR_CLUSTER_NODE_NOT_FOUND         = 0x000013b2,
    ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND   = 0x000013b3,
    ERROR_CLUSTER_NETWORK_EXISTS         = 0x000013b4,
    ERROR_CLUSTER_NETWORK_NOT_FOUND      = 0x000013b5,
    ERROR_CLUSTER_NETINTERFACE_EXISTS    = 0x000013b6,
    ERROR_CLUSTER_NETINTERFACE_NOT_FOUND = 0x000013b7,
}

enum int ERROR_CLUSTER_INVALID_NETWORK_PROVIDER = 0x000013b9;

enum : int
{
    ERROR_CLUSTER_NODE_UNREACHABLE        = 0x000013bb,
    ERROR_CLUSTER_NODE_NOT_MEMBER         = 0x000013bc,
    ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS    = 0x000013bd,
    ERROR_CLUSTER_INVALID_NETWORK         = 0x000013be,
    ERROR_CLUSTER_NODE_UP                 = 0x000013c0,
    ERROR_CLUSTER_IPADDR_IN_USE           = 0x000013c1,
    ERROR_CLUSTER_NODE_NOT_PAUSED         = 0x000013c2,
    ERROR_CLUSTER_NO_SECURITY_CONTEXT     = 0x000013c3,
    ERROR_CLUSTER_NETWORK_NOT_INTERNAL    = 0x000013c4,
    ERROR_CLUSTER_NODE_ALREADY_UP         = 0x000013c5,
    ERROR_CLUSTER_NODE_ALREADY_DOWN       = 0x000013c6,
    ERROR_CLUSTER_NETWORK_ALREADY_ONLINE  = 0x000013c7,
    ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE = 0x000013c8,
    ERROR_CLUSTER_NODE_ALREADY_MEMBER     = 0x000013c9,
    ERROR_CLUSTER_LAST_INTERNAL_NETWORK   = 0x000013ca,
}

enum int ERROR_INVALID_OPERATION_ON_QUORUM = 0x000013cc;
enum int ERROR_CLUSTER_NODE_PAUSED = 0x000013ce;

enum : int
{
    ERROR_CLUSTER_NODE_NOT_READY        = 0x000013d0,
    ERROR_CLUSTER_NODE_SHUTTING_DOWN    = 0x000013d1,
    ERROR_CLUSTER_JOIN_ABORTED          = 0x000013d2,
    ERROR_CLUSTER_INCOMPATIBLE_VERSIONS = 0x000013d3,
}

enum int ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED = 0x000013d5;

enum : int
{
    ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED      = 0x000013d7,
    ERROR_CLUSTER_RESNAME_NOT_FOUND          = 0x000013d8,
    ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED = 0x000013d9,
}

enum int ERROR_CLUSTER_DATABASE_SEQMISMATCH = 0x000013db;
enum int ERROR_CLUSTER_GUM_NOT_LOCKER = 0x000013dd;
enum int ERROR_DATABASE_BACKUP_CORRUPT = 0x000013df;
enum int ERROR_RESOURCE_PROPERTY_UNCHANGEABLE = 0x000013e1;
enum int ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE = 0x00001702;

enum : int
{
    ERROR_CLUSTER_MEMBERSHIP_HALT          = 0x00001704,
    ERROR_CLUSTER_INSTANCE_ID_MISMATCH     = 0x00001705,
    ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP = 0x00001706,
}

enum int ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP = 0x00001708;
enum int ERROR_NODE_CANNOT_BE_CLUSTERED = 0x0000170a;
enum int ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME = 0x0000170c;

enum : int
{
    ERROR_CLUSCFG_ROLLBACK_FAILED                   = 0x0000170e,
    ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT = 0x0000170f,
}

enum int ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME = 0x00001711;

enum : int
{
    ERROR_CLUSTER_POISONED           = 0x00001713,
    ERROR_CLUSTER_GROUP_MOVING       = 0x00001714,
    ERROR_CLUSTER_RESOURCE_TYPE_BUSY = 0x00001715,
}

enum int ERROR_INVALID_CLUSTER_IPV6_ADDRESS = 0x00001717;

enum : int
{
    ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS   = 0x00001719,
    ERROR_CLUSTER_PARTIAL_SEND              = 0x0000171a,
    ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION = 0x0000171b,
}

enum int ERROR_CLUSTER_INVALID_STRING_FORMAT = 0x0000171d;
enum int ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS = 0x0000171f;

enum : int
{
    ERROR_CLUSTER_PARTIAL_READ          = 0x00001721,
    ERROR_CLUSTER_PARTIAL_WRITE         = 0x00001722,
    ERROR_CLUSTER_CANT_DESERIALIZE_DATA = 0x00001723,
}

enum : int
{
    ERROR_CLUSTER_NO_QUORUM                   = 0x00001725,
    ERROR_CLUSTER_INVALID_IPV6_NETWORK        = 0x00001726,
    ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK = 0x00001727,
}

enum int ERROR_DEPENDENCY_TREE_TOO_COMPLEX = 0x00001729;
enum int ERROR_CLUSTER_RHS_FAILED_INITIALIZATION = 0x0000172b;
enum int ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE = 0x0000172d;

enum : int
{
    ERROR_CLUSTER_TOO_MANY_NODES      = 0x0000172f,
    ERROR_CLUSTER_OBJECT_ALREADY_USED = 0x00001730,
}

enum int ERROR_FILE_SHARE_RESOURCE_CONFLICT = 0x00001732;

enum : int
{
    ERROR_CLUSTER_SINGLETON_RESOURCE       = 0x00001734,
    ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE = 0x00001735,
}

enum int ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR = 0x00001737;

enum : int
{
    ERROR_CLUSTER_NOT_SHARED_VOLUME           = 0x00001739,
    ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR = 0x0000173a,
}

enum int ERROR_CLUSTER_USE_SHARED_VOLUMES_API = 0x0000173c;
enum int ERROR_NON_CSV_PATH = 0x0000173e;

enum : int
{
    ERROR_CLUSTER_WATCHDOG_TERMINATING                    = 0x00001740,
    ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES = 0x00001741,
}

enum int ERROR_CLUSTER_RESOURCE_VETOED_CALL = 0x00001743;

enum : int
{
    ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION = 0x00001745,
    ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE      = 0x00001746,
}

enum int ERROR_CLUSTER_RESOURCE_LOCKED_STATUS = 0x00001748;
enum int ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS = 0x0000174a;
enum int ERROR_DISK_NOT_CSV_CAPABLE = 0x0000174c;

enum : int
{
    ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED     = 0x0000174e,
    ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED = 0x0000174f,
}

enum int ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES = 0x00001751;

enum : int
{
    ERROR_CLUSTER_AFFINITY_CONFLICT                   = 0x00001753,
    ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE = 0x00001754,
}

enum : int
{
    ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED = 0x00001756,
    ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED         = 0x00001757,
    ERROR_CLUSTER_UPGRADE_IN_PROGRESS              = 0x00001758,
    ERROR_CLUSTER_UPGRADE_INCOMPLETE               = 0x00001759,
    ERROR_CLUSTER_NODE_IN_GRACE_PERIOD             = 0x0000175a,
    ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT             = 0x0000175b,
}

enum : int
{
    ERROR_CLUSTER_RESOURCE_NOT_MONITORED                = 0x0000175d,
    ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED = 0x0000175e,
    ERROR_CLUSTER_RESOURCE_IS_REPLICATED                = 0x0000175f,
}

enum : int
{
    ERROR_CLUSTER_NODE_QUARANTINED                 = 0x00001761,
    ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED = 0x00001762,
}

enum int ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED = 0x00001764;
enum int ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR = 0x00001766;

enum : int
{
    ERROR_GROUPSET_NOT_FOUND    = 0x00001768,
    ERROR_GROUPSET_CANT_PROVIDE = 0x00001769,
}

enum : int
{
    ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY     = 0x0000176b,
    ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION = 0x0000176c,
    ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS = 0x0000176d,
}

enum int ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE = 0x0000176f;
enum int ERROR_DECRYPTION_FAILED = 0x00001771;
enum int ERROR_NO_RECOVERY_POLICY = 0x00001773;
enum int ERROR_WRONG_EFS = 0x00001775;
enum int ERROR_FILE_NOT_ENCRYPTED = 0x00001777;
enum int ERROR_FILE_READ_ONLY = 0x00001779;
enum int ERROR_EFS_SERVER_NOT_TRUSTED = 0x0000177b;
enum int ERROR_EFS_ALG_BLOB_TOO_BIG = 0x0000177d;

enum : int
{
    ERROR_EFS_DISABLED            = 0x0000177f,
    ERROR_EFS_VERSION_NOT_SUPPORT = 0x00001780,
}

enum : int
{
    ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER      = 0x00001782,
    ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 0x00001783,
    ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE      = 0x00001784,
    ERROR_CS_ENCRYPTION_FILE_NOT_CSE            = 0x00001785,
}

enum int ERROR_WIP_ENCRYPTION_FAILED = 0x00001787;
enum int SCHED_E_SERVICE_NOT_LOCALSYSTEM = 0x00001838;

enum : int
{
    ERROR_LOG_SECTOR_INVALID        = 0x000019c8,
    ERROR_LOG_SECTOR_PARITY_INVALID = 0x000019c9,
    ERROR_LOG_SECTOR_REMAPPED       = 0x000019ca,
}

enum : int
{
    ERROR_LOG_INVALID_RANGE    = 0x000019cc,
    ERROR_LOG_BLOCKS_EXHAUSTED = 0x000019cd,
}

enum int ERROR_LOG_RESTART_INVALID = 0x000019cf;

enum : int
{
    ERROR_LOG_BLOCK_INVALID     = 0x000019d1,
    ERROR_LOG_READ_MODE_INVALID = 0x000019d2,
}

enum : int
{
    ERROR_LOG_METADATA_CORRUPT      = 0x000019d4,
    ERROR_LOG_METADATA_INVALID      = 0x000019d5,
    ERROR_LOG_METADATA_INCONSISTENT = 0x000019d6,
}

enum : int
{
    ERROR_LOG_CANT_DELETE              = 0x000019d8,
    ERROR_LOG_CONTAINER_LIMIT_EXCEEDED = 0x000019d9,
}

enum : int
{
    ERROR_LOG_POLICY_ALREADY_INSTALLED = 0x000019db,
    ERROR_LOG_POLICY_NOT_INSTALLED     = 0x000019dc,
    ERROR_LOG_POLICY_INVALID           = 0x000019dd,
    ERROR_LOG_POLICY_CONFLICT          = 0x000019de,
    ERROR_LOG_PINNED_ARCHIVE_TAIL      = 0x000019df,
}

enum int ERROR_LOG_RECORDS_RESERVED_INVALID = 0x000019e1;

enum : int
{
    ERROR_LOG_TAIL_INVALID     = 0x000019e3,
    ERROR_LOG_FULL             = 0x000019e4,
    ERROR_COULD_NOT_RESIZE_LOG = 0x000019e5,
}

enum : int
{
    ERROR_LOG_DEDICATED               = 0x000019e7,
    ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS = 0x000019e8,
    ERROR_LOG_ARCHIVE_IN_PROGRESS     = 0x000019e9,
}

enum int ERROR_LOG_NOT_ENOUGH_CONTAINERS = 0x000019eb;
enum int ERROR_LOG_CLIENT_NOT_REGISTERED = 0x000019ed;

enum : int
{
    ERROR_LOG_CONTAINER_READ_FAILED   = 0x000019ef,
    ERROR_LOG_CONTAINER_WRITE_FAILED  = 0x000019f0,
    ERROR_LOG_CONTAINER_OPEN_FAILED   = 0x000019f1,
    ERROR_LOG_CONTAINER_STATE_INVALID = 0x000019f2,
}

enum : int
{
    ERROR_LOG_PINNED                = 0x000019f4,
    ERROR_LOG_METADATA_FLUSH_FAILED = 0x000019f5,
}

enum int ERROR_LOG_APPENDED_FLUSH_FAILED = 0x000019f7;
enum int ERROR_INVALID_TRANSACTION = 0x00001a2c;

enum : int
{
    ERROR_TRANSACTION_REQUEST_NOT_VALID = 0x00001a2e,
    ERROR_TRANSACTION_NOT_REQUESTED     = 0x00001a2f,
    ERROR_TRANSACTION_ALREADY_ABORTED   = 0x00001a30,
    ERROR_TRANSACTION_ALREADY_COMMITTED = 0x00001a31,
}

enum int ERROR_RESOURCEMANAGER_READ_ONLY = 0x00001a33;
enum int ERROR_TRANSACTION_SUPERIOR_EXISTS = 0x00001a35;
enum int ERROR_TRANSACTION_PROPAGATION_FAILED = 0x00001a37;
enum int ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER = 0x00001a39;
enum int ERROR_TRANSACTION_NOT_FOUND = 0x00001a3b;
enum int ERROR_ENLISTMENT_NOT_FOUND = 0x00001a3d;

enum : int
{
    ERROR_TRANSACTIONMANAGER_NOT_ONLINE              = 0x00001a3f,
    ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = 0x00001a40,
}

enum : int
{
    ERROR_TRANSACTION_OBJECT_EXPIRED        = 0x00001a42,
    ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED = 0x00001a43,
    ERROR_TRANSACTION_RECORD_TOO_LONG       = 0x00001a44,
}

enum : int
{
    ERROR_TRANSACTION_INTEGRITY_VIOLATED       = 0x00001a46,
    ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH = 0x00001a47,
}

enum : int
{
    ERROR_TRANSACTION_MUST_WRITETHROUGH = 0x00001a49,
    ERROR_TRANSACTION_NO_SUPERIOR       = 0x00001a4a,
}

enum int ERROR_TRANSACTIONAL_CONFLICT = 0x00001a90;
enum int ERROR_RM_METADATA_CORRUPT = 0x00001a92;
enum int ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE = 0x00001a95;
enum int ERROR_OBJECT_NO_LONGER_EXISTS = 0x00001a97;
enum int ERROR_STREAM_MINIVERSION_NOT_VALID = 0x00001a99;
enum int ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = 0x00001a9b;
enum int ERROR_REMOTE_FILE_VERSION_MISMATCH = 0x00001a9e;
enum int ERROR_NO_TXF_METADATA = 0x00001aa0;
enum int ERROR_CANT_RECOVER_WITH_HANDLE_OPEN = 0x00001aa2;
enum int ERROR_ENLISTMENT_NOT_SUPERIOR = 0x00001aa4;
enum int ERROR_RM_ALREADY_STARTED = 0x00001aa6;
enum int ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = 0x00001aa8;
enum int ERROR_TXF_DIR_NOT_EMPTY = 0x00001aaa;
enum int ERROR_TM_VOLATILE = 0x00001aac;
enum int ERROR_TXF_ATTRIBUTE_CORRUPT = 0x00001aae;
enum int ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED = 0x00001ab0;
enum int ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = 0x00001ab2;

enum : int
{
    ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = 0x00001ab4,
    ERROR_TRANSACTION_REQUIRED_PROMOTION      = 0x00001ab5,
}

enum : int
{
    ERROR_TRANSACTIONS_NOT_FROZEN        = 0x00001ab7,
    ERROR_TRANSACTION_FREEZE_IN_PROGRESS = 0x00001ab8,
}

enum int ERROR_NO_SAVEPOINT_WITH_OPEN_FILES = 0x00001aba;
enum int ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION = 0x00001abc;
enum int ERROR_FLOATED_SECTION = 0x00001abe;
enum int ERROR_CANNOT_ABORT_TRANSACTIONS = 0x00001ac0;
enum int ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = 0x00001ac2;
enum int ERROR_NO_LINK_TRACKING_IN_TRANSACTION = 0x00001ac4;
enum int ERROR_EXPIRED_HANDLE = 0x00001ac6;
enum int ERROR_CTX_WINSTATION_NAME_INVALID = 0x00001b59;

enum : int
{
    ERROR_CTX_PD_NOT_FOUND               = 0x00001b5b,
    ERROR_CTX_WD_NOT_FOUND               = 0x00001b5c,
    ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY = 0x00001b5d,
}

enum : int
{
    ERROR_CTX_CLOSE_PENDING       = 0x00001b5f,
    ERROR_CTX_NO_OUTBUF           = 0x00001b60,
    ERROR_CTX_MODEM_INF_NOT_FOUND = 0x00001b61,
}

enum : int
{
    ERROR_CTX_MODEM_RESPONSE_ERROR       = 0x00001b63,
    ERROR_CTX_MODEM_RESPONSE_TIMEOUT     = 0x00001b64,
    ERROR_CTX_MODEM_RESPONSE_NO_CARRIER  = 0x00001b65,
    ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE = 0x00001b66,
    ERROR_CTX_MODEM_RESPONSE_BUSY        = 0x00001b67,
    ERROR_CTX_MODEM_RESPONSE_VOICE       = 0x00001b68,
}

enum : int
{
    ERROR_CTX_WINSTATION_NOT_FOUND      = 0x00001b6e,
    ERROR_CTX_WINSTATION_ALREADY_EXISTS = 0x00001b6f,
    ERROR_CTX_WINSTATION_BUSY           = 0x00001b70,
}

enum int ERROR_CTX_GRAPHICS_INVALID = 0x00001b7b;

enum : int
{
    ERROR_CTX_NOT_CONSOLE          = 0x00001b7e,
    ERROR_CTX_CLIENT_QUERY_TIMEOUT = 0x00001b80,
}

enum int ERROR_CTX_CONSOLE_CONNECT = 0x00001b82;
enum int ERROR_CTX_WINSTATION_ACCESS_DENIED = 0x00001b85;

enum : int
{
    ERROR_CTX_SHADOW_INVALID  = 0x00001b8a,
    ERROR_CTX_SHADOW_DISABLED = 0x00001b8b,
}

enum int ERROR_CTX_CLIENT_LICENSE_NOT_SET = 0x00001b8d;

enum : int
{
    ERROR_CTX_LICENSE_CLIENT_INVALID = 0x00001b8f,
    ERROR_CTX_LICENSE_EXPIRED        = 0x00001b90,
}

enum int ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 0x00001b92;
enum int ERROR_CTX_WINSTATIONS_DISABLED = 0x00001b94;

enum : int
{
    ERROR_CTX_SESSION_IN_USE  = 0x00001b96,
    ERROR_CTX_NO_FORCE_LOGOFF = 0x00001b97,
}

enum int ERROR_RDP_PROTOCOL_ERROR = 0x00001b99;

enum : int
{
    ERROR_CTX_CDM_DISCONNECT       = 0x00001b9b,
    ERROR_CTX_SECURITY_LAYER_ERROR = 0x00001b9c,
}

enum int ERROR_TS_VIDEO_SUBSYSTEM_ERROR = 0x00001b9e;

enum : int
{
    FRS_ERR_STARTING_SERVICE = 0x00001f42,
    FRS_ERR_STOPPING_SERVICE = 0x00001f43,
}

enum : int
{
    FRS_ERR_INTERNAL     = 0x00001f45,
    FRS_ERR_SERVICE_COMM = 0x00001f46,
}

enum int FRS_ERR_AUTHENTICATION = 0x00001f48;
enum int FRS_ERR_PARENT_AUTHENTICATION = 0x00001f4a;
enum int FRS_ERR_PARENT_TO_CHILD_COMM = 0x00001f4c;

enum : int
{
    FRS_ERR_SYSVOL_POPULATE_TIMEOUT = 0x00001f4e,
    FRS_ERR_SYSVOL_IS_BUSY          = 0x00001f4f,
    FRS_ERR_SYSVOL_DEMOTE           = 0x00001f50,
}

enum : int
{
    ERROR_DS_NOT_INSTALLED                = 0x00002008,
    ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY = 0x00002009,
}

enum int ERROR_DS_INVALID_ATTRIBUTE_SYNTAX = 0x0000200b;
enum int ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS = 0x0000200d;

enum : int
{
    ERROR_DS_UNAVAILABLE          = 0x0000200f,
    ERROR_DS_NO_RIDS_ALLOCATED    = 0x00002010,
    ERROR_DS_NO_MORE_RIDS         = 0x00002011,
    ERROR_DS_INCORRECT_ROLE_OWNER = 0x00002012,
}

enum int ERROR_DS_OBJ_CLASS_VIOLATION = 0x00002014;

enum : int
{
    ERROR_DS_CANT_ON_RDN        = 0x00002016,
    ERROR_DS_CANT_MOD_OBJ_CLASS = 0x00002017,
}

enum int ERROR_DS_GC_NOT_AVAILABLE = 0x00002019;

enum : int
{
    ERROR_POLICY_OBJECT_NOT_FOUND = 0x0000201b,
    ERROR_POLICY_ONLY_IN_DS       = 0x0000201c,
}

enum int ERROR_NO_PROMOTION_ACTIVE = 0x0000201e;
enum int ERROR_DS_PROTOCOL_ERROR = 0x00002021;
enum int ERROR_DS_SIZELIMIT_EXCEEDED = 0x00002023;

enum : int
{
    ERROR_DS_COMPARE_FALSE             = 0x00002025,
    ERROR_DS_COMPARE_TRUE              = 0x00002026,
    ERROR_DS_AUTH_METHOD_NOT_SUPPORTED = 0x00002027,
}

enum int ERROR_DS_INAPPROPRIATE_AUTH = 0x00002029;

enum : int
{
    ERROR_DS_REFERRAL                   = 0x0000202b,
    ERROR_DS_UNAVAILABLE_CRIT_EXTENSION = 0x0000202c,
}

enum int ERROR_DS_INAPPROPRIATE_MATCHING = 0x0000202e;
enum int ERROR_DS_NO_SUCH_OBJECT = 0x00002030;
enum int ERROR_DS_INVALID_DN_SYNTAX = 0x00002032;
enum int ERROR_DS_ALIAS_DEREF_PROBLEM = 0x00002034;

enum : int
{
    ERROR_DS_LOOP_DETECT      = 0x00002036,
    ERROR_DS_NAMING_VIOLATION = 0x00002037,
}

enum int ERROR_DS_AFFECTS_MULTIPLE_DSAS = 0x00002039;

enum : int
{
    ERROR_DS_LOCAL_ERROR    = 0x0000203b,
    ERROR_DS_ENCODING_ERROR = 0x0000203c,
}

enum int ERROR_DS_FILTER_UNKNOWN = 0x0000203e;

enum : int
{
    ERROR_DS_NOT_SUPPORTED       = 0x00002040,
    ERROR_DS_NO_RESULTS_RETURNED = 0x00002041,
}

enum : int
{
    ERROR_DS_CLIENT_LOOP             = 0x00002043,
    ERROR_DS_REFERRAL_LIMIT_EXCEEDED = 0x00002044,
}

enum int ERROR_DS_OFFSET_RANGE_ERROR = 0x00002046;
enum int ERROR_DS_ROOT_MUST_BE_NC = 0x0000206d;
enum int ERROR_DS_ATT_NOT_DEF_IN_SCHEMA = 0x0000206f;
enum int ERROR_DS_OBJ_STRING_NAME_EXISTS = 0x00002071;
enum int ERROR_DS_RDN_DOESNT_MATCH_SCHEMA = 0x00002073;
enum int ERROR_DS_USER_BUFFER_TO_SMALL = 0x00002075;
enum int ERROR_DS_ILLEGAL_MOD_OPERATION = 0x00002077;
enum int ERROR_DS_BAD_INSTANCE_TYPE = 0x00002079;
enum int ERROR_DS_OBJECT_CLASS_REQUIRED = 0x0000207b;

enum : int
{
    ERROR_DS_ATT_NOT_DEF_FOR_CLASS = 0x0000207d,
    ERROR_DS_ATT_ALREADY_EXISTS    = 0x0000207e,
}

enum int ERROR_DS_SINGLE_VALUE_CONSTRAINT = 0x00002081;
enum int ERROR_DS_ATT_VAL_ALREADY_EXISTS = 0x00002083;
enum int ERROR_DS_CANT_REM_MISSING_ATT_VAL = 0x00002085;

enum : int
{
    ERROR_DS_NO_CHAINING      = 0x00002087,
    ERROR_DS_NO_CHAINED_EVAL  = 0x00002088,
    ERROR_DS_NO_PARENT_OBJECT = 0x00002089,
}

enum int ERROR_DS_CANT_MIX_MASTER_AND_REPS = 0x0000208b;

enum : int
{
    ERROR_DS_OBJ_NOT_FOUND       = 0x0000208d,
    ERROR_DS_ALIASED_OBJ_MISSING = 0x0000208e,
}

enum int ERROR_DS_ALIAS_POINTS_TO_ALIAS = 0x00002090;

enum : int
{
    ERROR_DS_OUT_OF_SCOPE         = 0x00002092,
    ERROR_DS_OBJECT_BEING_REMOVED = 0x00002093,
}

enum : int
{
    ERROR_DS_GENERIC_ERROR          = 0x00002095,
    ERROR_DS_DSA_MUST_BE_INT_MASTER = 0x00002096,
}

enum int ERROR_DS_INSUFF_ACCESS_RIGHTS = 0x00002098;
enum int ERROR_DS_ATTRIBUTE_OWNED_BY_SAM = 0x0000209a;

enum : int
{
    ERROR_DS_NAME_TOO_LONG       = 0x0000209c,
    ERROR_DS_NAME_VALUE_TOO_LONG = 0x0000209d,
    ERROR_DS_NAME_UNPARSEABLE    = 0x0000209e,
    ERROR_DS_NAME_TYPE_UNKNOWN   = 0x0000209f,
}

enum : int
{
    ERROR_DS_SEC_DESC_TOO_SHORT = 0x000020a1,
    ERROR_DS_SEC_DESC_INVALID   = 0x000020a2,
}

enum int ERROR_DS_SUBREF_MUST_HAVE_PARENT = 0x000020a4;
enum int ERROR_DS_CANT_ADD_SYSTEM_ONLY = 0x000020a6;

enum : int
{
    ERROR_DS_INVALID_DMD     = 0x000020a8,
    ERROR_DS_OBJ_GUID_EXISTS = 0x000020a9,
}

enum int ERROR_DS_NO_CROSSREF_FOR_NC = 0x000020ab;
enum int ERROR_DS_UNKNOWN_OPERATION = 0x000020ad;
enum int ERROR_DS_COULDNT_CONTACT_FSMO = 0x000020af;
enum int ERROR_DS_CANT_MOD_SYSTEM_ONLY = 0x000020b1;

enum : int
{
    ERROR_DS_OBJ_CLASS_NOT_DEFINED  = 0x000020b3,
    ERROR_DS_OBJ_CLASS_NOT_SUBCLASS = 0x000020b4,
}

enum int ERROR_DS_CROSS_REF_EXISTS = 0x000020b6;
enum int ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD = 0x000020b8;

enum : int
{
    ERROR_DS_DUP_RDN               = 0x000020ba,
    ERROR_DS_DUP_OID               = 0x000020bb,
    ERROR_DS_DUP_MAPI_ID           = 0x000020bc,
    ERROR_DS_DUP_SCHEMA_ID_GUID    = 0x000020bd,
    ERROR_DS_DUP_LDAP_DISPLAY_NAME = 0x000020be,
}

enum int ERROR_DS_SYNTAX_MISMATCH = 0x000020c0;
enum int ERROR_DS_EXISTS_IN_MAY_HAVE = 0x000020c2;
enum int ERROR_DS_NONEXISTENT_MUST_HAVE = 0x000020c4;
enum int ERROR_DS_NONEXISTENT_POSS_SUP = 0x000020c6;
enum int ERROR_DS_BAD_RDN_ATT_ID_SYNTAX = 0x000020c8;

enum : int
{
    ERROR_DS_EXISTS_IN_SUB_CLS  = 0x000020ca,
    ERROR_DS_EXISTS_IN_POSS_SUP = 0x000020cb,
}

enum int ERROR_DS_TREE_DELETE_NOT_FINISHED = 0x000020cd;
enum int ERROR_DS_ATT_SCHEMA_REQ_ID = 0x000020cf;

enum : int
{
    ERROR_DS_CANT_CACHE_ATT          = 0x000020d1,
    ERROR_DS_CANT_CACHE_CLASS        = 0x000020d2,
    ERROR_DS_CANT_REMOVE_ATT_CACHE   = 0x000020d3,
    ERROR_DS_CANT_REMOVE_CLASS_CACHE = 0x000020d4,
    ERROR_DS_CANT_RETRIEVE_DN        = 0x000020d5,
}

enum int ERROR_DS_CANT_RETRIEVE_INSTANCE = 0x000020d7;
enum int ERROR_DS_DATABASE_ERROR = 0x000020d9;
enum int ERROR_DS_MISSING_EXPECTED_ATT = 0x000020db;
enum int ERROR_DS_SECURITY_CHECKING_ERROR = 0x000020dd;
enum int ERROR_DS_SCHEMA_ALLOC_FAILED = 0x000020df;
enum int ERROR_DS_GCVERIFY_ERROR = 0x000020e1;

enum : int
{
    ERROR_DS_CANT_FIND_DSA_OBJ     = 0x000020e3,
    ERROR_DS_CANT_FIND_EXPECTED_NC = 0x000020e4,
    ERROR_DS_CANT_FIND_NC_IN_CACHE = 0x000020e5,
    ERROR_DS_CANT_RETRIEVE_CHILD   = 0x000020e6,
}

enum int ERROR_DS_CANT_REPLACE_HIDDEN_REC = 0x000020e8;
enum int ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED = 0x000020ea;
enum int ERROR_DS_COUNTING_AB_INDICES_FAILED = 0x000020ec;
enum int ERROR_DS_INTERNAL_FAILURE = 0x000020ee;
enum int ERROR_DS_ROOT_REQUIRES_CLASS_TOP = 0x000020f0;
enum int ERROR_DS_MISSING_FSMO_SETTINGS = 0x000020f2;

enum : int
{
    ERROR_DS_DRA_GENERIC                  = 0x000020f4,
    ERROR_DS_DRA_INVALID_PARAMETER        = 0x000020f5,
    ERROR_DS_DRA_BUSY                     = 0x000020f6,
    ERROR_DS_DRA_BAD_DN                   = 0x000020f7,
    ERROR_DS_DRA_BAD_NC                   = 0x000020f8,
    ERROR_DS_DRA_DN_EXISTS                = 0x000020f9,
    ERROR_DS_DRA_INTERNAL_ERROR           = 0x000020fa,
    ERROR_DS_DRA_INCONSISTENT_DIT         = 0x000020fb,
    ERROR_DS_DRA_CONNECTION_FAILED        = 0x000020fc,
    ERROR_DS_DRA_BAD_INSTANCE_TYPE        = 0x000020fd,
    ERROR_DS_DRA_OUT_OF_MEM               = 0x000020fe,
    ERROR_DS_DRA_MAIL_PROBLEM             = 0x000020ff,
    ERROR_DS_DRA_REF_ALREADY_EXISTS       = 0x00002100,
    ERROR_DS_DRA_REF_NOT_FOUND            = 0x00002101,
    ERROR_DS_DRA_OBJ_IS_REP_SOURCE        = 0x00002102,
    ERROR_DS_DRA_DB_ERROR                 = 0x00002103,
    ERROR_DS_DRA_NO_REPLICA               = 0x00002104,
    ERROR_DS_DRA_ACCESS_DENIED            = 0x00002105,
    ERROR_DS_DRA_NOT_SUPPORTED            = 0x00002106,
    ERROR_DS_DRA_RPC_CANCELLED            = 0x00002107,
    ERROR_DS_DRA_SOURCE_DISABLED          = 0x00002108,
    ERROR_DS_DRA_SINK_DISABLED            = 0x00002109,
    ERROR_DS_DRA_NAME_COLLISION           = 0x0000210a,
    ERROR_DS_DRA_SOURCE_REINSTALLED       = 0x0000210b,
    ERROR_DS_DRA_MISSING_PARENT           = 0x0000210c,
    ERROR_DS_DRA_PREEMPTED                = 0x0000210d,
    ERROR_DS_DRA_ABANDON_SYNC             = 0x0000210e,
    ERROR_DS_DRA_SHUTDOWN                 = 0x0000210f,
    ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET = 0x00002110,
}

enum int ERROR_DS_DRA_EXTN_CONNECTION_FAILED = 0x00002112;

enum : int
{
    ERROR_DS_DUP_LINK_ID                       = 0x00002114,
    ERROR_DS_NAME_ERROR_RESOLVING              = 0x00002115,
    ERROR_DS_NAME_ERROR_NOT_FOUND              = 0x00002116,
    ERROR_DS_NAME_ERROR_NOT_UNIQUE             = 0x00002117,
    ERROR_DS_NAME_ERROR_NO_MAPPING             = 0x00002118,
    ERROR_DS_NAME_ERROR_DOMAIN_ONLY            = 0x00002119,
    ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = 0x0000211a,
}

enum int ERROR_DS_WRONG_OM_OBJ_CLASS = 0x0000211c;

enum : int
{
    ERROR_DS_DS_REQUIRED               = 0x0000211e,
    ERROR_DS_INVALID_LDAP_DISPLAY_NAME = 0x0000211f,
}

enum int ERROR_DS_CANT_RETRIEVE_ATTS = 0x00002121;
enum int ERROR_DS_EPOCH_MISMATCH = 0x00002123;
enum int ERROR_DS_SRC_AND_DST_NC_IDENTICAL = 0x00002125;
enum int ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC = 0x00002127;
enum int ERROR_DS_CANT_MOVE_DELETED_OBJECT = 0x00002129;
enum int ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD = 0x0000212b;
enum int ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS = 0x0000212d;
enum int ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE = 0x0000212f;
enum int ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER = 0x00002131;
enum int ERROR_DS_CANT_MOVE_RESOURCE_GROUP = 0x00002133;
enum int ERROR_DS_NO_TREE_DELETE_ABOVE_NC = 0x00002135;
enum int ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE = 0x00002137;
enum int ERROR_DS_SENSITIVE_GROUP_VIOLATION = 0x00002139;
enum int ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD = 0x0000213b;
enum int ERROR_DS_SCHEMA_UPDATE_DISALLOWED = 0x0000213d;

enum : int
{
    ERROR_DS_INSTALL_NO_SRC_SCH_VERSION        = 0x0000213f,
    ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE = 0x00002140,
}

enum int ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 0x00002142;

enum : int
{
    ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER     = 0x00002144,
    ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 0x00002145,
}

enum int ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 0x00002147;
enum int ERROR_DS_HAVE_PRIMARY_MEMBERS = 0x00002149;
enum int ERROR_DS_NAMING_MASTER_GC = 0x0000214b;
enum int ERROR_DS_COULDNT_UPDATE_SPNS = 0x0000214d;
enum int ERROR_DS_KEY_NOT_UNIQUE = 0x0000214f;

enum : int
{
    ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD = 0x00002151,
    ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY   = 0x00002152,
}

enum : int
{
    ERROR_DS_INIT_FAILURE                 = 0x00002154,
    ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION = 0x00002155,
}

enum : int
{
    ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST = 0x00002157,
    ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED = 0x00002158,
}

enum int ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER = 0x0000215a;
enum int ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH = 0x0000215c;

enum : int
{
    ERROR_DS_DRA_SCHEMA_INFO_SHIP        = 0x0000215e,
    ERROR_DS_DRA_SCHEMA_CONFLICT         = 0x0000215f,
    ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT = 0x00002160,
}

enum int ERROR_DS_NC_STILL_HAS_DSAS = 0x00002162;
enum int ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 0x00002164;
enum int ERROR_DS_CANT_ADD_TO_GC = 0x00002166;
enum int ERROR_DS_SOURCE_AUDITING_NOT_ENABLED = 0x00002168;
enum int ERROR_DS_INVALID_NAME_FOR_SPN = 0x0000216a;
enum int ERROR_DS_UNICODEPWD_NOT_IN_QUOTES = 0x0000216c;
enum int ERROR_DS_MUST_BE_RUN_ON_DST_DC = 0x0000216e;
enum int ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ = 0x00002170;
enum int ERROR_DS_SAM_INIT_FAILURE_CONSOLE = 0x00002172;
enum int ERROR_DS_DOMAIN_VERSION_TOO_HIGH = 0x00002174;
enum int ERROR_DS_DOMAIN_VERSION_TOO_LOW = 0x00002176;
enum int ERROR_DS_LOW_DSA_VERSION = 0x00002178;
enum int ERROR_DS_NOT_SUPPORTED_SORT_ORDER = 0x0000217a;
enum int ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 = 0x0000217c;
enum int ERROR_DS_INCOMPATIBLE_CONTROLS_USED = 0x0000217e;
enum int ERROR_DS_RESERVED_LINK_ID = 0x00002180;
enum int ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 0x00002182;
enum int ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC = 0x00002184;
enum int ERROR_DS_MODIFYDN_WRONG_GRANDPARENT = 0x00002186;
enum int ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER = 0x00002188;
enum int ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 = 0x0000218a;

enum : int
{
    ERROR_DS_NOT_CLOSEST                        = 0x0000218c,
    ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF = 0x0000218d,
}

enum : int
{
    ERROR_DS_NTDSCRIPT_SYNTAX_ERROR  = 0x0000218f,
    ERROR_DS_NTDSCRIPT_PROCESS_ERROR = 0x00002190,
}

enum int ERROR_DS_DRS_EXTENSIONS_CHANGED = 0x00002192;

enum : int
{
    ERROR_DS_NO_MSDS_INTID  = 0x00002194,
    ERROR_DS_DUP_MSDS_INTID = 0x00002195,
}

enum int ERROR_DS_AUTHORIZATION_FAILED = 0x00002197;
enum int ERROR_DS_REMOTE_CROSSREF_OP_FAILED = 0x00002199;
enum int ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN = 0x0000219b;
enum int ERROR_DS_DUPLICATE_ID_FOUND = 0x0000219d;
enum int ERROR_DS_GROUP_CONVERSION_ERROR = 0x0000219f;
enum int ERROR_DS_CANT_MOVE_APP_QUERY_GROUP = 0x000021a1;
enum int ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL = 0x000021a3;
enum int ERROR_DS_EXISTING_AD_CHILD_NC = 0x000021a5;
enum int ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER = 0x000021a7;
enum int ERROR_DS_DRA_OUT_SCHEDULE_WINDOW = 0x000021a9;
enum int ERROR_NO_SITE_SETTINGS_OBJECT = 0x000021ab;
enum int ERROR_NO_WRITABLE_DC_FOUND = 0x000021ad;

enum : int
{
    ERROR_DS_NO_NTDSA_OBJECT = 0x000021af,
    ERROR_DS_NON_ASQ_SEARCH  = 0x000021b0,
}

enum : int
{
    ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE = 0x000021b2,
    ERROR_DS_INVALID_SEARCH_FLAG_TUPLE   = 0x000021b3,
}

enum : int
{
    ERROR_DS_DRA_CORRUPT_UTD_VECTOR = 0x000021b5,
    ERROR_DS_DRA_SECRETS_DENIED     = 0x000021b6,
}

enum int ERROR_DS_MAPI_ID_NOT_AVAILABLE = 0x000021b8;
enum int ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST = 0x000021ba;
enum int ERROR_INVALID_USER_PRINCIPAL_NAME = 0x000021bc;

enum : int
{
    ERROR_DS_OID_NOT_FOUND       = 0x000021be,
    ERROR_DS_DRA_RECYCLED_TARGET = 0x000021bf,
}

enum : int
{
    ERROR_DS_HIGH_ADLDS_FFL   = 0x000021c1,
    ERROR_DS_HIGH_DSA_VERSION = 0x000021c2,
}

enum int ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION = 0x000021c4;
enum int ERROR_INCORRECT_ACCOUNT_TYPE = 0x000021c6;
enum int ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST = 0x000021c8;
enum int ERROR_DS_VALUE_KEY_NOT_UNIQUE = 0x000021ca;

enum : int
{
    DNS_ERROR_MASK                  = 0x00002328,
    DNS_ERROR_RCODE_FORMAT_ERROR    = 0x00002329,
    DNS_ERROR_RCODE_SERVER_FAILURE  = 0x0000232a,
    DNS_ERROR_RCODE_NAME_ERROR      = 0x0000232b,
    DNS_ERROR_RCODE_NOT_IMPLEMENTED = 0x0000232c,
    DNS_ERROR_RCODE_REFUSED         = 0x0000232d,
    DNS_ERROR_RCODE_YXDOMAIN        = 0x0000232e,
    DNS_ERROR_RCODE_YXRRSET         = 0x0000232f,
    DNS_ERROR_RCODE_NXRRSET         = 0x00002330,
    DNS_ERROR_RCODE_NOTAUTH         = 0x00002331,
    DNS_ERROR_RCODE_NOTZONE         = 0x00002332,
    DNS_ERROR_RCODE_BADSIG          = 0x00002338,
    DNS_ERROR_RCODE_BADKEY          = 0x00002339,
    DNS_ERROR_RCODE_BADTIME         = 0x0000233a,
    DNS_ERROR_DNSSEC_BASE           = 0x0000238c,
    DNS_ERROR_KEYMASTER_REQUIRED    = 0x0000238d,
}

enum int DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1 = 0x0000238f;
enum int DNS_ERROR_UNSUPPORTED_ALGORITHM = 0x00002391;
enum int DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE = 0x00002393;

enum : int
{
    DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR = 0x00002395,
    DNS_ERROR_UNEXPECTED_CNG_ERROR             = 0x00002396,
}

enum int DNS_ERROR_KSP_NOT_ACCESSIBLE = 0x00002398;

enum : int
{
    DNS_ERROR_INVALID_ROLLOVER_PERIOD         = 0x0000239a,
    DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET = 0x0000239b,
}

enum int DNS_ERROR_STANDBY_KEY_NOT_PRESENT = 0x0000239d;
enum int DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD = 0x0000239f;
enum int DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE = 0x000023a1;

enum : int
{
    DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD = 0x000023a3,
    DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT     = 0x000023a4,
}

enum : int
{
    DNS_ERROR_INVALID_XML            = 0x000023a6,
    DNS_ERROR_NO_VALID_TRUST_ANCHORS = 0x000023a7,
}

enum : int
{
    DNS_ERROR_NSEC3_NAME_COLLISION                  = 0x000023a9,
    DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1 = 0x000023aa,
}

enum int DNS_INFO_NO_RECORDS = 0x0000251d;

enum : int
{
    DNS_ERROR_NO_PACKET       = 0x0000251f,
    DNS_ERROR_RCODE           = 0x00002520,
    DNS_ERROR_UNSECURE_PACKET = 0x00002521,
}

enum int DNS_ERROR_GENERAL_API_BASE = 0x0000254e;

enum : int
{
    DNS_ERROR_INVALID_IP_ADDRESS = 0x00002550,
    DNS_ERROR_INVALID_PROPERTY   = 0x00002551,
}

enum : int
{
    DNS_ERROR_NOT_UNIQUE   = 0x00002553,
    DNS_ERROR_NON_RFC_NAME = 0x00002554,
}

enum : int
{
    DNS_STATUS_DOTTED_NAME      = 0x00002556,
    DNS_STATUS_SINGLE_PART_NAME = 0x00002557,
}

enum : int
{
    DNS_ERROR_NUMERIC_NAME                 = 0x00002559,
    DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER   = 0x0000255a,
    DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION = 0x0000255b,
}

enum int DNS_ERROR_INCONSISTENT_ROOT_HINTS = 0x0000255d;
enum int DNS_ERROR_DWORD_VALUE_TOO_LARGE = 0x0000255f;

enum : int
{
    DNS_ERROR_NOT_ALLOWED_ON_RODC     = 0x00002561,
    DNS_ERROR_NOT_ALLOWED_UNDER_DNAME = 0x00002562,
}

enum int DNS_ERROR_INVALID_POLICY_TABLE = 0x00002564;

enum : int
{
    DNS_ERROR_ZONE_BASE           = 0x00002580,
    DNS_ERROR_ZONE_DOES_NOT_EXIST = 0x00002581,
}

enum int DNS_ERROR_INVALID_ZONE_OPERATION = 0x00002583;

enum : int
{
    DNS_ERROR_ZONE_HAS_NO_SOA_RECORD = 0x00002585,
    DNS_ERROR_ZONE_HAS_NO_NS_RECORDS = 0x00002586,
    DNS_ERROR_ZONE_LOCKED            = 0x00002587,
    DNS_ERROR_ZONE_CREATION_FAILED   = 0x00002588,
    DNS_ERROR_ZONE_ALREADY_EXISTS    = 0x00002589,
}

enum int DNS_ERROR_INVALID_ZONE_TYPE = 0x0000258b;
enum int DNS_ERROR_ZONE_NOT_SECONDARY = 0x0000258d;
enum int DNS_ERROR_WINS_INIT_FAILED = 0x0000258f;
enum int DNS_ERROR_NBSTAT_INIT_FAILED = 0x00002591;
enum int DNS_ERROR_FORWARDER_ALREADY_EXISTS = 0x00002593;

enum : int
{
    DNS_ERROR_ZONE_IS_SHUTDOWN        = 0x00002595,
    DNS_ERROR_ZONE_LOCKED_FOR_SIGNING = 0x00002596,
}

enum int DNS_ERROR_PRIMARY_REQUIRES_DATAFILE = 0x000025b3;
enum int DNS_ERROR_DATAFILE_OPEN_FAILURE = 0x000025b5;

enum : int
{
    DNS_ERROR_DATAFILE_PARSING      = 0x000025b7,
    DNS_ERROR_DATABASE_BASE         = 0x000025e4,
    DNS_ERROR_RECORD_DOES_NOT_EXIST = 0x000025e5,
    DNS_ERROR_RECORD_FORMAT         = 0x000025e6,
    DNS_ERROR_NODE_CREATION_FAILED  = 0x000025e7,
}

enum int DNS_ERROR_RECORD_TIMED_OUT = 0x000025e9;

enum : int
{
    DNS_ERROR_CNAME_LOOP      = 0x000025eb,
    DNS_ERROR_NODE_IS_CNAME   = 0x000025ec,
    DNS_ERROR_CNAME_COLLISION = 0x000025ed,
}

enum int DNS_ERROR_RECORD_ALREADY_EXISTS = 0x000025ef;
enum int DNS_ERROR_NO_CREATE_CACHE_DATA = 0x000025f1;

enum : int
{
    DNS_WARNING_PTR_CREATE_FAILED = 0x000025f3,
    DNS_WARNING_DOMAIN_UNDELETED  = 0x000025f4,
}

enum int DNS_ERROR_DS_ZONE_ALREADY_EXISTS = 0x000025f6;

enum : int
{
    DNS_ERROR_NODE_IS_DNAME   = 0x000025f8,
    DNS_ERROR_DNAME_COLLISION = 0x000025f9,
}

enum int DNS_ERROR_OPERATION_BASE = 0x00002616;
enum int DNS_ERROR_AXFR = 0x00002618;
enum int DNS_ERROR_SECURE_BASE = 0x00002648;

enum : int
{
    DNS_ERROR_SETUP_BASE                     = 0x0000267a,
    DNS_ERROR_NO_TCPIP                       = 0x0000267b,
    DNS_ERROR_NO_DNS_SERVERS                 = 0x0000267c,
    DNS_ERROR_DP_BASE                        = 0x000026ac,
    DNS_ERROR_DP_DOES_NOT_EXIST              = 0x000026ad,
    DNS_ERROR_DP_ALREADY_EXISTS              = 0x000026ae,
    DNS_ERROR_DP_NOT_ENLISTED                = 0x000026af,
    DNS_ERROR_DP_ALREADY_ENLISTED            = 0x000026b0,
    DNS_ERROR_DP_NOT_AVAILABLE               = 0x000026b1,
    DNS_ERROR_DP_FSMO_ERROR                  = 0x000026b2,
    DNS_ERROR_RRL_NOT_ENABLED                = 0x000026b7,
    DNS_ERROR_RRL_INVALID_WINDOW_SIZE        = 0x000026b8,
    DNS_ERROR_RRL_INVALID_IPV4_PREFIX        = 0x000026b9,
    DNS_ERROR_RRL_INVALID_IPV6_PREFIX        = 0x000026ba,
    DNS_ERROR_RRL_INVALID_TC_RATE            = 0x000026bb,
    DNS_ERROR_RRL_INVALID_LEAK_RATE          = 0x000026bc,
    DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE = 0x000026bd,
}

enum : int
{
    DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST = 0x000026c2,
    DNS_ERROR_VIRTUALIZATION_TREE_LOCKED             = 0x000026c3,
}

enum int DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE = 0x000026c5;
enum int DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST = 0x000026e0;
enum int DNS_ERROR_INVALID_ZONESCOPE_NAME = 0x000026e2;
enum int DNS_ERROR_LOAD_ZONESCOPE_FAILED = 0x000026e4;
enum int DNS_ERROR_INVALID_SCOPE_NAME = 0x000026e6;

enum : int
{
    DNS_ERROR_DEFAULT_SCOPE           = 0x000026e8,
    DNS_ERROR_INVALID_SCOPE_OPERATION = 0x000026e9,
}

enum int DNS_ERROR_SCOPE_ALREADY_EXISTS = 0x000026eb;

enum : int
{
    DNS_ERROR_POLICY_DOES_NOT_EXIST   = 0x000026f4,
    DNS_ERROR_POLICY_INVALID_CRITERIA = 0x000026f5,
    DNS_ERROR_POLICY_INVALID_SETTINGS = 0x000026f6,
}

enum : int
{
    DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST = 0x000026f8,
    DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS = 0x000026f9,
}

enum int DNS_ERROR_SUBNET_ALREADY_EXISTS = 0x000026fb;

enum : int
{
    DNS_ERROR_POLICY_INVALID_WEIGHT   = 0x000026fd,
    DNS_ERROR_POLICY_INVALID_NAME     = 0x000026fe,
    DNS_ERROR_POLICY_MISSING_CRITERIA = 0x000026ff,
}

enum : int
{
    DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID = 0x00002701,
    DNS_ERROR_POLICY_SCOPE_MISSING            = 0x00002702,
    DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED        = 0x00002703,
}

enum int DNS_ERROR_ZONESCOPE_IS_REFERENCED = 0x00002705;

enum : int
{
    DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL = 0x00002707,
    DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL   = 0x00002708,
    DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE          = 0x00002709,
    DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN               = 0x0000270a,
    DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE         = 0x0000270b,
    DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY        = 0x0000270c,
}

enum : int
{
    WSAEINTR       = 0x00002714,
    WSAEBADF       = 0x00002719,
    WSAEACCES      = 0x0000271d,
    WSAEFAULT      = 0x0000271e,
    WSAEINVAL      = 0x00002726,
    WSAEMFILE      = 0x00002728,
    WSAEWOULDBLOCK = 0x00002733,
}

enum int WSAEALREADY = 0x00002735;
enum int WSAEDESTADDRREQ = 0x00002737;
enum int WSAEPROTOTYPE = 0x00002739;
enum int WSAEPROTONOSUPPORT = 0x0000273b;
enum int WSAEOPNOTSUPP = 0x0000273d;
enum int WSAEAFNOSUPPORT = 0x0000273f;
enum int WSAEADDRNOTAVAIL = 0x00002741;

enum : int
{
    WSAENETUNREACH = 0x00002743,
    WSAENETRESET   = 0x00002744,
}

enum int WSAECONNRESET = 0x00002746;
enum int WSAEISCONN = 0x00002748;
enum int WSAESHUTDOWN = 0x0000274a;
enum int WSAETIMEDOUT = 0x0000274c;

enum : int
{
    WSAELOOP        = 0x0000274e,
    WSAENAMETOOLONG = 0x0000274f,
}

enum int WSAEHOSTUNREACH = 0x00002751;
enum int WSAEPROCLIM = 0x00002753;

enum : int
{
    WSAEDQUOT  = 0x00002755,
    WSAESTALE  = 0x00002756,
    WSAEREMOTE = 0x00002757,
}

enum int WSAVERNOTSUPPORTED = 0x0000276c;
enum int WSAEDISCON = 0x00002775;
enum int WSAECANCELLED = 0x00002777;
enum int WSAEINVALIDPROVIDER = 0x00002779;
enum int WSASYSCALLFAILURE = 0x0000277b;
enum int WSATYPE_NOT_FOUND = 0x0000277d;
enum int WSA_E_CANCELLED = 0x0000277f;
enum int WSAHOST_NOT_FOUND = 0x00002af9;

enum : int
{
    WSANO_RECOVERY = 0x00002afb,
    WSANO_DATA     = 0x00002afc,
}

enum : int
{
    WSA_QOS_SENDERS      = 0x00002afe,
    WSA_QOS_NO_SENDERS   = 0x00002aff,
    WSA_QOS_NO_RECEIVERS = 0x00002b00,
}

enum int WSA_QOS_ADMISSION_FAILURE = 0x00002b02;

enum : int
{
    WSA_QOS_BAD_STYLE          = 0x00002b04,
    WSA_QOS_BAD_OBJECT         = 0x00002b05,
    WSA_QOS_TRAFFIC_CTRL_ERROR = 0x00002b06,
}

enum : int
{
    WSA_QOS_ESERVICETYPE  = 0x00002b08,
    WSA_QOS_EFLOWSPEC     = 0x00002b09,
    WSA_QOS_EPROVSPECBUF  = 0x00002b0a,
    WSA_QOS_EFILTERSTYLE  = 0x00002b0b,
    WSA_QOS_EFILTERTYPE   = 0x00002b0c,
    WSA_QOS_EFILTERCOUNT  = 0x00002b0d,
    WSA_QOS_EOBJLENGTH    = 0x00002b0e,
    WSA_QOS_EFLOWCOUNT    = 0x00002b0f,
    WSA_QOS_EUNKOWNPSOBJ  = 0x00002b10,
    WSA_QOS_EPOLICYOBJ    = 0x00002b11,
    WSA_QOS_EFLOWDESC     = 0x00002b12,
    WSA_QOS_EPSFLOWSPEC   = 0x00002b13,
    WSA_QOS_EPSFILTERSPEC = 0x00002b14,
    WSA_QOS_ESDMODEOBJ    = 0x00002b15,
    WSA_QOS_ESHAPERATEOBJ = 0x00002b16,
}

enum int WSA_SECURE_HOST_NOT_FOUND = 0x00002b18;

enum : int
{
    ERROR_IPSEC_QM_POLICY_EXISTS    = 0x000032c8,
    ERROR_IPSEC_QM_POLICY_NOT_FOUND = 0x000032c9,
    ERROR_IPSEC_QM_POLICY_IN_USE    = 0x000032ca,
    ERROR_IPSEC_MM_POLICY_EXISTS    = 0x000032cb,
    ERROR_IPSEC_MM_POLICY_NOT_FOUND = 0x000032cc,
    ERROR_IPSEC_MM_POLICY_IN_USE    = 0x000032cd,
    ERROR_IPSEC_MM_FILTER_EXISTS    = 0x000032ce,
    ERROR_IPSEC_MM_FILTER_NOT_FOUND = 0x000032cf,
}

enum int ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND = 0x000032d1;

enum : int
{
    ERROR_IPSEC_MM_AUTH_NOT_FOUND           = 0x000032d3,
    ERROR_IPSEC_MM_AUTH_IN_USE              = 0x000032d4,
    ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND = 0x000032d5,
    ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND   = 0x000032d6,
    ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND = 0x000032d7,
}

enum int ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND = 0x000032d9;
enum int ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION = 0x000032db;
enum int ERROR_IPSEC_MM_POLICY_PENDING_DELETION = 0x000032dd;
enum int ERROR_IPSEC_QM_POLICY_PENDING_DELETION = 0x000032df;
enum int WARNING_IPSEC_QM_POLICY_PRUNED = 0x000032e1;

enum : int
{
    ERROR_IPSEC_IKE_AUTH_FAIL                = 0x000035e9,
    ERROR_IPSEC_IKE_ATTRIB_FAIL              = 0x000035ea,
    ERROR_IPSEC_IKE_NEGOTIATION_PENDING      = 0x000035eb,
    ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR = 0x000035ec,
}

enum : int
{
    ERROR_IPSEC_IKE_NO_CERT                         = 0x000035ee,
    ERROR_IPSEC_IKE_SA_DELETED                      = 0x000035ef,
    ERROR_IPSEC_IKE_SA_REAPED                       = 0x000035f0,
    ERROR_IPSEC_IKE_MM_ACQUIRE_DROP                 = 0x000035f1,
    ERROR_IPSEC_IKE_QM_ACQUIRE_DROP                 = 0x000035f2,
    ERROR_IPSEC_IKE_QUEUE_DROP_MM                   = 0x000035f3,
    ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM                = 0x000035f4,
    ERROR_IPSEC_IKE_DROP_NO_RESPONSE                = 0x000035f5,
    ERROR_IPSEC_IKE_MM_DELAY_DROP                   = 0x000035f6,
    ERROR_IPSEC_IKE_QM_DELAY_DROP                   = 0x000035f7,
    ERROR_IPSEC_IKE_ERROR                           = 0x000035f8,
    ERROR_IPSEC_IKE_CRL_FAILED                      = 0x000035f9,
    ERROR_IPSEC_IKE_INVALID_KEY_USAGE               = 0x000035fa,
    ERROR_IPSEC_IKE_INVALID_CERT_TYPE               = 0x000035fb,
    ERROR_IPSEC_IKE_NO_PRIVATE_KEY                  = 0x000035fc,
    ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY              = 0x000035fd,
    ERROR_IPSEC_IKE_DH_FAIL                         = 0x000035fe,
    ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED = 0x000035ff,
}

enum : int
{
    ERROR_IPSEC_IKE_NO_POLICY                         = 0x00003601,
    ERROR_IPSEC_IKE_INVALID_SIGNATURE                 = 0x00003602,
    ERROR_IPSEC_IKE_KERBEROS_ERROR                    = 0x00003603,
    ERROR_IPSEC_IKE_NO_PUBLIC_KEY                     = 0x00003604,
    ERROR_IPSEC_IKE_PROCESS_ERR                       = 0x00003605,
    ERROR_IPSEC_IKE_PROCESS_ERR_SA                    = 0x00003606,
    ERROR_IPSEC_IKE_PROCESS_ERR_PROP                  = 0x00003607,
    ERROR_IPSEC_IKE_PROCESS_ERR_TRANS                 = 0x00003608,
    ERROR_IPSEC_IKE_PROCESS_ERR_KE                    = 0x00003609,
    ERROR_IPSEC_IKE_PROCESS_ERR_ID                    = 0x0000360a,
    ERROR_IPSEC_IKE_PROCESS_ERR_CERT                  = 0x0000360b,
    ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ              = 0x0000360c,
    ERROR_IPSEC_IKE_PROCESS_ERR_HASH                  = 0x0000360d,
    ERROR_IPSEC_IKE_PROCESS_ERR_SIG                   = 0x0000360e,
    ERROR_IPSEC_IKE_PROCESS_ERR_NONCE                 = 0x0000360f,
    ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY                = 0x00003610,
    ERROR_IPSEC_IKE_PROCESS_ERR_DELETE                = 0x00003611,
    ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR                = 0x00003612,
    ERROR_IPSEC_IKE_INVALID_PAYLOAD                   = 0x00003613,
    ERROR_IPSEC_IKE_LOAD_SOFT_SA                      = 0x00003614,
    ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN                 = 0x00003615,
    ERROR_IPSEC_IKE_INVALID_COOKIE                    = 0x00003616,
    ERROR_IPSEC_IKE_NO_PEER_CERT                      = 0x00003617,
    ERROR_IPSEC_IKE_PEER_CRL_FAILED                   = 0x00003618,
    ERROR_IPSEC_IKE_POLICY_CHANGE                     = 0x00003619,
    ERROR_IPSEC_IKE_NO_MM_POLICY                      = 0x0000361a,
    ERROR_IPSEC_IKE_NOTCBPRIV                         = 0x0000361b,
    ERROR_IPSEC_IKE_SECLOADFAIL                       = 0x0000361c,
    ERROR_IPSEC_IKE_FAILSSPINIT                       = 0x0000361d,
    ERROR_IPSEC_IKE_FAILQUERYSSP                      = 0x0000361e,
    ERROR_IPSEC_IKE_SRVACQFAIL                        = 0x0000361f,
    ERROR_IPSEC_IKE_SRVQUERYCRED                      = 0x00003620,
    ERROR_IPSEC_IKE_GETSPIFAIL                        = 0x00003621,
    ERROR_IPSEC_IKE_INVALID_FILTER                    = 0x00003622,
    ERROR_IPSEC_IKE_OUT_OF_MEMORY                     = 0x00003623,
    ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED             = 0x00003624,
    ERROR_IPSEC_IKE_INVALID_POLICY                    = 0x00003625,
    ERROR_IPSEC_IKE_UNKNOWN_DOI                       = 0x00003626,
    ERROR_IPSEC_IKE_INVALID_SITUATION                 = 0x00003627,
    ERROR_IPSEC_IKE_DH_FAILURE                        = 0x00003628,
    ERROR_IPSEC_IKE_INVALID_GROUP                     = 0x00003629,
    ERROR_IPSEC_IKE_ENCRYPT                           = 0x0000362a,
    ERROR_IPSEC_IKE_DECRYPT                           = 0x0000362b,
    ERROR_IPSEC_IKE_POLICY_MATCH                      = 0x0000362c,
    ERROR_IPSEC_IKE_UNSUPPORTED_ID                    = 0x0000362d,
    ERROR_IPSEC_IKE_INVALID_HASH                      = 0x0000362e,
    ERROR_IPSEC_IKE_INVALID_HASH_ALG                  = 0x0000362f,
    ERROR_IPSEC_IKE_INVALID_HASH_SIZE                 = 0x00003630,
    ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG               = 0x00003631,
    ERROR_IPSEC_IKE_INVALID_AUTH_ALG                  = 0x00003632,
    ERROR_IPSEC_IKE_INVALID_SIG                       = 0x00003633,
    ERROR_IPSEC_IKE_LOAD_FAILED                       = 0x00003634,
    ERROR_IPSEC_IKE_RPC_DELETE                        = 0x00003635,
    ERROR_IPSEC_IKE_BENIGN_REINIT                     = 0x00003636,
    ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY = 0x00003637,
    ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION             = 0x00003638,
    ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN               = 0x00003639,
    ERROR_IPSEC_IKE_MM_LIMIT                          = 0x0000363a,
    ERROR_IPSEC_IKE_NEGOTIATION_DISABLED              = 0x0000363b,
    ERROR_IPSEC_IKE_QM_LIMIT                          = 0x0000363c,
    ERROR_IPSEC_IKE_MM_EXPIRED                        = 0x0000363d,
    ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID           = 0x0000363e,
    ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH        = 0x0000363f,
}

enum : int
{
    ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD        = 0x00003641,
    ERROR_IPSEC_IKE_DOS_COOKIE_SENT             = 0x00003642,
    ERROR_IPSEC_IKE_SHUTTING_DOWN               = 0x00003643,
    ERROR_IPSEC_IKE_CGA_AUTH_FAILED             = 0x00003644,
    ERROR_IPSEC_IKE_PROCESS_ERR_NATOA           = 0x00003645,
    ERROR_IPSEC_IKE_INVALID_MM_FOR_QM           = 0x00003646,
    ERROR_IPSEC_IKE_QM_EXPIRED                  = 0x00003647,
    ERROR_IPSEC_IKE_TOO_MANY_FILTERS            = 0x00003648,
    ERROR_IPSEC_IKE_NEG_STATUS_END              = 0x00003649,
    ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL       = 0x0000364a,
    ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE = 0x0000364b,
}

enum int ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING = 0x0000364d;

enum : int
{
    ERROR_IPSEC_IKE_RATELIMIT_DROP             = 0x0000364f,
    ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE = 0x00003650,
}

enum int ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE = 0x00003652;
enum int ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE = 0x00003654;

enum : int
{
    ERROR_IPSEC_BAD_SPI             = 0x00003656,
    ERROR_IPSEC_SA_LIFETIME_EXPIRED = 0x00003657,
}

enum int ERROR_IPSEC_REPLAY_CHECK_FAILED = 0x00003659;
enum int ERROR_IPSEC_INTEGRITY_CHECK_FAILED = 0x0000365b;
enum int ERROR_IPSEC_AUTH_FIREWALL_DROP = 0x0000365d;

enum : int
{
    ERROR_IPSEC_DOSP_BLOCK                       = 0x00003665,
    ERROR_IPSEC_DOSP_RECEIVED_MULTICAST          = 0x00003666,
    ERROR_IPSEC_DOSP_INVALID_PACKET              = 0x00003667,
    ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED         = 0x00003668,
    ERROR_IPSEC_DOSP_MAX_ENTRIES                 = 0x00003669,
    ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED          = 0x0000366a,
    ERROR_IPSEC_DOSP_NOT_INSTALLED               = 0x0000366b,
    ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = 0x0000366c,
}

enum int ERROR_SXS_CANT_GEN_ACTCTX = 0x000036b1;
enum int ERROR_SXS_ASSEMBLY_NOT_FOUND = 0x000036b3;
enum int ERROR_SXS_MANIFEST_PARSE_ERROR = 0x000036b5;

enum : int
{
    ERROR_SXS_KEY_NOT_FOUND    = 0x000036b7,
    ERROR_SXS_VERSION_CONFLICT = 0x000036b8,
}

enum int ERROR_SXS_THREAD_QUERIES_DISABLED = 0x000036ba;

enum : int
{
    ERROR_SXS_UNKNOWN_ENCODING_GROUP = 0x000036bc,
    ERROR_SXS_UNKNOWN_ENCODING       = 0x000036bd,
}

enum int ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED = 0x000036bf;
enum int ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE = 0x000036c1;
enum int ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE = 0x000036c3;

enum : int
{
    ERROR_SXS_DUPLICATE_DLL_NAME         = 0x000036c5,
    ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME = 0x000036c6,
    ERROR_SXS_DUPLICATE_CLSID            = 0x000036c7,
    ERROR_SXS_DUPLICATE_IID              = 0x000036c8,
    ERROR_SXS_DUPLICATE_TLBID            = 0x000036c9,
    ERROR_SXS_DUPLICATE_PROGID           = 0x000036ca,
    ERROR_SXS_DUPLICATE_ASSEMBLY_NAME    = 0x000036cb,
}

enum int ERROR_SXS_POLICY_PARSE_ERROR = 0x000036cd;

enum : int
{
    ERROR_SXS_XML_E_COMMENTSYNTAX            = 0x000036cf,
    ERROR_SXS_XML_E_BADSTARTNAMECHAR         = 0x000036d0,
    ERROR_SXS_XML_E_BADNAMECHAR              = 0x000036d1,
    ERROR_SXS_XML_E_BADCHARINSTRING          = 0x000036d2,
    ERROR_SXS_XML_E_XMLDECLSYNTAX            = 0x000036d3,
    ERROR_SXS_XML_E_BADCHARDATA              = 0x000036d4,
    ERROR_SXS_XML_E_MISSINGWHITESPACE        = 0x000036d5,
    ERROR_SXS_XML_E_EXPECTINGTAGEND          = 0x000036d6,
    ERROR_SXS_XML_E_MISSINGSEMICOLON         = 0x000036d7,
    ERROR_SXS_XML_E_UNBALANCEDPAREN          = 0x000036d8,
    ERROR_SXS_XML_E_INTERNALERROR            = 0x000036d9,
    ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE    = 0x000036da,
    ERROR_SXS_XML_E_INCOMPLETE_ENCODING      = 0x000036db,
    ERROR_SXS_XML_E_MISSING_PAREN            = 0x000036dc,
    ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE      = 0x000036dd,
    ERROR_SXS_XML_E_MULTIPLE_COLONS          = 0x000036de,
    ERROR_SXS_XML_E_INVALID_DECIMAL          = 0x000036df,
    ERROR_SXS_XML_E_INVALID_HEXIDECIMAL      = 0x000036e0,
    ERROR_SXS_XML_E_INVALID_UNICODE          = 0x000036e1,
    ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK = 0x000036e2,
}

enum : int
{
    ERROR_SXS_XML_E_UNCLOSEDTAG           = 0x000036e4,
    ERROR_SXS_XML_E_DUPLICATEATTRIBUTE    = 0x000036e5,
    ERROR_SXS_XML_E_MULTIPLEROOTS         = 0x000036e6,
    ERROR_SXS_XML_E_INVALIDATROOTLEVEL    = 0x000036e7,
    ERROR_SXS_XML_E_BADXMLDECL            = 0x000036e8,
    ERROR_SXS_XML_E_MISSINGROOT           = 0x000036e9,
    ERROR_SXS_XML_E_UNEXPECTEDEOF         = 0x000036ea,
    ERROR_SXS_XML_E_BADPEREFINSUBSET      = 0x000036eb,
    ERROR_SXS_XML_E_UNCLOSEDSTARTTAG      = 0x000036ec,
    ERROR_SXS_XML_E_UNCLOSEDENDTAG        = 0x000036ed,
    ERROR_SXS_XML_E_UNCLOSEDSTRING        = 0x000036ee,
    ERROR_SXS_XML_E_UNCLOSEDCOMMENT       = 0x000036ef,
    ERROR_SXS_XML_E_UNCLOSEDDECL          = 0x000036f0,
    ERROR_SXS_XML_E_UNCLOSEDCDATA         = 0x000036f1,
    ERROR_SXS_XML_E_RESERVEDNAMESPACE     = 0x000036f2,
    ERROR_SXS_XML_E_INVALIDENCODING       = 0x000036f3,
    ERROR_SXS_XML_E_INVALIDSWITCH         = 0x000036f4,
    ERROR_SXS_XML_E_BADXMLCASE            = 0x000036f5,
    ERROR_SXS_XML_E_INVALID_STANDALONE    = 0x000036f6,
    ERROR_SXS_XML_E_UNEXPECTED_STANDALONE = 0x000036f7,
    ERROR_SXS_XML_E_INVALID_VERSION       = 0x000036f8,
    ERROR_SXS_XML_E_MISSINGEQUALS         = 0x000036f9,
}

enum : int
{
    ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT = 0x000036fb,
    ERROR_SXS_PROTECTION_CATALOG_NOT_VALID    = 0x000036fc,
}

enum int ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING = 0x000036fe;
enum int ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME = 0x00003700;

enum : int
{
    ERROR_SXS_CORRUPT_ACTIVATION_STACK = 0x00003702,
    ERROR_SXS_CORRUPTION               = 0x00003703,
    ERROR_SXS_EARLY_DEACTIVATION       = 0x00003704,
}

enum int ERROR_SXS_MULTIPLE_DEACTIVATION = 0x00003706;
enum int ERROR_SXS_RELEASE_ACTIVATION_CONTEXT = 0x00003708;

enum : int
{
    ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 0x0000370a,
    ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME  = 0x0000370b,
}

enum int ERROR_SXS_IDENTITY_PARSE_ERROR = 0x0000370d;
enum int ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN = 0x0000370f;
enum int ERROR_SXS_ASSEMBLY_NOT_LOCKED = 0x00003711;
enum int ERROR_ADVANCED_INSTALLER_FAILED = 0x00003713;
enum int ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 0x00003715;
enum int ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 0x00003717;
enum int ERROR_SXS_MANIFEST_TOO_BIG = 0x00003719;
enum int ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 0x0000371b;
enum int ERROR_GENERIC_COMMAND_FAILED = 0x0000371d;
enum int ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS = 0x0000371f;

enum : int
{
    ERROR_EVT_INVALID_QUERY                = 0x00003a99,
    ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND = 0x00003a9a,
}

enum : int
{
    ERROR_EVT_INVALID_PUBLISHER_NAME = 0x00003a9c,
    ERROR_EVT_INVALID_EVENT_DATA     = 0x00003a9d,
}

enum int ERROR_EVT_MALFORMED_XML_TEXT = 0x00003aa0;
enum int ERROR_EVT_CONFIGURATION_ERROR = 0x00003aa2;
enum int ERROR_EVT_QUERY_RESULT_INVALID_POSITION = 0x00003aa4;

enum : int
{
    ERROR_EVT_FILTER_ALREADYSCOPED   = 0x00003aa6,
    ERROR_EVT_FILTER_NOTELTSET       = 0x00003aa7,
    ERROR_EVT_FILTER_INVARG          = 0x00003aa8,
    ERROR_EVT_FILTER_INVTEST         = 0x00003aa9,
    ERROR_EVT_FILTER_INVTYPE         = 0x00003aaa,
    ERROR_EVT_FILTER_PARSEERR        = 0x00003aab,
    ERROR_EVT_FILTER_UNSUPPORTEDOP   = 0x00003aac,
    ERROR_EVT_FILTER_UNEXPECTEDTOKEN = 0x00003aad,
}

enum : int
{
    ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE   = 0x00003aaf,
    ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE = 0x00003ab0,
}

enum int ERROR_EVT_FILTER_TOO_COMPLEX = 0x00003ab2;
enum int ERROR_EVT_MESSAGE_ID_NOT_FOUND = 0x00003ab4;
enum int ERROR_EVT_UNRESOLVED_PARAMETER_INSERT = 0x00003ab6;
enum int ERROR_EVT_EVENT_DEFINITION_NOT_FOUND = 0x00003ab8;

enum : int
{
    ERROR_EVT_VERSION_TOO_OLD = 0x00003aba,
    ERROR_EVT_VERSION_TOO_NEW = 0x00003abb,
}

enum int ERROR_EVT_PUBLISHER_DISABLED = 0x00003abd;
enum int ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE = 0x00003ae8;
enum int ERROR_EC_CIRCULAR_FORWARDING = 0x00003aea;
enum int ERROR_EC_CRED_NOT_FOUND = 0x00003aec;

enum : int
{
    ERROR_MUI_FILE_NOT_FOUND                = 0x00003afc,
    ERROR_MUI_INVALID_FILE                  = 0x00003afd,
    ERROR_MUI_INVALID_RC_CONFIG             = 0x00003afe,
    ERROR_MUI_INVALID_LOCALE_NAME           = 0x00003aff,
    ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME = 0x00003b00,
}

enum int ERROR_RESOURCE_ENUM_USER_STOP = 0x00003b02;
enum int ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME = 0x00003b04;

enum : int
{
    ERROR_MRM_INVALID_PRICONFIG = 0x00003b07,
    ERROR_MRM_INVALID_FILE_TYPE = 0x00003b08,
}

enum int ERROR_MRM_INVALID_QUALIFIER_VALUE = 0x00003b0a;
enum int ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE = 0x00003b0c;

enum : int
{
    ERROR_MRM_DUPLICATE_MAP_NAME = 0x00003b0e,
    ERROR_MRM_DUPLICATE_ENTRY    = 0x00003b0f,
}

enum int ERROR_MRM_FILEPATH_TOO_LONG = 0x00003b11;
enum int ERROR_MRM_INVALID_PRI_FILE = 0x00003b16;

enum : int
{
    ERROR_MRM_MAP_NOT_FOUND            = 0x00003b1f,
    ERROR_MRM_UNSUPPORTED_PROFILE_TYPE = 0x00003b20,
}

enum int ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE = 0x00003b22;
enum int ERROR_MRM_TOO_MANY_RESOURCES = 0x00003b24;
enum int ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE = 0x00003b26;
enum int ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST = 0x00003b28;
enum int ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE = 0x00003b2a;

enum : int
{
    ERROR_PRI_MERGE_VERSION_MISMATCH                      = 0x00003b2c,
    ERROR_PRI_MERGE_MISSING_SCHEMA                        = 0x00003b2d,
    ERROR_PRI_MERGE_LOAD_FILE_FAILED                      = 0x00003b2e,
    ERROR_PRI_MERGE_ADD_FILE_FAILED                       = 0x00003b2f,
    ERROR_PRI_MERGE_WRITE_FILE_FAILED                     = 0x00003b30,
    ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED = 0x00003b31,
    ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED    = 0x00003b32,
}

enum : int
{
    ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED     = 0x00003b34,
    ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED = 0x00003b35,
}

enum int ERROR_MRM_PACKAGE_NOT_FOUND = 0x00003b37;

enum : int
{
    ERROR_MCA_INVALID_CAPABILITIES_STRING = 0x00003b60,
    ERROR_MCA_INVALID_VCP_VERSION         = 0x00003b61,
}

enum int ERROR_MCA_MCCS_VERSION_MISMATCH = 0x00003b63;

enum : int
{
    ERROR_MCA_INTERNAL_ERROR                   = 0x00003b65,
    ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = 0x00003b66,
}

enum int ERROR_AMBIGUOUS_SYSTEM_DEVICE = 0x00003b92;

enum : int
{
    ERROR_HASH_NOT_SUPPORTED = 0x00003bc4,
    ERROR_HASH_NOT_PRESENT   = 0x00003bc5,
}

enum int ERROR_GPIO_CLIENT_INFORMATION_INVALID = 0x00003bda;
enum int ERROR_GPIO_INVALID_REGISTRATION_PACKET = 0x00003bdc;
enum int ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE = 0x00003bde;
enum int ERROR_CANNOT_SWITCH_RUNLEVEL = 0x00003c28;

enum : int
{
    ERROR_RUNLEVEL_SWITCH_TIMEOUT       = 0x00003c2a,
    ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT = 0x00003c2b,
    ERROR_RUNLEVEL_SWITCH_IN_PROGRESS   = 0x00003c2c,
}

enum int ERROR_COM_TASK_STOP_PENDING = 0x00003c8d;

enum : int
{
    ERROR_INSTALL_PACKAGE_NOT_FOUND         = 0x00003cf1,
    ERROR_INSTALL_INVALID_PACKAGE           = 0x00003cf2,
    ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED = 0x00003cf3,
}

enum : int
{
    ERROR_INSTALL_NETWORK_FAILURE        = 0x00003cf5,
    ERROR_INSTALL_REGISTRATION_FAILURE   = 0x00003cf6,
    ERROR_INSTALL_DEREGISTRATION_FAILURE = 0x00003cf7,
}

enum int ERROR_INSTALL_FAILED = 0x00003cf9;
enum int ERROR_PACKAGE_ALREADY_EXISTS = 0x00003cfb;
enum int ERROR_INSTALL_PREREQUISITE_FAILED = 0x00003cfd;
enum int ERROR_INSTALL_POLICY_FAILURE = 0x00003cff;
enum int ERROR_DEPLOYMENT_BLOCKED_BY_POLICY = 0x00003d01;
enum int ERROR_RECOVERY_FILE_CORRUPT = 0x00003d03;
enum int ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED = 0x00003d05;
enum int ERROR_SYSTEM_NEEDS_REMEDIATION = 0x00003d07;
enum int ERROR_RESILIENCY_FILE_CORRUPT = 0x00003d09;
enum int ERROR_PACKAGE_MOVE_FAILED = 0x00003d0b;

enum : int
{
    ERROR_INSTALL_VOLUME_OFFLINE = 0x00003d0d,
    ERROR_INSTALL_VOLUME_CORRUPT = 0x00003d0e,
}

enum int ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE = 0x00003d10;
enum int ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE = 0x00003d12;
enum int ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING = 0x00003d14;
enum int ERROR_PACKAGE_STAGING_ONHOLD = 0x00003d16;
enum int ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY = 0x00003d18;
enum int ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED = 0x00003d1a;
enum int ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT = 0x00003d1c;
enum int ERROR_APPINSTALLER_ACTIVATION_BLOCKED = 0x00003d1e;
enum int ERROR_APPX_RAW_DATA_WRITE_FAILED = 0x00003d20;

enum : int
{
    ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE             = 0x00003d22,
    ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY                    = 0x00003d23,
    ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY = 0x00003d24,
}

enum int ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED = 0x00003d26;
enum int ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES = 0x00003d28;
enum int ERROR_PACKAGE_LACKS_CAPABILITY_TO_DEPLOY_ON_HOST = 0x00003d2a;
enum int ERROR_UNSIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE = 0x00003d2c;
enum int ERROR_PACKAGE_EXTERNAL_LOCATION_NOT_ALLOWED = 0x00003d2e;

enum : int
{
    APPMODEL_ERROR_NO_PACKAGE               = 0x00003d54,
    APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT  = 0x00003d55,
    APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT = 0x00003d56,
}

enum : int
{
    APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED = 0x00003d58,
    APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID     = 0x00003d59,
}

enum int APPMODEL_ERROR_NO_MUTABLE_DIRECTORY = 0x00003d5b;
enum int ERROR_STATE_GET_VERSION_FAILED = 0x00003db9;
enum int ERROR_STATE_STRUCTURED_RESET_FAILED = 0x00003dbb;
enum int ERROR_STATE_CREATE_CONTAINER_FAILED = 0x00003dbd;
enum int ERROR_STATE_READ_SETTING_FAILED = 0x00003dbf;
enum int ERROR_STATE_DELETE_SETTING_FAILED = 0x00003dc1;
enum int ERROR_STATE_READ_COMPOSITE_SETTING_FAILED = 0x00003dc3;

enum : int
{
    ERROR_STATE_ENUMERATE_CONTAINER_FAILED = 0x00003dc5,
    ERROR_STATE_ENUMERATE_SETTINGS_FAILED  = 0x00003dc6,
}

enum : int
{
    ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED = 0x00003dc8,
    ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED  = 0x00003dc9,
}

enum int ERROR_API_UNAVAILABLE = 0x00003de1;

enum : int
{
    STORE_ERROR_UNLICENSED_USER         = 0x00003df6,
    STORE_ERROR_PENDING_COM_TRANSACTION = 0x00003df7,
}

enum : int
{
    SEVERITY_SUCCESS = 0x00000000,
    SEVERITY_ERROR   = 0x00000001,
}

enum int NOERROR = 0x00000000;
enum int E_NOTIMPL = 0x80004001;
enum int E_INVALIDARG = 0x80070057;
enum int E_POINTER = 0x80004003;
enum int E_ABORT = 0x80004004;
enum int E_ACCESSDENIED = 0x80070005;
enum int E_BOUNDS = 0x8000000b;

enum : int
{
    E_ILLEGAL_STATE_CHANGE = 0x8000000d,
    E_ILLEGAL_METHOD_CALL  = 0x8000000e,
}

enum : int
{
    RO_E_METADATA_NAME_IS_NAMESPACE   = 0x80000010,
    RO_E_METADATA_INVALID_TYPE_FORMAT = 0x80000011,
}

enum : int
{
    RO_E_CLOSED          = 0x80000013,
    RO_E_EXCLUSIVE_WRITE = 0x80000014,
}

enum int RO_E_ERROR_STRING_NOT_FOUND = 0x80000016;
enum int E_ILLEGAL_DELEGATE_ASSIGNMENT = 0x80000018;

enum : int
{
    E_APPLICATION_EXITING      = 0x8000001a,
    E_APPLICATION_VIEW_EXITING = 0x8000001b,
}

enum int RO_E_UNSUPPORTED_FROM_MTA = 0x8000001d;
enum int RO_E_BLOCKED_CROSS_ASTA_CALL = 0x8000001f;
enum int RO_E_CANNOT_ACTIVATE_UNIVERSAL_APPLICATION_SERVER = 0x80000021;
enum int CO_E_INIT_SHARED_ALLOCATOR = 0x80004007;

enum : int
{
    CO_E_INIT_CLASS_CACHE             = 0x80004009,
    CO_E_INIT_RPC_CHANNEL             = 0x8000400a,
    CO_E_INIT_TLS_SET_CHANNEL_CONTROL = 0x8000400b,
    CO_E_INIT_TLS_CHANNEL_CONTROL     = 0x8000400c,
}

enum : int
{
    CO_E_INIT_SCM_MUTEX_EXISTS        = 0x8000400e,
    CO_E_INIT_SCM_FILE_MAPPING_EXISTS = 0x8000400f,
    CO_E_INIT_SCM_MAP_VIEW_OF_FILE    = 0x80004010,
    CO_E_INIT_SCM_EXEC_FAILURE        = 0x80004011,
}

enum int CO_E_CANT_REMOTE = 0x80004013;
enum int CO_E_WRONG_SERVER_IDENTITY = 0x80004015;
enum int CO_E_RUNAS_SYNTAX = 0x80004017;
enum int CO_E_RUNAS_CREATEPROCESS_FAILURE = 0x80004019;
enum int CO_E_LAUNCH_PERMSSION_DENIED = 0x8000401b;
enum int CO_E_REMOTE_COMMUNICATION_FAILURE = 0x8000401d;
enum int CO_E_CLSREG_INCONSISTENT = 0x8000401f;
enum int CO_E_NOT_SUPPORTED = 0x80004021;
enum int CO_E_MSI_ERROR = 0x80004023;

enum : int
{
    CO_E_SERVER_PAUSED     = 0x80004025,
    CO_E_SERVER_NOT_PAUSED = 0x80004026,
}

enum int CO_E_CLRNOTAVAILABLE = 0x80004028;
enum int CO_E_SERVER_INIT_TIMEOUT = 0x8000402a;
enum int CO_E_TRACKER_CONFIG = 0x80004030;
enum int CO_E_SXS_CONFIG = 0x80004032;
enum int CO_E_UNREVOKED_REGISTRATION_ON_APARTMENT_SHUTDOWN = 0x80004034;

enum : int
{
    S_OK    = 0x00000000,
    S_FALSE = 0x00000001,
}

enum int OLE_E_LAST = 0x800400ff;
enum int OLE_S_LAST = 0x000400ff;

enum : int
{
    OLE_E_ADVF        = 0x80040001,
    OLE_E_ENUM_NOMORE = 0x80040002,
}

enum : int
{
    OLE_E_NOCONNECTION      = 0x80040004,
    OLE_E_NOTRUNNING        = 0x80040005,
    OLE_E_NOCACHE           = 0x80040006,
    OLE_E_BLANK             = 0x80040007,
    OLE_E_CLASSDIFF         = 0x80040008,
    OLE_E_CANT_GETMONIKER   = 0x80040009,
    OLE_E_CANT_BINDTOSOURCE = 0x8004000a,
}

enum int OLE_E_PROMPTSAVECANCELLED = 0x8004000c;
enum int OLE_E_WRONGCOMPOBJ = 0x8004000e;
enum int OLE_E_NOT_INPLACEACTIVE = 0x80040010;
enum int OLE_E_NOSTORAGE = 0x80040012;
enum int DV_E_DVTARGETDEVICE = 0x80040065;
enum int DV_E_STATDATA = 0x80040067;

enum : int
{
    DV_E_TYMED      = 0x80040069,
    DV_E_CLIPFORMAT = 0x8004006a,
}

enum int DV_E_DVTARGETDEVICE_SIZE = 0x8004006c;

enum : int
{
    DRAGDROP_E_FIRST             = 0x80040100,
    DRAGDROP_E_LAST              = 0x8004010f,
    DRAGDROP_S_FIRST             = 0x00040100,
    DRAGDROP_S_LAST              = 0x0004010f,
    DRAGDROP_E_NOTREGISTERED     = 0x80040100,
    DRAGDROP_E_ALREADYREGISTERED = 0x80040101,
}

enum int DRAGDROP_E_CONCURRENT_DRAG_ATTEMPTED = 0x80040103;

enum : int
{
    CLASSFACTORY_E_LAST  = 0x8004011f,
    CLASSFACTORY_S_FIRST = 0x00040110,
    CLASSFACTORY_S_LAST  = 0x0004011f,
}

enum int CLASS_E_CLASSNOTAVAILABLE = 0x80040111;

enum : int
{
    MARSHAL_E_FIRST = 0x80040120,
    MARSHAL_E_LAST  = 0x8004012f,
    MARSHAL_S_FIRST = 0x00040120,
    MARSHAL_S_LAST  = 0x0004012f,
}

enum : int
{
    DATA_E_LAST  = 0x8004013f,
    DATA_S_FIRST = 0x00040130,
    DATA_S_LAST  = 0x0004013f,
}

enum : int
{
    VIEW_E_LAST  = 0x8004014f,
    VIEW_S_FIRST = 0x00040140,
    VIEW_S_LAST  = 0x0004014f,
    VIEW_E_DRAW  = 0x80040140,
}

enum : int
{
    REGDB_E_LAST         = 0x8004015f,
    REGDB_S_FIRST        = 0x00040150,
    REGDB_S_LAST         = 0x0004015f,
    REGDB_E_READREGDB    = 0x80040150,
    REGDB_E_WRITEREGDB   = 0x80040151,
    REGDB_E_KEYMISSING   = 0x80040152,
    REGDB_E_INVALIDVALUE = 0x80040153,
}

enum : int
{
    REGDB_E_IIDNOTREG         = 0x80040155,
    REGDB_E_BADTHREADINGMODEL = 0x80040156,
}

enum : int
{
    CAT_E_FIRST        = 0x80040160,
    CAT_E_LAST         = 0x80040161,
    CAT_E_CATIDNOEXIST = 0x80040160,
}

enum : int
{
    CS_E_FIRST            = 0x80040164,
    CS_E_LAST             = 0x8004016f,
    CS_E_PACKAGE_NOTFOUND = 0x80040164,
}

enum int CS_E_CLASS_NOTFOUND = 0x80040166;
enum int CS_E_NO_CLASSSTORE = 0x80040168;
enum int CS_E_OBJECT_ALREADY_EXISTS = 0x8004016a;
enum int CS_E_NETWORK_ERROR = 0x8004016c;
enum int CS_E_SCHEMA_MISMATCH = 0x8004016e;

enum : int
{
    CACHE_E_FIRST           = 0x80040170,
    CACHE_E_LAST            = 0x8004017f,
    CACHE_S_FIRST           = 0x00040170,
    CACHE_S_LAST            = 0x0004017f,
    CACHE_E_NOCACHE_UPDATED = 0x80040170,
}

enum : int
{
    OLEOBJ_E_LAST        = 0x8004018f,
    OLEOBJ_S_FIRST       = 0x00040180,
    OLEOBJ_S_LAST        = 0x0004018f,
    OLEOBJ_E_NOVERBS     = 0x80040180,
    OLEOBJ_E_INVALIDVERB = 0x80040181,
}

enum : int
{
    CLIENTSITE_E_LAST  = 0x8004019f,
    CLIENTSITE_S_FIRST = 0x00040190,
    CLIENTSITE_S_LAST  = 0x0004019f,
}

enum : int
{
    INPLACE_E_NOTOOLSPACE = 0x800401a1,
    INPLACE_E_FIRST       = 0x800401a0,
    INPLACE_E_LAST        = 0x800401af,
    INPLACE_S_FIRST       = 0x000401a0,
    INPLACE_S_LAST        = 0x000401af,
}

enum : int
{
    ENUM_E_LAST  = 0x800401bf,
    ENUM_S_FIRST = 0x000401b0,
    ENUM_S_LAST  = 0x000401bf,
}

enum : int
{
    CONVERT10_E_LAST                    = 0x800401cf,
    CONVERT10_S_FIRST                   = 0x000401c0,
    CONVERT10_S_LAST                    = 0x000401cf,
    CONVERT10_E_OLESTREAM_GET           = 0x800401c0,
    CONVERT10_E_OLESTREAM_PUT           = 0x800401c1,
    CONVERT10_E_OLESTREAM_FMT           = 0x800401c2,
    CONVERT10_E_OLESTREAM_BITMAP_TO_DIB = 0x800401c3,
}

enum : int
{
    CONVERT10_E_STG_NO_STD_STREAM = 0x800401c5,
    CONVERT10_E_STG_DIB_TO_BITMAP = 0x800401c6,
}

enum : int
{
    CLIPBRD_E_LAST       = 0x800401df,
    CLIPBRD_S_FIRST      = 0x000401d0,
    CLIPBRD_S_LAST       = 0x000401df,
    CLIPBRD_E_CANT_OPEN  = 0x800401d0,
    CLIPBRD_E_CANT_EMPTY = 0x800401d1,
    CLIPBRD_E_CANT_SET   = 0x800401d2,
    CLIPBRD_E_BAD_DATA   = 0x800401d3,
    CLIPBRD_E_CANT_CLOSE = 0x800401d4,
}

enum int MK_E_LAST = 0x800401ef;
enum int MK_S_LAST = 0x000401ef;
enum int MK_E_EXCEEDEDDEADLINE = 0x800401e1;
enum int MK_E_UNAVAILABLE = 0x800401e3;
enum int MK_E_NOOBJECT = 0x800401e5;
enum int MK_E_INTERMEDIATEINTERFACENOTSUPPORTED = 0x800401e7;
enum int MK_E_NOTBOUND = 0x800401e9;
enum int MK_E_MUSTBOTHERUSER = 0x800401eb;

enum : int
{
    MK_E_NOSTORAGE = 0x800401ed,
    MK_E_NOPREFIX  = 0x800401ee,
}

enum : int
{
    CO_E_FIRST = 0x800401f0,
    CO_E_LAST  = 0x800401ff,
}

enum int CO_S_LAST = 0x000401ff;
enum int CO_E_ALREADYINITIALIZED = 0x800401f1;
enum int CO_E_CLASSSTRING = 0x800401f3;

enum : int
{
    CO_E_APPNOTFOUND  = 0x800401f5,
    CO_E_APPSINGLEUSE = 0x800401f6,
}

enum int CO_E_DLLNOTFOUND = 0x800401f8;
enum int CO_E_WRONGOSFORAPP = 0x800401fa;

enum : int
{
    CO_E_OBJISREG        = 0x800401fc,
    CO_E_OBJNOTCONNECTED = 0x800401fd,
}

enum int CO_E_RELEASED = 0x800401ff;

enum : int
{
    EVENT_E_LAST                    = 0x8004021f,
    EVENT_S_FIRST                   = 0x00040200,
    EVENT_S_LAST                    = 0x0004021f,
    EVENT_S_SOME_SUBSCRIBERS_FAILED = 0x00040200,
}

enum int EVENT_S_NOSUBSCRIBERS = 0x00040202;

enum : int
{
    EVENT_E_QUERYFIELD           = 0x80040204,
    EVENT_E_INTERNALEXCEPTION    = 0x80040205,
    EVENT_E_INTERNALERROR        = 0x80040206,
    EVENT_E_INVALID_PER_USER_SID = 0x80040207,
}

enum int EVENT_E_TOO_MANY_METHODS = 0x80040209;
enum int EVENT_E_NOT_ALL_REMOVED = 0x8004020b;

enum : int
{
    EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT = 0x8004020d,
    EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT   = 0x8004020e,
}

enum int EVENT_E_PER_USER_SID_NOT_LOGGED_ON = 0x80040210;
enum int TPC_E_NO_DEFAULT_TABLET = 0x80040212;

enum : int
{
    TPC_E_INVALID_INPUT_RECT = 0x80040219,
    TPC_E_INVALID_STROKE     = 0x80040222,
}

enum int TPC_E_NOT_RELEVANT = 0x80040232;
enum int TPC_E_RECOGNIZER_NOT_REGISTERED = 0x80040235;
enum int TPC_E_OUT_OF_ORDER_CALL = 0x80040237;

enum : int
{
    TPC_E_INVALID_CONFIGURATION        = 0x80040239,
    TPC_E_INVALID_DATA_FROM_RECOGNIZER = 0x8004023a,
}

enum int TPC_S_INTERRUPTED = 0x00040253;

enum : uint
{
    XACT_E_FIRST = 0x8004d000,
    XACT_E_LAST  = 0x8004d02b,
}

enum : int
{
    XACT_S_LAST                    = 0x0004d010,
    XACT_E_ALREADYOTHERSINGLEPHASE = 0x8004d000,
}

enum : int
{
    XACT_E_COMMITFAILED    = 0x8004d002,
    XACT_E_COMMITPREVENTED = 0x8004d003,
}

enum : int
{
    XACT_E_HEURISTICCOMMIT = 0x8004d005,
    XACT_E_HEURISTICDAMAGE = 0x8004d006,
    XACT_E_HEURISTICDANGER = 0x8004d007,
}

enum : int
{
    XACT_E_NOASYNC       = 0x8004d009,
    XACT_E_NOENLIST      = 0x8004d00a,
    XACT_E_NOISORETAIN   = 0x8004d00b,
    XACT_E_NORESOURCE    = 0x8004d00c,
    XACT_E_NOTCURRENT    = 0x8004d00d,
    XACT_E_NOTRANSACTION = 0x8004d00e,
    XACT_E_NOTSUPPORTED  = 0x8004d00f,
}

enum : int
{
    XACT_E_WRONGSTATE  = 0x8004d011,
    XACT_E_WRONGUOW    = 0x8004d012,
    XACT_E_XTIONEXISTS = 0x8004d013,
}

enum : int
{
    XACT_E_INVALIDCOOKIE     = 0x8004d015,
    XACT_E_INDOUBT           = 0x8004d016,
    XACT_E_NOTIMEOUT         = 0x8004d017,
    XACT_E_ALREADYINPROGRESS = 0x8004d018,
}

enum : int
{
    XACT_E_LOGFULL        = 0x8004d01a,
    XACT_E_TMNOTAVAILABLE = 0x8004d01b,
}

enum int XACT_E_CONNECTION_DENIED = 0x8004d01d;

enum : int
{
    XACT_E_TIP_CONNECT_FAILED = 0x8004d01f,
    XACT_E_TIP_PROTOCOL_ERROR = 0x8004d020,
    XACT_E_TIP_PULL_FAILED    = 0x8004d021,
}

enum int XACT_E_TIP_DISABLED = 0x8004d023;
enum int XACT_E_PARTNER_NETWORK_TX_DISABLED = 0x8004d025;

enum : int
{
    XACT_E_UNABLE_TO_READ_DTC_CONFIG = 0x8004d027,
    XACT_E_UNABLE_TO_LOAD_DTC_PROXY  = 0x8004d028,
}

enum int XACT_E_PUSH_COMM_FAILURE = 0x8004d02a;
enum int XACT_E_LU_TX_DISABLED = 0x8004d02c;
enum int XACT_E_CLERKEXISTS = 0x8004d081;
enum int XACT_E_TRANSACTIONCLOSED = 0x8004d083;
enum int XACT_E_REPLAYREQUEST = 0x8004d085;

enum : int
{
    XACT_S_DEFECT       = 0x0004d001,
    XACT_S_READONLY     = 0x0004d002,
    XACT_S_SOMENORETAIN = 0x0004d003,
}

enum : int
{
    XACT_S_MADECHANGESCONTENT = 0x0004d005,
    XACT_S_MADECHANGESINFORM  = 0x0004d006,
}

enum : int
{
    XACT_S_ABORTING    = 0x0004d008,
    XACT_S_SINGLEPHASE = 0x0004d009,
}

enum int XACT_S_LASTRESOURCEMANAGER = 0x0004d010;

enum : int
{
    CONTEXT_E_LAST           = 0x8004e02f,
    CONTEXT_S_FIRST          = 0x0004e000,
    CONTEXT_S_LAST           = 0x0004e02f,
    CONTEXT_E_ABORTED        = 0x8004e002,
    CONTEXT_E_ABORTING       = 0x8004e003,
    CONTEXT_E_NOCONTEXT      = 0x8004e004,
    CONTEXT_E_WOULD_DEADLOCK = 0x8004e005,
    CONTEXT_E_SYNCH_TIMEOUT  = 0x8004e006,
    CONTEXT_E_OLDREF         = 0x8004e007,
    CONTEXT_E_ROLENOTFOUND   = 0x8004e00c,
    CONTEXT_E_TMNOTAVAILABLE = 0x8004e00f,
}

enum : int
{
    CO_E_ACTIVATIONFAILED_EVENTLOGGED  = 0x8004e022,
    CO_E_ACTIVATIONFAILED_CATALOGERROR = 0x8004e023,
    CO_E_ACTIVATIONFAILED_TIMEOUT      = 0x8004e024,
}

enum : int
{
    CONTEXT_E_NOJIT         = 0x8004e026,
    CONTEXT_E_NOTRANSACTION = 0x8004e027,
}

enum int CO_E_NOIISINTRINSICS = 0x8004e029;

enum : int
{
    CO_E_DBERROR        = 0x8004e02b,
    CO_E_NOTPOOLED      = 0x8004e02c,
    CO_E_NOTCONSTRUCTED = 0x8004e02d,
}

enum int CO_E_ISOLEVELMISMATCH = 0x8004e02f;
enum int CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED = 0x8004e031;

enum : int
{
    OLE_S_STATIC         = 0x00040001,
    OLE_S_MAC_CLIPFORMAT = 0x00040002,
}

enum : int
{
    DRAGDROP_S_CANCEL            = 0x00040101,
    DRAGDROP_S_USEDEFAULTCURSORS = 0x00040102,
}

enum int VIEW_S_ALREADY_FROZEN = 0x00040140;

enum : int
{
    CACHE_S_SAMECACHE             = 0x00040171,
    CACHE_S_SOMECACHES_NOTUPDATED = 0x00040172,
}

enum int OLEOBJ_S_CANNOT_DOVERB_NOW = 0x00040181;
enum int INPLACE_S_TRUNCATED = 0x000401a0;
enum int MK_S_REDUCED_TO_SELF = 0x000401e2;

enum : int
{
    MK_S_HIM                      = 0x000401e5,
    MK_S_US                       = 0x000401e6,
    MK_S_MONIKERALREADYREGISTERED = 0x000401e7,
}

enum : int
{
    SCHED_S_TASK_RUNNING           = 0x00041301,
    SCHED_S_TASK_DISABLED          = 0x00041302,
    SCHED_S_TASK_HAS_NOT_RUN       = 0x00041303,
    SCHED_S_TASK_NO_MORE_RUNS      = 0x00041304,
    SCHED_S_TASK_NOT_SCHEDULED     = 0x00041305,
    SCHED_S_TASK_TERMINATED        = 0x00041306,
    SCHED_S_TASK_NO_VALID_TRIGGERS = 0x00041307,
}

enum int SCHED_E_TRIGGER_NOT_FOUND = 0x80041309;
enum int SCHED_E_TASK_NOT_RUNNING = 0x8004130b;
enum int SCHED_E_CANNOT_OPEN_TASK = 0x8004130d;

enum : int
{
    SCHED_E_ACCOUNT_INFORMATION_NOT_SET = 0x8004130f,
    SCHED_E_ACCOUNT_NAME_NOT_FOUND      = 0x80041310,
    SCHED_E_ACCOUNT_DBASE_CORRUPT       = 0x80041311,
}

enum int SCHED_E_UNKNOWN_OBJECT_VERSION = 0x80041313;
enum int SCHED_E_SERVICE_NOT_RUNNING = 0x80041315;

enum : int
{
    SCHED_E_NAMESPACE    = 0x80041317,
    SCHED_E_INVALIDVALUE = 0x80041318,
}

enum int SCHED_E_MALFORMEDXML = 0x8004131a;
enum int SCHED_S_BATCH_LOGON_PROBLEM = 0x0004131c;
enum int SCHED_E_PAST_END_BOUNDARY = 0x8004131e;
enum int SCHED_E_USER_NOT_LOGGED_ON = 0x80041320;

enum : int
{
    SCHED_E_SERVICE_NOT_AVAILABLE = 0x80041322,
    SCHED_E_SERVICE_TOO_BUSY      = 0x80041323,
}

enum int SCHED_S_TASK_QUEUED = 0x00041325;
enum int SCHED_E_TASK_NOT_V1_COMPAT = 0x80041327;
enum int SCHED_E_TASK_NOT_UBPM_COMPAT = 0x80041329;
enum int CO_E_CLASS_CREATE_FAILED = 0x80080001;
enum int CO_E_SCM_RPC_FAILURE = 0x80080003;
enum int CO_E_SERVER_EXEC_FAILURE = 0x80080005;
enum int MK_E_NO_NORMALIZED = 0x80080007;

enum : int
{
    MEM_E_INVALID_ROOT = 0x80080009,
    MEM_E_INVALID_LINK = 0x80080010,
    MEM_E_INVALID_SIZE = 0x80080011,
}

enum int CO_S_MACHINENAMENOTFOUND = 0x00080013;
enum int CO_E_RUNAS_VALUE_MUST_BE_AAA = 0x80080016;
enum int APPX_E_PACKAGING_INTERNAL = 0x80080200;
enum int APPX_E_RELATIONSHIPS_NOT_ALLOWED = 0x80080202;

enum : int
{
    APPX_E_INVALID_MANIFEST = 0x80080204,
    APPX_E_INVALID_BLOCKMAP = 0x80080205,
}

enum int APPX_E_BLOCK_HASH_INVALID = 0x80080207;

enum : int
{
    APPX_E_INVALID_SIP_CLIENT_DATA = 0x80080209,
    APPX_E_INVALID_KEY_INFO        = 0x8008020a,
    APPX_E_INVALID_CONTENTGROUPMAP = 0x8008020b,
    APPX_E_INVALID_APPINSTALLER    = 0x8008020c,
}

enum int APPX_E_DELTA_PACKAGE_MISSING_FILE = 0x8008020e;
enum int APPX_E_DELTA_APPENDED_PACKAGE_NOT_ALLOWED = 0x80080210;
enum int APPX_E_INVALID_PACKAGESIGNCONFIG = 0x80080212;
enum int APPX_E_FILE_COMPRESSION_MISMATCH = 0x80080214;
enum int APPX_E_INVALID_ENCRYPTION_EXCLUSION_FILE_LIST = 0x80080216;
enum int DISP_E_UNKNOWNINTERFACE = 0x80020001;
enum int DISP_E_PARAMNOTFOUND = 0x80020004;
enum int DISP_E_UNKNOWNNAME = 0x80020006;

enum : int
{
    DISP_E_BADVARTYPE  = 0x80020008,
    DISP_E_EXCEPTION   = 0x80020009,
    DISP_E_OVERFLOW    = 0x8002000a,
    DISP_E_BADINDEX    = 0x8002000b,
    DISP_E_UNKNOWNLCID = 0x8002000c,
}

enum int DISP_E_BADPARAMCOUNT = 0x8002000e;

enum : int
{
    DISP_E_BADCALLEE      = 0x80020010,
    DISP_E_NOTACOLLECTION = 0x80020011,
}

enum int DISP_E_BUFFERTOOSMALL = 0x80020013;
enum int TYPE_E_FIELDNOTFOUND = 0x80028017;
enum int TYPE_E_UNSUPFORMAT = 0x80028019;
enum int TYPE_E_LIBNOTREGISTERED = 0x8002801d;
enum int TYPE_E_QUALIFIEDNAMEDISALLOWED = 0x80028028;
enum int TYPE_E_WRONGTYPEKIND = 0x8002802a;
enum int TYPE_E_AMBIGUOUSNAME = 0x8002802c;
enum int TYPE_E_UNKNOWNLCID = 0x8002802e;
enum int TYPE_E_BADMODULEKIND = 0x800288bd;
enum int TYPE_E_DUPLICATEID = 0x800288c6;
enum int TYPE_E_TYPEMISMATCH = 0x80028ca0;

enum : int
{
    TYPE_E_IOERROR           = 0x80028ca2,
    TYPE_E_CANTCREATETMPFILE = 0x80028ca3,
    TYPE_E_CANTLOADLIBRARY   = 0x80029c4a,
}

enum int TYPE_E_CIRCULARTYPE = 0x80029c84;
enum int STG_E_FILENOTFOUND = 0x80030002;
enum int STG_E_TOOMANYOPENFILES = 0x80030004;

enum : int
{
    STG_E_INVALIDHANDLE      = 0x80030006,
    STG_E_INSUFFICIENTMEMORY = 0x80030008,
}

enum int STG_E_NOMOREFILES = 0x80030012;
enum int STG_E_SEEKERROR = 0x80030019;
enum int STG_E_READFAULT = 0x8003001e;
enum int STG_E_LOCKVIOLATION = 0x80030021;
enum int STG_E_INVALIDPARAMETER = 0x80030057;
enum int STG_E_PROPSETMISMATCHED = 0x800300f0;

enum : int
{
    STG_E_INVALIDHEADER = 0x800300fb,
    STG_E_INVALIDNAME   = 0x800300fc,
}

enum int STG_E_UNIMPLEMENTEDFUNCTION = 0x800300fe;

enum : int
{
    STG_E_INUSE      = 0x80030100,
    STG_E_NOTCURRENT = 0x80030101,
}

enum : int
{
    STG_E_CANTSAVE      = 0x80030103,
    STG_E_OLDFORMAT     = 0x80030104,
    STG_E_OLDDLL        = 0x80030105,
    STG_E_SHAREREQUIRED = 0x80030106,
}

enum int STG_E_EXTANTMARSHALLINGS = 0x80030108;
enum int STG_E_BADBASEADDRESS = 0x80030110;
enum int STG_E_NOTSIMPLEFORMAT = 0x80030112;
enum int STG_E_TERMINATED = 0x80030202;

enum : int
{
    STG_S_BLOCK         = 0x00030201,
    STG_S_RETRYNOW      = 0x00030202,
    STG_S_MONITORING    = 0x00030203,
    STG_S_MULTIPLEOPENS = 0x00030204,
}

enum int STG_S_CANNOTCONSOLIDATE = 0x00030206;

enum : int
{
    STG_E_FIRMWARE_SLOT_INVALID  = 0x80030208,
    STG_E_FIRMWARE_IMAGE_INVALID = 0x80030209,
}

enum int STG_E_STATUS_COPY_PROTECTION_FAILURE = 0x80030305;

enum : int
{
    STG_E_CSS_KEY_NOT_PRESENT     = 0x80030307,
    STG_E_CSS_KEY_NOT_ESTABLISHED = 0x80030308,
}

enum int STG_E_CSS_REGION_MISMATCH = 0x8003030a;

enum : int
{
    RPC_E_CALL_REJECTED       = 0x80010001,
    RPC_E_CALL_CANCELED       = 0x80010002,
    RPC_E_CANTPOST_INSENDCALL = 0x80010003,
}

enum int RPC_E_CANTCALLOUT_INEXTERNALCALL = 0x80010005;
enum int RPC_E_SERVER_DIED = 0x80010007;
enum int RPC_E_INVALID_DATAPACKET = 0x80010009;

enum : int
{
    RPC_E_CLIENT_CANTMARSHAL_DATA   = 0x8001000b,
    RPC_E_CLIENT_CANTUNMARSHAL_DATA = 0x8001000c,
}

enum int RPC_E_SERVER_CANTUNMARSHAL_DATA = 0x8001000e;
enum int RPC_E_INVALID_PARAMETER = 0x80010010;
enum int RPC_E_SERVER_DIED_DNE = 0x80010012;
enum int RPC_E_OUT_OF_RESOURCES = 0x80010101;
enum int RPC_E_NOT_REGISTERED = 0x80010103;
enum int RPC_E_SERVERFAULT = 0x80010105;
enum int RPC_E_INVALIDMETHOD = 0x80010107;

enum : int
{
    RPC_E_RETRY                 = 0x80010109,
    RPC_E_SERVERCALL_RETRYLATER = 0x8001010a,
    RPC_E_SERVERCALL_REJECTED   = 0x8001010b,
}

enum int RPC_E_CANTCALLOUT_ININPUTSYNCCALL = 0x8001010d;
enum int RPC_E_THREAD_NOT_INIT = 0x8001010f;

enum : int
{
    RPC_E_INVALID_HEADER    = 0x80010111,
    RPC_E_INVALID_EXTENSION = 0x80010112,
    RPC_E_INVALID_IPID      = 0x80010113,
    RPC_E_INVALID_OBJECT    = 0x80010114,
}

enum int RPC_S_WAITONTIMER = 0x80010116;
enum int RPC_E_UNSECURE_CALL = 0x80010118;
enum int RPC_E_NO_GOOD_SECURITY_PACKAGES = 0x8001011a;
enum int RPC_E_REMOTE_DISABLED = 0x8001011c;
enum int RPC_E_NO_CONTEXT = 0x8001011e;

enum : int
{
    RPC_E_NO_SYNC          = 0x80010120,
    RPC_E_FULLSIC_REQUIRED = 0x80010121,
}

enum : int
{
    CO_E_FAILEDTOIMPERSONATE     = 0x80010123,
    CO_E_FAILEDTOGETSECCTX       = 0x80010124,
    CO_E_FAILEDTOOPENTHREADTOKEN = 0x80010125,
    CO_E_FAILEDTOGETTOKENINFO    = 0x80010126,
}

enum : int
{
    CO_E_FAILEDTOQUERYCLIENTBLANKET = 0x80010128,
    CO_E_FAILEDTOSETDACL            = 0x80010129,
}

enum int CO_E_NETACCESSAPIFAILED = 0x8001012b;
enum int CO_E_INVALIDSID = 0x8001012d;
enum int CO_E_NOMATCHINGSIDFOUND = 0x8001012f;
enum int CO_E_NOMATCHINGNAMEFOUND = 0x80010131;
enum int CO_E_SETSERLHNDLFAILED = 0x80010133;
enum int CO_E_PATHTOOLONG = 0x80010135;

enum : int
{
    CO_E_FAILEDTOCREATEFILE  = 0x80010137,
    CO_E_FAILEDTOCLOSEHANDLE = 0x80010138,
}

enum int CO_E_ACESINWRONGORDER = 0x8001013a;
enum int CO_E_FAILEDTOOPENPROCESSTOKEN = 0x8001013c;
enum int CO_E_ACNOTINITIALIZED = 0x8001013f;
enum int RPC_E_UNEXPECTED = 0x8001ffff;
enum int ERROR_ALL_SIDS_FILTERED = 0xc0090002;

enum : int
{
    NTE_BAD_UID        = 0x80090001,
    NTE_BAD_HASH       = 0x80090002,
    NTE_BAD_KEY        = 0x80090003,
    NTE_BAD_LEN        = 0x80090004,
    NTE_BAD_DATA       = 0x80090005,
    NTE_BAD_SIGNATURE  = 0x80090006,
    NTE_BAD_VER        = 0x80090007,
    NTE_BAD_ALGID      = 0x80090008,
    NTE_BAD_FLAGS      = 0x80090009,
    NTE_BAD_TYPE       = 0x8009000a,
    NTE_BAD_KEY_STATE  = 0x8009000b,
    NTE_BAD_HASH_STATE = 0x8009000c,
}

enum int NTE_NO_MEMORY = 0x8009000e;

enum : int
{
    NTE_PERM      = 0x80090010,
    NTE_NOT_FOUND = 0x80090011,
}

enum : int
{
    NTE_BAD_PROVIDER   = 0x80090013,
    NTE_BAD_PROV_TYPE  = 0x80090014,
    NTE_BAD_PUBLIC_KEY = 0x80090015,
    NTE_BAD_KEYSET     = 0x80090016,
}

enum int NTE_PROV_TYPE_ENTRY_BAD = 0x80090018;
enum int NTE_KEYSET_ENTRY_BAD = 0x8009001a;
enum int NTE_SIGNATURE_FILE_BAD = 0x8009001c;
enum int NTE_PROV_DLL_NOT_FOUND = 0x8009001e;

enum : int
{
    NTE_FAIL           = 0x80090020,
    NTE_SYS_ERR        = 0x80090021,
    NTE_SILENT_CONTEXT = 0x80090022,
}

enum int NTE_TEMPORARY_PROFILE = 0x80090024;

enum : int
{
    NTE_INVALID_HANDLE    = 0x80090026,
    NTE_INVALID_PARAMETER = 0x80090027,
}

enum int NTE_NOT_SUPPORTED = 0x80090029;
enum int NTE_BUFFERS_OVERLAP = 0x8009002b;
enum int NTE_INTERNAL_ERROR = 0x8009002d;
enum int NTE_HMAC_NOT_SUPPORTED = 0x8009002f;
enum int NTE_AUTHENTICATION_IGNORED = 0x80090031;
enum int NTE_INCORRECT_PASSWORD = 0x80090033;
enum int NTE_DEVICE_NOT_FOUND = 0x80090035;
enum int NTE_PASSWORD_CHANGE_REQUIRED = 0x80090037;
enum int SEC_E_INSUFFICIENT_MEMORY = 0x80090300;
enum int SEC_E_UNSUPPORTED_FUNCTION = 0x80090302;
enum int SEC_E_INTERNAL_ERROR = 0x80090304;
enum int SEC_E_NOT_OWNER = 0x80090306;
enum int SEC_E_INVALID_TOKEN = 0x80090308;
enum int SEC_E_QOP_NOT_SUPPORTED = 0x8009030a;
enum int SEC_E_LOGON_DENIED = 0x8009030c;
enum int SEC_E_NO_CREDENTIALS = 0x8009030e;
enum int SEC_E_OUT_OF_SEQUENCE = 0x80090310;
enum int SEC_I_CONTINUE_NEEDED = 0x00090312;
enum int SEC_I_COMPLETE_AND_CONTINUE = 0x00090314;
enum int SEC_I_GENERIC_EXTENSION_RECEIVED = 0x00090316;
enum int SEC_E_CONTEXT_EXPIRED = 0x80090317;

enum : int
{
    SEC_E_INCOMPLETE_MESSAGE     = 0x80090318,
    SEC_E_INCOMPLETE_CREDENTIALS = 0x80090320,
}

enum int SEC_I_INCOMPLETE_CREDENTIALS = 0x00090320;
enum int SEC_E_WRONG_PRINCIPAL = 0x80090322;
enum int SEC_E_TIME_SKEW = 0x80090324;
enum int SEC_E_ILLEGAL_MESSAGE = 0x80090326;
enum int SEC_E_CERT_EXPIRED = 0x80090328;
enum int SEC_E_DECRYPT_FAILURE = 0x80090330;
enum int SEC_E_SECURITY_QOS_FAILED = 0x80090332;

enum : int
{
    SEC_E_NO_TGT_REPLY    = 0x80090334,
    SEC_E_NO_IP_ADDRESSES = 0x80090335,
}

enum int SEC_E_CRYPTO_SYSTEM_INVALID = 0x80090337;
enum int SEC_E_MUST_BE_KDC = 0x80090339;
enum int SEC_E_TOO_MANY_PRINCIPALS = 0x8009033b;
enum int SEC_E_PKINIT_NAME_MISMATCH = 0x8009033d;
enum int SEC_E_SHUTDOWN_IN_PROGRESS = 0x8009033f;

enum : int
{
    SEC_E_KDC_UNABLE_TO_REFER = 0x80090341,
    SEC_E_KDC_UNKNOWN_ETYPE   = 0x80090342,
}

enum int SEC_E_DELEGATION_REQUIRED = 0x80090345;
enum int SEC_E_MULTIPLE_ACCOUNTS = 0x80090347;
enum int SEC_E_CERT_WRONG_USAGE = 0x80090349;
enum int SEC_E_SMARTCARD_CERT_REVOKED = 0x80090351;
enum int SEC_E_REVOCATION_OFFLINE_C = 0x80090353;
enum int SEC_E_SMARTCARD_CERT_EXPIRED = 0x80090355;
enum int SEC_E_CROSSREALM_DELEGATION_FAILURE = 0x80090357;
enum int SEC_E_ISSUING_CA_UNTRUSTED_KDC = 0x80090359;
enum int SEC_E_KDC_CERT_REVOKED = 0x8009035b;
enum int SEC_E_INVALID_PARAMETER = 0x8009035d;
enum int SEC_E_POLICY_NLTM_ONLY = 0x8009035f;
enum int SEC_E_NO_CONTEXT = 0x80090361;
enum int SEC_E_MUTUAL_AUTH_FAILED = 0x80090363;
enum int SEC_E_ONLY_HTTPS_ALLOWED = 0x80090365;
enum int SEC_E_APPLICATION_PROTOCOL_MISMATCH = 0x80090367;
enum int SEC_E_INVALID_UPN_NAME = 0x80090369;
enum int SEC_E_INSUFFICIENT_BUFFERS = 0x8009036b;
enum int CRYPT_E_UNKNOWN_ALGO = 0x80091002;
enum int CRYPT_E_INVALID_MSG_TYPE = 0x80091004;
enum int CRYPT_E_AUTH_ATTR_MISSING = 0x80091006;
enum int CRYPT_E_INVALID_INDEX = 0x80091008;
enum int CRYPT_E_NOT_DECRYPTED = 0x8009100a;
enum int CRYPT_E_CONTROL_TYPE = 0x8009100c;
enum int CRYPT_E_SIGNER_NOT_FOUND = 0x8009100e;

enum : int
{
    CRYPT_E_STREAM_MSG_NOT_READY     = 0x80091010,
    CRYPT_E_STREAM_INSUFFICIENT_DATA = 0x80091011,
}

enum : int
{
    CRYPT_E_BAD_LEN      = 0x80092001,
    CRYPT_E_BAD_ENCODE   = 0x80092002,
    CRYPT_E_FILE_ERROR   = 0x80092003,
    CRYPT_E_NOT_FOUND    = 0x80092004,
    CRYPT_E_EXISTS       = 0x80092005,
    CRYPT_E_NO_PROVIDER  = 0x80092006,
    CRYPT_E_SELF_SIGNED  = 0x80092007,
    CRYPT_E_DELETED_PREV = 0x80092008,
}

enum int CRYPT_E_UNEXPECTED_MSG_TYPE = 0x8009200a;
enum int CRYPT_E_NO_DECRYPT_CERT = 0x8009200c;

enum : int
{
    CRYPT_E_NO_SIGNER     = 0x8009200e,
    CRYPT_E_PENDING_CLOSE = 0x8009200f,
}

enum : int
{
    CRYPT_E_NO_REVOCATION_DLL   = 0x80092011,
    CRYPT_E_NO_REVOCATION_CHECK = 0x80092012,
}

enum int CRYPT_E_NOT_IN_REVOCATION_DATABASE = 0x80092014;

enum : int
{
    CRYPT_E_INVALID_PRINTABLE_STRING = 0x80092021,
    CRYPT_E_INVALID_IA5_STRING       = 0x80092022,
    CRYPT_E_INVALID_X500_STRING      = 0x80092023,
}

enum : int
{
    CRYPT_E_FILERESIZED       = 0x80092025,
    CRYPT_E_SECURITY_SETTINGS = 0x80092026,
}

enum int CRYPT_E_NO_VERIFY_USAGE_CHECK = 0x80092028;

enum : int
{
    CRYPT_E_NOT_IN_CTL        = 0x8009202a,
    CRYPT_E_NO_TRUSTED_SIGNER = 0x8009202b,
}

enum int CRYPT_E_OBJECT_LOCATOR_OBJECT_NOT_FOUND = 0x8009202d;
enum int OSS_MORE_BUF = 0x80093001;
enum int OSS_PDU_RANGE = 0x80093003;
enum int OSS_DATA_ERROR = 0x80093005;
enum int OSS_BAD_VERSION = 0x80093007;
enum int OSS_PDU_MISMATCH = 0x80093009;

enum : int
{
    OSS_BAD_PTR  = 0x8009300b,
    OSS_BAD_TIME = 0x8009300c,
}

enum int OSS_MEM_ERROR = 0x8009300e;
enum int OSS_TOO_LONG = 0x80093010;
enum int OSS_FATAL_ERROR = 0x80093012;

enum : int
{
    OSS_NULL_TBL = 0x80093014,
    OSS_NULL_FCN = 0x80093015,
}

enum int OSS_UNAVAIL_ENCRULES = 0x80093017;
enum int OSS_UNIMPLEMENTED = 0x80093019;
enum int OSS_CANT_OPEN_TRACE_FILE = 0x8009301b;
enum int OSS_TABLE_MISMATCH = 0x8009301d;
enum int OSS_REAL_DLL_NOT_LINKED = 0x8009301f;
enum int OSS_OUT_OF_RANGE = 0x80093021;
enum int OSS_CONSTRAINT_DLL_NOT_LINKED = 0x80093023;
enum int OSS_COMPARATOR_CODE_NOT_LINKED = 0x80093025;
enum int OSS_PDV_DLL_NOT_LINKED = 0x80093027;
enum int OSS_API_DLL_NOT_LINKED = 0x80093029;
enum int OSS_PER_DLL_NOT_LINKED = 0x8009302b;
enum int OSS_MUTEX_NOT_CREATED = 0x8009302d;

enum : int
{
    CRYPT_E_ASN1_ERROR      = 0x80093100,
    CRYPT_E_ASN1_INTERNAL   = 0x80093101,
    CRYPT_E_ASN1_EOD        = 0x80093102,
    CRYPT_E_ASN1_CORRUPT    = 0x80093103,
    CRYPT_E_ASN1_LARGE      = 0x80093104,
    CRYPT_E_ASN1_CONSTRAINT = 0x80093105,
    CRYPT_E_ASN1_MEMORY     = 0x80093106,
    CRYPT_E_ASN1_OVERFLOW   = 0x80093107,
    CRYPT_E_ASN1_BADPDU     = 0x80093108,
    CRYPT_E_ASN1_BADARGS    = 0x80093109,
    CRYPT_E_ASN1_BADREAL    = 0x8009310a,
    CRYPT_E_ASN1_BADTAG     = 0x8009310b,
    CRYPT_E_ASN1_CHOICE     = 0x8009310c,
    CRYPT_E_ASN1_RULE       = 0x8009310d,
    CRYPT_E_ASN1_UTF8       = 0x8009310e,
    CRYPT_E_ASN1_PDU_TYPE   = 0x80093133,
    CRYPT_E_ASN1_NYI        = 0x80093134,
    CRYPT_E_ASN1_EXTENDED   = 0x80093201,
    CRYPT_E_ASN1_NOEOD      = 0x80093202,
}

enum : int
{
    CERTSRV_E_NO_REQUEST        = 0x80094002,
    CERTSRV_E_BAD_REQUESTSTATUS = 0x80094003,
}

enum int CERTSRV_E_INVALID_CA_CERTIFICATE = 0x80094005;
enum int CERTSRV_E_ENCODING_LENGTH = 0x80094007;
enum int CERTSRV_E_RESTRICTEDOFFICER = 0x80094009;

enum : int
{
    CERTSRV_E_NO_VALID_KRA             = 0x8009400b,
    CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL = 0x8009400c,
}

enum int CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE = 0x8009400e;
enum int CERTSRV_E_ALIGNMENT_FAULT = 0x80094010;
enum int CERTSRV_E_TEMPLATE_DENIED = 0x80094012;
enum int CERTSRV_E_ADMIN_DENIED_REQUEST = 0x80094014;
enum int CERTSRV_E_WEAK_SIGNATURE_OR_KEY = 0x80094016;
enum int CERTSRV_E_ENCRYPTION_CERT_REQUIRED = 0x80094018;

enum : int
{
    CERTSRV_E_NO_CERT_TYPE      = 0x80094801,
    CERTSRV_E_TEMPLATE_CONFLICT = 0x80094802,
}

enum int CERTSRV_E_ARCHIVED_KEY_REQUIRED = 0x80094804;

enum : int
{
    CERTSRV_E_BAD_RENEWAL_SUBJECT  = 0x80094806,
    CERTSRV_E_BAD_TEMPLATE_VERSION = 0x80094807,
}

enum : int
{
    CERTSRV_E_SIGNATURE_POLICY_REQUIRED = 0x80094809,
    CERTSRV_E_SIGNATURE_COUNT           = 0x8009480a,
    CERTSRV_E_SIGNATURE_REJECTED        = 0x8009480b,
}

enum : int
{
    CERTSRV_E_SUBJECT_UPN_REQUIRED            = 0x8009480d,
    CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED = 0x8009480e,
    CERTSRV_E_SUBJECT_DNS_REQUIRED            = 0x8009480f,
}

enum : int
{
    CERTSRV_E_KEY_LENGTH             = 0x80094811,
    CERTSRV_E_SUBJECT_EMAIL_REQUIRED = 0x80094812,
}

enum int CERTSRV_E_CERT_TYPE_OVERLAP = 0x80094814;
enum int CERTSRV_E_RENEWAL_BAD_PUBLIC_KEY = 0x80094816;

enum : int
{
    CERTSRV_E_INVALID_IDBINDING   = 0x80094818,
    CERTSRV_E_INVALID_ATTESTATION = 0x80094819,
}

enum int CERTSRV_E_CORRUPT_KEY_ATTESTATION = 0x8009481b;

enum : int
{
    CERTSRV_E_INVALID_RESPONSE  = 0x8009481d,
    CERTSRV_E_INVALID_REQUESTID = 0x8009481e,
}

enum int CERTSRV_E_PENDING_CLIENT_RESPONSE = 0x80094820;
enum int XENROLL_E_CANNOT_ADD_ROOT_CERT = 0x80095001;

enum : int
{
    XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH = 0x80095003,
    XENROLL_E_RESPONSE_KA_HASH_MISMATCH   = 0x80095004,
}

enum int TRUST_E_SYSTEM_ERROR = 0x80096001;

enum : int
{
    TRUST_E_COUNTER_SIGNER = 0x80096003,
    TRUST_E_CERT_SIGNATURE = 0x80096004,
}

enum : int
{
    TRUST_E_BAD_DIGEST          = 0x80096010,
    TRUST_E_MALFORMED_SIGNATURE = 0x80096011,
}

enum int TRUST_E_FINANCIAL_CRITERIA = 0x8009601e;

enum : int
{
    MSSIPOTF_E_CANTGETOBJECT             = 0x80097002,
    MSSIPOTF_E_NOHEADTABLE               = 0x80097003,
    MSSIPOTF_E_BAD_MAGICNUMBER           = 0x80097004,
    MSSIPOTF_E_BAD_OFFSET_TABLE          = 0x80097005,
    MSSIPOTF_E_TABLE_TAGORDER            = 0x80097006,
    MSSIPOTF_E_TABLE_LONGWORD            = 0x80097007,
    MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT = 0x80097008,
}

enum : int
{
    MSSIPOTF_E_TABLE_PADBYTES     = 0x8009700a,
    MSSIPOTF_E_FILETOOSMALL       = 0x8009700b,
    MSSIPOTF_E_TABLE_CHECKSUM     = 0x8009700c,
    MSSIPOTF_E_FILE_CHECKSUM      = 0x8009700d,
    MSSIPOTF_E_FAILED_POLICY      = 0x80097010,
    MSSIPOTF_E_FAILED_HINTS_CHECK = 0x80097011,
}

enum : int
{
    MSSIPOTF_E_FILE           = 0x80097013,
    MSSIPOTF_E_CRYPT          = 0x80097014,
    MSSIPOTF_E_BADVERSION     = 0x80097015,
    MSSIPOTF_E_DSIG_STRUCTURE = 0x80097016,
    MSSIPOTF_E_PCONST_CHECK   = 0x80097017,
    MSSIPOTF_E_STRUCTURE      = 0x80097018,
}

enum int NTE_OP_OK = 0x00000000;
enum int TRUST_E_ACTION_UNKNOWN = 0x800b0002;
enum int TRUST_E_SUBJECT_NOT_TRUSTED = 0x800b0004;

enum : int
{
    DIGSIG_E_DECODE        = 0x800b0006,
    DIGSIG_E_EXTENSIBILITY = 0x800b0007,
    DIGSIG_E_CRYPTO        = 0x800b0008,
}

enum : int
{
    PERSIST_E_SIZEINDEFINITE = 0x800b000a,
    PERSIST_E_NOTSELFSIZING  = 0x800b000b,
}

enum : int
{
    CERT_E_EXPIRED               = 0x800b0101,
    CERT_E_VALIDITYPERIODNESTING = 0x800b0102,
}

enum int CERT_E_PATHLENCONST = 0x800b0104;

enum : int
{
    CERT_E_PURPOSE        = 0x800b0106,
    CERT_E_ISSUERCHAINING = 0x800b0107,
}

enum int CERT_E_UNTRUSTEDROOT = 0x800b0109;
enum int TRUST_E_FAIL = 0x800b010b;
enum int CERT_E_UNTRUSTEDTESTROOT = 0x800b010d;
enum int CERT_E_CN_NO_MATCH = 0x800b010f;
enum int TRUST_E_EXPLICIT_DISTRUST = 0x800b0111;

enum : int
{
    CERT_E_INVALID_POLICY = 0x800b0113,
    CERT_E_INVALID_NAME   = 0x800b0114,
}

enum int SPAPI_E_BAD_SECTION_NAME_LINE = 0x800f0001;
enum int SPAPI_E_GENERAL_SYNTAX = 0x800f0003;
enum int SPAPI_E_SECTION_NOT_FOUND = 0x800f0101;

enum : int
{
    SPAPI_E_NO_BACKUP           = 0x800f0103,
    SPAPI_E_NO_ASSOCIATED_CLASS = 0x800f0200,
}

enum int SPAPI_E_DUPLICATE_FOUND = 0x800f0202;
enum int SPAPI_E_KEY_DOES_NOT_EXIST = 0x800f0204;
enum int SPAPI_E_INVALID_CLASS = 0x800f0206;
enum int SPAPI_E_DEVINFO_NOT_REGISTERED = 0x800f0208;

enum : int
{
    SPAPI_E_NO_INF          = 0x800f020a,
    SPAPI_E_NO_SUCH_DEVINST = 0x800f020b,
}

enum int SPAPI_E_INVALID_CLASS_INSTALLER = 0x800f020d;
enum int SPAPI_E_DI_NOFILECOPY = 0x800f020f;
enum int SPAPI_E_NO_DEVICE_SELECTED = 0x800f0211;
enum int SPAPI_E_DEVINFO_DATA_LOCKED = 0x800f0213;
enum int SPAPI_E_NO_CLASSINSTALL_PARAMS = 0x800f0215;
enum int SPAPI_E_BAD_SERVICE_INSTALLSECT = 0x800f0217;
enum int SPAPI_E_NO_ASSOCIATED_SERVICE = 0x800f0219;

enum : int
{
    SPAPI_E_DEVICE_INTERFACE_ACTIVE  = 0x800f021b,
    SPAPI_E_DEVICE_INTERFACE_REMOVED = 0x800f021c,
}

enum int SPAPI_E_NO_SUCH_INTERFACE_CLASS = 0x800f021e;
enum int SPAPI_E_INVALID_MACHINENAME = 0x800f0220;
enum int SPAPI_E_MACHINE_UNAVAILABLE = 0x800f0222;
enum int SPAPI_E_INVALID_PROPPAGE_PROVIDER = 0x800f0224;
enum int SPAPI_E_DI_POSTPROCESSING_REQUIRED = 0x800f0226;

enum : int
{
    SPAPI_E_NO_COMPAT_DRIVERS = 0x800f0228,
    SPAPI_E_NO_DEVICE_ICON    = 0x800f0229,
}

enum int SPAPI_E_DI_DONT_INSTALL = 0x800f022b;

enum : int
{
    SPAPI_E_NON_WINDOWS_NT_DRIVER = 0x800f022d,
    SPAPI_E_NON_WINDOWS_DRIVER    = 0x800f022e,
}

enum int SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE = 0x800f0230;
enum int SPAPI_E_CANT_REMOVE_DEVINST = 0x800f0232;
enum int SPAPI_E_DRIVER_NONNATIVE = 0x800f0234;
enum int SPAPI_E_SET_SYSTEM_RESTORE_POINT = 0x800f0236;
enum int SPAPI_E_SCE_DISABLED = 0x800f0238;
enum int SPAPI_E_PNP_REGISTRY_ERROR = 0x800f023a;
enum int SPAPI_E_NOT_AN_INSTALLED_OEM_INF = 0x800f023c;
enum int SPAPI_E_DI_FUNCTION_OBSOLETE = 0x800f023e;

enum : int
{
    SPAPI_E_AUTHENTICODE_DISALLOWED            = 0x800f0240,
    SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER     = 0x800f0241,
    SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED = 0x800f0242,
    SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED = 0x800f0243,
}

enum int SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE = 0x800f0245;
enum int SPAPI_E_DRIVER_STORE_ADD_FAILED = 0x800f0247;
enum int SPAPI_E_DRIVER_INSTALL_BLOCKED = 0x800f0249;
enum int SPAPI_E_FILE_HASH_NOT_IN_CATALOG = 0x800f024b;
enum int SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW = 0x800f0300;
enum int SCARD_F_INTERNAL_ERROR = 0x80100001;

enum : int
{
    SCARD_E_INVALID_HANDLE    = 0x80100003,
    SCARD_E_INVALID_PARAMETER = 0x80100004,
    SCARD_E_INVALID_TARGET    = 0x80100005,
}

enum int SCARD_F_WAITED_TOO_LONG = 0x80100007;
enum int SCARD_E_UNKNOWN_READER = 0x80100009;
enum int SCARD_E_SHARING_VIOLATION = 0x8010000b;
enum int SCARD_E_UNKNOWN_CARD = 0x8010000d;
enum int SCARD_E_PROTO_MISMATCH = 0x8010000f;
enum int SCARD_E_INVALID_VALUE = 0x80100011;

enum : int
{
    SCARD_F_COMM_ERROR    = 0x80100013,
    SCARD_F_UNKNOWN_ERROR = 0x80100014,
}

enum int SCARD_E_NOT_TRANSACTED = 0x80100016;
enum int SCARD_P_SHUTDOWN = 0x80100018;
enum int SCARD_E_READER_UNSUPPORTED = 0x8010001a;
enum int SCARD_E_CARD_UNSUPPORTED = 0x8010001c;
enum int SCARD_E_SERVICE_STOPPED = 0x8010001e;

enum : int
{
    SCARD_E_ICC_INSTALLATION = 0x80100020,
    SCARD_E_ICC_CREATEORDER  = 0x80100021,
}

enum int SCARD_E_DIR_NOT_FOUND = 0x80100023;

enum : int
{
    SCARD_E_NO_DIR         = 0x80100025,
    SCARD_E_NO_FILE        = 0x80100026,
    SCARD_E_NO_ACCESS      = 0x80100027,
    SCARD_E_WRITE_TOO_MANY = 0x80100028,
}

enum : int
{
    SCARD_E_INVALID_CHV     = 0x8010002a,
    SCARD_E_UNKNOWN_RES_MNG = 0x8010002b,
}

enum int SCARD_E_CERTIFICATE_UNAVAILABLE = 0x8010002d;
enum int SCARD_E_COMM_DATA_LOST = 0x8010002f;
enum int SCARD_E_SERVER_TOO_BUSY = 0x80100031;
enum int SCARD_E_NO_PIN_CACHE = 0x80100033;

enum : int
{
    SCARD_W_UNSUPPORTED_CARD  = 0x80100065,
    SCARD_W_UNRESPONSIVE_CARD = 0x80100066,
}

enum : int
{
    SCARD_W_RESET_CARD   = 0x80100068,
    SCARD_W_REMOVED_CARD = 0x80100069,
}

enum : int
{
    SCARD_W_WRONG_CHV         = 0x8010006b,
    SCARD_W_CHV_BLOCKED       = 0x8010006c,
    SCARD_W_EOF               = 0x8010006d,
    SCARD_W_CANCELLED_BY_USER = 0x8010006e,
}

enum : int
{
    SCARD_W_CACHE_ITEM_NOT_FOUND = 0x80100070,
    SCARD_W_CACHE_ITEM_STALE     = 0x80100071,
    SCARD_W_CACHE_ITEM_TOO_BIG   = 0x80100072,
}

enum : int
{
    COMADMIN_E_OBJECTINVALID      = 0x80110402,
    COMADMIN_E_KEYMISSING         = 0x80110403,
    COMADMIN_E_ALREADYINSTALLED   = 0x80110404,
    COMADMIN_E_APP_FILE_WRITEFAIL = 0x80110407,
    COMADMIN_E_APP_FILE_READFAIL  = 0x80110408,
    COMADMIN_E_APP_FILE_VERSION   = 0x80110409,
    COMADMIN_E_BADPATH            = 0x8011040a,
    COMADMIN_E_APPLICATIONEXISTS  = 0x8011040b,
}

enum : int
{
    COMADMIN_E_CANTCOPYFILE      = 0x8011040d,
    COMADMIN_E_NOUSER            = 0x8011040f,
    COMADMIN_E_INVALIDUSERIDS    = 0x80110410,
    COMADMIN_E_NOREGISTRYCLSID   = 0x80110411,
    COMADMIN_E_BADREGISTRYPROGID = 0x80110412,
}

enum int COMADMIN_E_USERPASSWDNOTVALID = 0x80110414;

enum : int
{
    COMADMIN_E_REMOTEINTERFACE   = 0x80110419,
    COMADMIN_E_DLLREGISTERSERVER = 0x8011041a,
}

enum : int
{
    COMADMIN_E_DLLLOADFAILED           = 0x8011041d,
    COMADMIN_E_BADREGISTRYLIBID        = 0x8011041e,
    COMADMIN_E_APPDIRNOTFOUND          = 0x8011041f,
    COMADMIN_E_REGISTRARFAILED         = 0x80110423,
    COMADMIN_E_COMPFILE_DOESNOTEXIST   = 0x80110424,
    COMADMIN_E_COMPFILE_LOADDLLFAIL    = 0x80110425,
    COMADMIN_E_COMPFILE_GETCLASSOBJ    = 0x80110426,
    COMADMIN_E_COMPFILE_CLASSNOTAVAIL  = 0x80110427,
    COMADMIN_E_COMPFILE_BADTLB         = 0x80110428,
    COMADMIN_E_COMPFILE_NOTINSTALLABLE = 0x80110429,
}

enum : int
{
    COMADMIN_E_NOTDELETEABLE      = 0x8011042b,
    COMADMIN_E_SESSION            = 0x8011042c,
    COMADMIN_E_COMP_MOVE_LOCKED   = 0x8011042d,
    COMADMIN_E_COMP_MOVE_BAD_DEST = 0x8011042e,
}

enum : int
{
    COMADMIN_E_SYSTEMAPP            = 0x80110433,
    COMADMIN_E_COMPFILE_NOREGISTRAR = 0x80110434,
    COMADMIN_E_COREQCOMPINSTALLED   = 0x80110435,
}

enum int COMADMIN_E_PROPERTYSAVEFAILED = 0x80110437;

enum : int
{
    COMADMIN_E_COMPONENTEXISTS   = 0x80110439,
    COMADMIN_E_REGFILE_CORRUPT   = 0x8011043b,
    COMADMIN_E_PROPERTY_OVERFLOW = 0x8011043c,
}

enum int COMADMIN_E_OBJECTNOTPOOLABLE = 0x8011043f;
enum int COMADMIN_E_ROLE_DOES_NOT_EXIST = 0x80110447;
enum int COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM = 0x80110449;

enum : int
{
    COMADMIN_E_CAN_NOT_START_APP           = 0x8011044b,
    COMADMIN_E_CAN_NOT_EXPORT_SYS_APP      = 0x8011044c,
    COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT = 0x8011044d,
}

enum int COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE = 0x8011044f;
enum int COMADMIN_E_START_APP_DISABLED = 0x80110451;

enum : int
{
    COMADMIN_E_CAT_INVALID_PARTITION_NAME = 0x80110458,
    COMADMIN_E_CAT_PARTITION_IN_USE       = 0x80110459,
}

enum int COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED = 0x8011045b;
enum int COMADMIN_E_AMBIGUOUS_PARTITION_NAME = 0x8011045d;

enum : int
{
    COMADMIN_E_REGDB_NOTOPEN        = 0x80110473,
    COMADMIN_E_REGDB_SYSTEMERR      = 0x80110474,
    COMADMIN_E_REGDB_ALREADYRUNNING = 0x80110475,
}

enum int COMADMIN_E_MIG_SCHEMANOTFOUND = 0x80110481;

enum : int
{
    COMADMIN_E_CAT_UNACCEPTABLEBITNESS        = 0x80110483,
    COMADMIN_E_CAT_WRONGAPPBITNESS            = 0x80110484,
    COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED = 0x80110485,
}

enum int COMQC_E_APPLICATION_NOT_QUEUED = 0x80110600;
enum int COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE = 0x80110602;

enum : int
{
    COMQC_E_BAD_MESSAGE        = 0x80110604,
    COMQC_E_UNAUTHENTICATED    = 0x80110605,
    COMQC_E_UNTRUSTED_ENQUEUER = 0x80110606,
}

enum : int
{
    COMADMIN_E_OBJECT_PARENT_MISSING = 0x80110808,
    COMADMIN_E_OBJECT_DOES_NOT_EXIST = 0x80110809,
}

enum int COMADMIN_E_INVALID_PARTITION = 0x8011080b;

enum : int
{
    COMADMIN_E_USER_IN_SET            = 0x8011080e,
    COMADMIN_E_CANTRECYCLELIBRARYAPPS = 0x8011080f,
    COMADMIN_E_CANTRECYCLESERVICEAPPS = 0x80110811,
}

enum int COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED = 0x80110813;
enum int COMADMIN_E_PROGIDINUSEBYCLSID = 0x80110815;
enum int COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED = 0x80110817;
enum int COMADMIN_E_PARTITION_MSI_ONLY = 0x80110819;
enum int COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS = 0x8011081b;

enum : int
{
    COMADMIN_E_COMP_MOVE_DEST    = 0x8011081d,
    COMADMIN_E_COMP_MOVE_PRIVATE = 0x8011081e,
}

enum int COMADMIN_E_CANNOT_ALIAS_EVENTCLASS = 0x80110820;

enum : int
{
    COMADMIN_E_SAFERINVALID          = 0x80110822,
    COMADMIN_E_REGISTRY_ACCESSDENIED = 0x80110823,
}

enum : int
{
    WER_S_REPORT_DEBUG    = 0x001b0000,
    WER_S_REPORT_UPLOADED = 0x001b0001,
    WER_S_REPORT_QUEUED   = 0x001b0002,
}

enum int WER_S_SUSPENDED_UPLOAD = 0x001b0004;
enum int WER_S_DISABLED_ARCHIVE = 0x001b0006;

enum : int
{
    WER_S_IGNORE_ASSERT_INSTANCE = 0x001b0008,
    WER_S_IGNORE_ALL_ASSERTS     = 0x001b0009,
}

enum int WER_S_THROTTLED = 0x001b000b;
enum int WER_E_CRASH_FAILURE = 0x801b8000;
enum int WER_E_NETWORK_FAILURE = 0x801b8002;
enum int WER_E_ALREADY_REPORTING = 0x801b8004;
enum int WER_E_INSUFFICIENT_CONSENT = 0x801b8006;

enum : int
{
    ERROR_FLT_IO_COMPLETE        = 0x001f0001,
    ERROR_FLT_NO_HANDLER_DEFINED = 0x801f0001,
}

enum int ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST = 0x801f0003;
enum int ERROR_FLT_INVALID_NAME_REQUEST = 0x801f0005;
enum int ERROR_FLT_NOT_INITIALIZED = 0x801f0007;
enum int ERROR_FLT_POST_OPERATION_CLEANUP = 0x801f0009;
enum int ERROR_FLT_DELETING_OBJECT = 0x801f000b;
enum int ERROR_FLT_DUPLICATE_ENTRY = 0x801f000d;

enum : int
{
    ERROR_FLT_DO_NOT_ATTACH               = 0x801f000f,
    ERROR_FLT_DO_NOT_DETACH               = 0x801f0010,
    ERROR_FLT_INSTANCE_ALTITUDE_COLLISION = 0x801f0011,
    ERROR_FLT_INSTANCE_NAME_COLLISION     = 0x801f0012,
}

enum int ERROR_FLT_VOLUME_NOT_FOUND = 0x801f0014;
enum int ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND = 0x801f0016;

enum : int
{
    ERROR_FLT_NAME_CACHE_MISS  = 0x801f0018,
    ERROR_FLT_NO_DEVICE_OBJECT = 0x801f0019,
}

enum int ERROR_FLT_ALREADY_ENLISTED = 0x801f001b;
enum int ERROR_FLT_NO_WAITER_FOR_REPLY = 0x801f0020;
enum int ERROR_HUNG_DISPLAY_DRIVER_THREAD = 0x80260001;
enum int DWM_E_REMOTING_NOT_SUPPORTED = 0x80263002;
enum int DWM_E_NOT_QUEUING_PRESENTS = 0x80263004;
enum int DWM_S_GDI_REDIRECTION_SURFACE = 0x00263005;
enum int DWM_S_GDI_REDIRECTION_SURFACE_BLT_VIA_GDI = 0x00263008;
enum int ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT = 0x00261002;
enum int ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK = 0xc0261004;

enum : int
{
    ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK = 0xc0261006,
    ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK = 0xc0261007,
}

enum : int
{
    ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK = 0xc0261009,
    ERROR_MONITOR_INVALID_MANUFACTURE_DATE      = 0xc026100a,
}

enum : int
{
    ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER = 0xc0262001,
    ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER = 0xc0262002,
}

enum : int
{
    ERROR_GRAPHICS_INVALID_DRIVER_MODEL         = 0xc0262004,
    ERROR_GRAPHICS_PRESENT_MODE_CHANGED         = 0xc0262005,
    ERROR_GRAPHICS_PRESENT_OCCLUDED             = 0xc0262006,
    ERROR_GRAPHICS_PRESENT_DENIED               = 0xc0262007,
    ERROR_GRAPHICS_CANNOTCOLORCONVERT           = 0xc0262008,
    ERROR_GRAPHICS_DRIVER_MISMATCH              = 0xc0262009,
    ERROR_GRAPHICS_PARTIAL_DATA_POPULATED       = 0x4026200a,
    ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED = 0xc026200b,
    ERROR_GRAPHICS_PRESENT_UNOCCLUDED           = 0xc026200c,
    ERROR_GRAPHICS_WINDOWDC_NOT_AVAILABLE       = 0xc026200d,
    ERROR_GRAPHICS_WINDOWLESS_PRESENT_DISABLED  = 0xc026200e,
}

enum int ERROR_GRAPHICS_PRESENT_BUFFER_NOT_BOUND = 0xc0262010;

enum : int
{
    ERROR_GRAPHICS_INDIRECT_DISPLAY_ABANDON_SWAPCHAIN = 0xc0262012,
    ERROR_GRAPHICS_INDIRECT_DISPLAY_DEVICE_STOPPED    = 0xc0262013,
}

enum int ERROR_GRAPHICS_VAIL_FAILED_TO_SEND_DESTROY_SUPERWETINK_MESSAGE = 0xc0262015;

enum : int
{
    ERROR_GRAPHICS_CANT_LOCK_MEMORY                 = 0xc0262101,
    ERROR_GRAPHICS_ALLOCATION_BUSY                  = 0xc0262102,
    ERROR_GRAPHICS_TOO_MANY_REFERENCES              = 0xc0262103,
    ERROR_GRAPHICS_TRY_AGAIN_LATER                  = 0xc0262104,
    ERROR_GRAPHICS_TRY_AGAIN_NOW                    = 0xc0262105,
    ERROR_GRAPHICS_ALLOCATION_INVALID               = 0xc0262106,
    ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE = 0xc0262107,
    ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED = 0xc0262108,
}

enum int ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE = 0xc0262110;

enum : int
{
    ERROR_GRAPHICS_ALLOCATION_CLOSED           = 0xc0262112,
    ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE = 0xc0262113,
    ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE   = 0xc0262114,
}

enum int ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST = 0xc0262116;
enum int ERROR_GRAPHICS_SKIP_ALLOCATION_PREPARATION = 0x40262201;

enum : int
{
    ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED           = 0xc0262301,
    ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED = 0xc0262302,
}

enum : int
{
    ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE = 0xc0262304,
    ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET = 0xc0262305,
}

enum : int
{
    ERROR_GRAPHICS_MODE_NOT_PINNED                   = 0x00262307,
    ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET       = 0xc0262308,
    ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET       = 0xc0262309,
    ERROR_GRAPHICS_INVALID_FREQUENCY                 = 0xc026230a,
    ERROR_GRAPHICS_INVALID_ACTIVE_REGION             = 0xc026230b,
    ERROR_GRAPHICS_INVALID_TOTAL_REGION              = 0xc026230c,
    ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE = 0xc0262310,
    ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE = 0xc0262311,
}

enum int ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY = 0xc0262313;

enum : int
{
    ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET = 0xc0262315,
    ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET = 0xc0262316,
}

enum : int
{
    ERROR_GRAPHICS_TARGET_ALREADY_IN_SET      = 0xc0262318,
    ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH = 0xc0262319,
}

enum : int
{
    ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET = 0xc026231b,
    ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE    = 0xc026231c,
}

enum : int
{
    ERROR_GRAPHICS_NO_PREFERRED_MODE             = 0x0026231e,
    ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET = 0xc026231f,
}

enum : int
{
    ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET = 0xc0262321,
    ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE   = 0xc0262322,
}

enum : int
{
    ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE                          = 0xc0262324,
    ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION = 0xc0262325,
}

enum : int
{
    ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY                  = 0xc0262327,
    ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE = 0xc0262328,
    ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET = 0xc0262329,
}

enum int ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR = 0xc026232b;

enum : int
{
    ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET    = 0xc026232d,
    ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE = 0xc026232e,
}

enum : int
{
    ERROR_GRAPHICS_RESOURCES_NOT_RELATED    = 0xc0262330,
    ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE = 0xc0262331,
}

enum int ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET = 0xc0262333;

enum : int
{
    ERROR_GRAPHICS_NO_VIDPNMGR                  = 0xc0262335,
    ERROR_GRAPHICS_NO_ACTIVE_VIDPN              = 0xc0262336,
    ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY         = 0xc0262337,
    ERROR_GRAPHICS_MONITOR_NOT_CONNECTED        = 0xc0262338,
    ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY       = 0xc0262339,
    ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE  = 0xc026233a,
    ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE   = 0xc026233b,
    ERROR_GRAPHICS_INVALID_STRIDE               = 0xc026233c,
    ERROR_GRAPHICS_INVALID_PIXELFORMAT          = 0xc026233d,
    ERROR_GRAPHICS_INVALID_COLORBASIS           = 0xc026233e,
    ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE = 0xc026233f,
}

enum int ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT = 0xc0262341;
enum int ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN = 0xc0262343;
enum int ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION = 0xc0262345;

enum : int
{
    ERROR_GRAPHICS_INVALID_GAMMA_RAMP       = 0xc0262347,
    ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED = 0xc0262348,
}

enum : int
{
    ERROR_GRAPHICS_MODE_NOT_IN_MODESET         = 0xc026234a,
    ERROR_GRAPHICS_DATASET_IS_EMPTY            = 0x0026234b,
    ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET = 0x0026234c,
}

enum : int
{
    ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE   = 0xc026234e,
    ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE = 0xc026234f,
}

enum int ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED = 0x00262351;
enum int ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED = 0xc0262353;

enum : int
{
    ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT               = 0xc0262355,
    ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM            = 0xc0262356,
    ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN         = 0xc0262357,
    ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT = 0xc0262358,
}

enum int ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION = 0xc026235a;

enum : int
{
    ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET               = 0xc026235c,
    ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED = 0xc0262400,
}

enum : int
{
    ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS    = 0x4026242f,
    ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER    = 0xc0262430,
    ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED = 0xc0262431,
}

enum int ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY = 0xc0262433;
enum int ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON = 0xc0262435;
enum int ERROR_GRAPHICS_LEADLINK_START_DEFERRED = 0x40262437;

enum : int
{
    ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY      = 0x40262439,
    ERROR_GRAPHICS_START_DEFERRED              = 0x4026243a,
    ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED = 0xc026243b,
}

enum : int
{
    ERROR_GRAPHICS_OPM_NOT_SUPPORTED                = 0xc0262500,
    ERROR_GRAPHICS_COPP_NOT_SUPPORTED               = 0xc0262501,
    ERROR_GRAPHICS_UAB_NOT_SUPPORTED                = 0xc0262502,
    ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS = 0xc0262503,
    ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST       = 0xc0262505,
    ERROR_GRAPHICS_OPM_INTERNAL_ERROR               = 0xc026250b,
    ERROR_GRAPHICS_OPM_INVALID_HANDLE               = 0xc026250c,
    ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH   = 0xc026250e,
}

enum int ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED = 0xc0262510;

enum : int
{
    ERROR_GRAPHICS_OPM_INVALID_SRM                   = 0xc0262512,
    ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP  = 0xc0262513,
    ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP   = 0xc0262514,
    ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA = 0xc0262515,
}

enum : int
{
    ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH              = 0xc0262517,
    ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE = 0xc0262518,
}

enum int ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS = 0xc026251b;

enum : int
{
    ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST              = 0xc026251d,
    ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR                    = 0xc026251e,
    ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS = 0xc026251f,
}

enum int ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST = 0xc0262521;

enum : int
{
    ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST   = 0xc0262581,
    ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA = 0xc0262582,
    ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA    = 0xc0262583,
}

enum : int
{
    ERROR_GRAPHICS_DDCCI_INVALID_DATA                                = 0xc0262585,
    ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE = 0xc0262586,
}

enum : int
{
    ERROR_GRAPHICS_MCA_INTERNAL_ERROR             = 0xc0262588,
    ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND  = 0xc0262589,
    ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH   = 0xc026258a,
    ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM = 0xc026258b,
}

enum int ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS = 0xc026258d;

enum : int
{
    ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION                 = 0xc02625d9,
    ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = 0xc02625da,
}

enum : int
{
    ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION         = 0xc02625dc,
    ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = 0xc02625de,
}

enum int ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED = 0xc02625e0;
enum int ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = 0xc02625e2;

enum : int
{
    ERROR_GRAPHICS_INVALID_POINTER                          = 0xc02625e4,
    ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = 0xc02625e5,
}

enum : int
{
    ERROR_GRAPHICS_INTERNAL_ERROR                  = 0xc02625e7,
    ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS = 0xc02605e8,
}

enum int NAP_E_MISSING_SOH = 0x80270002;
enum int NAP_E_NO_CACHED_SOH = 0x80270004;

enum : int
{
    NAP_E_NOT_REGISTERED  = 0x80270006,
    NAP_E_NOT_INITIALIZED = 0x80270007,
}

enum int NAP_E_NOT_PENDING = 0x80270009;
enum int NAP_E_MAXSIZE_TOO_SMALL = 0x8027000b;
enum int NAP_S_CERT_ALREADY_PRESENT = 0x0027000d;
enum int NAP_E_NETSH_GROUPPOLICY_ERROR = 0x8027000f;

enum : int
{
    NAP_E_SHV_CONFIG_EXISTED   = 0x80270011,
    NAP_E_SHV_CONFIG_NOT_FOUND = 0x80270012,
}

enum int TPM_E_ERROR_MASK = 0x80280000;

enum : int
{
    TPM_E_BADINDEX      = 0x80280002,
    TPM_E_BAD_PARAMETER = 0x80280003,
}

enum int TPM_E_CLEAR_DISABLED = 0x80280005;

enum : int
{
    TPM_E_DISABLED     = 0x80280007,
    TPM_E_DISABLED_CMD = 0x80280008,
}

enum int TPM_E_BAD_ORDINAL = 0x8028000a;
enum int TPM_E_INVALID_KEYHANDLE = 0x8028000c;
enum int TPM_E_INAPPROPRIATE_ENC = 0x8028000e;
enum int TPM_E_INVALID_PCR_INFO = 0x80280010;

enum : int
{
    TPM_E_NOSRK          = 0x80280012,
    TPM_E_NOTSEALED_BLOB = 0x80280013,
}

enum int TPM_E_RESOURCES = 0x80280015;

enum : int
{
    TPM_E_SIZE        = 0x80280017,
    TPM_E_WRONGPCRVAL = 0x80280018,
}

enum : int
{
    TPM_E_SHA_THREAD = 0x8028001a,
    TPM_E_SHA_ERROR  = 0x8028001b,
}

enum int TPM_E_AUTH2FAIL = 0x8028001d;

enum : int
{
    TPM_E_IOERROR       = 0x8028001f,
    TPM_E_ENCRYPT_ERROR = 0x80280020,
}

enum int TPM_E_INVALID_AUTHHANDLE = 0x80280022;
enum int TPM_E_INVALID_KEYUSAGE = 0x80280024;
enum int TPM_E_INVALID_POSTINIT = 0x80280026;

enum : int
{
    TPM_E_BAD_KEY_PROPERTY = 0x80280028,
    TPM_E_BAD_MIGRATION    = 0x80280029,
    TPM_E_BAD_SCHEME       = 0x8028002a,
    TPM_E_BAD_DATASIZE     = 0x8028002b,
    TPM_E_BAD_MODE         = 0x8028002c,
    TPM_E_BAD_PRESENCE     = 0x8028002d,
    TPM_E_BAD_VERSION      = 0x8028002e,
}

enum : int
{
    TPM_E_AUDITFAIL_UNSUCCESSFUL = 0x80280030,
    TPM_E_AUDITFAIL_SUCCESSFUL   = 0x80280031,
}

enum : int
{
    TPM_E_NOTLOCAL         = 0x80280033,
    TPM_E_BAD_TYPE         = 0x80280034,
    TPM_E_INVALID_RESOURCE = 0x80280035,
}

enum int TPM_E_INVALID_FAMILY = 0x80280037;
enum int TPM_E_REQUIRES_SIGN = 0x80280039;
enum int TPM_E_AUTH_CONFLICT = 0x8028003b;
enum int TPM_E_BAD_LOCALITY = 0x8028003d;
enum int TPM_E_PER_NOWRITE = 0x8028003f;
enum int TPM_E_WRITE_LOCKED = 0x80280041;
enum int TPM_E_INVALID_STRUCTURE = 0x80280043;
enum int TPM_E_BAD_COUNTER = 0x80280045;
enum int TPM_E_CONTEXT_GAP = 0x80280047;
enum int TPM_E_NOOPERATOR = 0x80280049;

enum : int
{
    TPM_E_DELEGATE_LOCK   = 0x8028004b,
    TPM_E_DELEGATE_FAMILY = 0x8028004c,
    TPM_E_DELEGATE_ADMIN  = 0x8028004d,
}

enum int TPM_E_OWNER_CONTROL = 0x8028004f;

enum : int
{
    TPM_E_DAA_INPUT_DATA0     = 0x80280051,
    TPM_E_DAA_INPUT_DATA1     = 0x80280052,
    TPM_E_DAA_ISSUER_SETTINGS = 0x80280053,
}

enum : int
{
    TPM_E_DAA_STAGE           = 0x80280055,
    TPM_E_DAA_ISSUER_VALIDITY = 0x80280056,
}

enum : int
{
    TPM_E_BAD_HANDLE   = 0x80280058,
    TPM_E_BAD_DELEGATE = 0x80280059,
    TPM_E_BADCONTEXT   = 0x8028005a,
}

enum int TPM_E_MA_TICKET_SIGNATURE = 0x8028005c;

enum : int
{
    TPM_E_MA_SOURCE    = 0x8028005e,
    TPM_E_MA_AUTHORITY = 0x8028005f,
}

enum int TPM_E_BAD_SIGNATURE = 0x80280062;

enum : int
{
    TPM_20_E_ASYMMETRIC        = 0x80280081,
    TPM_20_E_ATTRIBUTES        = 0x80280082,
    TPM_20_E_HASH              = 0x80280083,
    TPM_20_E_VALUE             = 0x80280084,
    TPM_20_E_HIERARCHY         = 0x80280085,
    TPM_20_E_KEY_SIZE          = 0x80280087,
    TPM_20_E_MGF               = 0x80280088,
    TPM_20_E_MODE              = 0x80280089,
    TPM_20_E_TYPE              = 0x8028008a,
    TPM_20_E_HANDLE            = 0x8028008b,
    TPM_20_E_KDF               = 0x8028008c,
    TPM_20_E_RANGE             = 0x8028008d,
    TPM_20_E_AUTH_FAIL         = 0x8028008e,
    TPM_20_E_NONCE             = 0x8028008f,
    TPM_20_E_PP                = 0x80280090,
    TPM_20_E_SCHEME            = 0x80280092,
    TPM_20_E_SIZE              = 0x80280095,
    TPM_20_E_SYMMETRIC         = 0x80280096,
    TPM_20_E_TAG               = 0x80280097,
    TPM_20_E_SELECTOR          = 0x80280098,
    TPM_20_E_INSUFFICIENT      = 0x8028009a,
    TPM_20_E_SIGNATURE         = 0x8028009b,
    TPM_20_E_KEY               = 0x8028009c,
    TPM_20_E_POLICY_FAIL       = 0x8028009d,
    TPM_20_E_INTEGRITY         = 0x8028009f,
    TPM_20_E_TICKET            = 0x802800a0,
    TPM_20_E_RESERVED_BITS     = 0x802800a1,
    TPM_20_E_BAD_AUTH          = 0x802800a2,
    TPM_20_E_EXPIRED           = 0x802800a3,
    TPM_20_E_POLICY_CC         = 0x802800a4,
    TPM_20_E_BINDING           = 0x802800a5,
    TPM_20_E_CURVE             = 0x802800a6,
    TPM_20_E_ECC_POINT         = 0x802800a7,
    TPM_20_E_INITIALIZE        = 0x80280100,
    TPM_20_E_FAILURE           = 0x80280101,
    TPM_20_E_SEQUENCE          = 0x80280103,
    TPM_20_E_PRIVATE           = 0x8028010b,
    TPM_20_E_HMAC              = 0x80280119,
    TPM_20_E_DISABLED          = 0x80280120,
    TPM_20_E_EXCLUSIVE         = 0x80280121,
    TPM_20_E_ECC_CURVE         = 0x80280123,
    TPM_20_E_AUTH_TYPE         = 0x80280124,
    TPM_20_E_AUTH_MISSING      = 0x80280125,
    TPM_20_E_POLICY            = 0x80280126,
    TPM_20_E_PCR               = 0x80280127,
    TPM_20_E_PCR_CHANGED       = 0x80280128,
    TPM_20_E_UPGRADE           = 0x8028012d,
    TPM_20_E_TOO_MANY_CONTEXTS = 0x8028012e,
}

enum : int
{
    TPM_20_E_REBOOT           = 0x80280130,
    TPM_20_E_UNBALANCED       = 0x80280131,
    TPM_20_E_COMMAND_SIZE     = 0x80280142,
    TPM_20_E_COMMAND_CODE     = 0x80280143,
    TPM_20_E_AUTHSIZE         = 0x80280144,
    TPM_20_E_AUTH_CONTEXT     = 0x80280145,
    TPM_20_E_NV_RANGE         = 0x80280146,
    TPM_20_E_NV_SIZE          = 0x80280147,
    TPM_20_E_NV_LOCKED        = 0x80280148,
    TPM_20_E_NV_AUTHORIZATION = 0x80280149,
    TPM_20_E_NV_UNINITIALIZED = 0x8028014a,
    TPM_20_E_NV_SPACE         = 0x8028014b,
    TPM_20_E_NV_DEFINED       = 0x8028014c,
    TPM_20_E_BAD_CONTEXT      = 0x80280150,
    TPM_20_E_CPHASH           = 0x80280151,
    TPM_20_E_PARENT           = 0x80280152,
    TPM_20_E_NEEDS_TEST       = 0x80280153,
    TPM_20_E_NO_RESULT        = 0x80280154,
    TPM_20_E_SENSITIVE        = 0x80280155,
}

enum int TPM_E_INVALID_HANDLE = 0x80280401;

enum : int
{
    TPM_E_EMBEDDED_COMMAND_BLOCKED     = 0x80280403,
    TPM_E_EMBEDDED_COMMAND_UNSUPPORTED = 0x80280404,
}

enum int TPM_E_NEEDS_SELFTEST = 0x80280801;
enum int TPM_E_DEFEND_LOCK_RUNNING = 0x80280803;

enum : int
{
    TPM_20_E_OBJECT_MEMORY  = 0x80280902,
    TPM_20_E_SESSION_MEMORY = 0x80280903,
}

enum int TPM_20_E_SESSION_HANDLES = 0x80280905;

enum : int
{
    TPM_20_E_LOCALITY       = 0x80280907,
    TPM_20_E_YIELDED        = 0x80280908,
    TPM_20_E_CANCELED       = 0x80280909,
    TPM_20_E_TESTING        = 0x8028090a,
    TPM_20_E_NV_RATE        = 0x80280920,
    TPM_20_E_LOCKOUT        = 0x80280921,
    TPM_20_E_RETRY          = 0x80280922,
    TPM_20_E_NV_UNAVAILABLE = 0x80280923,
}

enum int TBS_E_BAD_PARAMETER = 0x80284002;
enum int TBS_E_INVALID_CONTEXT = 0x80284004;

enum : int
{
    TBS_E_IOERROR               = 0x80284006,
    TBS_E_INVALID_CONTEXT_PARAM = 0x80284007,
}

enum : int
{
    TBS_E_TOO_MANY_TBS_CONTEXTS = 0x80284009,
    TBS_E_TOO_MANY_RESOURCES    = 0x8028400a,
}

enum int TBS_E_PPI_NOT_SUPPORTED = 0x8028400c;
enum int TBS_E_BUFFER_TOO_LARGE = 0x8028400e;
enum int TBS_E_SERVICE_DISABLED = 0x80284010;
enum int TBS_E_ACCESS_DENIED = 0x80284012;
enum int TBS_E_PPI_FUNCTION_UNSUPPORTED = 0x80284014;
enum int TBS_E_PROVISIONING_INCOMPLETE = 0x80284016;
enum int TPMAPI_E_NOT_ENOUGH_DATA = 0x80290101;

enum : int
{
    TPMAPI_E_INVALID_OUTPUT_POINTER = 0x80290103,
    TPMAPI_E_INVALID_PARAMETER      = 0x80290104,
}

enum int TPMAPI_E_BUFFER_TOO_SMALL = 0x80290106;

enum : int
{
    TPMAPI_E_ACCESS_DENIED        = 0x80290108,
    TPMAPI_E_AUTHORIZATION_FAILED = 0x80290109,
}

enum int TPMAPI_E_TBS_COMMUNICATION_ERROR = 0x8029010b;
enum int TPMAPI_E_MESSAGE_TOO_LARGE = 0x8029010d;
enum int TPMAPI_E_INVALID_KEY_SIZE = 0x8029010f;

enum : int
{
    TPMAPI_E_INVALID_KEY_PARAMS                   = 0x80290111,
    TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB = 0x80290112,
}

enum : int
{
    TPMAPI_E_INVALID_DELEGATE_BLOB  = 0x80290114,
    TPMAPI_E_INVALID_CONTEXT_PARAMS = 0x80290115,
    TPMAPI_E_INVALID_KEY_BLOB       = 0x80290116,
    TPMAPI_E_INVALID_PCR_DATA       = 0x80290117,
    TPMAPI_E_INVALID_OWNER_AUTH     = 0x80290118,
}

enum : int
{
    TPMAPI_E_EMPTY_TCG_LOG         = 0x8029011a,
    TPMAPI_E_INVALID_TCG_LOG_ENTRY = 0x8029011b,
}

enum int TPMAPI_E_TCG_INVALID_DIGEST_ENTRY = 0x8029011d;

enum : int
{
    TPMAPI_E_NV_BITS_NOT_DEFINED = 0x8029011f,
    TPMAPI_E_NV_BITS_NOT_READY   = 0x80290120,
}

enum int TPMAPI_E_NO_AUTHORIZATION_CHAIN_FOUND = 0x80290122;
enum int TPMAPI_E_OWNER_AUTH_NOT_NULL = 0x80290124;
enum int TPMAPI_E_AUTHORIZATION_REVOKED = 0x80290126;
enum int TPMAPI_E_AUTHORIZING_KEY_NOT_SUPPORTED = 0x80290128;

enum : int
{
    TPMAPI_E_MALFORMED_AUTHORIZATION_POLICY = 0x8029012a,
    TPMAPI_E_MALFORMED_AUTHORIZATION_OTHER  = 0x8029012b,
}

enum : int
{
    TPMAPI_E_INVALID_TPM_VERSION          = 0x8029012d,
    TPMAPI_E_INVALID_POLICYAUTH_BLOB_TYPE = 0x8029012e,
}

enum int TBSIMP_E_CLEANUP_FAILED = 0x80290201;
enum int TBSIMP_E_INVALID_CONTEXT_PARAM = 0x80290203;

enum : int
{
    TBSIMP_E_HASH_BAD_KEY      = 0x80290205,
    TBSIMP_E_DUPLICATE_VHANDLE = 0x80290206,
}

enum int TBSIMP_E_INVALID_PARAMETER = 0x80290208;
enum int TBSIMP_E_SCHEDULER_NOT_RUNNING = 0x8029020a;

enum : int
{
    TBSIMP_E_OUT_OF_MEMORY      = 0x8029020c,
    TBSIMP_E_LIST_NO_MORE_ITEMS = 0x8029020d,
    TBSIMP_E_LIST_NOT_FOUND     = 0x8029020e,
}

enum int TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS = 0x80290210;
enum int TBSIMP_E_UNKNOWN_ORDINAL = 0x80290212;
enum int TBSIMP_E_INVALID_RESOURCE = 0x80290214;
enum int TBSIMP_E_HASH_TABLE_FULL = 0x80290216;
enum int TBSIMP_E_TOO_MANY_RESOURCES = 0x80290218;
enum int TBSIMP_E_TPM_INCOMPATIBLE = 0x8029021a;

enum : int
{
    TPM_E_PPI_ACPI_FAILURE    = 0x80290300,
    TPM_E_PPI_USER_ABORT      = 0x80290301,
    TPM_E_PPI_BIOS_FAILURE    = 0x80290302,
    TPM_E_PPI_NOT_SUPPORTED   = 0x80290303,
    TPM_E_PPI_BLOCKED_IN_BIOS = 0x80290304,
}

enum int TPM_E_PCP_DEVICE_NOT_READY = 0x80290401;
enum int TPM_E_PCP_INVALID_PARAMETER = 0x80290403;

enum : int
{
    TPM_E_PCP_NOT_SUPPORTED    = 0x80290405,
    TPM_E_PCP_BUFFER_TOO_SMALL = 0x80290406,
}

enum : int
{
    TPM_E_PCP_AUTHENTICATION_FAILED  = 0x80290408,
    TPM_E_PCP_AUTHENTICATION_IGNORED = 0x80290409,
}

enum int TPM_E_PCP_PROFILE_NOT_FOUND = 0x8029040b;
enum int TPM_E_PCP_WRONG_PARENT = 0x8029040e;
enum int TPM_E_NO_KEY_CERTIFICATION = 0x80290410;
enum int TPM_E_ATTESTATION_CHALLENGE_NOT_SET = 0x80290412;
enum int TPM_E_KEY_ALREADY_FINALIZED = 0x80290414;
enum int TPM_E_KEY_USAGE_POLICY_INVALID = 0x80290416;
enum int TPM_E_KEY_NOT_AUTHENTICATED = 0x80290418;
enum int TPM_E_KEY_NOT_SIGNING_KEY = 0x8029041a;
enum int TPM_E_CLAIM_TYPE_NOT_SUPPORTED = 0x8029041c;
enum int TPM_E_BUFFER_LENGTH_MISMATCH = 0x8029041e;

enum : int
{
    TPM_E_PCP_TICKET_MISSING           = 0x80290420,
    TPM_E_PCP_RAW_POLICY_NOT_SUPPORTED = 0x80290421,
}

enum int TPM_E_PCP_UNSUPPORTED_PSS_SALT = 0x40290423;

enum : int
{
    TPM_E_PCP_PLATFORM_CLAIM_OUTDATED = 0x40290425,
    TPM_E_PCP_PLATFORM_CLAIM_REBOOT   = 0x40290426,
}

enum int TPM_E_PROVISIONING_INCOMPLETE = 0x80290600;
enum int TPM_E_TOO_MUCH_DATA = 0x80290602;
enum int PLA_E_DCS_IN_USE = 0x803000aa;
enum int PLA_E_NO_MIN_DISK = 0x80300070;
enum int PLA_S_PROPERTY_IGNORED = 0x00300100;
enum int PLA_E_DCS_SINGLETON_REQUIRED = 0x80300102;
enum int PLA_E_DCS_NOT_RUNNING = 0x80300104;
enum int PLA_E_NETWORK_EXE_NOT_VALID = 0x80300106;
enum int PLA_E_EXE_PATH_NOT_VALID = 0x80300108;
enum int PLA_E_DCS_START_WAIT_TIMEOUT = 0x8030010a;
enum int PLA_E_REPORT_WAIT_TIMEOUT = 0x8030010c;
enum int PLA_E_EXE_FULL_PATH_REQUIRED = 0x8030010e;
enum int PLA_E_PLA_CHANNEL_NOT_ENABLED = 0x80300110;
enum int PLA_E_RULES_MANAGER_FAILED = 0x80300112;
enum int FVE_E_LOCKED_VOLUME = 0x80310000;

enum : int
{
    FVE_E_NO_TPM_BIOS          = 0x80310002,
    FVE_E_NO_MBR_METRIC        = 0x80310003,
    FVE_E_NO_BOOTSECTOR_METRIC = 0x80310004,
    FVE_E_NO_BOOTMGR_METRIC    = 0x80310005,
}

enum int FVE_E_SECURE_KEY_REQUIRED = 0x80310007;
enum int FVE_E_ACTION_NOT_ALLOWED = 0x80310009;

enum : int
{
    FVE_E_AD_INVALID_DATATYPE = 0x8031000b,
    FVE_E_AD_INVALID_DATASIZE = 0x8031000c,
}

enum : int
{
    FVE_E_AD_ATTR_NOT_SET   = 0x8031000e,
    FVE_E_AD_GUID_NOT_FOUND = 0x8031000f,
}

enum int FVE_E_TOO_SMALL = 0x80310011;
enum int FVE_E_FAILED_WRONG_FS = 0x80310013;
enum int FVE_E_NOT_SUPPORTED = 0x80310015;
enum int FVE_E_VOLUME_NOT_BOUND = 0x80310017;
enum int FVE_E_NOT_DATA_VOLUME = 0x80310019;

enum : int
{
    FVE_E_CONV_READ  = 0x8031001b,
    FVE_E_CONV_WRITE = 0x8031001c,
}

enum int FVE_E_CLUSTERING_NOT_SUPPORTED = 0x8031001e;
enum int FVE_E_OS_NOT_PROTECTED = 0x80310020;
enum int FVE_E_RECOVERY_KEY_REQUIRED = 0x80310022;
enum int FVE_E_OVERLAPPED_UPDATE = 0x80310024;

enum : int
{
    FVE_E_FAILED_SECTOR_SIZE    = 0x80310026,
    FVE_E_FAILED_AUTHENTICATION = 0x80310027,
}

enum int FVE_E_AUTOUNLOCK_ENABLED = 0x80310029;
enum int FVE_E_WRONG_SYSTEM_FS = 0x8031002b;

enum : int
{
    FVE_E_CANNOT_SET_FVEK_ENCRYPTED = 0x8031002d,
    FVE_E_CANNOT_ENCRYPT_NO_KEY     = 0x8031002e,
}

enum int FVE_E_PROTECTOR_EXISTS = 0x80310031;
enum int FVE_E_PROTECTOR_NOT_FOUND = 0x80310033;
enum int FVE_E_INVALID_PASSWORD_FORMAT = 0x80310035;

enum : int
{
    FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD   = 0x80310037,
    FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT = 0x80310038,
}

enum int FVE_E_INVALID_PROTECTOR_TYPE = 0x8031003a;

enum : int
{
    FVE_E_KEYFILE_NOT_FOUND = 0x8031003c,
    FVE_E_KEYFILE_INVALID   = 0x8031003d,
    FVE_E_KEYFILE_NO_VMK    = 0x8031003e,
}

enum int FVE_E_NOT_ALLOWED_IN_SAFE_MODE = 0x80310040;
enum int FVE_E_TPM_NO_VMK = 0x80310042;

enum : int
{
    FVE_E_AUTH_INVALID_APPLICATION = 0x80310044,
    FVE_E_AUTH_INVALID_CONFIG      = 0x80310045,
}

enum int FVE_E_FS_NOT_EXTENDED = 0x80310047;

enum : int
{
    FVE_E_NO_LICENSE   = 0x80310049,
    FVE_E_NOT_ON_STACK = 0x8031004a,
}

enum int FVE_E_TOKEN_NOT_IMPERSONATED = 0x8031004c;
enum int FVE_E_REBOOT_REQUIRED = 0x8031004e;

enum : int
{
    FVE_E_RAW_ACCESS  = 0x80310050,
    FVE_E_RAW_BLOCKED = 0x80310051,
}

enum int FVE_E_NOT_ALLOWED_IN_VERSION = 0x80310053;
enum int FVE_E_MOR_FAILED = 0x80310055;
enum int FVE_E_TRANSIENT_STATE = 0x80310057;
enum int FVE_E_VOLUME_HANDLE_OPEN = 0x80310059;
enum int FVE_E_INVALID_STARTUP_OPTIONS = 0x8031005b;

enum : int
{
    FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED = 0x8031005d,
    FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED   = 0x8031005e,
    FVE_E_POLICY_RECOVERY_KEY_REQUIRED      = 0x8031005f,
}

enum : int
{
    FVE_E_POLICY_STARTUP_PIN_REQUIRED        = 0x80310061,
    FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED     = 0x80310062,
    FVE_E_POLICY_STARTUP_KEY_REQUIRED        = 0x80310063,
    FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED = 0x80310064,
    FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED    = 0x80310065,
    FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED     = 0x80310066,
    FVE_E_POLICY_STARTUP_TPM_REQUIRED        = 0x80310067,
}

enum int FVE_E_KEY_PROTECTOR_NOT_SUPPORTED = 0x80310069;
enum int FVE_E_POLICY_PASSPHRASE_REQUIRED = 0x8031006b;
enum int FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED = 0x8031006d;
enum int FVE_E_VOLUME_TOO_SMALL = 0x8031006f;
enum int FVE_E_DV_NOT_ALLOWED_BY_GP = 0x80310071;

enum : int
{
    FVE_E_POLICY_USER_CERTIFICATE_REQUIRED                 = 0x80310073,
    FVE_E_POLICY_USER_CERT_MUST_BE_HW                      = 0x80310074,
    FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED = 0x80310075,
    FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED = 0x80310076,
    FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED            = 0x80310077,
    FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED               = 0x80310078,
    FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED              = 0x80310079,
}

enum int FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE = 0x80310081;

enum : int
{
    FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON = 0x80310083,
    FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON = 0x80310084,
}

enum int FVE_E_POLICY_PROHIBITS_SELFSIGNED = 0x80310086;
enum int FVE_E_CONV_RECOVERY_FAILED = 0x80310088;

enum : int
{
    FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON = 0x80310090,
    FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON = 0x80310091,
    FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON = 0x80310092,
}

enum int FVE_E_PRIVATEKEY_AUTH_FAILED = 0x80310094;
enum int FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME = 0x80310096;
enum int FVE_E_FIPS_HASH_KDF_NOT_ALLOWED = 0x80310098;

enum : int
{
    FVE_E_INVALID_PIN_CHARS  = 0x8031009a,
    FVE_E_INVALID_DATUM_TYPE = 0x8031009b,
}

enum int FVE_E_MULTIPLE_NKP_CERTS = 0x8031009d;
enum int FVE_E_INVALID_NKP_CERT = 0x8031009f;
enum int FVE_E_PROTECTOR_CHANGE_PIN_MISMATCH = 0x803100a1;
enum int FVE_E_PROTECTOR_CHANGE_MAX_PIN_CHANGE_ATTEMPTS_REACHED = 0x803100a3;
enum int FVE_E_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE = 0x803100a5;
enum int FVE_E_KEY_LENGTH_NOT_SUPPORTED_BY_EDRIVE = 0x803100a7;
enum int FVE_E_PROTECTOR_CHANGE_PASSPHRASE_MISMATCH = 0x803100a9;
enum int FVE_E_NO_PASSPHRASE_WITH_TPM = 0x803100ab;

enum : int
{
    FVE_E_NOT_ALLOWED_ON_CSV_STACK = 0x803100ad,
    FVE_E_NOT_ALLOWED_ON_CLUSTER   = 0x803100ae,
}

enum : int
{
    FVE_E_EDRIVE_BAND_IN_USE         = 0x803100b0,
    FVE_E_EDRIVE_DISALLOWED_BY_GP    = 0x803100b1,
    FVE_E_EDRIVE_INCOMPATIBLE_VOLUME = 0x803100b2,
}

enum int FVE_E_EDRIVE_DV_NOT_SUPPORTED = 0x803100b4;
enum int FVE_E_NO_PREBOOT_KEYBOARD_OR_WINRE_DETECTED = 0x803100b6;
enum int FVE_E_POLICY_REQUIRES_RECOVERY_PASSWORD_ON_TOUCH_DEVICE = 0x803100b8;

enum : int
{
    FVE_E_SECUREBOOT_DISABLED              = 0x803100ba,
    FVE_E_SECUREBOOT_CONFIGURATION_INVALID = 0x803100bb,
}

enum int FVE_E_SHADOW_COPY_PRESENT = 0x803100bd;
enum int FVE_E_EDRIVE_INCOMPATIBLE_FIRMWARE = 0x803100bf;
enum int FVE_E_PASSPHRASE_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED = 0x803100c1;
enum int FVE_E_LIVEID_ACCOUNT_BLOCKED = 0x803100c3;
enum int FVE_E_DE_FIXED_DATA_NOT_SUPPORTED = 0x803100c5;
enum int FVE_E_DE_WINRE_NOT_CONFIGURED = 0x803100c7;
enum int FVE_E_DE_OS_VOLUME_NOT_PROTECTED = 0x803100c9;
enum int FVE_E_DE_PROTECTION_NOT_YET_ENABLED = 0x803100cb;
enum int FVE_E_DEVICE_LOCKOUT_COUNTER_UNAVAILABLE = 0x803100cd;
enum int FVE_E_BUFFER_TOO_LARGE = 0x803100cf;
enum int FVE_E_DE_PREVENTED_FOR_OS = 0x803100d1;
enum int FVE_E_DE_VOLUME_NOT_SUPPORTED = 0x803100d3;
enum int FVE_E_ADBACKUP_NOT_ENABLED = 0x803100d5;
enum int FVE_E_NOT_DE_VOLUME = 0x803100d7;
enum int FVE_E_OSV_KSR_NOT_ALLOWED = 0x803100d9;

enum : int
{
    FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_FIXED_DRIVE     = 0x803100db,
    FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_REMOVABLE_DRIVE = 0x803100dc,
}

enum int FVE_E_EXECUTE_REQUEST_SENT_TOO_SOON = 0x803100de;
enum int FVE_E_DEVICE_NOT_JOINED = 0x803100e0;
enum int FWP_E_CALLOUT_NOT_FOUND = 0x80320001;
enum int FWP_E_FILTER_NOT_FOUND = 0x80320003;

enum : int
{
    FWP_E_PROVIDER_NOT_FOUND         = 0x80320005,
    FWP_E_PROVIDER_CONTEXT_NOT_FOUND = 0x80320006,
}

enum int FWP_E_NOT_FOUND = 0x80320008;

enum : int
{
    FWP_E_IN_USE                      = 0x8032000a,
    FWP_E_DYNAMIC_SESSION_IN_PROGRESS = 0x8032000b,
}

enum int FWP_E_NO_TXN_IN_PROGRESS = 0x8032000d;
enum int FWP_E_TXN_ABORTED = 0x8032000f;
enum int FWP_E_INCOMPATIBLE_TXN = 0x80320011;
enum int FWP_E_NET_EVENTS_DISABLED = 0x80320013;
enum int FWP_E_KM_CLIENTS_ONLY = 0x80320015;
enum int FWP_E_BUILTIN_OBJECT = 0x80320017;
enum int FWP_E_NOTIFICATION_DROPPED = 0x80320019;
enum int FWP_E_INCOMPATIBLE_SA_STATE = 0x8032001b;

enum : int
{
    FWP_E_INVALID_ENUMERATOR = 0x8032001d,
    FWP_E_INVALID_FLAGS      = 0x8032001e,
    FWP_E_INVALID_NET_MASK   = 0x8032001f,
    FWP_E_INVALID_RANGE      = 0x80320020,
    FWP_E_INVALID_INTERVAL   = 0x80320021,
}

enum int FWP_E_NULL_DISPLAY_NAME = 0x80320023;
enum int FWP_E_INVALID_WEIGHT = 0x80320025;
enum int FWP_E_TYPE_MISMATCH = 0x80320027;

enum : int
{
    FWP_E_RESERVED            = 0x80320029,
    FWP_E_DUPLICATE_CONDITION = 0x8032002a,
    FWP_E_DUPLICATE_KEYMOD    = 0x8032002b,
}

enum int FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER = 0x8032002d;
enum int FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT = 0x8032002f;
enum int FWP_E_INCOMPATIBLE_DH_GROUP = 0x80320031;
enum int FWP_E_NEVER_MATCH = 0x80320033;
enum int FWP_E_INVALID_PARAMETER = 0x80320035;
enum int FWP_E_CALLOUT_NOTIFICATION_FAILED = 0x80320037;
enum int FWP_E_INVALID_CIPHER_TRANSFORM = 0x80320039;
enum int FWP_E_INVALID_TRANSFORM_COMBINATION = 0x8032003b;
enum int FWP_E_INVALID_TUNNEL_ENDPOINT = 0x8032003d;

enum : int
{
    FWP_E_KEY_DICTATOR_ALREADY_REGISTERED       = 0x8032003f,
    FWP_E_KEY_DICTATION_INVALID_KEYING_MATERIAL = 0x80320040,
}

enum int FWP_E_INVALID_DNS_NAME = 0x80320042;
enum int FWP_E_IKEEXT_NOT_RUNNING = 0x80320044;

enum : int
{
    WS_S_ASYNC = 0x003d0000,
    WS_S_END   = 0x003d0001,
}

enum int WS_E_OBJECT_FAULTED = 0x803d0001;
enum int WS_E_INVALID_OPERATION = 0x803d0003;
enum int WS_E_ENDPOINT_ACCESS_DENIED = 0x803d0005;
enum int WS_E_OPERATION_ABANDONED = 0x803d0007;
enum int WS_E_NO_TRANSLATION_AVAILABLE = 0x803d0009;

enum : int
{
    WS_E_ADDRESS_IN_USE        = 0x803d000b,
    WS_E_ADDRESS_NOT_AVAILABLE = 0x803d000c,
}

enum : int
{
    WS_E_ENDPOINT_NOT_AVAILABLE        = 0x803d000e,
    WS_E_ENDPOINT_FAILURE              = 0x803d000f,
    WS_E_ENDPOINT_UNREACHABLE          = 0x803d0010,
    WS_E_ENDPOINT_ACTION_NOT_SUPPORTED = 0x803d0011,
    WS_E_ENDPOINT_TOO_BUSY             = 0x803d0012,
    WS_E_ENDPOINT_FAULT_RECEIVED       = 0x803d0013,
    WS_E_ENDPOINT_DISCONNECTED         = 0x803d0014,
}

enum int WS_E_PROXY_ACCESS_DENIED = 0x803d0016;

enum : int
{
    WS_E_PROXY_REQUIRES_BASIC_AUTH     = 0x803d0018,
    WS_E_PROXY_REQUIRES_DIGEST_AUTH    = 0x803d0019,
    WS_E_PROXY_REQUIRES_NTLM_AUTH      = 0x803d001a,
    WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH = 0x803d001b,
}

enum : int
{
    WS_E_SERVER_REQUIRES_DIGEST_AUTH    = 0x803d001d,
    WS_E_SERVER_REQUIRES_NTLM_AUTH      = 0x803d001e,
    WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH = 0x803d001f,
}

enum : int
{
    WS_E_OTHER                   = 0x803d0021,
    WS_E_SECURITY_TOKEN_EXPIRED  = 0x803d0022,
    WS_E_SECURITY_SYSTEM_FAILURE = 0x803d0023,
}

enum : uint
{
    ERROR_NDIS_BAD_VERSION         = 0x80340004,
    ERROR_NDIS_BAD_CHARACTERISTICS = 0x80340005,
}

enum : uint
{
    ERROR_NDIS_OPEN_FAILED         = 0x80340007,
    ERROR_NDIS_DEVICE_FAILED       = 0x80340008,
    ERROR_NDIS_MULTICAST_FULL      = 0x80340009,
    ERROR_NDIS_MULTICAST_EXISTS    = 0x8034000a,
    ERROR_NDIS_MULTICAST_NOT_FOUND = 0x8034000b,
}

enum uint ERROR_NDIS_RESET_IN_PROGRESS = 0x8034000d;

enum : uint
{
    ERROR_NDIS_INVALID_PACKET    = 0x8034000f,
    ERROR_NDIS_ADAPTER_NOT_READY = 0x80340011,
}

enum : uint
{
    ERROR_NDIS_INVALID_DATA      = 0x80340015,
    ERROR_NDIS_BUFFER_TOO_SHORT  = 0x80340016,
    ERROR_NDIS_INVALID_OID       = 0x80340017,
    ERROR_NDIS_ADAPTER_REMOVED   = 0x80340018,
    ERROR_NDIS_UNSUPPORTED_MEDIA = 0x80340019,
}

enum : uint
{
    ERROR_NDIS_FILE_NOT_FOUND     = 0x8034001b,
    ERROR_NDIS_ERROR_READING_FILE = 0x8034001c,
}

enum uint ERROR_NDIS_RESOURCE_CONFLICT = 0x8034001e;

enum : uint
{
    ERROR_NDIS_INVALID_ADDRESS        = 0x80340022,
    ERROR_NDIS_INVALID_DEVICE_REQUEST = 0x80340010,
}

enum uint ERROR_NDIS_INTERFACE_NOT_FOUND = 0x8034002b;

enum : uint
{
    ERROR_NDIS_INVALID_PORT       = 0x8034002d,
    ERROR_NDIS_INVALID_PORT_STATE = 0x8034002e,
}

enum : uint
{
    ERROR_NDIS_REINIT_REQUIRED           = 0x80340030,
    ERROR_NDIS_NO_QUEUES                 = 0x80340031,
    ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED = 0x80342000,
    ERROR_NDIS_DOT11_MEDIA_IN_USE        = 0x80342001,
    ERROR_NDIS_DOT11_POWER_STATE_INVALID = 0x80342002,
}

enum uint ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = 0x80342004;

enum : uint
{
    ERROR_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE = 0x80342006,
    ERROR_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED          = 0x80342007,
    ERROR_NDIS_DOT11_AP_BAND_NOT_ALLOWED             = 0x80342008,
}

enum : uint
{
    ERROR_NDIS_OFFLOAD_POLICY              = 0xc034100f,
    ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED = 0xc0341012,
    ERROR_NDIS_OFFLOAD_PATH_REJECTED       = 0xc0341013,
}

enum : uint
{
    ERROR_HV_INVALID_HYPERCALL_INPUT = 0xc0350003,
    ERROR_HV_INVALID_ALIGNMENT       = 0xc0350004,
    ERROR_HV_INVALID_PARAMETER       = 0xc0350005,
}

enum uint ERROR_HV_INVALID_PARTITION_STATE = 0xc0350007;
enum uint ERROR_HV_UNKNOWN_PROPERTY = 0xc0350009;
enum uint ERROR_HV_INSUFFICIENT_MEMORY = 0xc035000b;

enum : uint
{
    ERROR_HV_INVALID_PARTITION_ID  = 0xc035000d,
    ERROR_HV_INVALID_VP_INDEX      = 0xc035000e,
    ERROR_HV_INVALID_PORT_ID       = 0xc0350011,
    ERROR_HV_INVALID_CONNECTION_ID = 0xc0350012,
}

enum uint ERROR_HV_NOT_ACKNOWLEDGED = 0xc0350014;

enum : uint
{
    ERROR_HV_ACKNOWLEDGED               = 0xc0350016,
    ERROR_HV_INVALID_SAVE_RESTORE_STATE = 0xc0350017,
    ERROR_HV_INVALID_SYNIC_STATE        = 0xc0350018,
}

enum uint ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO = 0xc035001a;

enum : uint
{
    ERROR_HV_INACTIVE            = 0xc035001c,
    ERROR_HV_NO_RESOURCES        = 0xc035001d,
    ERROR_HV_FEATURE_UNAVAILABLE = 0xc035001e,
}

enum uint ERROR_HV_INSUFFICIENT_DEVICE_DOMAINS = 0xc0350038;
enum uint ERROR_HV_CPUID_XSAVE_FEATURE_VALIDATION = 0xc035003d;

enum : uint
{
    ERROR_HV_SMX_ENABLED            = 0xc035003f,
    ERROR_HV_INVALID_LP_INDEX       = 0xc0350041,
    ERROR_HV_INVALID_REGISTER_VALUE = 0xc0350050,
    ERROR_HV_INVALID_VTL_STATE      = 0xc0350051,
}

enum : uint
{
    ERROR_HV_INVALID_DEVICE_ID    = 0xc0350057,
    ERROR_HV_INVALID_DEVICE_STATE = 0xc0350058,
}

enum uint ERROR_HV_PAGE_REQUEST_INVALID = 0xc0350060;
enum uint ERROR_HV_INVALID_CPU_GROUP_STATE = 0xc0350070;
enum uint ERROR_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE = 0xc0350072;
enum uint ERROR_HV_EVENT_BUFFER_ALREADY_FREED = 0xc0350074;
enum uint ERROR_HV_NOT_PRESENT = 0xc0351000;
enum uint ERROR_VID_TOO_MANY_HANDLERS = 0xc0370002;
enum uint ERROR_VID_HANDLER_NOT_PRESENT = 0xc0370004;
enum uint ERROR_VID_PARTITION_NAME_TOO_LONG = 0xc0370006;

enum : uint
{
    ERROR_VID_PARTITION_ALREADY_EXISTS = 0xc0370008,
    ERROR_VID_PARTITION_DOES_NOT_EXIST = 0xc0370009,
    ERROR_VID_PARTITION_NAME_NOT_FOUND = 0xc037000a,
}

enum uint ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT = 0xc037000c;
enum uint ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED = 0xc037000e;
enum uint ERROR_VID_INVALID_NUMA_NODE_INDEX = 0xc0370010;
enum uint ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE = 0xc0370012;

enum : uint
{
    ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE = 0xc0370014,
    ERROR_VID_INVALID_GPA_RANGE_HANDLE     = 0xc0370015,
}

enum uint ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED = 0xc0370017;

enum : uint
{
    ERROR_VID_MBPS_ARE_LOCKED      = 0xc0370019,
    ERROR_VID_MESSAGE_QUEUE_CLOSED = 0xc037001a,
}

enum : uint
{
    ERROR_VID_STOP_PENDING            = 0xc037001c,
    ERROR_VID_INVALID_PROCESSOR_STATE = 0xc037001d,
}

enum uint ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED = 0xc037001f;
enum uint ERROR_VID_MMIO_RANGE_DESTROYED = 0xc0370021;

enum : uint
{
    ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED = 0xc0370023,
    ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL     = 0xc0370024,
}

enum uint ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT = 0xc0370026;

enum : uint
{
    ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM = 0xc0370028,
    ERROR_VID_SAVED_STATE_INCOMPATIBLE      = 0xc0370029,
}

enum : uint
{
    ERROR_VMCOMPUTE_TERMINATED_DURING_START      = 0xc0370100,
    ERROR_VMCOMPUTE_IMAGE_MISMATCH               = 0xc0370101,
    ERROR_VMCOMPUTE_HYPERV_NOT_INSTALLED         = 0xc0370102,
    ERROR_VMCOMPUTE_OPERATION_PENDING            = 0xc0370103,
    ERROR_VMCOMPUTE_TOO_MANY_NOTIFICATIONS       = 0xc0370104,
    ERROR_VMCOMPUTE_INVALID_STATE                = 0xc0370105,
    ERROR_VMCOMPUTE_UNEXPECTED_EXIT              = 0xc0370106,
    ERROR_VMCOMPUTE_TERMINATED                   = 0xc0370107,
    ERROR_VMCOMPUTE_CONNECT_FAILED               = 0xc0370108,
    ERROR_VMCOMPUTE_TIMEOUT                      = 0xc0370109,
    ERROR_VMCOMPUTE_CONNECTION_CLOSED            = 0xc037010a,
    ERROR_VMCOMPUTE_UNKNOWN_MESSAGE              = 0xc037010b,
    ERROR_VMCOMPUTE_UNSUPPORTED_PROTOCOL_VERSION = 0xc037010c,
}

enum : uint
{
    ERROR_VMCOMPUTE_SYSTEM_NOT_FOUND         = 0xc037010e,
    ERROR_VMCOMPUTE_SYSTEM_ALREADY_EXISTS    = 0xc037010f,
    ERROR_VMCOMPUTE_SYSTEM_ALREADY_STOPPED   = 0xc0370110,
    ERROR_VMCOMPUTE_PROTOCOL_ERROR           = 0xc0370111,
    ERROR_VMCOMPUTE_INVALID_LAYER            = 0xc0370112,
    ERROR_VMCOMPUTE_WINDOWS_INSIDER_REQUIRED = 0xc0370113,
}

enum int HCS_E_IMAGE_MISMATCH = 0x80370101;
enum int HCS_E_INVALID_STATE = 0x80370105;
enum int HCS_E_TERMINATED = 0x80370107;

enum : int
{
    HCS_E_CONNECTION_TIMEOUT = 0x80370109,
    HCS_E_CONNECTION_CLOSED  = 0x8037010a,
}

enum int HCS_E_UNSUPPORTED_PROTOCOL_VERSION = 0x8037010c;

enum : int
{
    HCS_E_SYSTEM_NOT_FOUND       = 0x8037010e,
    HCS_E_SYSTEM_ALREADY_EXISTS  = 0x8037010f,
    HCS_E_SYSTEM_ALREADY_STOPPED = 0x80370110,
}

enum int HCS_E_INVALID_LAYER = 0x80370112;
enum int HCS_E_SERVICE_NOT_AVAILABLE = 0x80370114;

enum : int
{
    HCS_E_OPERATION_ALREADY_STARTED             = 0x80370116,
    HCS_E_OPERATION_PENDING                     = 0x80370117,
    HCS_E_OPERATION_TIMEOUT                     = 0x80370118,
    HCS_E_OPERATION_SYSTEM_CALLBACK_ALREADY_SET = 0x80370119,
}

enum int HCS_E_ACCESS_DENIED = 0x8037011b;
enum int HCS_E_PROCESS_INFO_NOT_AVAILABLE = 0x8037011d;
enum int HCS_E_PROCESS_ALREADY_STOPPED = 0x8037011f;
enum uint ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED = 0x80370001;
enum int WHV_E_INSUFFICIENT_BUFFER = 0x80370301;
enum int WHV_E_UNSUPPORTED_HYPERVISOR_CONFIG = 0x80370303;
enum int WHV_E_GPA_RANGE_NOT_FOUND = 0x80370305;
enum int WHV_E_VP_DOES_NOT_EXIST = 0x80370307;
enum int WHV_E_INVALID_VP_REGISTER_NAME = 0x80370309;

enum : uint
{
    ERROR_VSMB_SAVED_STATE_FILE_NOT_FOUND = 0xc0370400,
    ERROR_VSMB_SAVED_STATE_CORRUPT        = 0xc0370401,
}

enum : int
{
    VM_SAVED_STATE_DUMP_E_GUEST_MEMORY_NOT_FOUND              = 0xc0370501,
    VM_SAVED_STATE_DUMP_E_NO_VP_FOUND_IN_PARTITION_STATE      = 0xc0370502,
    VM_SAVED_STATE_DUMP_E_NESTED_VIRTUALIZATION_NOT_SUPPORTED = 0xc0370503,
}

enum : int
{
    VM_SAVED_STATE_DUMP_E_PXE_NOT_PRESENT   = 0xc0370505,
    VM_SAVED_STATE_DUMP_E_PDPTE_NOT_PRESENT = 0xc0370506,
    VM_SAVED_STATE_DUMP_E_PDE_NOT_PRESENT   = 0xc0370507,
    VM_SAVED_STATE_DUMP_E_PTE_NOT_PRESENT   = 0xc0370508,
}

enum uint ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION = 0x80380002;

enum : uint
{
    ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED   = 0xc0380002,
    ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC = 0xc0380003,
}

enum : uint
{
    ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME                = 0xc0380005,
    ERROR_VOLMGR_DISK_DUPLICATE                                 = 0xc0380006,
    ERROR_VOLMGR_DISK_DYNAMIC                                   = 0xc0380007,
    ERROR_VOLMGR_DISK_ID_INVALID                                = 0xc0380008,
    ERROR_VOLMGR_DISK_INVALID                                   = 0xc0380009,
    ERROR_VOLMGR_DISK_LAST_VOTER                                = 0xc038000a,
    ERROR_VOLMGR_DISK_LAYOUT_INVALID                            = 0xc038000b,
    ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS = 0xc038000c,
    ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED               = 0xc038000d,
    ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL               = 0xc038000e,
    ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS = 0xc038000f,
    ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS                = 0xc0380010,
    ERROR_VOLMGR_DISK_MISSING                                   = 0xc0380011,
    ERROR_VOLMGR_DISK_NOT_EMPTY                                 = 0xc0380012,
    ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE                          = 0xc0380013,
    ERROR_VOLMGR_DISK_REVECTORING_FAILED                        = 0xc0380014,
    ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID                       = 0xc0380015,
    ERROR_VOLMGR_DISK_SET_NOT_CONTAINED                         = 0xc0380016,
    ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS                  = 0xc0380017,
    ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES                   = 0xc0380018,
}

enum : uint
{
    ERROR_VOLMGR_EXTENT_ALREADY_USED                = 0xc038001a,
    ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS              = 0xc038001b,
    ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION        = 0xc038001c,
    ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED          = 0xc038001d,
    ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION      = 0xc038001e,
    ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH = 0xc038001f,
}

enum uint ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID = 0xc0380021;

enum : uint
{
    ERROR_VOLMGR_MEMBER_IN_SYNC            = 0xc0380023,
    ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE    = 0xc0380024,
    ERROR_VOLMGR_MEMBER_INDEX_INVALID      = 0xc0380025,
    ERROR_VOLMGR_MEMBER_MISSING            = 0xc0380026,
    ERROR_VOLMGR_MEMBER_NOT_DETACHED       = 0xc0380027,
    ERROR_VOLMGR_MEMBER_REGENERATING       = 0xc0380028,
    ERROR_VOLMGR_ALL_DISKS_FAILED          = 0xc0380029,
    ERROR_VOLMGR_NO_REGISTERED_USERS       = 0xc038002a,
    ERROR_VOLMGR_NO_SUCH_USER              = 0xc038002b,
    ERROR_VOLMGR_NOTIFICATION_RESET        = 0xc038002c,
    ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID = 0xc038002d,
    ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID  = 0xc038002e,
}

enum : uint
{
    ERROR_VOLMGR_PACK_ID_INVALID         = 0xc0380030,
    ERROR_VOLMGR_PACK_INVALID            = 0xc0380031,
    ERROR_VOLMGR_PACK_NAME_INVALID       = 0xc0380032,
    ERROR_VOLMGR_PACK_OFFLINE            = 0xc0380033,
    ERROR_VOLMGR_PACK_HAS_QUORUM         = 0xc0380034,
    ERROR_VOLMGR_PACK_WITHOUT_QUORUM     = 0xc0380035,
    ERROR_VOLMGR_PARTITION_STYLE_INVALID = 0xc0380036,
    ERROR_VOLMGR_PARTITION_UPDATE_FAILED = 0xc0380037,
}

enum : uint
{
    ERROR_VOLMGR_PLEX_INDEX_DUPLICATE   = 0xc0380039,
    ERROR_VOLMGR_PLEX_INDEX_INVALID     = 0xc038003a,
    ERROR_VOLMGR_PLEX_LAST_ACTIVE       = 0xc038003b,
    ERROR_VOLMGR_PLEX_MISSING           = 0xc038003c,
    ERROR_VOLMGR_PLEX_REGENERATING      = 0xc038003d,
    ERROR_VOLMGR_PLEX_TYPE_INVALID      = 0xc038003e,
    ERROR_VOLMGR_PLEX_NOT_RAID5         = 0xc038003f,
    ERROR_VOLMGR_PLEX_NOT_SIMPLE        = 0xc0380040,
    ERROR_VOLMGR_STRUCTURE_SIZE_INVALID = 0xc0380041,
}

enum uint ERROR_VOLMGR_TRANSACTION_IN_PROGRESS = 0xc0380043;

enum : uint
{
    ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK           = 0xc0380045,
    ERROR_VOLMGR_VOLUME_ID_INVALID                      = 0xc0380046,
    ERROR_VOLMGR_VOLUME_LENGTH_INVALID                  = 0xc0380047,
    ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = 0xc0380048,
}

enum : uint
{
    ERROR_VOLMGR_VOLUME_NOT_RETAINED       = 0xc038004a,
    ERROR_VOLMGR_VOLUME_OFFLINE            = 0xc038004b,
    ERROR_VOLMGR_VOLUME_RETAINED           = 0xc038004c,
    ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID = 0xc038004d,
}

enum : uint
{
    ERROR_VOLMGR_BAD_BOOT_DISK          = 0xc038004f,
    ERROR_VOLMGR_PACK_CONFIG_OFFLINE    = 0xc0380050,
    ERROR_VOLMGR_PACK_CONFIG_ONLINE     = 0xc0380051,
    ERROR_VOLMGR_NOT_PRIMARY_PACK       = 0xc0380052,
    ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED = 0xc0380053,
}

enum uint ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID = 0xc0380055;
enum uint ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED = 0xc0380057;
enum uint ERROR_VOLMGR_PRIMARY_PACK_PRESENT = 0xc0380059;
enum uint ERROR_VOLMGR_MIRROR_NOT_SUPPORTED = 0xc038005b;
enum uint ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED = 0x80390001;
enum uint ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED = 0x80390003;

enum : uint
{
    ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH = 0xc03a0002,
    ERROR_VHD_DRIVE_FOOTER_CORRUPT           = 0xc03a0003,
}

enum uint ERROR_VHD_FORMAT_UNSUPPORTED_VERSION = 0xc03a0005;

enum : uint
{
    ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION = 0xc03a0007,
    ERROR_VHD_SPARSE_HEADER_CORRUPT             = 0xc03a0008,
}

enum uint ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT = 0xc03a000a;
enum uint ERROR_VHD_BITMAP_MISMATCH = 0xc03a000c;

enum : uint
{
    ERROR_VHD_CHILD_PARENT_ID_MISMATCH        = 0xc03a000e,
    ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH = 0xc03a000f,
}

enum uint ERROR_VHD_METADATA_WRITE_FAILURE = 0xc03a0011;
enum uint ERROR_VHD_INVALID_FILE_SIZE = 0xc03a0013;
enum uint ERROR_VIRTDISK_NOT_VIRTUAL_DISK = 0xc03a0015;
enum uint ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH = 0xc03a0017;
enum uint ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = 0xc03a0019;

enum : uint
{
    ERROR_VHD_INVALID_TYPE  = 0xc03a001b,
    ERROR_VHD_INVALID_STATE = 0xc03a001c,
}

enum : uint
{
    ERROR_VIRTDISK_DISK_ALREADY_OWNED       = 0xc03a001e,
    ERROR_VIRTDISK_DISK_ONLINE_AND_WRITABLE = 0xc03a001f,
}

enum uint ERROR_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE = 0xc03a0021;

enum : uint
{
    ERROR_CTLOG_INVALID_TRACKING_STATE     = 0xc03a0023,
    ERROR_CTLOG_INCONSISTENT_TRACKING_FILE = 0xc03a0024,
}

enum uint ERROR_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE = 0xc03a0026;

enum : uint
{
    ERROR_VHD_METADATA_FULL              = 0xc03a0028,
    ERROR_VHD_INVALID_CHANGE_TRACKING_ID = 0xc03a0029,
}

enum uint ERROR_VHD_MISSING_CHANGE_TRACKING_INFORMATION = 0xc03a0030;
enum int HCN_E_NETWORK_NOT_FOUND = 0x803b0001;
enum int HCN_E_LAYER_NOT_FOUND = 0x803b0003;
enum int HCN_E_SUBNET_NOT_FOUND = 0x803b0005;
enum int HCN_E_PORT_NOT_FOUND = 0x803b0007;
enum int HCN_E_VFP_PORTSETTING_NOT_FOUND = 0x803b0009;

enum : int
{
    HCN_E_INVALID_NETWORK_TYPE              = 0x803b000b,
    HCN_E_INVALID_ENDPOINT                  = 0x803b000c,
    HCN_E_INVALID_POLICY                    = 0x803b000d,
    HCN_E_INVALID_POLICY_TYPE               = 0x803b000e,
    HCN_E_INVALID_REMOTE_ENDPOINT_OPERATION = 0x803b000f,
}

enum int HCN_E_LAYER_ALREADY_EXISTS = 0x803b0011;
enum int HCN_E_PORT_ALREADY_EXISTS = 0x803b0013;
enum int HCN_E_REQUEST_UNSUPPORTED = 0x803b0015;
enum int HCN_E_DEGRADED_OPERATION = 0x803b0017;
enum int HCN_E_GUID_CONVERSION_FAILURE = 0x803b0019;

enum : int
{
    HCN_E_INVALID_JSON           = 0x803b001b,
    HCN_E_INVALID_JSON_REFERENCE = 0x803b001c,
}

enum int HCN_E_INVALID_IP = 0x803b001e;
enum int HCN_E_MANAGER_STOPPED = 0x803b0020;
enum int GCN_E_NO_REQUEST_HANDLERS = 0x803b0022;
enum int GCN_E_RUNTIMEKEYS_FAILED = 0x803b0024;
enum int GCN_E_NETADAPTER_NOT_FOUND = 0x803b0026;
enum int GCN_E_NETINTERFACE_NOT_FOUND = 0x803b0028;
enum int HCN_E_ICS_DISABLED = 0x803b002a;
enum int HCN_E_ENTITY_HAS_REFERENCES = 0x803b002c;
enum int HCN_E_NAMESPACE_ATTACH_FAILED = 0x803b002e;
enum int HCN_E_INVALID_PREFIX = 0x803b0030;

enum : int
{
    HCN_E_INVALID_SUBNET    = 0x803b0032,
    HCN_E_INVALID_IP_SUBNET = 0x803b0033,
}

enum int HCN_E_ENDPOINT_NOT_LOCAL = 0x803b0035;

enum : uint
{
    SDIAG_E_CANCELLED   = 0x803c0100,
    SDIAG_E_SCRIPT      = 0x803c0101,
    SDIAG_E_POWERSHELL  = 0x803c0102,
    SDIAG_E_MANAGEDHOST = 0x803c0103,
    SDIAG_E_NOVERIFIER  = 0x803c0104,
}

enum : uint
{
    SDIAG_E_DISABLED  = 0x803c0106,
    SDIAG_E_TRUST     = 0x803c0107,
    SDIAG_E_CANNOTRUN = 0x803c0108,
    SDIAG_E_VERSION   = 0x803c0109,
    SDIAG_E_RESOURCE  = 0x803c010a,
    SDIAG_E_ROOTCAUSE = 0x803c010b,
}

enum int WPN_E_CHANNEL_REQUEST_NOT_COMPLETE = 0x803e0101;
enum int WPN_E_OUTSTANDING_CHANNEL_REQUEST = 0x803e0103;
enum int WPN_E_PLATFORM_UNAVAILABLE = 0x803e0105;

enum : int
{
    WPN_E_NOTIFICATION_HIDDEN     = 0x803e0107,
    WPN_E_NOTIFICATION_NOT_POSTED = 0x803e0108,
}

enum : int
{
    WPN_E_CLOUD_INCAPABLE           = 0x803e0110,
    WPN_E_CLOUD_AUTH_UNAVAILABLE    = 0x803e011a,
    WPN_E_CLOUD_SERVICE_UNAVAILABLE = 0x803e011b,
}

enum : int
{
    WPN_E_NOTIFICATION_DISABLED  = 0x803e0111,
    WPN_E_NOTIFICATION_INCAPABLE = 0x803e0112,
}

enum : int
{
    WPN_E_NOTIFICATION_TYPE_DISABLED = 0x803e0114,
    WPN_E_NOTIFICATION_SIZE          = 0x803e0115,
}

enum int WPN_E_ACCESS_DENIED = 0x803e0117;
enum int WPN_E_PUSH_NOTIFICATION_INCAPABLE = 0x803e0119;
enum int WPN_E_TAG_ALPHANUMERIC = 0x803e012a;
enum int WPN_E_OUT_OF_SESSION = 0x803e0200;
enum int WPN_E_IMAGE_NOT_FOUND_IN_CACHE = 0x803e0202;
enum int WPN_E_INVALID_CLOUD_IMAGE = 0x803e0204;
enum int WPN_E_CALLBACK_ALREADY_REGISTERED = 0x803e0206;
enum int WPN_E_STORAGE_LOCKED = 0x803e0208;
enum int WPN_E_GROUP_ALPHANUMERIC = 0x803e020a;
enum int E_MBN_CONTEXT_NOT_ACTIVATED = 0x80548201;
enum int E_MBN_DATA_CLASS_NOT_AVAILABLE = 0x80548203;
enum int E_MBN_MAX_ACTIVATED_CONTEXTS = 0x80548205;
enum int E_MBN_PROVIDER_NOT_VISIBLE = 0x80548207;
enum int E_MBN_SERVICE_NOT_ACTIVATED = 0x80548209;
enum int E_MBN_VOICE_CALL_IN_PROGRESS = 0x8054820b;
enum int E_MBN_NOT_REGISTERED = 0x8054820d;

enum : int
{
    E_MBN_PIN_NOT_SUPPORTED = 0x8054820f,
    E_MBN_PIN_REQUIRED      = 0x80548210,
    E_MBN_PIN_DISABLED      = 0x80548211,
}

enum int E_MBN_INVALID_PROFILE = 0x80548218;
enum int E_MBN_SMS_ENCODING_NOT_SUPPORTED = 0x80548220;
enum int E_MBN_SMS_INVALID_MEMORY_INDEX = 0x80548222;

enum : int
{
    E_MBN_SMS_MEMORY_FAILURE  = 0x80548224,
    E_MBN_SMS_NETWORK_TIMEOUT = 0x80548225,
}

enum int E_MBN_SMS_FORMAT_NOT_SUPPORTED = 0x80548227;
enum int E_MBN_SMS_MEMORY_FULL = 0x80548229;
enum int PEER_E_NOT_INITIALIZED = 0x80630002;
enum int PEER_E_NOT_LICENSED = 0x80630004;
enum int PEER_E_DBNAME_CHANGED = 0x80630011;

enum : int
{
    PEER_E_GRAPH_NOT_READY     = 0x80630013,
    PEER_E_GRAPH_SHUTTING_DOWN = 0x80630014,
    PEER_E_GRAPH_IN_USE        = 0x80630015,
}

enum int PEER_E_TOO_MANY_ATTRIBUTES = 0x80630017;
enum int PEER_E_CONNECT_SELF = 0x80630106;
enum int PEER_E_NODE_NOT_FOUND = 0x80630108;

enum : int
{
    PEER_E_CONNECTION_NOT_AUTHENTICATED = 0x8063010a,
    PEER_E_CONNECTION_REFUSED           = 0x8063010b,
}

enum int PEER_E_TOO_MANY_IDENTITIES = 0x80630202;
enum int PEER_E_GROUPS_EXIST = 0x80630204;
enum int PEER_E_DATABASE_ACCESSDENIED = 0x80630302;
enum int PEER_E_MAX_RECORD_SIZE_EXCEEDED = 0x80630304;
enum int PEER_E_DATABASE_NOT_PRESENT = 0x80630306;
enum int PEER_E_EVENT_HANDLE_NOT_FOUND = 0x80630501;
enum int PEER_E_INVALID_ATTRIBUTES = 0x80630602;
enum int PEER_E_CHAIN_TOO_LONG = 0x80630703;
enum int PEER_E_CIRCULAR_CHAIN_DETECTED = 0x80630706;

enum : int
{
    PEER_E_NO_CLOUD             = 0x80631001,
    PEER_E_CLOUD_NAME_AMBIGUOUS = 0x80631005,
}

enum int PEER_E_NOT_AUTHORIZED = 0x80632020;
enum int PEER_E_DEFERRED_VALIDATION = 0x80632030;

enum : int
{
    PEER_E_INVALID_PEER_NAME           = 0x80632050,
    PEER_E_INVALID_CLASSIFIER          = 0x80632060,
    PEER_E_INVALID_FRIENDLY_NAME       = 0x80632070,
    PEER_E_INVALID_ROLE_PROPERTY       = 0x80632071,
    PEER_E_INVALID_CLASSIFIER_PROPERTY = 0x80632072,
    PEER_E_INVALID_RECORD_EXPIRATION   = 0x80632080,
    PEER_E_INVALID_CREDENTIAL_INFO     = 0x80632081,
    PEER_E_INVALID_CREDENTIAL          = 0x80632082,
    PEER_E_INVALID_RECORD_SIZE         = 0x80632083,
}

enum : int
{
    PEER_E_GROUP_NOT_READY = 0x80632091,
    PEER_E_GROUP_IN_USE    = 0x80632092,
}

enum : int
{
    PEER_E_NO_MEMBERS_FOUND      = 0x80632094,
    PEER_E_NO_MEMBER_CONNECTIONS = 0x80632095,
}

enum int PEER_E_IDENTITY_DELETED = 0x806320a0;
enum int PEER_E_CONTACT_NOT_FOUND = 0x80636001;
enum int PEER_S_NO_EVENT_DATA = 0x00630002;
enum int PEER_S_SUBSCRIPTION_EXISTS = 0x00636000;
enum int PEER_S_ALREADY_A_MEMBER = 0x00630006;
enum int PEER_E_INVALID_PEER_HOST_NAME = 0x80634002;
enum int PEER_E_PNRP_DUPLICATE_PEER_NAME = 0x80634005;
enum int PEER_E_INVITE_RESPONSE_NOT_AVAILABLE = 0x80637001;
enum int PEER_E_PRIVACY_DECLINED = 0x80637004;
enum int PEER_E_INVALID_ADDRESS = 0x80637007;

enum : int
{
    PEER_E_FW_BLOCKED_BY_POLICY     = 0x80637009,
    PEER_E_FW_BLOCKED_BY_SHIELDS_UP = 0x8063700a,
}

enum int UI_E_CREATE_FAILED = 0x802a0001;
enum int UI_E_ILLEGAL_REENTRANCY = 0x802a0003;

enum : int
{
    UI_E_VALUE_NOT_SET        = 0x802a0005,
    UI_E_VALUE_NOT_DETERMINED = 0x802a0006,
}

enum int UI_E_BOOLEAN_EXPECTED = 0x802a0008;
enum int UI_E_AMBIGUOUS_MATCH = 0x802a000a;
enum int UI_E_WRONG_THREAD = 0x802a000c;
enum int UI_E_STORYBOARD_NOT_PLAYING = 0x802a0102;
enum int UI_E_END_KEYFRAME_NOT_DETERMINED = 0x802a0104;

enum : int
{
    UI_E_TRANSITION_ALREADY_USED      = 0x802a0106,
    UI_E_TRANSITION_NOT_IN_STORYBOARD = 0x802a0107,
    UI_E_TRANSITION_ECLIPSED          = 0x802a0108,
}

enum int UI_E_TIMER_CLIENT_ALREADY_CONNECTED = 0x802a010a;
enum int UI_E_PRIMITIVE_OUT_OF_BOUNDS = 0x802a010c;

enum : int
{
    E_BLUETOOTH_ATT_INVALID_HANDLE              = 0x80650001,
    E_BLUETOOTH_ATT_READ_NOT_PERMITTED          = 0x80650002,
    E_BLUETOOTH_ATT_WRITE_NOT_PERMITTED         = 0x80650003,
    E_BLUETOOTH_ATT_INVALID_PDU                 = 0x80650004,
    E_BLUETOOTH_ATT_INSUFFICIENT_AUTHENTICATION = 0x80650005,
}

enum : int
{
    E_BLUETOOTH_ATT_INVALID_OFFSET             = 0x80650007,
    E_BLUETOOTH_ATT_INSUFFICIENT_AUTHORIZATION = 0x80650008,
}

enum : int
{
    E_BLUETOOTH_ATT_ATTRIBUTE_NOT_FOUND              = 0x8065000a,
    E_BLUETOOTH_ATT_ATTRIBUTE_NOT_LONG               = 0x8065000b,
    E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE = 0x8065000c,
}

enum : int
{
    E_BLUETOOTH_ATT_UNLIKELY                = 0x8065000e,
    E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION = 0x8065000f,
    E_BLUETOOTH_ATT_UNSUPPORTED_GROUP_TYPE  = 0x80650010,
    E_BLUETOOTH_ATT_INSUFFICIENT_RESOURCES  = 0x80650011,
    E_BLUETOOTH_ATT_UNKNOWN_ERROR           = 0x80651000,
}

enum int E_HDAUDIO_EMPTY_CONNECTION_LIST = 0x80660002;
enum int E_HDAUDIO_NO_LOGICAL_DEVICES_CREATED = 0x80660004;
enum int STATEREPOSITORY_E_CONCURRENCY_LOCKING_FAILURE = 0x80670001;

enum : int
{
    STATEREPOSITORY_E_CONFIGURATION_INVALID          = 0x80670003,
    STATEREPOSITORY_E_UNKNOWN_SCHEMA_VERSION         = 0x80670004,
    STATEREPOSITORY_ERROR_DICTIONARY_CORRUPTED       = 0x80670005,
    STATEREPOSITORY_E_BLOCKED                        = 0x80670006,
    STATEREPOSITORY_E_BUSY_RETRY                     = 0x80670007,
    STATEREPOSITORY_E_BUSY_RECOVERY_RETRY            = 0x80670008,
    STATEREPOSITORY_E_LOCKED_RETRY                   = 0x80670009,
    STATEREPOSITORY_E_LOCKED_SHAREDCACHE_RETRY       = 0x8067000a,
    STATEREPOSITORY_E_TRANSACTION_REQUIRED           = 0x8067000b,
    STATEREPOSITORY_E_BUSY_TIMEOUT_EXCEEDED          = 0x8067000c,
    STATEREPOSITORY_E_BUSY_RECOVERY_TIMEOUT_EXCEEDED = 0x8067000d,
}

enum int STATEREPOSITORY_E_LOCKED_SHAREDCACHE_TIMEOUT_EXCEEDED = 0x8067000f;
enum int STATEREPOSTORY_E_NESTED_TRANSACTION_NOT_SUPPORTED = 0x80670011;

enum : int
{
    STATEREPOSITORY_TRANSACTION_CALLER_ID_CHANGED = 0x00670013,
    STATEREPOSITORY_TRANSACTION_IN_PROGRESS       = 0x00670014,
}

enum int ERROR_SPACES_FAULT_DOMAIN_TYPE_INVALID = 0x80e70001;
enum int ERROR_SPACES_RESILIENCY_TYPE_INVALID = 0x80e70003;
enum int ERROR_SPACES_DRIVE_REDUNDANCY_INVALID = 0x80e70006;
enum int ERROR_SPACES_PARITY_LAYOUT_INVALID = 0x80e70008;
enum int ERROR_SPACES_NUMBER_OF_COLUMNS_INVALID = 0x80e7000a;

enum : int
{
    ERROR_SPACES_EXTENDED_ERROR            = 0x80e7000c,
    ERROR_SPACES_PROVISIONING_TYPE_INVALID = 0x80e7000d,
}

enum int ERROR_SPACES_ENCLOSURE_AWARE_INVALID = 0x80e7000f;
enum int ERROR_SPACES_NUMBER_OF_GROUPS_INVALID = 0x80e70011;

enum : int
{
    ERROR_SPACES_ENTRY_INCOMPLETE = 0x80e70013,
    ERROR_SPACES_ENTRY_INVALID    = 0x80e70014,
}

enum int ERROR_VOLSNAP_ACTIVATION_TIMEOUT = 0x80820002;
enum int ERROR_TIERING_VOLUME_DISMOUNT_IN_PROGRESS = 0x80830002;

enum : int
{
    ERROR_TIERING_INVALID_FILE_ID    = 0x80830004,
    ERROR_TIERING_WRONG_CLUSTER_NODE = 0x80830005,
    ERROR_TIERING_ALREADY_PROCESSING = 0x80830006,
    ERROR_TIERING_CANNOT_PIN_OBJECT  = 0x80830007,
    ERROR_TIERING_FILE_IS_NOT_PINNED = 0x80830008,
}

enum int ERROR_ATTRIBUTE_NOT_PRESENT = 0x8083000a;
enum int ERROR_NO_APPLICABLE_APP_LICENSES_FOUND = 0xc0ea0001;
enum int ERROR_CLIP_DEVICE_LICENSE_MISSING = 0xc0ea0003;
enum int ERROR_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID = 0xc0ea0005;

enum : int
{
    ERROR_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE     = 0xc0ea0007,
    ERROR_CLIP_LICENSE_NOT_SIGNED                   = 0xc0ea0008,
    ERROR_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE = 0xc0ea0009,
    ERROR_CLIP_LICENSE_DEVICE_ID_MISMATCH           = 0xc0ea000a,
}

enum : int
{
    DXGI_STATUS_CLIPPED                      = 0x087a0002,
    DXGI_STATUS_NO_REDIRECTION               = 0x087a0004,
    DXGI_STATUS_NO_DESKTOP_ACCESS            = 0x087a0005,
    DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE = 0x087a0006,
}

enum int DXGI_STATUS_MODE_CHANGE_IN_PROGRESS = 0x087a0008;

enum : int
{
    DXGI_ERROR_NOT_FOUND         = 0x887a0002,
    DXGI_ERROR_MORE_DATA         = 0x887a0003,
    DXGI_ERROR_UNSUPPORTED       = 0x887a0004,
    DXGI_ERROR_DEVICE_REMOVED    = 0x887a0005,
    DXGI_ERROR_DEVICE_HUNG       = 0x887a0006,
    DXGI_ERROR_DEVICE_RESET      = 0x887a0007,
    DXGI_ERROR_WAS_STILL_DRAWING = 0x887a000a,
}

enum int DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE = 0x887a000c;

enum : int
{
    DXGI_ERROR_NONEXCLUSIVE            = 0x887a0021,
    DXGI_ERROR_NOT_CURRENTLY_AVAILABLE = 0x887a0022,
}

enum int DXGI_ERROR_REMOTE_OUTOFMEMORY = 0x887a0024;

enum : int
{
    DXGI_ERROR_WAIT_TIMEOUT         = 0x887a0027,
    DXGI_ERROR_SESSION_DISCONNECTED = 0x887a0028,
}

enum int DXGI_ERROR_CANNOT_PROTECT_CONTENT = 0x887a002a;
enum int DXGI_ERROR_NAME_ALREADY_EXISTS = 0x887a002c;

enum : int
{
    DXGI_ERROR_NOT_CURRENT               = 0x887a002e,
    DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY = 0x887a0030,
}

enum int DXGI_ERROR_NON_COMPOSITED_UI = 0x887a0032;

enum : int
{
    DXGI_STATUS_UNOCCLUDED            = 0x087a0009,
    DXGI_STATUS_DDA_WAS_STILL_DRAWING = 0x087a000a,
}

enum int DXGI_STATUS_PRESENT_REQUIRED = 0x087a002f;

enum : int
{
    DXGI_ERROR_CACHE_FULL           = 0x887a0034,
    DXGI_ERROR_CACHE_HASH_COLLISION = 0x887a0035,
}

enum : int
{
    DXGI_DDI_ERR_WASSTILLDRAWING = 0x887b0001,
    DXGI_DDI_ERR_UNSUPPORTED     = 0x887b0002,
    DXGI_DDI_ERR_NONEXCLUSIVE    = 0x887b0003,
}

enum int D3D10_ERROR_FILE_NOT_FOUND = 0x88790002;

enum : int
{
    D3D11_ERROR_FILE_NOT_FOUND               = 0x887c0002,
    D3D11_ERROR_TOO_MANY_UNIQUE_VIEW_OBJECTS = 0x887c0003,
}

enum : int
{
    D3D12_ERROR_ADAPTER_NOT_FOUND       = 0x887e0001,
    D3D12_ERROR_DRIVER_VERSION_MISMATCH = 0x887e0002,
}

enum int D2DERR_NOT_INITIALIZED = 0x88990002;

enum : int
{
    D2DERR_SCANNER_FAILED       = 0x88990004,
    D2DERR_SCREEN_ACCESS_DENIED = 0x88990005,
}

enum int D2DERR_ZERO_VECTOR = 0x88990007;
enum int D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED = 0x88990009;
enum int D2DERR_NO_HARDWARE_DEVICE = 0x8899000b;
enum int D2DERR_TOO_MANY_SHADER_ELEMENTS = 0x8899000d;
enum int D2DERR_MAX_TEXTURE_SIZE_EXCEEDED = 0x8899000f;

enum : int
{
    D2DERR_BAD_NUMBER    = 0x88990011,
    D2DERR_WRONG_FACTORY = 0x88990012,
}

enum int D2DERR_POP_CALL_DID_NOT_MATCH_PUSH = 0x88990014;
enum int D2DERR_PUSH_POP_UNBALANCED = 0x88990016;
enum int D2DERR_INCOMPATIBLE_BRUSH_TYPES = 0x88990018;
enum int D2DERR_TARGET_NOT_GDI_COMPATIBLE = 0x8899001a;
enum int D2DERR_TEXT_RENDERER_NOT_RELEASED = 0x8899001c;

enum : int
{
    D2DERR_INVALID_GRAPH_CONFIGURATION          = 0x8899001e,
    D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION = 0x8899001f,
}

enum int D2DERR_BITMAP_CANNOT_DRAW = 0x88990021;
enum int D2DERR_ORIGINAL_TARGET_NOT_BOUND = 0x88990023;
enum int D2DERR_BITMAP_BOUND_AS_TARGET = 0x88990025;
enum int D2DERR_INTERMEDIATE_TOO_LARGE = 0x88990027;
enum int D2DERR_INVALID_PROPERTY = 0x88990029;

enum : int
{
    D2DERR_PRINT_JOB_CLOSED           = 0x8899002b,
    D2DERR_PRINT_FORMAT_NOT_SUPPORTED = 0x8899002c,
}

enum int D2DERR_INVALID_GLYPH_IMAGE = 0x8899002e;

enum : int
{
    DWRITE_E_UNEXPECTED             = 0x88985001,
    DWRITE_E_NOFONT                 = 0x88985002,
    DWRITE_E_FILENOTFOUND           = 0x88985003,
    DWRITE_E_FILEACCESS             = 0x88985004,
    DWRITE_E_FONTCOLLECTIONOBSOLETE = 0x88985005,
}

enum : int
{
    DWRITE_E_CACHEFORMAT          = 0x88985007,
    DWRITE_E_CACHEVERSION         = 0x88985008,
    DWRITE_E_UNSUPPORTEDOPERATION = 0x88985009,
}

enum int DWRITE_E_FLOWDIRECTIONCONFLICTS = 0x8898500b;

enum : int
{
    DWRITE_E_REMOTEFONT        = 0x8898500d,
    DWRITE_E_DOWNLOADCANCELLED = 0x8898500e,
    DWRITE_E_DOWNLOADFAILED    = 0x8898500f,
}

enum : int
{
    WINCODEC_ERR_WRONGSTATE            = 0x88982f04,
    WINCODEC_ERR_VALUEOUTOFRANGE       = 0x88982f05,
    WINCODEC_ERR_UNKNOWNIMAGEFORMAT    = 0x88982f07,
    WINCODEC_ERR_UNSUPPORTEDVERSION    = 0x88982f0b,
    WINCODEC_ERR_NOTINITIALIZED        = 0x88982f0c,
    WINCODEC_ERR_ALREADYLOCKED         = 0x88982f0d,
    WINCODEC_ERR_PROPERTYNOTFOUND      = 0x88982f40,
    WINCODEC_ERR_PROPERTYNOTSUPPORTED  = 0x88982f41,
    WINCODEC_ERR_PROPERTYSIZE          = 0x88982f42,
    WINCODEC_ERR_CODECPRESENT          = 0x88982f43,
    WINCODEC_ERR_CODECNOTHUMBNAIL      = 0x88982f44,
    WINCODEC_ERR_PALETTEUNAVAILABLE    = 0x88982f45,
    WINCODEC_ERR_CODECTOOMANYSCANLINES = 0x88982f46,
}

enum int WINCODEC_ERR_SOURCERECTDOESNOTMATCHDIMENSIONS = 0x88982f49;

enum : int
{
    WINCODEC_ERR_IMAGESIZEOUTOFRANGE    = 0x88982f51,
    WINCODEC_ERR_TOOMUCHMETADATA        = 0x88982f52,
    WINCODEC_ERR_BADIMAGE               = 0x88982f60,
    WINCODEC_ERR_BADHEADER              = 0x88982f61,
    WINCODEC_ERR_FRAMEMISSING           = 0x88982f62,
    WINCODEC_ERR_BADMETADATAHEADER      = 0x88982f63,
    WINCODEC_ERR_BADSTREAMDATA          = 0x88982f70,
    WINCODEC_ERR_STREAMWRITE            = 0x88982f71,
    WINCODEC_ERR_STREAMREAD             = 0x88982f72,
    WINCODEC_ERR_STREAMNOTAVAILABLE     = 0x88982f73,
    WINCODEC_ERR_UNSUPPORTEDPIXELFORMAT = 0x88982f80,
    WINCODEC_ERR_UNSUPPORTEDOPERATION   = 0x88982f81,
}

enum int WINCODEC_ERR_COMPONENTINITIALIZEFAILURE = 0x88982f8b;
enum int WINCODEC_ERR_DUPLICATEMETADATAPRESENT = 0x88982f8d;

enum : int
{
    WINCODEC_ERR_UNEXPECTEDSIZE         = 0x88982f8f,
    WINCODEC_ERR_INVALIDQUERYREQUEST    = 0x88982f90,
    WINCODEC_ERR_UNEXPECTEDMETADATATYPE = 0x88982f91,
}

enum int WINCODEC_ERR_INVALIDQUERYCHARACTER = 0x88982f93;

enum : int
{
    WINCODEC_ERR_INVALIDPROGRESSIVELEVEL = 0x88982f95,
    WINCODEC_ERR_INVALIDJPEGSCANINDEX    = 0x88982f96,
}

enum int MILERR_INSUFFICIENTBUFFER = 0x88980002;

enum : int
{
    MILERR_SCANNER_FAILED     = 0x88980004,
    MILERR_SCREENACCESSDENIED = 0x88980005,
}

enum int MILERR_NONINVERTIBLEMATRIX = 0x88980007;

enum : int
{
    MILERR_TERMINATED    = 0x88980009,
    MILERR_BADNUMBER     = 0x8898000a,
    MILERR_INTERNALERROR = 0x88980080,
}

enum int MILERR_INVALIDCALL = 0x88980085;

enum : int
{
    MILERR_NOTLOCKED              = 0x88980087,
    MILERR_DEVICECANNOTRENDERTEXT = 0x88980088,
}

enum int MILERR_MALFORMEDGLYPHCACHE = 0x8898008a;
enum int MILERR_MALFORMED_GUIDELINE_DATA = 0x8898008c;
enum int MILERR_NEED_RECREATE_AND_PRESENT = 0x8898008e;
enum int MILERR_MISMATCHED_SIZE = 0x88980090;
enum int MILERR_REMOTING_NOT_SUPPORTED = 0x88980092;
enum int MILERR_NOT_QUEUING_PRESENTS = 0x88980094;
enum int MILERR_TOOMANYSHADERELEMNTS = 0x88980096;
enum int MILERR_MROW_UPDATE_FAILED = 0x88980098;
enum int MILERR_MAX_TEXTURE_SIZE_EXCEEDED = 0x8898009a;
enum int MILERR_DXGI_ENUMERATION_OUT_OF_SYNC = 0x8898009d;
enum int MILERR_COLORSPACE_NOT_SUPPORTED = 0x8898009f;
enum int MILERR_DISPLAYID_ACCESS_DENIED = 0x889800a1;
enum int UCEERR_UNKNOWNPACKET = 0x88980401;
enum int UCEERR_MALFORMEDPACKET = 0x88980403;
enum int UCEERR_HANDLELOOKUPFAILED = 0x88980405;
enum int UCEERR_CTXSTACKFRSTTARGETNULL = 0x88980407;

enum : int
{
    UCEERR_BLOCKSFULL    = 0x88980409,
    UCEERR_MEMORYFAILURE = 0x8898040a,
}

enum int UCEERR_ILLEGALRECORDTYPE = 0x8898040c;
enum int UCEERR_UNCHANGABLE_UPDATE_ATTEMPTED = 0x8898040e;
enum int UCEERR_REMOTINGNOTSUPPORTED = 0x88980410;
enum int UCEERR_MISSINGBEGINCOMMAND = 0x88980412;
enum int UCEERR_CHANNELSYNCABANDONED = 0x88980414;
enum int UCEERR_TRANSPORTUNAVAILABLE = 0x88980416;
enum int UCEERR_COMMANDTRANSPORTDENIED = 0x88980418;
enum int UCEERR_GRAPHICSSTREAMALREADYOPEN = 0x88980420;
enum int UCEERR_TRANSPORTOVERLOADED = 0x88980422;

enum : int
{
    MILAVERR_NOCLOCK          = 0x88980500,
    MILAVERR_NOMEDIATYPE      = 0x88980501,
    MILAVERR_NOVIDEOMIXER     = 0x88980502,
    MILAVERR_NOVIDEOPRESENTER = 0x88980503,
    MILAVERR_NOREADYFRAMES    = 0x88980504,
    MILAVERR_MODULENOTLOADED  = 0x88980505,
}

enum : int
{
    MILAVERR_INVALIDWMPVERSION          = 0x88980507,
    MILAVERR_INSUFFICIENTVIDEORESOURCES = 0x88980508,
}

enum int MILAVERR_REQUESTEDTEXTURETOOBIG = 0x8898050a;
enum int MILAVERR_UNEXPECTEDWMPFAILURE = 0x8898050c;
enum int MILAVERR_UNKNOWNHARDWAREERROR = 0x8898050e;

enum : int
{
    MILEFFECTSERR_EFFECTNOTPARTOFGROUP  = 0x8898060f,
    MILEFFECTSERR_NOINPUTSOURCEATTACHED = 0x88980610,
}

enum int MILEFFECTSERR_CONNECTORNOTASSOCIATEDWITHEFFECT = 0x88980612;

enum : int
{
    MILEFFECTSERR_CYCLEDETECTED             = 0x88980614,
    MILEFFECTSERR_EFFECTINMORETHANONEGRAPH  = 0x88980615,
    MILEFFECTSERR_EFFECTALREADYINAGRAPH     = 0x88980616,
    MILEFFECTSERR_EFFECTHASNOCHILDREN       = 0x88980617,
    MILEFFECTSERR_ALREADYATTACHEDTOLISTENER = 0x88980618,
}

enum : int
{
    MILEFFECTSERR_EMPTYBOUNDS        = 0x8898061a,
    MILEFFECTSERR_OUTPUTSIZETOOLARGE = 0x8898061b,
}

enum int DWMERR_THEME_FAILED = 0x88980701;

enum : int
{
    DCOMPOSITION_ERROR_WINDOW_ALREADY_COMPOSED    = 0x88980800,
    DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED     = 0x88980801,
    DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED = 0x88980802,
}

enum int ONL_E_ACCESS_DENIED_BY_TOU = 0x80860002;
enum int ONL_E_PASSWORD_UPDATE_REQUIRED = 0x80860004;
enum int ONL_E_FORCESIGNIN = 0x80860006;
enum int ONL_E_PARENTAL_CONSENT_REQUIRED = 0x80860008;

enum : int
{
    ONL_E_ACCOUNT_SUSPENDED_COMPROIMISE = 0x8086000a,
    ONL_E_ACCOUNT_SUSPENDED_ABUSE       = 0x8086000b,
}

enum int ONL_CONNECTION_COUNT_LIMIT = 0x8086000d;
enum int ONL_E_USER_AUTHENTICATION_REQUIRED = 0x8086000f;
enum int FA_E_MAX_PERSISTED_ITEMS_REACHED = 0x80270220;
enum int E_MONITOR_RESOLUTION_TOO_LOW = 0x80270250;
enum int E_UAC_DISABLED = 0x80270252;
enum int E_APPLICATION_NOT_REGISTERED = 0x80270254;
enum int E_MULTIPLE_PACKAGES_FOR_FAMILY = 0x80270256;
enum int S_STORE_LAUNCHED_FOR_REMEDIATION = 0x00270258;

enum : int
{
    E_APPLICATION_ACTIVATION_TIMED_OUT    = 0x8027025a,
    E_APPLICATION_ACTIVATION_EXEC_FAILURE = 0x8027025b,
}

enum int E_APPLICATION_TRIAL_LICENSE_EXPIRED = 0x8027025d;

enum : int
{
    E_SKYDRIVE_ROOT_TARGET_OVERLAP      = 0x80270261,
    E_SKYDRIVE_ROOT_TARGET_CANNOT_INDEX = 0x80270262,
}

enum int E_SKYDRIVE_UPDATE_AVAILABILITY_FAIL = 0x80270264;

enum : int
{
    E_SYNCENGINE_FILE_SIZE_OVER_LIMIT              = 0x8802b001,
    E_SYNCENGINE_FILE_SIZE_EXCEEDS_REMAINING_QUOTA = 0x8802b002,
}

enum int E_SYNCENGINE_FOLDER_ITEM_COUNT_LIMIT_EXCEEDED = 0x8802b004;
enum int E_SYNCENGINE_SYNC_PAUSED_BY_SERVICE = 0x8802b006;
enum int E_SYNCENGINE_SERVICE_AUTHENTICATION_FAILED = 0x8802c003;
enum int E_SYNCENGINE_SERVICE_RETURNED_UNEXPECTED_SIZE = 0x8802c005;
enum int E_SYNCENGINE_REQUEST_BLOCKED_DUE_TO_CLIENT_ERROR = 0x8802c007;

enum : int
{
    E_SYNCENGINE_UNSUPPORTED_FOLDER_NAME    = 0x8802d002,
    E_SYNCENGINE_UNSUPPORTED_MARKET         = 0x8802d003,
    E_SYNCENGINE_PATH_LENGTH_LIMIT_EXCEEDED = 0x8802d004,
}

enum int E_SYNCENGINE_CLIENT_UPDATE_NEEDED = 0x8802d006;
enum int E_SYNCENGINE_STORAGE_SERVICE_PROVISIONING_FAILED = 0x8802d008;
enum int E_SYNCENGINE_STORAGE_SERVICE_BLOCKED = 0x8802d00a;

enum : int
{
    EAS_E_POLICY_NOT_MANAGED_BY_OS      = 0x80550001,
    EAS_E_POLICY_COMPLIANT_WITH_ACTIONS = 0x80550002,
}

enum int EAS_E_CURRENT_USER_HAS_BLANK_PASSWORD = 0x80550004;
enum int EAS_E_USER_CANNOT_CHANGE_PASSWORD = 0x80550006;
enum int EAS_E_ADMINS_CANNOT_CHANGE_PASSWORD = 0x80550008;
enum int EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CONNECTED_ADMINS = 0x8055000a;
enum int EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CURRENT_CONNECTED_USER = 0x8055000c;
enum int WEB_E_UNSUPPORTED_FORMAT = 0x83750001;

enum : int
{
    WEB_E_MISSING_REQUIRED_ELEMENT   = 0x83750003,
    WEB_E_MISSING_REQUIRED_ATTRIBUTE = 0x83750004,
}

enum int WEB_E_RESOURCE_TOO_LARGE = 0x83750006;
enum int WEB_E_INVALID_JSON_NUMBER = 0x83750008;

enum : int
{
    HTTP_E_STATUS_UNEXPECTED              = 0x80190001,
    HTTP_E_STATUS_UNEXPECTED_REDIRECTION  = 0x80190003,
    HTTP_E_STATUS_UNEXPECTED_CLIENT_ERROR = 0x80190004,
    HTTP_E_STATUS_UNEXPECTED_SERVER_ERROR = 0x80190005,
}

enum : int
{
    HTTP_E_STATUS_MOVED                 = 0x8019012d,
    HTTP_E_STATUS_REDIRECT              = 0x8019012e,
    HTTP_E_STATUS_REDIRECT_METHOD       = 0x8019012f,
    HTTP_E_STATUS_NOT_MODIFIED          = 0x80190130,
    HTTP_E_STATUS_USE_PROXY             = 0x80190131,
    HTTP_E_STATUS_REDIRECT_KEEP_VERB    = 0x80190133,
    HTTP_E_STATUS_BAD_REQUEST           = 0x80190190,
    HTTP_E_STATUS_DENIED                = 0x80190191,
    HTTP_E_STATUS_PAYMENT_REQ           = 0x80190192,
    HTTP_E_STATUS_FORBIDDEN             = 0x80190193,
    HTTP_E_STATUS_NOT_FOUND             = 0x80190194,
    HTTP_E_STATUS_BAD_METHOD            = 0x80190195,
    HTTP_E_STATUS_NONE_ACCEPTABLE       = 0x80190196,
    HTTP_E_STATUS_PROXY_AUTH_REQ        = 0x80190197,
    HTTP_E_STATUS_REQUEST_TIMEOUT       = 0x80190198,
    HTTP_E_STATUS_CONFLICT              = 0x80190199,
    HTTP_E_STATUS_GONE                  = 0x8019019a,
    HTTP_E_STATUS_LENGTH_REQUIRED       = 0x8019019b,
    HTTP_E_STATUS_PRECOND_FAILED        = 0x8019019c,
    HTTP_E_STATUS_REQUEST_TOO_LARGE     = 0x8019019d,
    HTTP_E_STATUS_URI_TOO_LONG          = 0x8019019e,
    HTTP_E_STATUS_UNSUPPORTED_MEDIA     = 0x8019019f,
    HTTP_E_STATUS_RANGE_NOT_SATISFIABLE = 0x801901a0,
}

enum : int
{
    HTTP_E_STATUS_SERVER_ERROR    = 0x801901f4,
    HTTP_E_STATUS_NOT_SUPPORTED   = 0x801901f5,
    HTTP_E_STATUS_BAD_GATEWAY     = 0x801901f6,
    HTTP_E_STATUS_SERVICE_UNAVAIL = 0x801901f7,
    HTTP_E_STATUS_GATEWAY_TIMEOUT = 0x801901f8,
    HTTP_E_STATUS_VERSION_NOT_SUP = 0x801901f9,
}

enum int E_INVALID_PROTOCOL_FORMAT = 0x83760002;
enum int E_SUBPROTOCOL_NOT_SUPPORTED = 0x83760004;
enum int INPUT_E_OUT_OF_ORDER = 0x80400000;

enum : int
{
    INPUT_E_MULTIMODAL      = 0x80400002,
    INPUT_E_PACKET          = 0x80400003,
    INPUT_E_FRAME           = 0x80400004,
    INPUT_E_HISTORY         = 0x80400005,
    INPUT_E_DEVICE_INFO     = 0x80400006,
    INPUT_E_TRANSFORM       = 0x80400007,
    INPUT_E_DEVICE_PROPERTY = 0x80400008,
}

enum : int
{
    INET_E_NO_SESSION     = 0x800c0003,
    INET_E_CANNOT_CONNECT = 0x800c0004,
}

enum int INET_E_OBJECT_NOT_FOUND = 0x800c0006;
enum int INET_E_DOWNLOAD_FAILURE = 0x800c0008;
enum int INET_E_NO_VALID_MEDIA = 0x800c000a;
enum int INET_E_INVALID_REQUEST = 0x800c000c;
enum int INET_E_SECURITY_PROBLEM = 0x800c000e;
enum int INET_E_CANNOT_INSTANTIATE_OBJECT = 0x800c0010;

enum : int
{
    INET_E_REDIRECT_FAILED = 0x800c0014,
    INET_E_REDIRECT_TO_DIR = 0x800c0015,
}

enum int ERROR_DBG_ATTACH_PROCESS_FAILURE_LOCKDOWN = 0x80b00002;
enum int ERROR_DBG_START_SERVER_FAILURE_LOCKDOWN = 0x80b00004;
enum int JSCRIPT_E_CANTEXECUTE = 0x89020001;
enum int WEP_E_FIXED_DATA_NOT_SUPPORTED = 0x88010002;
enum int WEP_E_LOCK_NOT_CONFIGURED = 0x88010004;
enum int WEP_E_NO_LICENSE = 0x88010006;
enum int WEP_E_UNEXPECTED_FAIL = 0x88010008;

enum : int
{
    ERROR_SVHDX_ERROR_STORED        = 0xc05c0000,
    ERROR_SVHDX_ERROR_NOT_AVAILABLE = 0xc05cff00,
}

enum : int
{
    ERROR_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED        = 0xc05cff02,
    ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED       = 0xc05cff03,
    ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED        = 0xc05cff04,
    ERROR_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED      = 0xc05cff05,
    ERROR_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED = 0xc05cff06,
}

enum : int
{
    ERROR_SVHDX_WRONG_FILE_TYPE  = 0xc05cff08,
    ERROR_SVHDX_VERSION_MISMATCH = 0xc05cff09,
}

enum int ERROR_SVHDX_NO_INITIATOR = 0xc05cff0b;
enum int ERROR_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP = 0xc05d0000;

enum : int
{
    WININET_E_OUT_OF_HANDLES      = 0x80072ee1,
    WININET_E_TIMEOUT             = 0x80072ee2,
    WININET_E_EXTENDED_ERROR      = 0x80072ee3,
    WININET_E_INTERNAL_ERROR      = 0x80072ee4,
    WININET_E_INVALID_URL         = 0x80072ee5,
    WININET_E_UNRECOGNIZED_SCHEME = 0x80072ee6,
}

enum int WININET_E_PROTOCOL_NOT_FOUND = 0x80072ee8;
enum int WININET_E_BAD_OPTION_LENGTH = 0x80072eea;

enum : int
{
    WININET_E_SHUTDOWN            = 0x80072eec,
    WININET_E_INCORRECT_USER_NAME = 0x80072eed,
    WININET_E_INCORRECT_PASSWORD  = 0x80072eee,
}

enum int WININET_E_INVALID_OPERATION = 0x80072ef0;

enum : int
{
    WININET_E_INCORRECT_HANDLE_TYPE  = 0x80072ef2,
    WININET_E_INCORRECT_HANDLE_STATE = 0x80072ef3,
}

enum int WININET_E_REGISTRY_VALUE_NOT_FOUND = 0x80072ef5;

enum : int
{
    WININET_E_NO_DIRECT_ACCESS = 0x80072ef7,
    WININET_E_NO_CONTEXT       = 0x80072ef8,
    WININET_E_NO_CALLBACK      = 0x80072ef9,
    WININET_E_REQUEST_PENDING  = 0x80072efa,
}

enum : int
{
    WININET_E_ITEM_NOT_FOUND     = 0x80072efc,
    WININET_E_CANNOT_CONNECT     = 0x80072efd,
    WININET_E_CONNECTION_ABORTED = 0x80072efe,
    WININET_E_CONNECTION_RESET   = 0x80072eff,
}

enum int WININET_E_INVALID_PROXY_REQUEST = 0x80072f01;

enum : int
{
    WININET_E_HANDLE_EXISTS         = 0x80072f04,
    WININET_E_SEC_CERT_DATE_INVALID = 0x80072f05,
    WININET_E_SEC_CERT_CN_INVALID   = 0x80072f06,
}

enum int WININET_E_HTTPS_TO_HTTP_ON_REDIR = 0x80072f08;
enum int WININET_E_CHG_POST_IS_NON_SECURE = 0x80072f0a;
enum int WININET_E_CLIENT_AUTH_CERT_NEEDED = 0x80072f0c;
enum int WININET_E_CLIENT_AUTH_NOT_SETUP = 0x80072f0e;
enum int WININET_E_REDIRECT_SCHEME_CHANGE = 0x80072f10;

enum : int
{
    WININET_E_RETRY_DIALOG      = 0x80072f12,
    WININET_E_NO_NEW_CONTAINERS = 0x80072f13,
}

enum : int
{
    WININET_E_SEC_CERT_ERRORS     = 0x80072f17,
    WININET_E_SEC_CERT_REV_FAILED = 0x80072f19,
}

enum int WININET_E_DOWNLEVEL_SERVER = 0x80072f77;

enum : int
{
    WININET_E_INVALID_HEADER        = 0x80072f79,
    WININET_E_INVALID_QUERY_REQUEST = 0x80072f7a,
}

enum int WININET_E_REDIRECT_FAILED = 0x80072f7c;
enum int WININET_E_UNABLE_TO_CACHE_FILE = 0x80072f7e;

enum : int
{
    WININET_E_DISCONNECTED       = 0x80072f83,
    WININET_E_SERVER_UNREACHABLE = 0x80072f84,
}

enum int WININET_E_BAD_AUTO_PROXY_SCRIPT = 0x80072f86;

enum : int
{
    WININET_E_SEC_INVALID_CERT = 0x80072f89,
    WININET_E_SEC_CERT_REVOKED = 0x80072f8a,
}

enum int WININET_E_NOT_INITIALIZED = 0x80072f8c;
enum int WININET_E_DECODING_FAILED = 0x80072f8f;

enum : int
{
    WININET_E_COOKIE_NEEDS_CONFIRMATION = 0x80072f81,
    WININET_E_COOKIE_DECLINED           = 0x80072f82,
}

enum : int
{
    SQLITE_E_ERROR                   = 0x87af0001,
    SQLITE_E_INTERNAL                = 0x87af0002,
    SQLITE_E_PERM                    = 0x87af0003,
    SQLITE_E_ABORT                   = 0x87af0004,
    SQLITE_E_BUSY                    = 0x87af0005,
    SQLITE_E_LOCKED                  = 0x87af0006,
    SQLITE_E_NOMEM                   = 0x87af0007,
    SQLITE_E_READONLY                = 0x87af0008,
    SQLITE_E_INTERRUPT               = 0x87af0009,
    SQLITE_E_IOERR                   = 0x87af000a,
    SQLITE_E_CORRUPT                 = 0x87af000b,
    SQLITE_E_NOTFOUND                = 0x87af000c,
    SQLITE_E_FULL                    = 0x87af000d,
    SQLITE_E_CANTOPEN                = 0x87af000e,
    SQLITE_E_PROTOCOL                = 0x87af000f,
    SQLITE_E_EMPTY                   = 0x87af0010,
    SQLITE_E_SCHEMA                  = 0x87af0011,
    SQLITE_E_TOOBIG                  = 0x87af0012,
    SQLITE_E_CONSTRAINT              = 0x87af0013,
    SQLITE_E_MISMATCH                = 0x87af0014,
    SQLITE_E_MISUSE                  = 0x87af0015,
    SQLITE_E_NOLFS                   = 0x87af0016,
    SQLITE_E_AUTH                    = 0x87af0017,
    SQLITE_E_FORMAT                  = 0x87af0018,
    SQLITE_E_RANGE                   = 0x87af0019,
    SQLITE_E_NOTADB                  = 0x87af001a,
    SQLITE_E_NOTICE                  = 0x87af001b,
    SQLITE_E_WARNING                 = 0x87af001c,
    SQLITE_E_ROW                     = 0x87af0064,
    SQLITE_E_DONE                    = 0x87af0065,
    SQLITE_E_IOERR_READ              = 0x87af010a,
    SQLITE_E_IOERR_SHORT_READ        = 0x87af020a,
    SQLITE_E_IOERR_WRITE             = 0x87af030a,
    SQLITE_E_IOERR_FSYNC             = 0x87af040a,
    SQLITE_E_IOERR_DIR_FSYNC         = 0x87af050a,
    SQLITE_E_IOERR_TRUNCATE          = 0x87af060a,
    SQLITE_E_IOERR_FSTAT             = 0x87af070a,
    SQLITE_E_IOERR_UNLOCK            = 0x87af080a,
    SQLITE_E_IOERR_RDLOCK            = 0x87af090a,
    SQLITE_E_IOERR_DELETE            = 0x87af0a0a,
    SQLITE_E_IOERR_BLOCKED           = 0x87af0b0a,
    SQLITE_E_IOERR_NOMEM             = 0x87af0c0a,
    SQLITE_E_IOERR_ACCESS            = 0x87af0d0a,
    SQLITE_E_IOERR_CHECKRESERVEDLOCK = 0x87af0e0a,
    SQLITE_E_IOERR_LOCK              = 0x87af0f0a,
    SQLITE_E_IOERR_CLOSE             = 0x87af100a,
    SQLITE_E_IOERR_DIR_CLOSE         = 0x87af110a,
    SQLITE_E_IOERR_SHMOPEN           = 0x87af120a,
    SQLITE_E_IOERR_SHMSIZE           = 0x87af130a,
    SQLITE_E_IOERR_SHMLOCK           = 0x87af140a,
    SQLITE_E_IOERR_SHMMAP            = 0x87af150a,
    SQLITE_E_IOERR_SEEK              = 0x87af160a,
    SQLITE_E_IOERR_DELETE_NOENT      = 0x87af170a,
    SQLITE_E_IOERR_MMAP              = 0x87af180a,
    SQLITE_E_IOERR_GETTEMPPATH       = 0x87af190a,
    SQLITE_E_IOERR_CONVPATH          = 0x87af1a0a,
    SQLITE_E_IOERR_VNODE             = 0x87af1a02,
    SQLITE_E_IOERR_AUTH              = 0x87af1a03,
    SQLITE_E_LOCKED_SHAREDCACHE      = 0x87af0106,
}

enum : int
{
    SQLITE_E_BUSY_SNAPSHOT      = 0x87af0205,
    SQLITE_E_CANTOPEN_NOTEMPDIR = 0x87af010e,
    SQLITE_E_CANTOPEN_ISDIR     = 0x87af020e,
    SQLITE_E_CANTOPEN_FULLPATH  = 0x87af030e,
    SQLITE_E_CANTOPEN_CONVPATH  = 0x87af040e,
}

enum : int
{
    SQLITE_E_READONLY_RECOVERY = 0x87af0108,
    SQLITE_E_READONLY_CANTLOCK = 0x87af0208,
    SQLITE_E_READONLY_ROLLBACK = 0x87af0308,
    SQLITE_E_READONLY_DBMOVED  = 0x87af0408,
}

enum : int
{
    SQLITE_E_CONSTRAINT_CHECK      = 0x87af0113,
    SQLITE_E_CONSTRAINT_COMMITHOOK = 0x87af0213,
    SQLITE_E_CONSTRAINT_FOREIGNKEY = 0x87af0313,
    SQLITE_E_CONSTRAINT_FUNCTION   = 0x87af0413,
    SQLITE_E_CONSTRAINT_NOTNULL    = 0x87af0513,
    SQLITE_E_CONSTRAINT_PRIMARYKEY = 0x87af0613,
    SQLITE_E_CONSTRAINT_TRIGGER    = 0x87af0713,
    SQLITE_E_CONSTRAINT_UNIQUE     = 0x87af0813,
    SQLITE_E_CONSTRAINT_VTAB       = 0x87af0913,
    SQLITE_E_CONSTRAINT_ROWID      = 0x87af0a13,
}

enum int SQLITE_E_NOTICE_RECOVER_ROLLBACK = 0x87af021b;
enum int UTC_E_TOGGLE_TRACE_STARTED = 0x87c51001;
enum int UTC_E_AOT_NOT_RUNNING = 0x87c51003;
enum int UTC_E_SCENARIODEF_NOT_FOUND = 0x87c51005;

enum : int
{
    UTC_E_FORWARDER_ALREADY_ENABLED  = 0x87c51007,
    UTC_E_FORWARDER_ALREADY_DISABLED = 0x87c51008,
}

enum int UTC_E_DIAGRULES_SCHEMAVERSION_MISMATCH = 0x87c5100a;
enum int UTC_E_INVALID_CUSTOM_FILTER = 0x87c5100c;
enum int UTC_E_REESCALATED_TOO_QUICKLY = 0x87c5100e;
enum int UTC_E_PERFTRACK_ALREADY_TRACING = 0x87c51010;
enum int UTC_E_FORWARDER_PRODUCER_MISMATCH = 0x87c51012;
enum int UTC_E_SQM_INIT_FAILED = 0x87c51014;
enum int UTC_E_TRACERS_DONT_EXIST = 0x87c51016;
enum int UTC_E_SCENARIODEF_SCHEMAVERSION_MISMATCH = 0x87c51018;
enum int UTC_E_EXE_TERMINATED = 0x87c5101a;
enum int UTC_E_SETUP_NOT_AUTHORIZED = 0x87c5101c;
enum int UTC_E_COMMAND_LINE_NOT_AUTHORIZED = 0x87c5101e;
enum int UTC_E_ESCALATION_TIMED_OUT = 0x87c51020;

enum : int
{
    UTC_E_TRIGGER_MISMATCH  = 0x87c51022,
    UTC_E_TRIGGER_NOT_FOUND = 0x87c51023,
}

enum int UTC_E_DELAY_TERMINATED = 0x87c51025;
enum int UTC_E_TRACE_BUFFER_LIMIT_EXCEEDED = 0x87c51027;

enum : int
{
    UTC_E_RPC_TIMEOUT     = 0x87c51029,
    UTC_E_RPC_WAIT_FAILED = 0x87c5102a,
}

enum int UTC_E_TRACE_MIN_DURATION_REQUIREMENT_NOT_MET = 0x87c5102c;
enum int UTC_E_GETFILE_FILE_PATH_NOT_APPROVED = 0x87c5102e;

enum : int
{
    UTC_E_TIME_TRIGGER_ON_START_INVALID                = 0x87c51030,
    UTC_E_TIME_TRIGGER_ONLY_VALID_ON_SINGLE_TRANSITION = 0x87c51031,
}

enum int UTC_E_MULTIPLE_TIME_TRIGGER_ON_SINGLE_STATE = 0x87c51033;
enum int UTC_E_FAILED_TO_RESOLVE_CONTAINER_ID = 0x87c51036;
enum int UTC_E_THROTTLED = 0x87c51038;
enum int UTC_E_SCRIPT_MISSING = 0x87c5103a;
enum int UTC_E_API_NOT_SUPPORTED = 0x87c5103c;
enum int UTC_E_TRY_GET_SCENARIO_TIMEOUT_EXCEEDED = 0x87c5103e;
enum int UTC_E_FAILED_TO_START_NDISCAP = 0x87c51040;
enum int UTC_E_MISSING_AGGREGATE_EVENT_TAG = 0x87c51042;
enum int UTC_E_ACTION_NOT_SUPPORTED_IN_DESTINATION = 0x87c51044;

enum : int
{
    UTC_E_FILTER_INVALID_TYPE            = 0x87c51046,
    UTC_E_FILTER_VARIABLE_NOT_FOUND      = 0x87c51047,
    UTC_E_FILTER_FUNCTION_RESTRICTED     = 0x87c51048,
    UTC_E_FILTER_VERSION_MISMATCH        = 0x87c51049,
    UTC_E_FILTER_INVALID_FUNCTION        = 0x87c51050,
    UTC_E_FILTER_INVALID_FUNCTION_PARAMS = 0x87c51051,
    UTC_E_FILTER_INVALID_COMMAND         = 0x87c51052,
    UTC_E_FILTER_ILLEGAL_EVAL            = 0x87c51053,
}

enum int UTC_E_AGENT_DIAGNOSTICS_TOO_LARGE = 0x87c51055;
enum int UTC_E_SCENARIO_HAS_NO_ACTIONS = 0x87c51057;
enum int UTC_E_INSUFFICIENT_SPACE_TO_START_TRACE = 0x87c51059;
enum int UTC_E_GETFILEINFOACTION_FILE_NOT_APPROVED = 0x87c5105b;

enum : int
{
    WINML_ERR_INVALID_DEVICE  = 0x88900001,
    WINML_ERR_INVALID_BINDING = 0x88900002,
}

enum int WINML_ERR_SIZE_MISMATCH = 0x88900004;
enum int ERROR_QUIC_VER_NEG_FAILURE = 0x80410001;

enum : int
{
    DNS_ERROR_RCODE_NO_ERROR = 0x00000000,
    DNS_ERROR_RCODE_LAST     = 0x0000233a,
}

enum : int
{
    DNS_ERROR_NO_MEMORY    = 0x0000000e,
    DNS_ERROR_INVALID_NAME = 0x0000007b,
    DNS_ERROR_INVALID_DATA = 0x0000000d,
}

enum int SEC_E_NOT_SUPPORTED = 0x80090302;

enum : int
{
    PWM_IOCTL_ID_CONTROLLER_GET_INFO           = 0x00000000,
    PWM_IOCTL_ID_CONTROLLER_GET_ACTUAL_PERIOD  = 0x00000001,
    PWM_IOCTL_ID_CONTROLLER_SET_DESIRED_PERIOD = 0x00000002,
}

enum int PWM_IOCTL_ID_PIN_SET_ACTIVE_DUTY_CYCLE_PERCENTAGE = 0x00000065;

enum : int
{
    PWM_IOCTL_ID_PIN_SET_POLARITY = 0x00000067,
    PWM_IOCTL_ID_PIN_START        = 0x00000068,
    PWM_IOCTL_ID_PIN_STOP         = 0x00000069,
    PWM_IOCTL_ID_PIN_IS_STARTED   = 0x0000006a,
}

// Callbacks

alias PTHREAD_START_ROUTINE = uint function(void* lpThreadParameter);
alias LPTHREAD_START_ROUTINE = uint function();
alias PENCLAVE_ROUTINE = void* function(void* lpThreadParameter);
alias LPENCLAVE_ROUTINE = void* function();
alias BAD_MEMORY_CALLBACK_ROUTINE = void function();
alias PBAD_MEMORY_CALLBACK_ROUTINE = void function();
alias ENUMRESLANGPROCA = BOOL function(ptrdiff_t hModule, const(PSTR) lpType, const(PSTR) lpName, ushort wLanguage, 
                                       ptrdiff_t lParam);
alias ENUMRESLANGPROCW = BOOL function(ptrdiff_t hModule, const(PWSTR) lpType, const(PWSTR) lpName, 
                                       ushort wLanguage, ptrdiff_t lParam);
alias PGET_MODULE_HANDLE_EXA = BOOL function(uint dwFlags, const(PSTR) lpModuleName, ptrdiff_t* phModule);
alias PGET_MODULE_HANDLE_EXW = BOOL function(uint dwFlags, const(PWSTR) lpModuleName, ptrdiff_t* phModule);
alias PHANDLER_ROUTINE = BOOL function(uint CtrlType);
alias TIMECALLBACK = void function(uint uTimerID, uint uMsg, size_t dwUser, size_t dw1, size_t dw2);
alias LPTIMECALLBACK = void function();
alias PM_OPEN_PROC = uint function(PWSTR param0);
alias PM_QUERY_PROC = uint function(uint* param0, void** param1, uint* param2, uint* param3);
alias PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = void function(IO_IRP_EXT_TRACK_OFFSET_HEADER* SourceContext, 
                                                                  IO_IRP_EXT_TRACK_OFFSET_HEADER* TargetContext, 
                                                                  long RelativeOffset);
alias LPDDENUMVIDEOCALLBACK = HRESULT function(DDVIDEOPORTCAPS* param0, void* param1);
alias PDD_SETCOLORKEY = uint function(DD_DRVSETCOLORKEYDATA* param0);
alias PDD_DESTROYDRIVER = uint function(_DD_DESTROYDRIVERDATA* param0);
alias PDD_SETMODE = uint function(_DD_SETMODEDATA* param0);
alias PDD_ALPHABLT = uint function(DD_BLTDATA* param0);
alias PDD_SURFCB_SETCLIPLIST = uint function(DD_SETCLIPLISTDATA* param0);
alias PDD_VPORTCB_GETAUTOFLIPSURF = uint function(_DD_GETVPORTAUTOFLIPSURFACEDATA* param0);
alias LPD3DVALIDATECALLBACK = HRESULT function(void* lpUserArg, uint dwOffset);
alias LPD3DENUMTEXTUREFORMATSCALLBACK = HRESULT function(DDSURFACEDESC* lpDdsd, void* lpContext);
alias LPD3DENUMPIXELFORMATSCALLBACK = HRESULT function(DDPIXELFORMAT* lpDDPixFmt, void* lpContext);
alias LPD3DENUMDEVICESCALLBACK = HRESULT function(GUID* lpGuid, PSTR lpDeviceDescription, PSTR lpDeviceName, 
                                                  _D3DDeviceDesc* param3, _D3DDeviceDesc* param4, void* param5);
alias LPD3DENUMDEVICESCALLBACK7 = HRESULT function(PSTR lpDeviceDescription, PSTR lpDeviceName, 
                                                   _D3DDeviceDesc7* param2, void* param3);
alias LPD3DNTHAL_CONTEXTCREATECB = uint function(D3DNTHAL_CONTEXTCREATEDATA* param0);
alias LPD3DNTHAL_CONTEXTDESTROYCB = uint function(D3DNTHAL_CONTEXTDESTROYDATA* param0);
alias LPD3DNTHAL_CONTEXTDESTROYALLCB = uint function(D3DNTHAL_CONTEXTDESTROYALLDATA* param0);
alias LPD3DNTHAL_SCENECAPTURECB = uint function(D3DNTHAL_SCENECAPTUREDATA* param0);
alias LPD3DNTHAL_TEXTURECREATECB = uint function(D3DNTHAL_TEXTURECREATEDATA* param0);
alias LPD3DNTHAL_TEXTUREDESTROYCB = uint function(D3DNTHAL_TEXTUREDESTROYDATA* param0);
alias LPD3DNTHAL_TEXTURESWAPCB = uint function(D3DNTHAL_TEXTURESWAPDATA* param0);
alias LPD3DNTHAL_TEXTUREGETSURFCB = uint function(D3DNTHAL_TEXTUREGETSURFDATA* param0);
alias LPD3DNTHAL_SETRENDERTARGETCB = uint function(D3DNTHAL_SETRENDERTARGETDATA* param0);
alias LPD3DNTHAL_CLEAR2CB = uint function(D3DNTHAL_CLEAR2DATA* param0);
alias LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB = uint function(D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA* param0);
alias LPD3DNTHAL_DRAWPRIMITIVES2CB = uint function(D3DNTHAL_DRAWPRIMITIVES2DATA* param0);
alias PFND3DNTPARSEUNKNOWNCOMMAND = HRESULT function(void* lpvCommands, void** lplpvReturnedCommand);
alias PFN = ptrdiff_t function();
alias FREEOBJPROC = BOOL function(DRIVEROBJ* pDriverObj);
alias WNDOBJCHANGEPROC = void function(WNDOBJ* pwo, uint fl);
alias SORTCOMP = int function(const(void)* pv1, const(void)* pv2);
alias PFN_DrvEnableDriver = BOOL function(uint param0, uint param1, DRVENABLEDATA* param2);
alias PFN_DrvEnablePDEV = DHPDEV__* function(DEVMODEW* param0, PWSTR param1, uint param2, HSURF* param3, 
                                             uint param4, GDIINFO* param5, uint param6, DEVINFO* param7, 
                                             ptrdiff_t param8, PWSTR param9, HANDLE param10);
alias PFN_DrvCompletePDEV = void function(DHPDEV__* param0, ptrdiff_t param1);
alias PFN_DrvResetDevice = uint function(DHPDEV__* param0, void* param1);
alias PFN_DrvDisablePDEV = void function(DHPDEV__* param0);
alias PFN_DrvSynchronize = void function(DHPDEV__* param0, RECTL* param1);
alias PFN_DrvEnableSurface = HSURF function(DHPDEV__* param0);
alias PFN_DrvDisableDriver = void function();
alias PFN_DrvDisableSurface = void function(DHPDEV__* param0);
alias PFN_DrvAssertMode = BOOL function(DHPDEV__* param0, BOOL param1);
alias PFN_DrvTextOut = BOOL function(SURFOBJ* param0, STROBJ* param1, FONTOBJ* param2, CLIPOBJ* param3, 
                                     RECTL* param4, RECTL* param5, BRUSHOBJ* param6, BRUSHOBJ* param7, 
                                     POINTL* param8, uint param9);
alias PFN_DrvStretchBlt = BOOL function(SURFOBJ* param0, SURFOBJ* param1, SURFOBJ* param2, CLIPOBJ* param3, 
                                        XLATEOBJ* param4, COLORADJUSTMENT* param5, POINTL* param6, RECTL* param7, 
                                        RECTL* param8, POINTL* param9, uint param10);
alias PFN_DrvStretchBltROP = BOOL function(SURFOBJ* param0, SURFOBJ* param1, SURFOBJ* param2, CLIPOBJ* param3, 
                                           XLATEOBJ* param4, COLORADJUSTMENT* param5, POINTL* param6, RECTL* param7, 
                                           RECTL* param8, POINTL* param9, uint param10, BRUSHOBJ* param11, 
                                           uint param12);
alias PFN_DrvTransparentBlt = BOOL function(SURFOBJ* param0, SURFOBJ* param1, CLIPOBJ* param2, XLATEOBJ* param3, 
                                            RECTL* param4, RECTL* param5, uint param6, uint param7);
alias PFN_DrvPlgBlt = BOOL function(SURFOBJ* param0, SURFOBJ* param1, SURFOBJ* param2, CLIPOBJ* param3, 
                                    XLATEOBJ* param4, COLORADJUSTMENT* param5, POINTL* param6, POINTFIX* param7, 
                                    RECTL* param8, POINTL* param9, uint param10);
alias PFN_DrvBitBlt = BOOL function(SURFOBJ* param0, SURFOBJ* param1, SURFOBJ* param2, CLIPOBJ* param3, 
                                    XLATEOBJ* param4, RECTL* param5, POINTL* param6, POINTL* param7, 
                                    BRUSHOBJ* param8, POINTL* param9, uint param10);
alias PFN_DrvRealizeBrush = BOOL function(BRUSHOBJ* param0, SURFOBJ* param1, SURFOBJ* param2, SURFOBJ* param3, 
                                          XLATEOBJ* param4, uint param5);
alias PFN_DrvCopyBits = BOOL function(SURFOBJ* param0, SURFOBJ* param1, CLIPOBJ* param2, XLATEOBJ* param3, 
                                      RECTL* param4, POINTL* param5);
alias PFN_DrvDitherColor = uint function(DHPDEV__* param0, uint param1, uint param2, uint* param3);
alias PFN_DrvCreateDeviceBitmap = HBITMAP function(DHPDEV__* param0, SIZE param1, uint param2);
alias PFN_DrvDeleteDeviceBitmap = void function(DHSURF__* param0);
alias PFN_DrvSetPalette = BOOL function(DHPDEV__* param0, PALOBJ* param1, uint param2, uint param3, uint param4);
alias PFN_DrvEscape = uint function(SURFOBJ* param0, uint param1, uint param2, void* param3, uint param4, 
                                    void* param5);
alias PFN_DrvDrawEscape = uint function(SURFOBJ* param0, uint param1, CLIPOBJ* param2, RECTL* param3, uint param4, 
                                        void* param5);
alias PFN_DrvQueryFont = IFIMETRICS* function(DHPDEV__* param0, size_t param1, uint param2, size_t* param3);
alias PFN_DrvQueryFontTree = void* function(DHPDEV__* param0, size_t param1, uint param2, uint param3, 
                                            size_t* param4);
alias PFN_DrvQueryFontData = int function(DHPDEV__* param0, FONTOBJ* param1, uint param2, uint param3, 
                                          GLYPHDATA* param4, void* param5, uint param6);
alias PFN_DrvFree = void function(void* param0, size_t param1);
alias PFN_DrvDestroyFont = void function(FONTOBJ* param0);
alias PFN_DrvQueryFontCaps = int function(uint param0, uint* param1);
alias PFN_DrvLoadFontFile = size_t function(uint param0, size_t* param1, void** param2, uint* param3, 
                                            DESIGNVECTOR* param4, uint param5, uint param6);
alias PFN_DrvUnloadFontFile = BOOL function(size_t param0);
alias PFN_DrvSetPointerShape = uint function(SURFOBJ* param0, SURFOBJ* param1, SURFOBJ* param2, XLATEOBJ* param3, 
                                             int param4, int param5, int param6, int param7, RECTL* param8, 
                                             uint param9);
alias PFN_DrvMovePointer = void function(SURFOBJ* pso, int x, int y, RECTL* prcl);
alias PFN_DrvSendPage = BOOL function(SURFOBJ* param0);
alias PFN_DrvStartPage = BOOL function(SURFOBJ* pso);
alias PFN_DrvStartDoc = BOOL function(SURFOBJ* pso, PWSTR pwszDocName, uint dwJobId);
alias PFN_DrvEndDoc = BOOL function(SURFOBJ* pso, uint fl);
alias PFN_DrvQuerySpoolType = BOOL function(DHPDEV__* dhpdev, PWSTR pwchType);
alias PFN_DrvLineTo = BOOL function(SURFOBJ* param0, CLIPOBJ* param1, BRUSHOBJ* param2, int param3, int param4, 
                                    int param5, int param6, RECTL* param7, uint param8);
alias PFN_DrvStrokePath = BOOL function(SURFOBJ* param0, PATHOBJ* param1, CLIPOBJ* param2, XFORMOBJ* param3, 
                                        BRUSHOBJ* param4, POINTL* param5, LINEATTRS* param6, uint param7);
alias PFN_DrvFillPath = BOOL function(SURFOBJ* param0, PATHOBJ* param1, CLIPOBJ* param2, BRUSHOBJ* param3, 
                                      POINTL* param4, uint param5, uint param6);
alias PFN_DrvStrokeAndFillPath = BOOL function(SURFOBJ* param0, PATHOBJ* param1, CLIPOBJ* param2, XFORMOBJ* param3, 
                                               BRUSHOBJ* param4, LINEATTRS* param5, BRUSHOBJ* param6, POINTL* param7, 
                                               uint param8, uint param9);
alias PFN_DrvPaint = BOOL function(SURFOBJ* param0, CLIPOBJ* param1, BRUSHOBJ* param2, POINTL* param3, uint param4);
alias PFN_DrvGetGlyphMode = uint function(DHPDEV__* dhpdev, FONTOBJ* pfo);
alias PFN_DrvResetPDEV = BOOL function(DHPDEV__* dhpdevOld, DHPDEV__* dhpdevNew);
alias PFN_DrvSaveScreenBits = size_t function(SURFOBJ* param0, uint param1, size_t param2, RECTL* param3);
alias PFN_DrvGetModes = uint function(HANDLE param0, uint param1, DEVMODEW* param2);
alias PFN_DrvQueryTrueTypeTable = int function(size_t param0, uint param1, uint param2, int param3, uint param4, 
                                               ubyte* param5, ubyte** param6, uint* param7);
alias PFN_DrvQueryTrueTypeSection = int function(uint param0, uint param1, uint param2, HANDLE* param3, 
                                                 int* param4);
alias PFN_DrvQueryTrueTypeOutline = int function(DHPDEV__* param0, FONTOBJ* param1, uint param2, BOOL param3, 
                                                 GLYPHDATA* param4, uint param5, TTPOLYGONHEADER* param6);
alias PFN_DrvGetTrueTypeFile = void* function(size_t param0, uint* param1);
alias PFN_DrvQueryFontFile = int function(size_t param0, uint param1, uint param2, uint* param3);
alias PFN_DrvQueryAdvanceWidths = BOOL function(DHPDEV__* param0, FONTOBJ* param1, uint param2, uint* param3, 
                                                void* param4, uint param5);
alias PFN_DrvFontManagement = uint function(SURFOBJ* param0, FONTOBJ* param1, uint param2, uint param3, 
                                            void* param4, uint param5, void* param6);
alias PFN_DrvSetPixelFormat = BOOL function(SURFOBJ* param0, int param1, HWND param2);
alias PFN_DrvDescribePixelFormat = int function(DHPDEV__* param0, int param1, uint param2, 
                                                PIXELFORMATDESCRIPTOR* param3);
alias PFN_DrvSwapBuffers = BOOL function(SURFOBJ* param0, WNDOBJ* param1);
alias PFN_DrvStartBanding = BOOL function(SURFOBJ* param0, POINTL* ppointl);
alias PFN_DrvNextBand = BOOL function(SURFOBJ* param0, POINTL* ppointl);
alias PFN_DrvQueryPerBandInfo = BOOL function(SURFOBJ* param0, PERBANDINFO* param1);
alias PFN_DrvEnableDirectDraw = BOOL function(DHPDEV__* param0, DD_CALLBACKS* param1, DD_SURFACECALLBACKS* param2, 
                                              DD_PALETTECALLBACKS* param3);
alias PFN_DrvDisableDirectDraw = void function(DHPDEV__* param0);
alias PFN_DrvGetDirectDrawInfo = BOOL function(DHPDEV__* param0, DD_HALINFO* param1, uint* param2, 
                                               VIDEOMEMORY* param3, uint* param4, uint* param5);
alias PFN_DrvIcmCreateColorTransform = HANDLE function(DHPDEV__* param0, LOGCOLORSPACEW* param1, void* param2, 
                                                       uint param3, void* param4, uint param5, void* param6, 
                                                       uint param7, uint param8);
alias PFN_DrvIcmDeleteColorTransform = BOOL function(DHPDEV__* param0, HANDLE param1);
alias PFN_DrvIcmCheckBitmapBits = BOOL function(DHPDEV__* param0, HANDLE param1, SURFOBJ* param2, ubyte* param3);
alias PFN_DrvIcmSetDeviceGammaRamp = BOOL function(DHPDEV__* param0, uint param1, void* param2);
alias PFN_DrvAlphaBlend = BOOL function(SURFOBJ* param0, SURFOBJ* param1, CLIPOBJ* param2, XLATEOBJ* param3, 
                                        RECTL* param4, RECTL* param5, BLENDOBJ* param6);
alias PFN_DrvGradientFill = BOOL function(SURFOBJ* param0, CLIPOBJ* param1, XLATEOBJ* param2, TRIVERTEX* param3, 
                                          uint param4, void* param5, uint param6, RECTL* param7, POINTL* param8, 
                                          uint param9);
alias PFN_DrvQueryDeviceSupport = BOOL function(SURFOBJ* param0, XLATEOBJ* param1, XFORMOBJ* param2, uint param3, 
                                                uint param4, void* param5, uint param6, void* param7);
alias PFN_DrvDeriveSurface = HBITMAP function(DD_DIRECTDRAW_GLOBAL* param0, DD_SURFACE_LOCAL* param1);
alias PFN_DrvSynchronizeSurface = void function(SURFOBJ* param0, RECTL* param1, uint param2);
alias PFN_DrvNotify = void function(SURFOBJ* param0, uint param1, void* param2);
alias PFN_DrvRenderHint = int function(DHPDEV__* dhpdev, uint NotifyCode, size_t Length, void* Data);
alias PFN_EngCreateRectRgn = HANDLE function(int left, int top, int right, int bottom);
alias PFN_EngDeleteRgn = void function(HANDLE hrgn);
alias PFN_EngCombineRgn = int function(HANDLE hrgnTrg, HANDLE hrgnSrc1, HANDLE hrgnSrc2, int imode);
alias PFN_EngCopyRgn = int function(HANDLE hrgnDst, HANDLE hrgnSrc);
alias PFN_EngIntersectRgn = int function(HANDLE hrgnResult, HANDLE hRgnA, HANDLE hRgnB);
alias PFN_EngSubtractRgn = int function(HANDLE hrgnResult, HANDLE hRgnA, HANDLE hRgnB);
alias PFN_EngUnionRgn = int function(HANDLE hrgnResult, HANDLE hRgnA, HANDLE hRgnB);
alias PFN_EngXorRgn = int function(HANDLE hrgnResult, HANDLE hRgnA, HANDLE hRgnB);
alias PFN_DrvCreateDeviceBitmapEx = HBITMAP function(DHPDEV__* param0, SIZE param1, uint param2, uint param3, 
                                                     DHSURF__* param4, uint param5, uint param6, HANDLE* param7);
alias PFN_DrvDeleteDeviceBitmapEx = void function(DHSURF__* param0);
alias PFN_DrvAssociateSharedSurface = BOOL function(SURFOBJ* param0, HANDLE param1, HANDLE param2, SIZE param3);
alias PFN_DrvSynchronizeRedirectionBitmaps = NTSTATUS function(DHPDEV__* param0, ulong* param1);
alias PFN_DrvAccumulateD3DDirtyRect = BOOL function(SURFOBJ* param0, CDDDXGK_REDIRBITMAPPRESENTINFO* param1);
alias PFN_DrvStartDxInterop = BOOL function(SURFOBJ* param0, BOOL param1, void* KernelModeDeviceHandle);
alias PFN_DrvEndDxInterop = BOOL function(SURFOBJ* param0, BOOL param1, BOOL* param2, void* KernelModeDeviceHandle);
alias PFN_DrvLockDisplayArea = void function(DHPDEV__* param0, RECTL* param1);
alias PFN_DrvUnlockDisplayArea = void function(DHPDEV__* param0, RECTL* param1);
alias PFN_DrvSurfaceComplete = BOOL function(DHPDEV__* param0, HANDLE param1);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE = void function(size_t ReturnValue);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION = int function(void* ExceptionRecord);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD = int function(VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32* ThreadDescriptor);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD = int function(VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32* ThreadDescriptor);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES = int function(void* EnclaveAddress, size_t NumberOfBytes, 
                                                               void* SourceAddress, uint PageProtection);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES = int function(void* EnclaveAddress, size_t NumberOfBytes);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES = int function(void* EnclaveAddress, size_t NumberOfytes, 
                                                                uint PageProtection);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD = int function(VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32* ThreadDescriptor);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION = int function(ENCLAVE_INFORMATION* EnclaveInfo);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY = int function(ENCLAVE_VBS_BASIC_KEY_REQUEST* KeyRequest, 
                                                               uint RequestedKeySize, ubyte* ReturnedKey);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT = int function(const(ubyte)* EnclaveData, void* Report, 
                                                                  uint BufferSize, uint* OutputSize);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT = int function(const(void)* Report, uint ReportSize);
alias VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA = int function(ubyte* Buffer, uint NumberOfBytes, 
                                                                       ulong* Generation);
///Function class for effective power mode callback.
///Params:
///    Mode = Indicates the effective power mode the system is running in
///    Context = User-specified opaque context. This context would have been passed in at registration in
///              PowerRegisterForEffectivePowerModeNotifications.
alias EFFECTIVE_POWER_MODE_CALLBACK = void function(EFFECTIVE_POWER_MODE Mode, void* Context);
alias PWRSCHEMESENUMPROC_V1 = ubyte function(uint Index, uint NameSize, byte* Name, uint DescriptionSize, 
                                             byte* Description, POWER_POLICY* Policy, LPARAM Context);
alias PWRSCHEMESENUMPROC_V2 = ubyte function(uint Index, uint NameSize, PWSTR Name, uint DescriptionSize, 
                                             PWSTR Description, POWER_POLICY* Policy, LPARAM Context);
alias PWRSCHEMESENUMPROC = ubyte function();
///An application's <i>DeviceNotifyCallbackRoutine</i> callback function is used for receiving power notifications.
///Params:
///    Context = The context provided when registering for the power notification.
///    Type = The type of power event that caused this notification.
///    Setting = The value of this parameter depends on the type of notification subscribed to.
///Returns:
///    This function returns a Windows error code.
///    
alias DEVICE_NOTIFY_CALLBACK_ROUTINE = uint function(void* Context, uint Type, void* Setting);
alias PDEVICE_NOTIFY_CALLBACK_ROUTINE = uint function();
alias PVIDEO_WIN32K_CALLOUT = void function(void* Params);
alias ENCLAVE_TARGET_FUNCTION = void* function(void* param0);
alias PENCLAVE_TARGET_FUNCTION = void* function();
alias LPENCLAVE_TARGET_FUNCTION = void* function();
alias PIMAGE_TLS_CALLBACK = void function(void* DllHandle, uint Reason, void* Reserved);
///The application-defined user-mode scheduling (UMS) scheduler entry point function associated with a UMS completion
///list. The <b>PUMS_SCHEDULER_ENTRY_POINT</b> type defines a pointer to this function. <i>UmsSchedulerProc</i> is a
///placeholder for the application-defined function name.
///Params:
///    Reason = The reason the scheduler entry point is being called. This parameter can be one of the following values. <table>
///             <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="UmsSchedulerStartup"></a><a
///             id="umsschedulerstartup"></a><a id="UMSSCHEDULERSTARTUP"></a><dl> <dt><b>UmsSchedulerStartup</b></dt> <dt>0</dt>
///             </dl> </td> <td width="60%"> A UMS scheduler thread was created. The entry point is called with this reason once
///             each time EnterUmsSchedulingMode is called. </td> </tr> <tr> <td width="40%"><a
///             id="UmsSchedulerThreadBlocked"></a><a id="umsschedulerthreadblocked"></a><a
///             id="UMSSCHEDULERTHREADBLOCKED"></a><dl> <dt><b>UmsSchedulerThreadBlocked</b></dt> <dt>1</dt> </dl> </td> <td
///             width="60%"> A UMS worker thread blocked. </td> </tr> <tr> <td width="40%"><a id="UmsSchedulerThreadYield"></a><a
///             id="umsschedulerthreadyield"></a><a id="UMSSCHEDULERTHREADYIELD"></a><dl> <dt><b>UmsSchedulerThreadYield</b></dt>
///             <dt>2</dt> </dl> </td> <td width="60%"> An executing UMS worker thread yielded control by calling the
///             UmsThreadYield function. </td> </tr> </table>
///    ActivationPayload = If the <i>Reason</i> parameter is <b>UmsSchedulerStartup</b>, this parameter is NULL. If the <i>Reason</i>
///                        parameter is <b>UmsSchedulerThreadBlocked</b>, bit 0 of this parameter indicates the type of activity that was
///                        being serviced when the UMS worker thread blocked. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                        width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> The thread blocked on a trap (for
///                        example, a hard page fault) or an interrupt (for example, an asynchronous procedure call). </td> </tr> <tr> <td
///                        width="40%"><a id="1"></a><dl> <dt><b>1</b></dt> </dl> </td> <td width="60%"> The thread blocked on a system
///                        call. </td> </tr> </table> If the <i>Reason</i> parameter is <b>UmsSchedulerThreadYield</b>, this parameter is a
///                        pointer to the UMS thread context of the UMS worker thread that yielded.
///    SchedulerParam = If the <i>Reason</i> parameter is <b>UmsSchedulerStartup</b>, this parameter is the <b>SchedulerParam</b> member
///                     of the UMS_SCHEDULER_STARTUP_INFO structure passed to the EnterUmsSchedulingMode function that triggered the
///                     entry point call. If the <i>Reason</i> parameter is <b>UmsSchedulerThreadYield</b> this parameter is the
///                     SchedulerParam parameter passed to the UmsThreadYield function that triggered the entry point call. If the
///                     <i>Reason</i> parameter is <b>UmsSchedulerThreadBlocked</b>, this parameter is NULL.
alias RTL_UMS_SCHEDULER_ENTRY_POINT = void function(RTL_UMS_SCHEDULER_REASON Reason, size_t ActivationPayload, 
                                                    void* SchedulerParam);
alias PRTL_UMS_SCHEDULER_ENTRY_POINT = void function();
///An application-defined completion routine. Specify this address when calling the QueueUserAPC function. The
///<b>PAPCFUNC</b> type defines a pointer to this callback function. <b>APCProc</b> is a placeholder for the
///application-defined function name.
///Params:
///    Parameter = 
///    Parameter = The data passed to the function using the <i>dwData</i> parameter of the QueueUserAPC function.
alias PAPCFUNC = void function(size_t Parameter);
alias WAITORTIMERCALLBACKFUNC = void function(void* param0, ubyte param1);
alias WORKERCALLBACKFUNC = void function(void* param0);
alias APC_CALLBACK_FUNCTION = void function(uint param0, void* param1, void* param2);
alias WAITORTIMERCALLBACK = void function();
///An application-defined function. If the FLS slot is in use, <b>FlsCallback</b> is called on fiber deletion, thread
///exit, and when an FLS index is freed. Specify this function when calling the FlsAlloc function. The
///<i>PFLS_CALLBACK_FUNCTION</i> type defines a pointer to this callback function. <b>FlsCallback</b> is a placeholder
///for the application-defined function name.
///Params:
///    lpFlsData = The value stored in the FLS slot for the calling fiber.
alias PFLS_CALLBACK_FUNCTION = void function(void* lpFlsData);
///An application-defined function previously registered with the AddSecureMemoryCacheCallback function that is called
///when a secured memory range is freed or its protections are changed. The <b>PSECURE_MEMORY_CACHE_CALLBACK</b> type
///defines a pointer to this callback function. <i>SecureMemoryCacheCallback</i> is a placeholder for the
///application-defined function name.
///Params:
///    Addr = The starting address of the memory range.
///    Range = The size of the memory range, in bytes.
///Returns:
///    The return value indicates the success or failure of this function. If the caller has secured the specified
///    memory range, this function should unsecure the memory and return <b>TRUE</b>. If the caller has not secured the
///    specified memory range, this function should return <b>FALSE</b>.
///    
alias PSECURE_MEMORY_CACHE_CALLBACK = ubyte function(void* Addr, size_t Range);
alias PTP_SIMPLE_CALLBACK = void function(TP_CALLBACK_INSTANCE* Instance, void* Context);
///Applications implement this callback if they call the SetThreadpoolCallbackCleanupGroup function to specify the
///callback to use when CloseThreadpoolCleanupGroup is called. The <b>PTP_CLEANUP_GROUP_CANCEL_CALLBACK</b> type defines
///a pointer to this callback function. <i>CleanupGroupCancelCallback</i> is a placeholder for the application-defined
///function name.
///Params:
///    ObjectContext = Optional application-defined data specified during creation of the object.
///    CleanupContext = Optional application-defined data specified using CloseThreadpoolCleanupGroupMembers.
alias PTP_CLEANUP_GROUP_CANCEL_CALLBACK = void function(void* ObjectContext, void* CleanupContext);
alias PTP_WORK_CALLBACK = void function(TP_CALLBACK_INSTANCE* Instance, void* Context, TP_WORK* Work);
alias PTP_TIMER_CALLBACK = void function(TP_CALLBACK_INSTANCE* Instance, void* Context, TP_TIMER* Timer);
alias PTP_WAIT_CALLBACK = void function(TP_CALLBACK_INSTANCE* Instance, void* Context, TP_WAIT* Wait, 
                                        uint WaitResult);
alias FARPROC = int function();
alias NEARPROC = int function();
alias PROC = int function();
///An application-defined callback function. Specify a pointer to this function when calling the InitOnceExecuteOnce
///function. The <b>PINIT_ONCE_FN</b> type defines a pointer to this callback function. <b>InitOnceCallback</b> is a
///placeholder for the application-defined function name.
///Params:
///    InitOnce = A pointer to the one-time initialization structure.
///    Parameter = An optional parameter that was passed to the callback function.
///    Context = The data to be stored with the one-time initialization structure. If <i>Context</i> references a value, the
///              low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> of the value must be zero. If <i>Context</i> points to a data
///              structure, the data structure must be <b>DWORD</b>-aligned.
///Returns:
///    If the function returns <b>TRUE</b>, the block is marked as initialized. If the function returns <b>FALSE</b>,
///    the block is not marked as initialized and the call to InitOnceExecuteOnce fails. To communicate additional error
///    information, call SetLastError before returning <b>FALSE</b>.
///    
alias PINIT_ONCE_FN = BOOL function(RTL_RUN_ONCE* InitOnce, void* Parameter, void** Context);
///An application-defined timer completion routine. Specify this address when calling the SetWaitableTimer function. The
///<b>PTIMERAPCROUTINE</b> type defines a pointer to this callback function. <b>TimerAPCProc</b> is a placeholder for
///the application-defined function name.
///Params:
///    lpArgToCompletionRoutine = The value passed to the function using the <i>lpArgToCompletionRoutine</i> parameter of the SetWaitableTimer
///                               function.
///    dwTimerLowValue = The low-order portion of the UTC-based time at which the timer was signaled. This value corresponds to the
///                      <b>dwLowDateTime</b> member of the FILETIME structure. For more information about UTC-based time, see System
///                      Time.
///    dwTimerHighValue = The high-order portion of the UTC-based time at which the timer was signaled. This value corresponds to the
///                       <b>dwHighDateTime</b> member of the FILETIME structure.
alias PTIMERAPCROUTINE = void function(void* lpArgToCompletionRoutine, uint dwTimerLowValue, uint dwTimerHighValue);
alias PTP_WIN32_IO_CALLBACK = void function(TP_CALLBACK_INSTANCE* Instance, void* Context, void* Overlapped, 
                                            uint IoResult, size_t NumberOfBytesTransferred, TP_IO* Io);
///An application-defined function used with the CreateFiber function. It serves as the starting address for a fiber.
///The <b>LPFIBER_START_ROUTINE</b> type defines a pointer to this callback function. <b>FiberProc</b> is a placeholder
///for the application-defined function name.
///Params:
///    lpFiberParameter = 
alias PFIBER_START_ROUTINE = void function(void* lpFiberParameter);

// Structs


struct SECURITY_ATTRIBUTES
{
    uint  nLength;
    void* lpSecurityDescriptor;
    BOOL  bInheritHandle;
}

///Contains information used in asynchronous (overlapped) input/output (I/O).
struct OVERLAPPED
{
    ///Type: <b>ULONG_PTR</b> Reserved for operating system use. This member, which specifies a system-dependent status,
    ///is valid when the IStreamAsync::OverlappedResult function returns without setting the extended error information
    ///to <b>ERROR_IO_PENDING</b>.
    size_t Internal;
    ///Type: <b>ULONG_PTR</b> Reserved for operating system use. This member, which specifies the length of the data
    ///transferred, is valid when the IStreamAsync::OverlappedResult function returns <b>TRUE</b>.
    size_t InternalHigh;
union
    {
struct
        {
            uint Offset;
            uint OffsetHigh;
        }
        void* Pointer;
    }
    ///Type: <b>handle</b> Handle to an event that is set to the signaled state when the operation has been completed.
    ///The calling process must set this member either to zero or a valid event handle before it calls any overlapped
    ///functions. To create an event object, use the CreateEvent function. This function returns a handle that can be
    ///used to synchronize simultaneous I/O requests for a device. Functions such as IStreamAsync::ReadAsync and
    ///IStreamAsync::WriteAsync set this handle to the nonsignaled state before they begin an I/O operation. When the
    ///operation has completed, the handle is set to the signaled state. Functions such as
    ///IStreamAsync::OverlappedResult and the wait functions reset auto-reset events to the nonsignaled state.
    ///Therefore, if an auto-reset event is used, the application can stop responding if it waits for the operation to
    ///complete and then calls <b>IStreamAsync::OverlappedResult</b>.
    HANDLE hEvent;
}

///Contains information about a heap element. The HeapWalk function uses a <b>PROCESS_HEAP_ENTRY</b> structure to
///enumerate the elements of a heap.
struct PROCESS_HEAP_ENTRY
{
    ///A pointer to the data portion of the heap element. To initiate a HeapWalk heap enumeration, set <b>lpData</b> to
    ///<b>NULL</b>. If <b>PROCESS_HEAP_REGION</b> is used in the <b>wFlags</b> member, <b>lpData</b> points to the first
    ///virtual address used by the region. If <b>PROCESS_HEAP_UNCOMMITTED_RANGE</b> is used in <b>wFlags</b>,
    ///<b>lpData</b> points to the beginning of the range of uncommitted memory.
    void*  lpData;
    ///The size of the data portion of the heap element, in bytes. If <b>PROCESS_HEAP_REGION</b> is used in
    ///<b>wFlags</b>, <b>cbData</b> specifies the total size, in bytes, of the address space that is reserved for this
    ///region. If <b>PROCESS_HEAP_UNCOMMITTED_RANGE</b> is used in <b>wFlags</b>, <b>cbData</b> specifies the size, in
    ///bytes, of the range of uncommitted memory.
    uint   cbData;
    ///The size of the data used by the system to maintain information about the heap element, in bytes. These overhead
    ///bytes are in addition to the <b>cbData</b> bytes of the data portion of the heap element. If
    ///<b>PROCESS_HEAP_REGION</b> is used in <b>wFlags</b>, <b>cbOverhead</b> specifies the size, in bytes, of the heap
    ///control structures that describe the region. If <b>PROCESS_HEAP_UNCOMMITTED_RANGE</b> is used in <b>wFlags</b>,
    ///<b>cbOverhead</b> specifies the size, in bytes, of the control structures that describe this uncommitted range.
    ubyte  cbOverhead;
    ///A handle to the heap region that contains the heap element. A heap consists of one or more regions of virtual
    ///memory, each with a unique region index. In the first heap entry returned for most heap regions, HeapWalk uses
    ///the <b>PROCESS_HEAP_REGION</b> in the <b>wFlags</b> member. When this value is used, the members of the
    ///<b>Region</b> structure contain additional information about the region. The HeapAlloc function sometimes uses
    ///the VirtualAlloc function to allocate large blocks from a growable heap. The heap manager treats such a large
    ///block allocation as a separate region with a unique region index. HeapWalk does not use
    ///<b>PROCESS_HEAP_REGION</b> in the heap entry returned for a large block region, so the members of the
    ///<b>Region</b> structure are not valid. You can use the VirtualQuery function to get additional information about
    ///a large block region.
    ubyte  iRegionIndex;
    ///The properties of the heap element. Some values affect the meaning of other members of this
    ///<b>PROCESS_HEAP_ENTRY</b> data structure. The following values are defined. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="PROCESS_HEAP_ENTRY_BUSY"></a><a
    ///id="process_heap_entry_busy"></a><dl> <dt><b>PROCESS_HEAP_ENTRY_BUSY</b></dt> <dt>0x0004</dt> </dl> </td> <td
    ///width="60%"> The heap element is an allocated block. If <b>PROCESS_HEAP_ENTRY_MOVEABLE</b> is also specified, the
    ///<b>Block</b> structure becomes valid. The <b>hMem</b> member of the <b>Block</b> structure contains a handle to
    ///the allocated, moveable memory block. </td> </tr> <tr> <td width="40%"><a id="PROCESS_HEAP_ENTRY_DDESHARE"></a><a
    ///id="process_heap_entry_ddeshare"></a><dl> <dt><b>PROCESS_HEAP_ENTRY_DDESHARE</b></dt> <dt>0x0020</dt> </dl> </td>
    ///<td width="60%"> This value must be used with <b>PROCESS_HEAP_ENTRY_BUSY</b>, indicating that the heap element is
    ///an allocated block. </td> </tr> <tr> <td width="40%"><a id="PROCESS_HEAP_ENTRY_MOVEABLE"></a><a
    ///id="process_heap_entry_moveable"></a><dl> <dt><b>PROCESS_HEAP_ENTRY_MOVEABLE</b></dt> <dt>0x0010</dt> </dl> </td>
    ///<td width="60%"> This value must be used with <b>PROCESS_HEAP_ENTRY_BUSY</b>, indicating that the heap element is
    ///an allocated block. The block was allocated with <b>LMEM_MOVEABLE</b> or <b>GMEM_MOVEABLE</b>, and the
    ///<b>Block</b> structure becomes valid. The <b>hMem</b> member of the <b>Block</b> structure contains a handle to
    ///the allocated, moveable memory block. </td> </tr> <tr> <td width="40%"><a id="PROCESS_HEAP_REGION"></a><a
    ///id="process_heap_region"></a><dl> <dt><b>PROCESS_HEAP_REGION</b></dt> <dt>0x0001</dt> </dl> </td> <td
    ///width="60%"> The heap element is located at the beginning of a region of contiguous virtual memory in use by the
    ///heap. The <b>lpData</b> member of the structure points to the first virtual address used by the region; the
    ///<b>cbData</b> member specifies the total size, in bytes, of the address space that is reserved for this region;
    ///and the <b>cbOverhead</b> member specifies the size, in bytes, of the heap control structures that describe the
    ///region. The <b>Region</b> structure becomes valid. The <b>dwCommittedSize</b>, <b>dwUnCommittedSize</b>,
    ///<b>lpFirstBlock</b>, and <b>lpLastBlock</b> members of the structure contain additional information about the
    ///region. </td> </tr> <tr> <td width="40%"><a id="PROCESS_HEAP_UNCOMMITTED_RANGE"></a><a
    ///id="process_heap_uncommitted_range"></a><dl> <dt><b>PROCESS_HEAP_UNCOMMITTED_RANGE</b></dt> <dt>0x0002</dt> </dl>
    ///</td> <td width="60%"> The heap element is located in a range of uncommitted memory within the heap region. The
    ///<b>lpData</b> member points to the beginning of the range of uncommitted memory; the <b>cbData</b> member
    ///specifies the size, in bytes, of the range of uncommitted memory; and the <b>cbOverhead</b> member specifies the
    ///size, in bytes, of the control structures that describe this uncommitted range. </td> </tr> </table>
    ushort wFlags;
union
    {
struct Block
        {
            HANDLE  hMem;
            uint[3] dwReserved;
        }
struct Region
        {
            uint  dwCommittedSize;
            uint  dwUnCommittedSize;
            void* lpFirstBlock;
            void* lpLastBlock;
        }
    }
}

///Contains information about a power request. This structure is used by the PowerCreateRequest and SetWaitableTimerEx
///functions.
struct REASON_CONTEXT
{
    ///The version number of the structure. This parameter must be set to <b>POWER_REQUEST_CONTEXT_VERSION</b>.
    uint Version;
    ///The format of the reason for the power request. This parameter can be one of the following values: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="POWER_REQUEST_CONTEXT_DETAILED_STRING"></a><a
    ///id="power_request_context_detailed_string"></a><dl> <dt><b>POWER_REQUEST_CONTEXT_DETAILED_STRING</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The <i>Detailed</i> structure identifies a localizable string
    ///resource that describes the reason for the power request. </td> </tr> <tr> <td width="40%"><a
    ///id="POWER_REQUEST_CONTEXT_SIMPLE_STRING"></a><a id="power_request_context_simple_string"></a><dl>
    ///<dt><b>POWER_REQUEST_CONTEXT_SIMPLE_STRING</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The
    ///<i>SimpleReasonString</i> parameter contains a simple, non-localizable string that describes the reason for the
    ///power request. </td> </tr> </table>
    uint Flags;
union Reason
    {
struct Detailed
        {
            ptrdiff_t LocalizedReasonModule;
            uint      LocalizedReasonId;
            uint      ReasonStringCount;
            PWSTR*    ReasonStrings;
        }
        PWSTR SimpleReasonString;
    }
}

///Represents a heap summary retrieved with a call to [HeapSummary](nf-heapapi-heapsummary.md)
struct HEAP_SUMMARY
{
    ///The size of this data structure, in bytes. Set this member to sizeof(HEAP_SUMMARY).
    uint   cb;
    ///The size of the allocated memory.
    size_t cbAllocated;
    ///The size of the committed memory.
    size_t cbCommitted;
    ///The size of the reserved memory.
    size_t cbReserved;
    ///The size of the maximum reserved memory.
    size_t cbMaxReserve;
}

///Specifies a range of memory. This structure is used by the PrefetchVirtualMemory function.
struct WIN32_MEMORY_RANGE_ENTRY
{
    void*  VirtualAddress;
    size_t NumberOfBytes;
}

///Contains information about a memory region. A memory region is a single allocation that is created using a memory
///allocation function, such as VirtualAlloc or MapViewOfFile.
struct WIN32_MEMORY_REGION_INFORMATION
{
    ///The base address of the allocation.
    void*  AllocationBase;
    ///The page protection value that was specified when the allocation was created. Protections of individual pages
    ///within the allocation can be different from this value. To query protection values of individual pages, use the
    ///VirtualQuery function.
    uint   AllocationProtect;
union
    {
        uint Flags;
struct
        {
            uint _bitfield112;
        }
    }
    ///The size of the allocation.
    size_t RegionSize;
    ///The commit charge associated with the allocation. For private allocations, this is the combined size of pages in
    ///the region that are committed, as opposed to reserved. For mapped views, this is the combined size of pages that
    ///have copy-on-write protection, or have been made private as a result of copy-on-write.
    size_t CommitSize;
}

struct ENUMUILANG
{
    uint    NumOfEnumUILang;
    uint    SizeOfEnumUIBuffer;
    ushort* pEnumUIBuffer;
}

struct REDIRECTION_FUNCTION_DESCRIPTOR
{
    const(PSTR) DllName;
    const(PSTR) FunctionName;
    void*       RedirectionTarget;
}

struct REDIRECTION_DESCRIPTOR
{
    uint Version;
    uint FunctionCount;
    REDIRECTION_FUNCTION_DESCRIPTOR* Redirections;
}

struct COORD
{
    short X;
    short Y;
}

struct SMALL_RECT
{
    short Left;
    short Top;
    short Right;
    short Bottom;
}

struct KEY_EVENT_RECORD
{
    BOOL   bKeyDown;
    ushort wRepeatCount;
    ushort wVirtualKeyCode;
    ushort wVirtualScanCode;
union uChar
    {
        ushort UnicodeChar;
        byte   AsciiChar;
    }
    uint   dwControlKeyState;
}

struct MOUSE_EVENT_RECORD
{
    COORD dwMousePosition;
    uint  dwButtonState;
    uint  dwControlKeyState;
    uint  dwEventFlags;
}

struct WINDOW_BUFFER_SIZE_RECORD
{
    COORD dwSize;
}

struct MENU_EVENT_RECORD
{
    uint dwCommandId;
}

struct FOCUS_EVENT_RECORD
{
    BOOL bSetFocus;
}

struct INPUT_RECORD
{
    ushort EventType;
union Event
    {
        KEY_EVENT_RECORD   KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD  MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    }
}

struct CHAR_INFO
{
union Char
    {
        ushort UnicodeChar;
        byte   AsciiChar;
    }
    ushort Attributes;
}

struct CONSOLE_FONT_INFO
{
    uint  nFont;
    COORD dwFontSize;
}

struct CONSOLE_READCONSOLE_CONTROL
{
    uint nLength;
    uint nInitialChars;
    uint dwCtrlWakeupMask;
    uint dwControlKeyState;
}

struct CONSOLE_CURSOR_INFO
{
    uint dwSize;
    BOOL bVisible;
}

struct CONSOLE_SCREEN_BUFFER_INFO
{
    COORD      dwSize;
    COORD      dwCursorPosition;
    ushort     wAttributes;
    SMALL_RECT srWindow;
    COORD      dwMaximumWindowSize;
}

struct CONSOLE_SCREEN_BUFFER_INFOEX
{
    uint       cbSize;
    COORD      dwSize;
    COORD      dwCursorPosition;
    ushort     wAttributes;
    SMALL_RECT srWindow;
    COORD      dwMaximumWindowSize;
    ushort     wPopupAttributes;
    BOOL       bFullscreenSupported;
    uint[16]   ColorTable;
}

struct CONSOLE_FONT_INFOEX
{
    uint       cbSize;
    uint       nFont;
    COORD      dwFontSize;
    uint       FontFamily;
    uint       FontWeight;
    ushort[32] FaceName;
}

struct CONSOLE_SELECTION_INFO
{
    uint       dwFlags;
    COORD      dwSelectionAnchor;
    SMALL_RECT srSelection;
}

struct CONSOLE_HISTORY_INFO
{
    uint cbSize;
    uint HistoryBufferSize;
    uint NumberOfHistoryBuffers;
    uint dwFlags;
}

struct RPC_IMPORT_CONTEXT_P
{
    void*               LookupContext;
    void*               ProposedHandle;
    RPC_BINDING_VECTOR* Bindings;
}

struct RemHGLOBAL
{
    int      fNullHGlobal;
    uint     cbData;
    ubyte[1] data;
}

struct RemHMETAFILEPICT
{
    int      mm;
    int      xExt;
    int      yExt;
    uint     cbData;
    ubyte[1] data;
}

struct RemHENHMETAFILE
{
    uint     cbData;
    ubyte[1] data;
}

struct RemHBITMAP
{
    uint     cbData;
    ubyte[1] data;
}

struct RemHPALETTE
{
    uint     cbData;
    ubyte[1] data;
}

struct RemBRUSH
{
    uint     cbData;
    ubyte[1] data;
}

struct userCLIPFORMAT
{
    int fContext;
union u
    {
        uint  dwValue;
        PWSTR pwszName;
    }
}

struct GDI_NONREMOTE
{
    int fContext;
union u
    {
        int         hInproc;
        DWORD_BLOB* hRemote;
    }
}

struct userHGLOBAL
{
    int fContext;
union u
    {
        int                hInproc;
        FLAGGED_BYTE_BLOB* hRemote;
        long               hInproc64;
    }
}

struct userHMETAFILE
{
    int fContext;
union u
    {
        int        hInproc;
        BYTE_BLOB* hRemote;
        long       hInproc64;
    }
}

struct remoteMETAFILEPICT
{
    int            mm;
    int            xExt;
    int            yExt;
    userHMETAFILE* hMF;
}

struct userHMETAFILEPICT
{
    int fContext;
union u
    {
        int                 hInproc;
        remoteMETAFILEPICT* hRemote;
        long                hInproc64;
    }
}

struct userHENHMETAFILE
{
    int fContext;
union u
    {
        int        hInproc;
        BYTE_BLOB* hRemote;
        long       hInproc64;
    }
}

struct userBITMAP
{
    int      bmType;
    int      bmWidth;
    int      bmHeight;
    int      bmWidthBytes;
    ushort   bmPlanes;
    ushort   bmBitsPixel;
    uint     cbSize;
    ubyte[1] pBuffer;
}

struct userHBITMAP
{
    int fContext;
union u
    {
        int         hInproc;
        userBITMAP* hRemote;
        long        hInproc64;
    }
}

struct userHPALETTE
{
    int fContext;
union u
    {
        int         hInproc;
        LOGPALETTE* hRemote;
        long        hInproc64;
    }
}

struct RemotableHandle
{
    int fContext;
union u
    {
        int hInproc;
        int hRemote;
    }
}

///A currency number stored as an 8-byte, two's complement integer, scaled by 10,000 to give a fixed-point number with
///15 digits to the left of the decimal point and 4 digits to the right. This <b>IDispatch::GetTypeInfo</b> resentation
///provides a range of 922337203685477.5807 to -922337203685477.5808. The CURRENCY data type is useful for calculations
///involving money, or for any fixed-point calculation where accuracy is particularly important.
union CY
{
struct
    {
        uint Lo;
        int  Hi;
    }
    long int64;
}

///Represents a decimal data type that provides a sign and scale for a number (as in coordinates.) Decimal variables are
///stored as 96-bit (12-byte) unsigned integers scaled by a variable power of 10. The power of 10 scaling factor
///specifies the number of digits to the right of the decimal point, and ranges from 0 to 28.
struct DECIMAL
{
    ///Reserved.
    ushort wReserved;
union
    {
struct
        {
            ubyte scale;
            ubyte sign;
        }
        ushort signscale;
    }
    ///The high 32 bits of the number.
    uint   Hi32;
union
    {
struct
        {
            uint Lo32;
            uint Mid32;
        }
        ulong Lo64;
    }
}

struct BSTRBLOB
{
    uint   cbSize;
    ubyte* pData;
}

struct CLIPDATA
{
    uint   cbSize;
    int    ulClipFmt;
    ubyte* pClipData;
}

struct uCLSSPEC
{
    uint tyspec;
union tagged_union
    {
        GUID  clsid;
        PWSTR pFileExt;
        PWSTR pMimeType;
        PWSTR pProgId;
        PWSTR pFileName;
struct ByName
        {
            PWSTR pPackageName;
            GUID  PolicyId;
        }
struct ByObjectId
        {
            GUID ObjectId;
            GUID PolicyId;
        }
    }
}

///Provides information about the hotplug information of a device.
struct STORAGE_HOTPLUG_INFO
{
    ///The size of this structure, in bytes. The caller must set this member to
    ///<code>sizeof(STORAGE_HOTPLUG_INFO)</code>.
    uint  Size;
    ///If this member is set to a nonzero value, the device media is removable. Otherwise, the device media is not
    ///removable.
    ubyte MediaRemovable;
    ///If this member is set to a nonzero value, the media is not lockable. Otherwise, the device media is lockable.
    ubyte MediaHotplug;
    ///If this member is set to a nonzero value, the device is a hotplug device. Otherwise, the device is not a hotplug
    ///device.
    ubyte DeviceHotplug;
    ///Reserved; set the value to <b>NULL</b>.
    ubyte WriteCacheEnableOverride;
}

///Contains information about a device. This structure is used by the IOCTL_STORAGE_GET_DEVICE_NUMBER control code.
struct STORAGE_DEVICE_NUMBER
{
    ///The type of device. Values from 0 through 32,767 are reserved for use by Microsoft. Values from 32,768 through
    ///65,535 are reserved for use by other vendors. The following values are defined by Microsoft: <a
    ///id="FILE_DEVICE_8042_PORT"></a> <a id="file_device_8042_port"></a>
    uint DeviceType;
    ///The number of this device.
    uint DeviceNumber;
    ///The partition number of the device, if the device can be partitioned. Otherwise, this member is –1.
    uint PartitionNumber;
}

struct STORAGE_DEVICE_NUMBERS
{
    uint Version;
    uint Size;
    uint NumberOfDevices;
    STORAGE_DEVICE_NUMBER[1] Devices;
}

struct STORAGE_DEVICE_NUMBER_EX
{
    uint Version;
    uint Size;
    uint Flags;
    uint DeviceType;
    uint DeviceNumber;
    GUID DeviceGuid;
    uint PartitionNumber;
}

struct STORAGE_BUS_RESET_REQUEST
{
    ubyte PathId;
}

struct STORAGE_BREAK_RESERVATION_REQUEST
{
    uint  Length;
    ubyte _unused;
    ubyte PathId;
    ubyte TargetId;
    ubyte Lun;
}

///Provides removable media locking data. It is used by the IOCTL_STORAGE_MEDIA_REMOVAL control code.
struct PREVENT_MEDIA_REMOVAL
{
    ///If this member is <b>TRUE</b>, the media is to be locked. Otherwise, it is not.
    ubyte PreventMediaRemoval;
}

///Contains information associated with a media change event.
struct CLASS_MEDIA_CHANGE_CONTEXT
{
    ///The number of times that media has been changed since system startup.
    uint MediaChangeCount;
    ///The state information. This member can be one of the following values from the
    ///<b>MEDIA_CHANGE_DETECTION_STATE</b> enumeration type.
    uint NewState;
}

struct TAPE_STATISTICS
{
    uint          Version;
    uint          Flags;
    LARGE_INTEGER RecoveredWrites;
    LARGE_INTEGER UnrecoveredWrites;
    LARGE_INTEGER RecoveredReads;
    LARGE_INTEGER UnrecoveredReads;
    ubyte         CompressionRatioReads;
    ubyte         CompressionRatioWrites;
}

struct TAPE_GET_STATISTICS
{
    uint Operation;
}

///Provides information about the media supported by a device.
struct DEVICE_MEDIA_INFO
{
union DeviceSpecific
    {
struct DiskInfo
        {
            LARGE_INTEGER      Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            uint               TracksPerCylinder;
            uint               SectorsPerTrack;
            uint               BytesPerSector;
            uint               NumberMediaSides;
            uint               MediaCharacteristics;
        }
struct RemovableDiskInfo
        {
            LARGE_INTEGER      Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            uint               TracksPerCylinder;
            uint               SectorsPerTrack;
            uint               BytesPerSector;
            uint               NumberMediaSides;
            uint               MediaCharacteristics;
        }
struct TapeInfo
        {
            STORAGE_MEDIA_TYPE MediaType;
            uint               MediaCharacteristics;
            uint               CurrentBlockSize;
            STORAGE_BUS_TYPE   BusType;
union BusSpecificData
            {
struct ScsiInformation
                {
                    ubyte MediumType;
                    ubyte DensityCode;
                }
            }
        }
    }
}

///Contains information about the media types supported by a device.
struct GET_MEDIA_TYPES
{
    ///The type of device. Values from 0 through 32,767 are reserved for use by Microsoft Corporation. Values from
    ///32,768 through 65,535 are reserved for use by other vendors. The following values are defined by Microsoft: <a
    ///id="FILE_DEVICE_8042_PORT"></a> <a id="file_device_8042_port"></a>
    uint                 DeviceType;
    ///The number of elements in the <b>MediaInfo</b> array.
    uint                 MediaInfoCount;
    ///A pointer to the first DEVICE_MEDIA_INFO structure in the array. There is one structure for each media type
    ///supported by the device.
    DEVICE_MEDIA_INFO[1] MediaInfo;
}

struct STORAGE_PREDICT_FAILURE
{
    uint       PredictFailure;
    ubyte[512] VendorSpecific;
}

struct STORAGE_FAILURE_PREDICTION_CONFIG
{
    uint   Version;
    uint   Size;
    ubyte  Set;
    ubyte  Enabled;
    ushort Reserved;
}

struct STORAGE_PROPERTY_SET
{
    STORAGE_PROPERTY_ID PropertyId;
    STORAGE_SET_TYPE    SetType;
    ubyte[1]            AdditionalParameters;
}

struct STORAGE_IDENTIFIER
{
    STORAGE_IDENTIFIER_CODE_SET CodeSet;
    STORAGE_IDENTIFIER_TYPE Type;
    ushort   IdentifierSize;
    ushort   NextOffset;
    STORAGE_ASSOCIATION_TYPE Association;
    ubyte[1] Identifier;
}

struct STORAGE_LB_PROVISIONING_MAP_RESOURCES
{
    uint     Size;
    uint     Version;
    ubyte    _bitfield1;
    ubyte[3] Reserved1;
    ubyte    _bitfield2;
    ubyte[3] Reserved3;
    ulong    AvailableMappingResources;
    ulong    UsedMappingResources;
}

///To interface with the Replay Protected Memory Block (RPMB), applications first need to query whether the device
///contains an RPMB and the max payload size the RPMB supports. To do this, the application sends
///[IOCTL_STORAGE_QUERY_PROPERTY IOCTL](ni-winioctl-ioctl_storage_query_property.md) with [STORAGE_PROPERTY_ID
///enumeration](ne-winioctl-storage_property_id.md) set to StorageAdapterRpmbProperty (defined in STORAGE_PROPERTY_QUERY
///in ntddstor.h). Storport then responds with the following payload (defined in ntddstor.h) when [STORAGE_QUERY_TYPE
///enumeration](ne-winioctl-storage_query_type.md) is set to PropertyStandardQuery.
struct STORAGE_RPMB_DESCRIPTOR
{
    ///Shall be set to STORAGE_RPMB_DESCRIPTOR_VERSION_1
    uint Version;
    ///Shall be set to sizeof(STORAGE_RPMB_DESCRIPTOR)
    uint Size;
    ///The size of the RPMB, in bytes. 0 if not supported, RPMB size in bytes otherwise.
    uint SizeInBytes;
    ///The maximum amount of data supported in one transaction in bytes. 0 if not supported, minimum 512 bytes.
    uint MaxReliableWriteSizeInBytes;
    ///To support different RPMB frame formats, specifies which frame format the payload will be in so the port driver
    ///can take the appropriate action.
    STORAGE_RPMB_FRAME_TYPE FrameFormat;
}

struct STORAGE_CRYPTO_CAPABILITY
{
    uint Version;
    uint Size;
    uint CryptoCapabilityIndex;
    STORAGE_CRYPTO_ALGORITHM_ID AlgorithmId;
    STORAGE_CRYPTO_KEY_SIZE KeySize;
    uint DataUnitSizeBitmask;
}

struct STORAGE_CRYPTO_DESCRIPTOR
{
    uint Version;
    uint Size;
    uint NumKeysSupported;
    uint NumCryptoCapabilities;
    STORAGE_CRYPTO_CAPABILITY[1] CryptoCapabilities;
}

struct STORAGE_TIER
{
    GUID               Id;
    ushort[256]        Name;
    ushort[256]        Description;
    ulong              Flags;
    ulong              ProvisionedCapacity;
    STORAGE_TIER_MEDIA_TYPE MediaType;
    STORAGE_TIER_CLASS Class;
}

struct STORAGE_DEVICE_TIERING_DESCRIPTOR
{
    uint            Version;
    uint            Size;
    uint            Flags;
    uint            TotalNumberOfTiers;
    uint            NumberOfTiersReturned;
    STORAGE_TIER[1] Tiers;
}

struct STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR
{
    uint    Version;
    uint    Size;
    uint    NumberOfFaultDomains;
    GUID[1] FaultDomainIds;
}

struct STORAGE_PROTOCOL_SPECIFIC_DATA_EXT
{
    STORAGE_PROTOCOL_TYPE ProtocolType;
    uint    DataType;
    uint    ProtocolDataValue;
    uint    ProtocolDataSubValue;
    uint    ProtocolDataOffset;
    uint    ProtocolDataLength;
    uint    FixedProtocolReturnData;
    uint    ProtocolDataSubValue2;
    uint    ProtocolDataSubValue3;
    uint    ProtocolDataSubValue4;
    uint    ProtocolDataSubValue5;
    uint[5] Reserved;
}

struct STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT
{
    uint Version;
    uint Size;
    STORAGE_PROTOCOL_SPECIFIC_DATA_EXT ProtocolSpecificData;
}

struct STORAGE_OPERATIONAL_REASON
{
    uint Version;
    uint Size;
    STORAGE_OPERATIONAL_STATUS_REASON Reason;
union RawBytes
    {
struct ScsiSenseKey
        {
            ubyte SenseKey;
            ubyte ASC;
            ubyte ASCQ;
            ubyte Reserved;
        }
struct NVDIMM_N
        {
            ubyte    CriticalHealth;
            ubyte[2] ModuleHealth;
            ubyte    ErrorThresholdStatus;
        }
        uint AsUlong;
    }
}

struct STORAGE_DEVICE_MANAGEMENT_STATUS
{
    uint Version;
    uint Size;
    STORAGE_DISK_HEALTH_STATUS Health;
    uint NumberOfOperationalStatus;
    uint NumberOfAdditionalReasons;
    STORAGE_DISK_OPERATIONAL_STATUS[16] OperationalStatus;
    STORAGE_OPERATIONAL_REASON[1] AdditionalReasons;
}

struct STORAGE_ZONE_GROUP
{
    uint               ZoneCount;
    STORAGE_ZONE_TYPES ZoneType;
    ulong              ZoneSize;
}

struct STORAGE_ZONED_DEVICE_DESCRIPTOR
{
    uint Version;
    uint Size;
    STORAGE_ZONED_DEVICE_TYPES DeviceType;
    uint ZoneCount;
union ZoneAttributes
    {
struct SequentialRequiredZone
        {
            uint     MaxOpenZoneCount;
            ubyte    UnrestrictedRead;
            ubyte[3] Reserved;
        }
struct SequentialPreferredZone
        {
            uint OptimalOpenZoneCount;
            uint Reserved;
        }
    }
    uint ZoneGroupCount;
    STORAGE_ZONE_GROUP[1] ZoneGroup;
}

struct DEVICE_LOCATION
{
    uint Socket;
    uint Slot;
    uint Adapter;
    uint Port;
union
    {
struct
        {
            uint Channel;
            uint Device;
        }
struct
        {
            uint Target;
            uint Lun;
        }
    }
}

struct STORAGE_DEVICE_LOCATION_DESCRIPTOR
{
    uint            Version;
    uint            Size;
    DEVICE_LOCATION Location;
    uint            StringOffset;
}

struct STORAGE_DEVICE_NUMA_PROPERTY
{
    uint Version;
    uint Size;
    uint NumaNode;
}

struct STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT
{
    uint Version;
    uint Size;
    uint UnsafeShutdownCount;
}

struct STORAGE_HW_ENDURANCE_INFO
{
    uint      ValidFields;
    uint      GroupId;
struct Flags
    {
        uint _bitfield113;
    }
    uint      LifePercentage;
    ubyte[16] BytesReadCount;
    ubyte[16] ByteWriteCount;
}

struct STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR
{
    uint Version;
    uint Size;
    STORAGE_HW_ENDURANCE_INFO EnduranceInfo;
}

///Provides data set range information for use with the IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES control code.
struct DEVICE_DATA_SET_RANGE
{
    ///Starting offset of the data set range in bytes, relative to the start of the volume. Must align to disk logical
    ///sector size.
    long  StartingOffset;
    ///Length of the data set range, in bytes. Must be a multiple of disk logical sector size.
    ulong LengthInBytes;
}

///Input structure for the IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES control code.
struct DEVICE_MANAGE_DATA_SET_ATTRIBUTES
{
    ///Size of this data structure. Must be set to <code>sizeof(DEVICE_MANAGE_DATA_SET_ATTRIBUTES)</code>.
    uint Size;
    ///A valid value of type DEVICE_DATA_MANAGEMENT_SET_ACTION. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="DeviceDsmAction_Trim"></a><a id="devicedsmaction_trim"></a><a
    ///id="DEVICEDSMACTION_TRIM"></a><dl> <dt><b>DeviceDsmAction_Trim</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> A
    ///trim action is performed. This value is not supported for user-mode applications. </td> </tr> <tr> <td
    ///width="40%"><a id="DeviceDsmAction_Notification"></a><a id="devicedsmaction_notification"></a><a
    ///id="DEVICEDSMACTION_NOTIFICATION"></a><dl> <dt><b>DeviceDsmAction_Notification</b></dt> <dt>2 |
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000002)</dt> </dl> </td> <td width="60%"> A notification action is
    ///performed. The additional parameters are in a DEVICE_DSM_NOTIFICATION_PARAMETERS structure. The
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit flag to indicate to the driver stack that this
    ///operation is non-destructive. </td> </tr> <tr> <td width="40%"><a id="DeviceDsmAction_OffloadRead"></a><a
    ///id="devicedsmaction_offloadread"></a><a id="DEVICEDSMACTION_OFFLOADREAD"></a><dl>
    ///<dt><b>DeviceDsmAction_OffloadRead</b></dt> <dt>3 | <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000003)</dt>
    ///</dl> </td> <td width="60%"> An offload read action is performed. The additional parameters are in a
    ///DEVICE_DSM_OFFLOAD_READ_PARAMETERS structure. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit
    ///flag to indicate to the driver stack that this operation is non-destructive. <b>Windows 7 and Windows Server 2008
    ///R2: </b>This value is not supported before Windows 8 and Windows Server 2012. </td> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_OffloadWrite"></a><a id="devicedsmaction_offloadwrite"></a><a
    ///id="DEVICEDSMACTION_OFFLOADWRITE"></a><dl> <dt><b>DeviceDsmAction_OffloadWrite</b></dt> <dt>4</dt> </dl> </td>
    ///<td width="60%"> An offload write action is performed. The additional parameters are in a
    ///DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS structure. <b>Windows 7 and Windows Server 2008 R2: </b>This value is not
    ///supported before Windows 8 and Windows Server 2012. </td> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_Allocation"></a><a id="devicedsmaction_allocation"></a><a
    ///id="DEVICEDSMACTION_ALLOCATION"></a><dl> <dt><b>DeviceDsmAction_Allocation</b></dt> <dt>5 |
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000005)</dt> </dl> </td> <td width="60%"> An allocation bitmap is
    ///retrieved for the first data set range specified. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a
    ///bit flag to indicate to the driver stack that this operation is non-destructive. <b>Windows 7 and Windows Server
    ///2008 R2: </b>This value is not supported before Windows 8 and Windows Server 2012. </td> </tr> <tr> <td
    ///width="40%"><a id="DeviceDsmAction_Repair"></a><a id="devicedsmaction_repair"></a><a
    ///id="DEVICEDSMACTION_REPAIR"></a><dl> <dt><b>DeviceDsmAction_Repair</b></dt> <dt>6 |
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000006)</dt> </dl> </td> <td width="60%"> A repair action is
    ///performed. The additional parameters are in a DEVICE_DATA_SET_REPAIR_PARAMETERS structure. The
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit flag to indicate to the driver stack that this
    ///operation is non-destructive. <b>Windows 7 and Windows Server 2008 R2: </b>This value is not supported before
    ///Windows 8 and Windows Server 2012. </td> </tr> <tr> <td width="40%"><a id="DeviceDsmAction_Scrub"></a><a
    ///id="devicedsmaction_scrub"></a><a id="DEVICEDSMACTION_SCRUB"></a><dl> <dt><b>DeviceDsmAction_Scrub</b></dt> <dt>7
    ///| <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000007)</dt> </dl> </td> <td width="60%"> A scrub action is
    ///performed. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit flag to indicate to the driver
    ///stack that this operation is non-destructive. <b>Windows 7 and Windows Server 2008 R2: </b>This value is not
    ///supported before Windows 8 and Windows Server 2012. </td> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_Resiliency"></a><a id="devicedsmaction_resiliency"></a><a
    ///id="DEVICEDSMACTION_RESILIENCY"></a><dl> <dt><b>DeviceDsmAction_Resiliency</b></dt> <dt>8 |
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000008)</dt> </dl> </td> <td width="60%"> A resiliency action is
    ///performed. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit flag to indicate to the driver
    ///stack that this operation is non-destructive. <b>Windows 7 and Windows Server 2008 R2: </b>This value is not
    ///supported before Windows 8 and Windows Server 2012. </td> </tr> </table>
    uint Action;
    ///Flags for the actions. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="DEVICE_DSM_FLAG_TRIM_NOT_FS_ALLOCATED"></a><a id="device_dsm_flag_trim_not_fs_allocated"></a><dl>
    ///<dt><b>DEVICE_DSM_FLAG_TRIM_NOT_FS_ALLOCATED</b></dt> <dt>0x80000000</dt> </dl> </td> <td width="60%"> If set
    ///then the described ranges are not allocated by a file system. This flag is specific to the
    ///<b>DeviceDsmAction_Trim</b> action. </td> </tr> <tr> <td width="40%"><a
    ///id="DEVICE_DSM_FLAG_RESILIENCY_START_RESYNC"></a><a id="device_dsm_flag_resiliency_start_resync"></a><dl>
    ///<dt><b>DEVICE_DSM_FLAG_RESILIENCY_START_RESYNC</b></dt> <dt>0x10000000</dt> </dl> </td> <td width="60%"> Starts a
    ///resync operation on the storage device. This flag is specific to the <b>DeviceDsmAction_Resiliency</b> action.
    ///</td> </tr> <tr> <td width="40%"><a id="DEVICE_DSM_FLAG_RESILIENCY_START_LOAD_BALANCING"></a><a
    ///id="device_dsm_flag_resiliency_start_load_balancing"></a><dl>
    ///<dt><b>DEVICE_DSM_FLAG_RESILIENCY_START_LOAD_BALANCING</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%">
    ///Starts a load balancing operation on the storage device. This flag is specific to the
    ///<b>DeviceDsmAction_Resiliency</b> action. </td> </tr> </table>
    uint Flags;
    ///Byte offset to the start of the parameter block stored in the buffer contiguous to this structure. Must be
    ///aligned to the corresponding structure alignment. A value of zero indicates there is no parameter block and the
    ///<b>ParameterBlockLength</b> member must also be zero.
    uint ParameterBlockOffset;
    ///Length of the parameter block, in bytes. A value of zero indicates there is no parameter block and the
    ///<b>ParameterBlockOffset</b> member must also be zero.
    uint ParameterBlockLength;
    ///Byte offset to the start of the data set ranges block made up of an array of DEVICE_DATA_SET_RANGE structures
    ///stored in the buffer contiguous to this structure. Must be aligned to the <b>DEVICE_DATA_SET_RANGE</b> structure
    ///alignment. A value of zero indicates there is no data set ranges block and the <b>DataSetRangesLength</b> member
    ///must also be zero.
    uint DataSetRangesOffset;
    ///Length of the data set ranges block, in bytes. A value of zero indicates there is no data set ranges block and
    ///the <b>DataSetRangesOffset</b> member must also be zero.
    uint DataSetRangesLength;
}

///Output structure for the IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES control code.
struct DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT
{
    ///Size of the structure. This is set to <code>sizeof(DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT)</code>.
    uint Size;
    ///The action related to the instance of this structure. This is a value for the DEVICE_DATA_MANAGEMENT_SET_ACTION
    ///data type. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_Trim"></a><a id="devicedsmaction_trim"></a><a id="DEVICEDSMACTION_TRIM"></a><dl>
    ///<dt><b>DeviceDsmAction_Trim</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> A trim action is performed. This
    ///value is not supported for user-mode applications. </td> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_Notification"></a><a id="devicedsmaction_notification"></a><a
    ///id="DEVICEDSMACTION_NOTIFICATION"></a><dl> <dt><b>DeviceDsmAction_Notification</b></dt> <dt>2 |
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000002)</dt> </dl> </td> <td width="60%"> A notification action is
    ///performed. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit flag to indicate to the driver
    ///stack that this operation is non-destructive. </td> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_OffloadRead"></a><a id="devicedsmaction_offloadread"></a><a
    ///id="DEVICEDSMACTION_OFFLOADREAD"></a><dl> <dt><b>DeviceDsmAction_OffloadRead</b></dt> <dt>3 |
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000003)</dt> </dl> </td> <td width="60%"> An offload read action
    ///is performed. The output described by the <b>OutputBlockOffset</b> and <b>OutputBlockLength</b> members is a
    ///STORAGE_OFFLOAD_READ_OUTPUT structure. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit flag
    ///to indicate to the driver stack that this operation is non-destructive. </td> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_OffloadWrite"></a><a id="devicedsmaction_offloadwrite"></a><a
    ///id="DEVICEDSMACTION_OFFLOADWRITE"></a><dl> <dt><b>DeviceDsmAction_OffloadWrite</b></dt> <dt>4</dt> </dl> </td>
    ///<td width="60%"> An offload write action is performed. The output described by the <b>OutputBlockOffset</b> and
    ///<b>OutputBlockLength</b> members is a STORAGE_OFFLOAD_WRITE_OUTPUT structure. </td> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_Allocation"></a><a id="devicedsmaction_allocation"></a><a
    ///id="DEVICEDSMACTION_ALLOCATION"></a><dl> <dt><b>DeviceDsmAction_Allocation</b></dt> <dt>5 |
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000005)</dt> </dl> </td> <td width="60%"> An allocation bitmap is
    ///returned for the first data set range passed in. The output is in a DEVICE_DATA_SET_LB_PROVISIONING_STATE
    ///structure. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit flag to indicate to the driver
    ///stack that this operation is non-destructive. </td> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_Repair"></a><a id="devicedsmaction_repair"></a><a id="DEVICEDSMACTION_REPAIR"></a><dl>
    ///<dt><b>DeviceDsmAction_Repair</b></dt> <dt>6 | <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000006)</dt> </dl>
    ///</td> <td width="60%"> A repair action is performed. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000)
    ///is a bit flag to indicate to the driver stack that this operation is non-destructive. <b>Windows 7 and Windows
    ///Server 2008 R2: </b>This value is not supported before Windows 8 and Windows Server 2012. </td> </tr> <tr> <td
    ///width="40%"><a id="DeviceDsmAction_Scrub"></a><a id="devicedsmaction_scrub"></a><a
    ///id="DEVICEDSMACTION_SCRUB"></a><dl> <dt><b>DeviceDsmAction_Scrub</b></dt> <dt>7 |
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000007)</dt> </dl> </td> <td width="60%"> A scrub action is
    ///performed. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit flag to indicate to the driver
    ///stack that this operation is non-destructive. <b>Windows 7 and Windows Server 2008 R2: </b>This value is not
    ///supported before Windows 8 and Windows Server 2012. </td> </tr> <tr> <td width="40%"><a
    ///id="DeviceDsmAction_Resiliency"></a><a id="devicedsmaction_resiliency"></a><a
    ///id="DEVICEDSMACTION_RESILIENCY"></a><dl> <dt><b>DeviceDsmAction_Resiliency</b></dt> <dt>8 |
    ///<b>DeviceDsmActionFlag_NonDestructive</b> (0x80000008)</dt> </dl> </td> <td width="60%"> A resiliency action is
    ///performed. The <b>DeviceDsmActionFlag_NonDestructive</b> (0x80000000) is a bit flag to indicate to the driver
    ///stack that this operation is non-destructive. <b>Windows 7 and Windows Server 2008 R2: </b>This value is not
    ///supported before Windows 8 and Windows Server 2012. </td> </tr> </table>
    uint Action;
    ///Not used.
    uint Flags;
    ///Not used.
    uint OperationStatus;
    ///Extended error information.
    uint ExtendedError;
    ///Target specific error.
    uint TargetDetailedError;
    ///Reserved.
    uint ReservedStatus;
    ///The offset, in bytes, from the beginning of this structure to where any action-specific data is located.
    uint OutputBlockOffset;
    ///The length, in bytes, of the action-specific data.
    uint OutputBlockLength;
}

struct DEVICE_DSM_DEFINITION
{
    uint  Action;
    ubyte SingleRange;
    uint  ParameterBlockAlignment;
    uint  ParameterBlockLength;
    ubyte HasOutput;
    uint  OutputBlockAlignment;
    uint  OutputBlockLength;
}

///Contains parameters for the <b>DeviceDsmAction_Notification</b> action for the
///IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES control code.
struct DEVICE_DSM_NOTIFICATION_PARAMETERS
{
    ///Specifies the total size, in bytes, of this structure. The value of this member must include the total size, in
    ///bytes, of the <b>FileTypeIDs</b> member.
    uint    Size;
    ///Flags specific to the notify operation <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="DEVICE_DSM_NOTIFY_FLAG_BEGIN"></a><a id="device_dsm_notify_flag_begin"></a><dl>
    ///<dt><b>DEVICE_DSM_NOTIFY_FLAG_BEGIN</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The ranges
    ///specified in the DEVICE_DATA_SET_RANGE structures following the DEVICE_MANAGE_DATA_SET_ATTRIBUTES structure are
    ///currently being used by the file types that are specified in the <b>FileTypeIDs</b> member. </td> </tr> <tr> <td
    ///width="40%"><a id="DEVICE_DSM_NOTIFY_FLAG_END"></a><a id="device_dsm_notify_flag_end"></a><dl>
    ///<dt><b>DEVICE_DSM_NOTIFY_FLAG_END</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The ranges are no
    ///longer being used by the file types that are specified in the <b>FileTypeIDs</b> member. </td> </tr> </table>
    uint    Flags;
    ///The number of entries in the <b>FileTypeIDs</b> member.
    uint    NumFileTypeIDs;
    ///One or more <b>GUID</b> values that specify the file type for the notification operation. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE"></a><a
    ///id="file_type_notification_guid_page_file"></a><dl> <dt><b>FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE</b></dt>
    ///<dt>0d0a64a1-38fc-4db8-9fe7-3f4352cd7c5c</dt> </dl> </td> <td width="60%"> Specifies a notification operation for
    ///a page file. </td> </tr> <tr> <td width="40%"><a id="FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE"></a><a
    ///id="file_type_notification_guid_hibernation_file"></a><dl>
    ///<dt><b>FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE</b></dt> <dt>b7624d64-b9a3-4cf8-8011-5b86c940e7b7</dt> </dl>
    ///</td> <td width="60%"> Specifies a notification operation for the system hibernation file. </td> </tr> <tr> <td
    ///width="40%"><a id="FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE"></a><a
    ///id="file_type_notification_guid_crashdump_file"></a><dl>
    ///<dt><b>FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE</b></dt> <dt>9d453eb7-d2a6-4dbd-a2e3-fbd0ed9109a9</dt> </dl>
    ///</td> <td width="60%"> Specifies a notification operation for a system crash dump file. </td> </tr> </table>
    GUID[1] FileTypeID;
}

///Contains the token used to represent a portion of a file used in by offload read and write operations specified by
///<b>DeviceDsmAction_OffloadRead</b> or <b>DeviceDsmAction_OffloadWrite</b> actions for the
///IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES control code.
struct STORAGE_OFFLOAD_TOKEN
{
    ///A 32-bit unsigned integer which defines the type of <b>Token</b>.
    ubyte[4] TokenType;
    ///Reserved.
    ubyte[2] Reserved;
    ///The length of the token data in <b>Token</b>.
    ubyte[2] TokenIdLength;
union
    {
struct StorageOffloadZeroDataToken
        {
            ubyte[504] Reserved2;
        }
        ubyte[504] Token;
    }
}

///Contains parameters for the <b>DeviceDsmAction_OffloadRead</b> action for the
///IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES control code.
struct DEVICE_DSM_OFFLOAD_READ_PARAMETERS
{
    ///Set to 0.
    uint    Flags;
    ///The time to live (TTL) for the token, in milliseconds.
    uint    TimeToLive;
    ///Set to 0.
    uint[2] Reserved;
}

///Output structure for the <b>DeviceDsmAction_OffloadRead</b> action of the IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES
///control code.
struct STORAGE_OFFLOAD_READ_OUTPUT
{
    ///Output flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STORAGE_OFFLOAD_READ_RANGE_TRUNCATED"></a><a id="storage_offload_read_range_truncated"></a><dl>
    ///<dt><b>STORAGE_OFFLOAD_READ_RANGE_TRUNCATED</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> The ranges
    ///represented by the token is smaller than the ranges specified in the DEVICE_DATA_SET_RANGE structures passed in
    ///the IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES control code input buffer. In other words the <b>LengthProtected</b>
    ///member is less than the sum of all of the <b>LengthInBytes</b> members of the <b>DEVICE_DATA_SET_RANGE</b>
    ///structures passed. </td> </tr> </table>
    uint  OffloadReadFlags;
    ///Reserved.
    uint  Reserved;
    ///The total length of the snapshot represented by the token.
    ulong LengthProtected;
    ///Length of the token in bytes.
    uint  TokenLength;
    ///A STORAGE_OFFLOAD_TOKEN containing the token created.
    STORAGE_OFFLOAD_TOKEN Token;
}

///Specifies parameters for the offload write operation. An offload write operation is initiated by specifying
///<b>DeviceDsmAction_OffloadWrite</b> in the <b>Action</b> member of the DEVICE_MANAGE_DATA_SET_ATTRIBUTES structure
///passed in a IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES control code.
struct DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS
{
    ///Set to 0.
    uint  Flags;
    ///Reserved.
    uint  Reserved;
    ///The starting offset to copy from the range bound to the token
    ulong TokenOffset;
    ///STORAGE_OFFLOAD_TOKEN structure containing the token returned from the offload read operation.
    STORAGE_OFFLOAD_TOKEN Token;
}

///Output structure for the <b>DeviceDsmAction_OffloadWrite</b> action of the IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES
///control code.
struct STORAGE_OFFLOAD_WRITE_OUTPUT
{
    ///Out flags <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STORAGE_OFFLOAD_WRITE_RANGE_TRUNCATED"></a><a id="storage_offload_write_range_truncated"></a><dl>
    ///<dt><b>STORAGE_OFFLOAD_WRITE_RANGE_TRUNCATED</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> The range
    ///written is less than the range specified. </td> </tr> <tr> <td width="40%"><a
    ///id="STORAGE_OFFLOAD_TOKEN_INVALID"></a><a id="storage_offload_token_invalid"></a><dl>
    ///<dt><b>STORAGE_OFFLOAD_TOKEN_INVALID</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> The token specified is
    ///not valid. </td> </tr> </table>
    uint  OffloadWriteFlags;
    ///Reserved.
    uint  Reserved;
    ///The length of the copied content.
    ulong LengthCopied;
}

struct DEVICE_DATA_SET_LBP_STATE_PARAMETERS
{
    uint Version;
    uint Size;
    uint Flags;
    uint OutputVersion;
}

///Output structure for the <b>DeviceDsmAction_Allocation</b> action of the IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES
///control code.
struct DEVICE_DATA_SET_LB_PROVISIONING_STATE
{
    ///The size of this structure, including the bitmap, in bytes.
    uint    Size;
    ///The version of this structure.
    uint    Version;
    ///The size of a slab, in bytes.
    ulong   SlabSizeInBytes;
    ///If the range specified is not aligned to the <b>OptimalUnmapGranularity</b> as returned in
    ///DEVICE_LB_PROVISIONING_DESCRIPTOR structure then the data represented in the <b>SlabAllocationBitMap</b> is
    ///offset from the specified range by this amount.
    uint    SlabOffsetDeltaInBytes;
    ///The number of relevant bits in the bitmap.
    uint    SlabAllocationBitMapBitCount;
    ///The number of<b> DWORD</b>s in the bitmap array.
    uint    SlabAllocationBitMapLength;
    ///The allocation bitmap containing one bit for each slab. If a bit is set then the corresponding slab is allocated.
    ///Otherwise, if a bit is clear, the corresponding slab is unallocated.
    uint[1] SlabAllocationBitMap;
}

struct DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2
{
    uint    Size;
    uint    Version;
    ulong   SlabSizeInBytes;
    ulong   SlabOffsetDeltaInBytes;
    uint    SlabAllocationBitMapBitCount;
    uint    SlabAllocationBitMapLength;
    uint[1] SlabAllocationBitMap;
}

///Specifies parameters for the repair operation. A repair operation is initiated by specifying
///<b>DeviceDsmAction_Repair</b> in the <b>Action</b> member of the DEVICE_MANAGE_DATA_SET_ATTRIBUTES structure passed
///in a IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES control code.
struct DEVICE_DATA_SET_REPAIR_PARAMETERS
{
    ///The number of copies that will be repaired.
    uint    NumberOfRepairCopies;
    ///The copy number of the source copy.
    uint    SourceCopy;
    ///The copy numbers of all the copies that will be repaired.
    uint[1] RepairCopies;
}

struct DEVICE_DATA_SET_REPAIR_OUTPUT
{
    DEVICE_DATA_SET_RANGE ParityExtent;
}

struct DEVICE_DATA_SET_SCRUB_OUTPUT
{
    ulong BytesProcessed;
    ulong BytesRepaired;
    ulong BytesFailed;
}

struct DEVICE_DATA_SET_SCRUB_EX_OUTPUT
{
    ulong BytesProcessed;
    ulong BytesRepaired;
    ulong BytesFailed;
    DEVICE_DATA_SET_RANGE ParityExtent;
}

struct DEVICE_DSM_TIERING_QUERY_INPUT
{
    uint    Version;
    uint    Size;
    uint    Flags;
    uint    NumberOfTierIds;
    GUID[1] TierIds;
}

struct STORAGE_TIER_REGION
{
    GUID  TierId;
    ulong Offset;
    ulong Length;
}

struct DEVICE_DSM_TIERING_QUERY_OUTPUT
{
    uint  Version;
    uint  Size;
    uint  Flags;
    uint  Reserved;
    ulong Alignment;
    uint  TotalNumberOfRegions;
    uint  NumberOfRegionsReturned;
    STORAGE_TIER_REGION[1] Regions;
}

struct DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS
{
    uint     Size;
    ubyte    TargetPriority;
    ubyte[3] Reserved;
}

struct DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT
{
    ulong     TopologyRangeBytes;
    ubyte[16] TopologyId;
}

struct DEVICE_STORAGE_ADDRESS_RANGE
{
    long  StartAddress;
    ulong LengthInBytes;
}

struct DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT
{
    uint Version;
    uint Flags;
    uint TotalNumberOfRanges;
    uint NumberOfRangesReturned;
    DEVICE_STORAGE_ADDRESS_RANGE[1] Ranges;
}

struct DEVICE_DSM_REPORT_ZONES_PARAMETERS
{
    uint     Size;
    ubyte    ReportOption;
    ubyte    Partial;
    ubyte[2] Reserved;
}

struct STORAGE_ZONE_DESCRIPTOR
{
    uint               Size;
    STORAGE_ZONE_TYPES ZoneType;
    STORAGE_ZONE_CONDITION ZoneCondition;
    ubyte              ResetWritePointerRecommend;
    ubyte[3]           Reserved0;
    ulong              ZoneSize;
    ulong              WritePointerOffset;
}

struct DEVICE_DSM_REPORT_ZONES_DATA
{
    uint Size;
    uint ZoneCount;
    STORAGE_ZONES_ATTRIBUTES Attributes;
    uint Reserved0;
    STORAGE_ZONE_DESCRIPTOR[1] ZoneDescriptors;
}

struct DEVICE_STORAGE_RANGE_ATTRIBUTES
{
    ulong LengthInBytes;
union
    {
        uint AllFlags;
struct
        {
            uint _bitfield114;
        }
    }
    uint  Reserved;
}

struct DEVICE_DSM_RANGE_ERROR_INFO
{
    uint Version;
    uint Flags;
    uint TotalNumberOfRanges;
    uint NumberOfRangesReturned;
    DEVICE_STORAGE_RANGE_ATTRIBUTES[1] Ranges;
}

struct DEVICE_DSM_LOST_QUERY_PARAMETERS
{
    uint  Version;
    ulong Granularity;
}

struct DEVICE_DSM_LOST_QUERY_OUTPUT
{
    uint    Version;
    uint    Size;
    ulong   Alignment;
    uint    NumberOfBits;
    uint[1] BitMap;
}

struct DEVICE_DSM_FREE_SPACE_OUTPUT
{
    uint  Version;
    ulong FreeSpace;
}

struct DEVICE_DSM_CONVERSION_OUTPUT
{
    uint Version;
    GUID Source;
}

struct STORAGE_GET_BC_PROPERTIES_OUTPUT
{
    uint  MaximumRequestsPerPeriod;
    uint  MinimumPeriod;
    ulong MaximumRequestSize;
    uint  EstimatedTimePerRequest;
    uint  NumOutStandingRequests;
    ulong RequestSize;
}

struct STORAGE_ALLOCATE_BC_STREAM_INPUT
{
    uint     Version;
    uint     RequestsPerPeriod;
    uint     Period;
    ubyte    RetryFailures;
    ubyte    Discardable;
    ubyte[2] Reserved1;
    uint     AccessType;
    uint     AccessMode;
}

struct STORAGE_ALLOCATE_BC_STREAM_OUTPUT
{
    ulong RequestSize;
    uint  NumOutStandingRequests;
}

struct STORAGE_PRIORITY_HINT_SUPPORT
{
    uint SupportFlags;
}

struct STORAGE_DIAGNOSTIC_REQUEST
{
    uint Version;
    uint Size;
    uint Reserved;
    STORAGE_DIAGNOSTIC_TARGET_TYPE TargetType;
    STORAGE_DIAGNOSTIC_LEVEL Level;
}

struct STORAGE_DIAGNOSTIC_DATA
{
    uint     Version;
    uint     Size;
    GUID     ProviderId;
    uint     BufferSize;
    uint     Reserved;
    ubyte[1] DiagnosticDataBuffer;
}

struct PHYSICAL_ELEMENT_STATUS_REQUEST
{
    uint     Version;
    uint     Size;
    uint     StartingElement;
    ubyte    Filter;
    ubyte    ReportType;
    ubyte[2] Reserved;
}

struct PHYSICAL_ELEMENT_STATUS_DESCRIPTOR
{
    uint     Version;
    uint     Size;
    uint     ElementIdentifier;
    ubyte    PhysicalElementType;
    ubyte    PhysicalElementHealth;
    ubyte[2] Reserved1;
    ulong    AssociatedCapacity;
    uint[4]  Reserved2;
}

struct PHYSICAL_ELEMENT_STATUS
{
    uint Version;
    uint Size;
    uint DescriptorCount;
    uint ReturnedDescriptorCount;
    uint ElementIdentifierBeingDepoped;
    uint Reserved;
    PHYSICAL_ELEMENT_STATUS_DESCRIPTOR[1] Descriptors;
}

struct REMOVE_ELEMENT_AND_TRUNCATE_REQUEST
{
    uint  Version;
    uint  Size;
    ulong RequestCapacity;
    uint  ElementIdentifier;
    uint  Reserved;
}

struct GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST
{
    uint Version;
    uint Size;
    DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE RequestDataType;
    DEVICE_INTERNAL_STATUS_DATA_SET RequestDataSet;
}

struct DEVICE_INTERNAL_STATUS_DATA
{
    uint       Version;
    uint       Size;
    ulong      T10VendorId;
    uint       DataSet1Length;
    uint       DataSet2Length;
    uint       DataSet3Length;
    uint       DataSet4Length;
    ubyte      StatusDataVersion;
    ubyte[3]   Reserved;
    ubyte[128] ReasonIdentifier;
    uint       StatusDataLength;
    ubyte[1]   StatusData;
}

struct STORAGE_MEDIA_SERIAL_NUMBER_DATA
{
    ushort   Reserved;
    ushort   SerialNumberLength;
    ubyte[1] SerialNumber;
}

struct STORAGE_READ_CAPACITY
{
    uint          Version;
    uint          Size;
    uint          BlockLength;
    LARGE_INTEGER NumberOfBlocks;
    LARGE_INTEGER DiskLength;
}

struct PERSISTENT_RESERVE_COMMAND
{
    uint Version;
    uint Size;
union
    {
struct PR_IN
        {
            ubyte  _bitfield115;
            ushort AllocationLength;
        }
struct PR_OUT
        {
            ubyte    _bitfield1;
            ubyte    _bitfield2;
            ubyte[1] ParameterList;
        }
    }
}

struct DEVICEDUMP_SUBSECTION_POINTER
{
align (1):
    uint dwSize;
    uint dwFlags;
    uint dwOffset;
}

struct DEVICEDUMP_STRUCTURE_VERSION
{
align (1):
    uint dwSignature;
    uint dwVersion;
    uint dwSize;
}

struct DEVICEDUMP_SECTION_HEADER
{
align (1):
    GUID       guidDeviceDataId;
    ubyte[16]  sOrganizationID;
    uint       dwFirmwareRevision;
    ubyte[32]  sModelNumber;
    ubyte[32]  szDeviceManufacturingID;
    uint       dwFlags;
    uint       bRestrictedPrivateDataVersion;
    uint       dwFirmwareIssueId;
    ubyte[132] szIssueDescriptionString;
}

struct GP_LOG_PAGE_DESCRIPTOR
{
align (1):
    ushort LogAddress;
    ushort LogSectors;
}

struct DEVICEDUMP_PUBLIC_SUBSECTION
{
align (1):
    uint     dwFlags;
    GP_LOG_PAGE_DESCRIPTOR[16] GPLogTable;
    byte[16] szDescription;
    ubyte[1] bData;
}

struct DEVICEDUMP_RESTRICTED_SUBSECTION
{
    ubyte[1] bData;
}

struct DEVICEDUMP_PRIVATE_SUBSECTION
{
align (1):
    uint     dwFlags;
    GP_LOG_PAGE_DESCRIPTOR GPLogId;
    ubyte[1] bData;
}

struct DEVICEDUMP_STORAGEDEVICE_DATA
{
align (1):
    DEVICEDUMP_STRUCTURE_VERSION Descriptor;
    DEVICEDUMP_SECTION_HEADER SectionHeader;
    uint dwBufferSize;
    uint dwReasonForCollection;
    DEVICEDUMP_SUBSECTION_POINTER PublicData;
    DEVICEDUMP_SUBSECTION_POINTER RestrictedData;
    DEVICEDUMP_SUBSECTION_POINTER PrivateData;
}

struct DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD
{
align (1):
    ubyte[16] Cdb;
    ubyte[16] Command;
    ulong     StartTime;
    ulong     EndTime;
    uint      OperationStatus;
    uint      OperationError;
union StackSpecific
    {
struct ExternalStack
        {
        align (1):
            uint dwReserved;
        }
struct AtaPort
        {
        align (1):
            uint dwAtaPortSpecific;
        }
struct StorPort
        {
        align (1):
            uint SrbTag;
        }
    }
}

struct DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP
{
align (1):
    DEVICEDUMP_STRUCTURE_VERSION Descriptor;
    uint      dwReasonForCollection;
    ubyte[16] cDriverName;
    uint      uiNumRecords;
    DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD[1] RecordArray;
}

struct STORAGE_IDLE_POWER
{
    uint Version;
    uint Size;
    uint _bitfield116;
    uint D3IdleTimeout;
}

struct STORAGE_IDLE_POWERUP_REASON
{
    uint Version;
    uint Size;
    STORAGE_POWERUP_REASON_TYPE PowerupReason;
}

///Using the information from IOCTL_STORAGE_QUERY_PROPERTY, an application can create an RPMB frame to perform one of
///the following actions: • Program Authentication Key • Query RPMB Write Counter • Authenticated Write •
///Authenticated Read • Authenticated Device Configuration Write • Authenticated Device Configuration Read
struct STORAGE_RPMB_DATA_FRAME
{
    ///Reserved space.
    ubyte[196] Stuff;
    ///Either the key to be programmed or the MAC authenticating this frame or series of frames.
    ubyte[32]  KeyOrMAC;
    ///The data input or output.
    ubyte[256] Data;
    ///Random 128-bit number generated by host. Only required for reads.
    ubyte[16]  Nonce;
    ///32-bit counter. Only required for writes.
    ubyte[4]   WriteCounter;
    ///The half-sector address to operate on.
    ubyte[2]   Address;
    ///The count of half-sector blocks to read/write.
    ubyte[2]   BlockCount;
    ///The result of the operation.
    ubyte[2]   OperationResult;
    ///The type of request or response.
    ubyte[2]   RequestOrResponseType;
}

struct STORAGE_EVENT_NOTIFICATION
{
    uint  Version;
    uint  Size;
    ulong Events;
}

struct STORAGE_COUNTER
{
    STORAGE_COUNTER_TYPE Type;
union Value
    {
struct ManufactureDate
        {
            uint Week;
            uint Year;
        }
        ulong AsUlonglong;
    }
}

struct STORAGE_COUNTERS
{
    uint               Version;
    uint               Size;
    uint               NumberOfCounters;
    STORAGE_COUNTER[1] Counters;
}

struct STORAGE_HW_FIRMWARE_INFO_QUERY
{
    uint Version;
    uint Size;
    uint Flags;
    uint Reserved;
}

struct STORAGE_HW_FIRMWARE_SLOT_INFO
{
    uint      Version;
    uint      Size;
    ubyte     SlotNumber;
    ubyte     _bitfield117;
    ubyte[6]  Reserved1;
    ubyte[16] Revision;
}

struct STORAGE_HW_FIRMWARE_INFO
{
    uint     Version;
    uint     Size;
    ubyte    _bitfield118;
    ubyte    SlotCount;
    ubyte    ActiveSlot;
    ubyte    PendingActivateSlot;
    ubyte    FirmwareShared;
    ubyte[3] Reserved;
    uint     ImagePayloadAlignment;
    uint     ImagePayloadMaxSize;
    STORAGE_HW_FIRMWARE_SLOT_INFO[1] Slot;
}

struct STORAGE_HW_FIRMWARE_DOWNLOAD_V2
{
    uint     Version;
    uint     Size;
    uint     Flags;
    ubyte    Slot;
    ubyte[3] Reserved;
    ulong    Offset;
    ulong    BufferSize;
    uint     ImageSize;
    uint     Reserved2;
    ubyte[1] ImageBuffer;
}

struct STORAGE_ATTRIBUTE_MGMT
{
    uint Version;
    uint Size;
    STORAGE_ATTRIBUTE_MGMT_ACTION Action;
    uint Attribute;
}

struct SCM_PD_HEALTH_NOTIFICATION_DATA
{
    GUID DeviceGuid;
}

struct SCM_LOGICAL_DEVICE_INSTANCE
{
    uint        Version;
    uint        Size;
    GUID        DeviceGuid;
    ushort[256] SymbolicLink;
}

struct SCM_LOGICAL_DEVICES
{
    uint Version;
    uint Size;
    uint DeviceCount;
    SCM_LOGICAL_DEVICE_INSTANCE[1] Devices;
}

struct SCM_PHYSICAL_DEVICE_INSTANCE
{
    uint        Version;
    uint        Size;
    uint        NfitHandle;
    ushort[256] SymbolicLink;
}

struct SCM_PHYSICAL_DEVICES
{
    uint Version;
    uint Size;
    uint DeviceCount;
    SCM_PHYSICAL_DEVICE_INSTANCE[1] Devices;
}

struct SCM_REGION
{
    uint  Version;
    uint  Size;
    uint  Flags;
    uint  NfitHandle;
    GUID  LogicalDeviceGuid;
    GUID  AddressRangeType;
    uint  AssociatedId;
    ulong Length;
    ulong StartingDPA;
    ulong BaseSPA;
    ulong SPAOffset;
    ulong RegionOffset;
}

struct SCM_REGIONS
{
    uint          Version;
    uint          Size;
    uint          RegionCount;
    SCM_REGION[1] Regions;
}

struct SCM_INTERLEAVED_PD_INFO
{
    uint DeviceHandle;
    GUID DeviceGuid;
}

struct SCM_LD_INTERLEAVE_SET_INFO
{
    uint Version;
    uint Size;
    uint InterleaveSetSize;
    SCM_INTERLEAVED_PD_INFO[1] InterleaveSet;
}

struct SCM_PD_PROPERTY_QUERY
{
    uint               Version;
    uint               Size;
    SCM_PD_PROPERTY_ID PropertyId;
    SCM_PD_QUERY_TYPE  QueryType;
    ubyte[1]           AdditionalParameters;
}

struct SCM_PD_DESCRIPTOR_HEADER
{
    uint Version;
    uint Size;
}

struct SCM_PD_DEVICE_HANDLE
{
    uint Version;
    uint Size;
    GUID DeviceGuid;
    uint DeviceHandle;
}

struct SCM_PD_DEVICE_INFO
{
    uint      Version;
    uint      Size;
    GUID      DeviceGuid;
    uint      UnsafeShutdownCount;
    ulong     PersistentMemorySizeInBytes;
    ulong     VolatileMemorySizeInBytes;
    ulong     TotalMemorySizeInBytes;
    uint      SlotNumber;
    uint      DeviceHandle;
    ushort    PhysicalId;
    ubyte     NumberOfFormatInterfaceCodes;
    ushort[8] FormatInterfaceCodes;
    uint      VendorId;
    uint      ProductId;
    uint      SubsystemDeviceId;
    uint      SubsystemVendorId;
    ubyte     ManufacturingLocation;
    ubyte     ManufacturingWeek;
    ubyte     ManufacturingYear;
    uint      SerialNumber4Byte;
    uint      SerialNumberLengthInChars;
    byte[1]   SerialNumber;
}

struct SCM_PD_DEVICE_SPECIFIC_PROPERTY
{
    ushort[128] Name;
    long        Value;
}

struct SCM_PD_DEVICE_SPECIFIC_INFO
{
    uint Version;
    uint Size;
    uint NumberOfProperties;
    SCM_PD_DEVICE_SPECIFIC_PROPERTY[1] DeviceSpecificProperties;
}

struct SCM_PD_FIRMWARE_SLOT_INFO
{
    uint      Version;
    uint      Size;
    ubyte     SlotNumber;
    ubyte     _bitfield119;
    ubyte[6]  Reserved1;
    ubyte[32] Revision;
}

struct SCM_PD_FIRMWARE_INFO
{
    uint  Version;
    uint  Size;
    ubyte ActiveSlot;
    ubyte NextActiveSlot;
    ubyte SlotCount;
    SCM_PD_FIRMWARE_SLOT_INFO[1] Slots;
}

struct SCM_PD_MANAGEMENT_STATUS
{
    uint                 Version;
    uint                 Size;
    SCM_PD_HEALTH_STATUS Health;
    uint                 NumberOfOperationalStatus;
    uint                 NumberOfAdditionalReasons;
    SCM_PD_OPERATIONAL_STATUS[16] OperationalStatus;
    SCM_PD_OPERATIONAL_STATUS_REASON[1] AdditionalReasons;
}

struct SCM_PD_LOCATION_STRING
{
    uint      Version;
    uint      Size;
    ushort[1] Location;
}

struct SCM_PD_FIRMWARE_DOWNLOAD
{
    uint     Version;
    uint     Size;
    uint     Flags;
    ubyte    Slot;
    ubyte[3] Reserved;
    ulong    Offset;
    uint     FirmwareImageSizeInBytes;
    ubyte[1] FirmwareImage;
}

struct SCM_PD_FIRMWARE_ACTIVATE
{
    uint  Version;
    uint  Size;
    uint  Flags;
    ubyte Slot;
}

struct SCM_PD_PASSTHROUGH_INPUT
{
    uint     Version;
    uint     Size;
    GUID     ProtocolGuid;
    uint     DataSize;
    ubyte[1] Data;
}

struct SCM_PD_PASSTHROUGH_OUTPUT
{
    uint     Version;
    uint     Size;
    GUID     ProtocolGuid;
    uint     DataSize;
    ubyte[1] Data;
}

struct SCM_PD_PASSTHROUGH_INVDIMM_INPUT
{
    uint     Opcode;
    uint     OpcodeParametersLength;
    ubyte[1] OpcodeParameters;
}

struct SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT
{
    ushort   GeneralStatus;
    ushort   ExtendedStatus;
    uint     OutputDataLength;
    ubyte[1] OutputData;
}

struct SCM_PD_REINITIALIZE_MEDIA_INPUT
{
    uint Version;
    uint Size;
struct Options
    {
        uint _bitfield120;
    }
}

struct SCM_PD_REINITIALIZE_MEDIA_OUTPUT
{
    uint Version;
    uint Size;
    SCM_PD_MEDIA_REINITIALIZATION_STATUS Status;
}

struct SET_PARTITION_INFORMATION_EX
{
    PARTITION_STYLE PartitionStyle;
union
    {
        SET_PARTITION_INFORMATION Mbr;
        PARTITION_INFORMATION_GPT Gpt;
    }
}

struct DISK_CONTROLLER_NUMBER
{
    uint ControllerNumber;
    uint DiskNumber;
}

struct HISTOGRAM_BUCKET
{
    uint Reads;
    uint Writes;
}

struct DISK_HISTOGRAM
{
    LARGE_INTEGER     DiskSize;
    LARGE_INTEGER     Start;
    LARGE_INTEGER     End;
    LARGE_INTEGER     Average;
    LARGE_INTEGER     AverageRead;
    LARGE_INTEGER     AverageWrite;
    uint              Granularity;
    uint              Size;
    uint              ReadCount;
    uint              WriteCount;
    HISTOGRAM_BUCKET* Histogram;
}

struct DISK_RECORD
{
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    void*         VirtualAddress;
    uint          NumberOfBytes;
    ubyte         DeviceNumber;
    ubyte         ReadRequest;
}

struct DISK_LOGGING
{
    ubyte Function;
    void* BufferAddress;
    uint  BufferSize;
}

struct BIN_RANGE
{
    LARGE_INTEGER StartValue;
    LARGE_INTEGER Length;
}

struct PERF_BIN
{
    uint         NumberOfBins;
    uint         TypeOfBin;
    BIN_RANGE[1] BinsRanges;
}

struct BIN_COUNT
{
    BIN_RANGE BinRange;
    uint      BinCount;
}

struct BIN_RESULTS
{
    uint         NumberOfBins;
    BIN_COUNT[1] BinCounts;
}

struct GETVERSIONINPARAMS
{
align (1):
    ubyte   bVersion;
    ubyte   bRevision;
    ubyte   bReserved;
    ubyte   bIDEDeviceMap;
    uint    fCapabilities;
    uint[4] dwReserved;
}

struct IDEREGS
{
    ubyte bFeaturesReg;
    ubyte bSectorCountReg;
    ubyte bSectorNumberReg;
    ubyte bCylLowReg;
    ubyte bCylHighReg;
    ubyte bDriveHeadReg;
    ubyte bCommandReg;
    ubyte bReserved;
}

struct SENDCMDINPARAMS
{
align (1):
    uint     cBufferSize;
    IDEREGS  irDriveRegs;
    ubyte    bDriveNumber;
    ubyte[3] bReserved;
    uint[4]  dwReserved;
    ubyte[1] bBuffer;
}

struct DRIVERSTATUS
{
align (1):
    ubyte    bDriverError;
    ubyte    bIDEError;
    ubyte[2] bReserved;
    uint[2]  dwReserved;
}

struct SENDCMDOUTPARAMS
{
align (1):
    uint         cBufferSize;
    DRIVERSTATUS DriverStatus;
    ubyte[1]     bBuffer;
}

///Represents a changer element.
struct CHANGER_ELEMENT
{
    ///The element type. This parameter can be one of the values from the ELEMENT_TYPE enumeration type.
    ELEMENT_TYPE ElementType;
    ///The zero-based address of the element.
    uint         ElementAddress;
}

///Represents a range of elements of a single type, typically for an operation such as getting or initializing the
///status of multiple elements.
struct CHANGER_ELEMENT_LIST
{
    ///A CHANGER_ELEMENT structure that represent the first element in the range.
    CHANGER_ELEMENT Element;
    ///The number of elements in the range.
    uint            NumberOfElements;
}

///Represents the parameters of a changer.
struct GET_CHANGER_PARAMETERS
{
    ///The size of this structure, in bytes. The caller must set this member to
    ///<code>sizeof(GET_CHANGER_PARAMETERS)</code>.
    uint     Size;
    ///The number of transport elements in the changer. For a SCSI changer, this is defined in the element address page.
    ///This value is almost always 1, because most changers have a single transport element with one or two picker
    ///mechanisms. A changer that has two picker mechanisms on its transport must not be represented as having two
    ///transports, because pickers are not individually addressable. High-end media libraries can have dual and multiple
    ///transport elements for fault tolerance.
    ushort   NumberTransportElements;
    ///The number of storage elements (slots) in the changer. For a SCSI changer, this is defined in the element address
    ///page. This value represents the maximum number of slots available for this changer including those in removable
    ///magazines, whether or not the magazines are installed. If <b>NumberCleanerSlots</b> is 1, then
    ///<b>NumberStorageElements</b> is 1 less than the maximum number of slots in the changer.
    ushort   NumberStorageElements;
    ///The number of storage elements (slots) for cleaner cartridges in the changer. If <b>NumberCleanerSlots</b> is 1,
    ///then <b>FirstCleanerSlotAddress</b> indicates the zero-based address of the slot in which a drive cleaner should
    ///be inserted. If the changer does not support drive cleaning by programmatically moving the cleaner cartridge from
    ///its slot to a drive, <b>NumberCleanerSlots</b> is 0. <b>NumberCleanerSlots</b> cannot be greater than 1.
    ushort   NumberCleanerSlots;
    ///The number of import/export elements (insert/eject ports) the changer has for inserting and ejecting media. For a
    ///SCSI changer, this is defined in the element address page. An import/export element must not be part of the
    ///storage element (slot) space, and it must be possible to transport media between the import/export element and a
    ///slot using a MOVE MEDIUM command. If the changer has a door and not a true import/export element,
    ///<b>NumberIEElements</b> is 0.
    ushort   NumberIEElements;
    ///The number of data transfer elements (drives) in the changer. For a SCSI changer, this is defined in the element
    ///address page. Unlike <b>NumberStorageElements</b>, which indicates the total number of possible slots whether or
    ///not the slots are actually present, <b>NumberDataTransferElements</b> indicates the number of drives that are
    ///actually present in the changer.
    ushort   NumberDataTransferElements;
    ///The number of doors in the changer. A door provides access to all media in the changer at once, unlike an
    ///insert/eject port, which provides access to one or more, but not all, media. A changer's door can be a physical
    ///front door or a single magazine that contains all media. If a changer supports only an insert/eject port for
    ///inserting and ejecting media, <b>NumberOfDoors</b> is 0.
    ushort   NumberOfDoors;
    ///The number used by the changer vendor to identify the first storage element (slot) in the changer to the end
    ///user, either by marking a magazine or by defining a slot numbering scheme in the changer's operators guide.
    ///<b>FirstSlotNumber</b> is typically 0 or 1, but it can be the first address in a consecutive range of slot
    ///addresses defined by the vendor.
    ushort   FirstSlotNumber;
    ///The number used by the changer vendor to identify the first data transfer element (drive) in the changer to the
    ///end user. <b>FirstDriveNumber</b> is typically 0 or 1, but it can be the first address in a consecutive range of
    ///drive addresses defined by the vendor.
    ushort   FirstDriveNumber;
    ///The number used by the changer vendor to identify the first (and usually only) transport element in the changer
    ///to the end user. <b>FirstTransportNumber</b> is typically 0 or 1, but it can be the first address in a
    ///consecutive range of transport addresses defined by the vendor.
    ushort   FirstTransportNumber;
    ///The number used by the changer vendor to identify the first (and usually only) insert/eject port in the changer
    ///to the end user. <b>FirstIEPortNumber</b> is typically 0 or 1, but it can be the first address in a consecutive
    ///range of insert/eject port addresses defined by the vendor. If <b>NumberIEElements</b> is 0,
    ///<b>FirstIEPortNumber</b> must also be 0.
    ushort   FirstIEPortNumber;
    ///The number used by the changer vendor to identify the first (and only) slot address assigned to a drive cleaner
    ///cartridge to the end user. This must be the value defined by the vendor in the changer's operators guide. For
    ///example, if a changer has 8 slots numbered 1 through 8 and its operator's guide designates slot 8 as the drive
    ///cleaner slot, <b>FirstSlotNumber</b> would be 1 and <b>FirstCleanerSlotAddress</b> would be 8. If the same 8
    ///slots were numbered 0 through 7, <b>FirstSlotNumber</b> would be 0 and <b>FirstCleanerSlotAddress</b> would be 7.
    ///If <b>NumberCleanerSlots</b> is 0, <b>FirstCleanerSlotAddress</b> must be 0.
    ushort   FirstCleanerSlotAddress;
    ///The number of slots in the removable magazines in the changer. This member is valid only if
    ///CHANGER_CARTRIDGE_MAGAZINE is set in <b>Features0</b>.
    ushort   MagazineSize;
    ///Twice the maximum number of seconds a cleaning is expected to take. The changer's drives should be cleaned by its
    ///cleaner cartridge in half the time specified by <b>DriveCleanTimeout</b>. For example, if a drive is typically
    ///cleaned in 300 seconds (5 minutes), <b>DriveCleanTimeout</b> should be set to 600.
    uint     DriveCleanTimeout;
    ///The features supported by the changer. This member can be one or more of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CHANGER_BAR_CODE_SCANNER_INSTALLED"></a><a
    ///id="changer_bar_code_scanner_installed"></a><dl> <dt><b>CHANGER_BAR_CODE_SCANNER_INSTALLED</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> The changer supports a bar-code reader and the reader is
    ///installed. </td> </tr> <tr> <td width="40%"><a id="CHANGER_CARTRIDGE_MAGAZINE"></a><a
    ///id="changer_cartridge_magazine"></a><dl> <dt><b>CHANGER_CARTRIDGE_MAGAZINE</b></dt> <dt>0x00000100</dt> </dl>
    ///</td> <td width="60%"> The changer uses removable cartridge magazines for some or all storage slots. </td> </tr>
    ///<tr> <td width="40%"><a id="CHANGER_CLEANER_ACCESS_NOT_VALID"></a><a
    ///id="changer_cleaner_access_not_valid"></a><dl> <dt><b>CHANGER_CLEANER_ACCESS_NOT_VALID</b></dt>
    ///<dt>0x00040000</dt> </dl> </td> <td width="60%"> The ELEMENT_STATUS_ACCESS flag in a CHANGER_ELEMENT_STATUS
    ///structure for a data transport element is invalid when the transport element contains a cleaning cartridge. </td>
    ///</tr> <tr> <td width="40%"><a id="CHANGER_CLEANER_SLOT"></a><a id="changer_cleaner_slot"></a><dl>
    ///<dt><b>CHANGER_CLEANER_SLOT</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The changer has a slot
    ///designated for a cleaner cartridge. If this flag is set, <b>NumberCleanerSlots</b> must be 1 and
    ///<b>FirstCleanerSlotAddress</b> must specify the address of the cleaner slot. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_CLOSE_IEPORT"></a><a id="changer_close_ieport"></a><dl> <dt><b>CHANGER_CLOSE_IEPORT</b></dt>
    ///<dt>0x00000004</dt> </dl> </td> <td width="60%"> The changer has an insert/eject port and can retract the
    ///insert/eject port programmatically. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_DEVICE_REINITIALIZE_CAPABLE"></a><a id="changer_device_reinitialize_capable"></a><dl>
    ///<dt><b>CHANGER_DEVICE_REINITIALIZE_CAPABLE</b></dt> <dt>0x08000000</dt> </dl> </td> <td width="60%"> The changer
    ///can recalibrate its transport element in response to an explicit command. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_DRIVE_CLEANING_REQUIRED"></a><a id="changer_drive_cleaning_required"></a><dl>
    ///<dt><b>CHANGER_DRIVE_CLEANING_REQUIRED</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> The changer's
    ///drives require periodic cleaning, which must be initiated by either the user or an application, and the changer
    ///can use its transport element to mount a cleaner cartridge in a drive. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS"></a><a id="changer_drive_empty_on_door_access"></a><dl>
    ///<dt><b>CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%"> The changer
    ///requires all drives to be empty (dismounted) before they can be accessed through its door. </td> </tr> <tr> <td
    ///width="40%"><a id="CHANGER_EXCHANGE_MEDIA"></a><a id="changer_exchange_media"></a><dl>
    ///<dt><b>CHANGER_EXCHANGE_MEDIA</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> The changer can exchange
    ///media between elements. For a SCSI changer, this flag indicates whether the changer supports the EXCHANGE MEDIUM
    ///command. </td> </tr> <tr> <td width="40%"><a id="CHANGER_INIT_ELEM_STAT_WITH_RANGE"></a><a
    ///id="changer_init_elem_stat_with_range"></a><dl> <dt><b>CHANGER_INIT_ELEM_STAT_WITH_RANGE</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The changer can initialize elements within a specified range.
    ///For a SCSI changer, this flag indicates whether the changer supports the INITIALIZE ELEMENT STATUS WITH RANGE
    ///command. </td> </tr> <tr> <td width="40%"><a id="CHANGER_KEYPAD_ENABLE_DISABLE"></a><a
    ///id="changer_keypad_enable_disable"></a><dl> <dt><b>CHANGER_KEYPAD_ENABLE_DISABLE</b></dt> <dt>0x10000000</dt>
    ///</dl> </td> <td width="60%"> The changer keypad can be enabled and disabled programmatically. </td> </tr> <tr>
    ///<td width="40%"><a id="CHANGER_LOCK_UNLOCK"></a><a id="changer_lock_unlock"></a><dl>
    ///<dt><b>CHANGER_LOCK_UNLOCK</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> The changer's door,
    ///insert/eject port, or keypad can be locked or unlocked programmatically. If this flag is set,
    ///<b>LockUnlockCapabilities</b> indicates which elements can be locked or unlocked. </td> </tr> <tr> <td
    ///width="40%"><a id="CHANGER_MEDIUM_FLIP"></a><a id="changer_medium_flip"></a><dl>
    ///<dt><b>CHANGER_MEDIUM_FLIP</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> The changer's transport
    ///element supports flipping (rotating) media. For a SCSI changer, this flag reflects the rotate bit in the
    ///transport geometry parameters page. </td> </tr> <tr> <td width="40%"><a id="CHANGER_OPEN_IEPORT"></a><a
    ///id="changer_open_ieport"></a><dl> <dt><b>CHANGER_OPEN_IEPORT</b></dt> <dt>0x00000008</dt> </dl> </td> <td
    ///width="60%"> The changer has an insert/eject port and can extend the insert/eject port programmatically. </td>
    ///</tr> <tr> <td width="40%"><a id="CHANGER_POSITION_TO_ELEMENT"></a><a id="changer_position_to_element"></a><dl>
    ///<dt><b>CHANGER_POSITION_TO_ELEMENT</b></dt> <dt>0x00000400</dt> </dl> </td> <td width="60%"> The changer can
    ///position the transport to a particular destination. For a SCSI changer, this flag indicates whether the changer
    ///supports the POSITION TO ELEMENT command. If this flag is set, <b>PositionCapabilities</b> indicates the elements
    ///to which the transport can be positioned. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_PREDISMOUNT_EJECT_REQUIRED"></a><a id="changer_predismount_eject_required"></a><dl>
    ///<dt><b>CHANGER_PREDISMOUNT_EJECT_REQUIRED</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> The changer
    ///requires an explicit command issued through a mass-storage driver (tape, disk, or CDROM, for example) to eject
    ///media from a drive before the changer can move the media from a drive to a slot. </td> </tr> <tr> <td
    ///width="40%"><a id="CHANGER_PREMOUNT_EJECT_REQUIRED"></a><a id="changer_premount_eject_required"></a><dl>
    ///<dt><b>CHANGER_PREMOUNT_EJECT_REQUIRED</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> The changer
    ///requires an explicit command issued through a mass storage driver to eject a drive mechanism before the changer
    ///can move media from a slot to the drive. For example, a changer with CD-ROM drives might require the tray to be
    ///presented to the robotic transport so that a piece of media could be loaded onto the tray during a mount
    ///operation. </td> </tr> <tr> <td width="40%"><a id="CHANGER_REPORT_IEPORT_STATE"></a><a
    ///id="changer_report_ieport_state"></a><dl> <dt><b>CHANGER_REPORT_IEPORT_STATE</b></dt> <dt>0x00000800</dt> </dl>
    ///</td> <td width="60%"> The changer can report whether media is present in the insert/eject port. Such a changer
    ///must have a sensor in the insert/eject port to detect the presence or absence of media. </td> </tr> <tr> <td
    ///width="40%"><a id="CHANGER_SERIAL_NUMBER_VALID"></a><a id="changer_serial_number_valid"></a><dl>
    ///<dt><b>CHANGER_SERIAL_NUMBER_VALID</b></dt> <dt>0x04000000</dt> </dl> </td> <td width="60%"> The serial number is
    ///valid and unique for all changers of this type. Serial numbers are not guaranteed to be unique across vendor and
    ///product lines. </td> </tr> <tr> <td width="40%"><a id="CHANGER_STATUS_NON_VOLATILE"></a><a
    ///id="changer_status_non_volatile"></a><dl> <dt><b>CHANGER_STATUS_NON_VOLATILE</b></dt> <dt>0x00000010</dt> </dl>
    ///</td> <td width="60%"> The changer uses nonvolatile memory for element status information. </td> </tr> <tr> <td
    ///width="40%"><a id="CHANGER_STORAGE_DRIVE"></a><a id="changer_storage_drive"></a><dl>
    ///<dt><b>CHANGER_STORAGE_DRIVE</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> The changer can use a
    ///drive as an independent storage element; that is, it can store media in the drive without reading it. For a SCSI
    ///changer, this flag reflects the state of the DT bit in the device capabilities page. </td> </tr> <tr> <td
    ///width="40%"><a id="CHANGER_STORAGE_IEPORT"></a><a id="changer_storage_ieport"></a><dl>
    ///<dt><b>CHANGER_STORAGE_IEPORT</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> The changer can use an
    ///insert/eject port as an independent storage element. For a SCSI changer, this flag reflects the state of the I/E
    ///bit in the device capabilities page. </td> </tr> <tr> <td width="40%"><a id="CHANGER_STORAGE_SLOT"></a><a
    ///id="changer_storage_slot"></a><dl> <dt><b>CHANGER_STORAGE_SLOT</b></dt> <dt>0x00004000</dt> </dl> </td> <td
    ///width="60%"> The changer can use a slot as an independent storage element for media. For a SCSI changer, this
    ///flag reflects the state of the ST bit in the device capabilities page. Slots are the normal storage location for
    ///media, so the changer must support this functionality. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_STORAGE_TRANSPORT"></a><a id="changer_storage_transport"></a><dl>
    ///<dt><b>CHANGER_STORAGE_TRANSPORT</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> The changer can use a
    ///transport as an independent storage element. For a SCSI changer, this flag reflects the state of the MT bit in
    ///the device capabilities page. </td> </tr> <tr> <td width="40%"><a id="CHANGER_VOLUME_ASSERT"></a><a
    ///id="changer_volume_assert"></a><dl> <dt><b>CHANGER_VOLUME_ASSERT</b></dt> <dt>0x00400000</dt> </dl> </td> <td
    ///width="60%"> The changer can verify volume information. For a SCSI changer, this flag indicates whether the
    ///changer supports the SEND VOLUME TAG command with a send action code of ASSERT. </td> </tr> <tr> <td
    ///width="40%"><a id="CHANGER_VOLUME_IDENTIFICATION"></a><a id="changer_volume_identification"></a><dl>
    ///<dt><b>CHANGER_VOLUME_IDENTIFICATION</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The changer
    ///supports volume identification. For a SCSI changer, this flag indicates whether the changer supports the SEND
    ///VOLUME TAG and REQUEST VOLUME ELEMENT ADDRESS commands. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_VOLUME_REPLACE"></a><a id="changer_volume_replace"></a><dl> <dt><b>CHANGER_VOLUME_REPLACE</b></dt>
    ///<dt>0x00800000</dt> </dl> </td> <td width="60%"> The changer can replace volume information. For a SCSI changer,
    ///this flag indicates whether the changer supports the SEND VOLUME TAG command with a send action code of REPLACE.
    ///</td> </tr> <tr> <td width="40%"><a id="CHANGER_VOLUME_SEARCH"></a><a id="changer_volume_search"></a><dl>
    ///<dt><b>CHANGER_VOLUME_SEARCH</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> The changer can search for
    ///volume information. For a SCSI changer, this flag indicates whether the changer supports the supports the SEND
    ///VOLUME TAG command with a send action code of TRANSLATE. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_VOLUME_UNDEFINE"></a><a id="changer_volume_undefine"></a><dl> <dt><b>CHANGER_VOLUME_UNDEFINE</b></dt>
    ///<dt>0x01000000</dt> </dl> </td> <td width="60%"> The changer can clear existing volume information. For a SCSI
    ///changer, this flag indicates whether the changer supports the SEND VOLUME TAG command with a send action code of
    ///UNDEFINE. </td> </tr> </table>
    uint     Features0;
    ///Any additional features supported by the changer. This member can be one or more of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CHANGER_CLEANER_AUTODISMOUNT"></a><a
    ///id="changer_cleaner_autodismount"></a><dl> <dt><b>CHANGER_CLEANER_AUTODISMOUNT</b></dt> <dt>0x80000004</dt> </dl>
    ///</td> <td width="60%"> The changer will move the cleaning cartridge back to its original slot automatically after
    ///cleaning is finished. </td> </tr> <tr> <td width="40%"><a id="CHANGER_CLEANER_OPS_NOT_SUPPORTED"></a><a
    ///id="changer_cleaner_ops_not_supported"></a><dl> <dt><b>CHANGER_CLEANER_OPS_NOT_SUPPORTED</b></dt>
    ///<dt>0x80000040</dt> </dl> </td> <td width="60%"> The changer does not support automatic cleaning of its elements.
    ///</td> </tr> <tr> <td width="40%"><a id="CHANGER_IEPORT_USER_CONTROL_CLOSE"></a><a
    ///id="changer_ieport_user_control_close"></a><dl> <dt><b>CHANGER_IEPORT_USER_CONTROL_CLOSE</b></dt>
    ///<dt>0x80000100</dt> </dl> </td> <td width="60%"> The changer requires the user to manually close an open
    ///insert/eject port. </td> </tr> <tr> <td width="40%"><a id="CHANGER_IEPORT_USER_CONTROL_OPEN"></a><a
    ///id="changer_ieport_user_control_open"></a><dl> <dt><b>CHANGER_IEPORT_USER_CONTROL_OPEN</b></dt>
    ///<dt>0x80000080</dt> </dl> </td> <td width="60%"> The changer requires the user to manually open a closed
    ///insert/eject port. </td> </tr> <tr> <td width="40%"><a id="CHANGER_MOVE_EXTENDS_IEPORT"></a><a
    ///id="changer_move_extends_ieport"></a><dl> <dt><b>CHANGER_MOVE_EXTENDS_IEPORT</b></dt> <dt>0x80000200</dt> </dl>
    ///</td> <td width="60%"> The changer will extend the tray automatically whenever a command is issued to move media
    ///to an insert/eject port. </td> </tr> <tr> <td width="40%"><a id="CHANGER_MOVE_RETRACTS_IEPORT"></a><a
    ///id="changer_move_retracts_ieport"></a><dl> <dt><b>CHANGER_MOVE_RETRACTS_IEPORT</b></dt> <dt>0x80000400</dt> </dl>
    ///</td> <td width="60%"> The changer will retract the tray automatically whenever a command is issued to move media
    ///from an insert/eject port. </td> </tr> <tr> <td width="40%"><a id="CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE"></a><a
    ///id="changer_predismount_align_to_drive"></a><dl> <dt><b>CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE</b></dt>
    ///<dt>0x80000002</dt> </dl> </td> <td width="60%"> The changer requires an explicit command to position the
    ///transport element to a drive before it can eject media from the drive. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_PREDISMOUNT_ALIGN_TO_SLOT"></a><a id="changer_predismount_align_to_slot"></a><dl>
    ///<dt><b>CHANGER_PREDISMOUNT_ALIGN_TO_SLOT</b></dt> <dt>0x80000001</dt> </dl> </td> <td width="60%"> The changer
    ///requires an explicit command to position the transport element to a slot before it can eject media from the slot.
    ///</td> </tr> <tr> <td width="40%"><a id="CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR"></a><a
    ///id="changer_rtn_media_to_original_addr"></a><dl> <dt><b>CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR</b></dt>
    ///<dt>0x80000020</dt> </dl> </td> <td width="60%"> The changer requires media to be returned to its original slot
    ///after it has been moved. </td> </tr> <tr> <td width="40%"><a id="CHANGER_SLOTS_USE_TRAYS"></a><a
    ///id="changer_slots_use_trays"></a><dl> <dt><b>CHANGER_SLOTS_USE_TRAYS</b></dt> <dt>0x80000010</dt> </dl> </td> <td
    ///width="60%"> The changer uses removable trays in its slots, which require the media to be placed in a tray and
    ///the tray moved to the desired position. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_TRUE_EXCHANGE_CAPABLE"></a><a id="changer_true_exchange_capable"></a><dl>
    ///<dt><b>CHANGER_TRUE_EXCHANGE_CAPABLE</b></dt> <dt>0x80000008</dt> </dl> </td> <td width="60%"> The changer can
    ///exchange media between a source and a destination in a single operation. This flag is valid only if
    ///CHANGER_EXCHANGE_MEDIA is also set in <b>Features0</b>. </td> </tr> </table>
    uint     Features1;
    ///Indicates whether the changer supports moving a piece of media from a transport element to another transport
    ///element, a storage slot, an insert/eject port, or a drive. For a SCSI changer, this is defined in the device
    ///capabilities page. The transport is not typically the source or destination for moving or exchanging media. To
    ///determine whether the changer can move media to a given element, use the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CHANGER_TO_DRIVE"></a><a
    ///id="changer_to_drive"></a><dl> <dt><b>CHANGER_TO_DRIVE</b></dt> <dt>0x08</dt> </dl> </td> <td width="60%"> The
    ///changer can carry out the operation from the specified element to a drive. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_TO_IEPORT"></a><a id="changer_to_ieport"></a><dl> <dt><b>CHANGER_TO_IEPORT</b></dt> <dt>0x04</dt>
    ///</dl> </td> <td width="60%"> The changer can carry out the operation from the specified element to an
    ///insert/eject port. </td> </tr> <tr> <td width="40%"><a id="CHANGER_TO_SLOT"></a><a id="changer_to_slot"></a><dl>
    ///<dt><b>CHANGER_TO_SLOT</b></dt> <dt>0x02</dt> </dl> </td> <td width="60%"> The changer can carry out the
    ///operation from the specified element to a storage slot. </td> </tr> <tr> <td width="40%"><a
    ///id="CHANGER_TO_TRANSPORT"></a><a id="changer_to_transport"></a><dl> <dt><b>CHANGER_TO_TRANSPORT</b></dt>
    ///<dt>0x01</dt> </dl> </td> <td width="60%"> The changer can carry out the operation from the specified element to
    ///a transport. </td> </tr> </table>
    ubyte    MoveFromTransport;
    ///Indicates whether the changer supports moving medium from a storage slot to a transport element, another storage
    ///slot, an insert/eject port, or a drive. Use the flags described under <b>MoveFromTransport</b> to determine
    ///whether the changer supports the move.
    ubyte    MoveFromSlot;
    ///Indicates whether the changer supports moving medium from an insert/eject port to a transport element, a storage
    ///slot, another insert/eject port, or a drive. For a SCSI changer, this is defined in the device capabilities page.
    ///Use the flags described under <b>MoveFromTransport</b> to determine whether the changer supports the move.
    ubyte    MoveFromIePort;
    ///Indicates whether the changer supports moving medium from a drive to a transport element, a storage slot, an
    ///insert/eject port, or another drive. Use the flags described under <b>MoveFromTransport</b> to determine whether
    ///the changer supports the move.
    ubyte    MoveFromDrive;
    ///Indicates whether the changer supports exchanging medium between a transport element and another transport
    ///element, a storage slot, an insert/eject port, or a drive. Use the flags described under <b>MoveFromTransport</b>
    ///to determine whether the changer supports the exchange.
    ubyte    ExchangeFromTransport;
    ///Indicates whether the changer supports exchanging medium between a storage slot and a transport element, another
    ///storage slot, an insert/eject port, or a drive. Use the flags described under <b>MoveFromTransport</b> to
    ///determine whether the changer supports the exchange.
    ubyte    ExchangeFromSlot;
    ///Indicates whether the changer supports exchanging medium between an insert/eject port and a transport element, a
    ///storage slot, another insert/eject port, or a drive. Use the flags described under <b>MoveFromTransport</b> to
    ///determine whether the changer supports the exchange.
    ubyte    ExchangeFromIePort;
    ///Indicates whether the changer supports exchanging medium between a drive and a transport element, a storage slot,
    ///an insert/eject port, or another drive. Use the flags described under <b>MoveFromTransport</b> to determine
    ///whether the changer supports the exchange.
    ubyte    ExchangeFromDrive;
    ///The elements of a changer that can be locked or unlocked programmatically. This member is valid only if
    ///CHANGER_LOCK_UNLOCK is set in <b>Features0</b>. To determine whether the changer can lock or unlock a particular
    ///element, use one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="LOCK_UNLOCK_DOOR"></a><a id="lock_unlock_door"></a><dl> <dt><b>LOCK_UNLOCK_DOOR</b></dt>
    ///<dt>0x02</dt> </dl> </td> <td width="60%"> The changer can lock or unlock its door. </td> </tr> <tr> <td
    ///width="40%"><a id="LOCK_UNLOCK_IEPORT"></a><a id="lock_unlock_ieport"></a><dl> <dt><b>LOCK_UNLOCK_IEPORT</b></dt>
    ///<dt>0x01</dt> </dl> </td> <td width="60%"> The changer can lock or unlock its insert/eject port. </td> </tr> <tr>
    ///<td width="40%"><a id="LOCK_UNLOCK_KEYPAD"></a><a id="lock_unlock_keypad"></a><dl>
    ///<dt><b>LOCK_UNLOCK_KEYPAD</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> The changer can lock or unlock its
    ///keypad. </td> </tr> </table>
    ubyte    LockUnlockCapabilities;
    ///The elements to which a changer can position its transport. Use the flags described under
    ///<b>MoveFromTransport</b> to determine whether the changer supports positioning the transport to a particular
    ///element. This member is valid only if CHANGER_POSITION_TO_ELEMENT is set in <b>Features0</b>.
    ubyte    PositionCapabilities;
    ///Reserved for future use.
    ubyte[2] Reserved1;
    ///Reserved for future use.
    uint[2]  Reserved2;
}

///Represents product data for a changer device. It is used by the IOCTL_CHANGER_GET_PRODUCT_DATA control code.
struct CHANGER_PRODUCT_DATA
{
    ///The device manufacturer's name. This is acquired directly from the device inquiry data.
    ubyte[8]  VendorId;
    ///The product identification, as defined by the vendor. This is acquired directly from the device inquiry data.
    ubyte[16] ProductId;
    ///The product revision, as defined by the vendor.
    ubyte[4]  Revision;
    ///A unique value used to globally identify this device, as defined by the vendor.
    ubyte[32] SerialNumber;
    ///The device type of data transports, as defined by SCSI-2. This member must be <b>FILE_DEVICE_CHANGER</b>.
    ubyte     DeviceType;
}

///Contains information that the IOCTL_CHANGER_SET_ACCESS control code needs to set the state of the device's
///insert/eject port, door, or keypad.
struct CHANGER_SET_ACCESS
{
    ///A CHANGER_ELEMENT structure that represents the changer element. The <b>ElementType</b> member can be one of the
    ///following values: ChangerDoor, ChangerIEPort, or ChangerKeypad.
    CHANGER_ELEMENT Element;
    ///The operation to be performed. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="EXTEND_IEPORT"></a><a id="extend_ieport"></a><dl> <dt><b>EXTEND_IEPORT</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> The element is to be extended. Requires that <b>Features0</b> is CHANGER_OPEN_IEPORT. </td> </tr>
    ///<tr> <td width="40%"><a id="LOCK_ELEMENT"></a><a id="lock_element"></a><dl> <dt><b>LOCK_ELEMENT</b></dt>
    ///<dt>0</dt> </dl> </td> <td width="60%"> The element is to be locked. Requires that <b>Features0</b> is
    ///CHANGER_LOCK_UNLOCK. </td> </tr> <tr> <td width="40%"><a id="RETRACT_IEPORT"></a><a id="retract_ieport"></a><dl>
    ///<dt><b>RETRACT_IEPORT</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The element is to be retracted. Requires
    ///that <b>Features0</b> is CHANGER_CLOSE_IEPORT. </td> </tr> <tr> <td width="40%"><a id="UNLOCK_ELEMENT"></a><a
    ///id="unlock_element"></a><dl> <dt><b>UNLOCK_ELEMENT</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The element
    ///is to be unlocked. Requires that <b>Features0</b> is CHANGER_LOCK_UNLOCK. </td> </tr> </table>
    uint            Control;
}

///Contains information that the IOCTL_CHANGER_GET_ELEMENT_STATUS control code needs to determine the elements whose
///status is to be retrieved.
struct CHANGER_READ_ELEMENT_STATUS
{
    ///A CHANGER_ELEMENT_LIST structure that contains an array of structures that represents the range of elements for
    ///which information is to be retrieved. The <b>ElementType</b> member of each structure can be one of the following
    ///values: ChangerDrive, ChangerSlot, ChangerTransport, ChangerIEPort, or AllElements.
    CHANGER_ELEMENT_LIST ElementList;
    ///If this member is <b>TRUE</b>, volume tag information is to be retrieved. Otherwise, no volume information is
    ///retrieved. A volume tag can be a bar code or an application-defined value. This member is valid only if the
    ///<b>Features0</b> member of the GET_CHANGER_PARAMETERS structure is CHANGER_BAR_CODE_SCANNER_INSTALLED or
    ///CHANGER_VOLUME_IDENTIFICATION.
    ubyte                VolumeTagInfo;
}

///Represents the status of the specified element.
struct CHANGER_ELEMENT_STATUS
{
    ///A CHANGER_ELEMENT structure that represents the element.
    CHANGER_ELEMENT Element;
    ///A CHANGER_ELEMENT structure that represents the element from which the media currently in this element was most
    ///recently moved. This member is valid only if the <b>Flags</b> member includes ELEMENT_STATUS_SVALID.
    CHANGER_ELEMENT SrcElementAddress;
    ///The element status. This member can be one or more of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ELEMENT_STATUS_ACCESS"></a><a
    ///id="element_status_access"></a><dl> <dt><b>ELEMENT_STATUS_ACCESS</b></dt> <dt>0x00000008</dt> </dl> </td> <td
    ///width="60%"> The changer's transport element can access the piece of media in this element. The media is not
    ///accessible in the following circumstances: (1) If the element type is ChangerSlot, the slot is not present in the
    ///changer (for example, the magazine containing the slot has been physically removed). (2) If the element type is
    ///ChangerDrive, the drive is broken or has been removed. (3) If the element type is ChangerIEPort, the changer's
    ///insert/eject port is extended. </td> </tr> <tr> <td width="40%"><a id="ELEMENT_STATUS_AVOLTAG"></a><a
    ///id="element_status_avoltag"></a><dl> <dt><b>ELEMENT_STATUS_AVOLTAG</b></dt> <dt>0x20000000</dt> </dl> </td> <td
    ///width="60%"> Alternate volume information in the <b>AlternateVolumeID</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="ELEMENT_STATUS_EXCEPT"></a><a id="element_status_except"></a><dl>
    ///<dt><b>ELEMENT_STATUS_EXCEPT</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The element is in an
    ///abnormal state. Check the <b>ExceptionCode</b> member for more information. </td> </tr> <tr> <td width="40%"><a
    ///id="ELEMENT_STATUS_EXENAB"></a><a id="element_status_exenab"></a><dl> <dt><b>ELEMENT_STATUS_EXENAB</b></dt>
    ///<dt>0x00000010</dt> </dl> </td> <td width="60%"> The element supports export of media through the changer's
    ///insert/eject port. </td> </tr> <tr> <td width="40%"><a id="ELEMENT_STATUS_FULL"></a><a
    ///id="element_status_full"></a><dl> <dt><b>ELEMENT_STATUS_FULL</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> The element contains a piece of media. Note that this value is valid only if the element type is
    ///ChangerDrive, ChangerSlot, or ChangerTransport. If <b>ElementType</b> is ChangerIEPort, this value is valid only
    ///if the <b>Features0</b> member of GET_CHANGER_PARAMETERS includes CHANGER_REPORT_IEPORT_STATE. </td> </tr> <tr>
    ///<td width="40%"><a id="ELEMENT_STATUS_ID_VALID"></a><a id="element_status_id_valid"></a><dl>
    ///<dt><b>ELEMENT_STATUS_ID_VALID</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> The SCSI target ID in
    ///the <b>TargetID</b> member is valid. This value is valid only if the element type is ChangerDrive. </td> </tr>
    ///<tr> <td width="40%"><a id="ELEMENT_STATUS_IMPEXP"></a><a id="element_status_impexp"></a><dl>
    ///<dt><b>ELEMENT_STATUS_IMPEXP</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The media in this element
    ///was placed there by an operator. This value is valid only if the element type is ChangerIEPort. </td> </tr> <tr>
    ///<td width="40%"><a id="ELEMENT_STATUS_INENAB"></a><a id="element_status_inenab"></a><dl>
    ///<dt><b>ELEMENT_STATUS_INENAB</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> The element supports
    ///import of media through the changer's insert/eject port. </td> </tr> <tr> <td width="40%"><a
    ///id="ELEMENT_STATUS_INVERT"></a><a id="element_status_invert"></a><dl> <dt><b>ELEMENT_STATUS_INVERT</b></dt>
    ///<dt>0x00400000</dt> </dl> </td> <td width="60%"> The media in the element was flipped. This value is valid only
    ///if ELEMENT_STATUS_SVALID is also included. </td> </tr> <tr> <td width="40%"><a
    ///id="ELEMENT_STATUS_LUN_VALID"></a><a id="element_status_lun_valid"></a><dl>
    ///<dt><b>ELEMENT_STATUS_LUN_VALID</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> The logical unit number
    ///in the <b>Lun</b> member is valid. This value is valid only if the element type is ChangerDrive. </td> </tr> <tr>
    ///<td width="40%"><a id="ELEMENT_STATUS_NOT_BUS"></a><a id="element_status_not_bus"></a><dl>
    ///<dt><b>ELEMENT_STATUS_NOT_BUS</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> The drive at the address
    ///indicated by <b>Lun</b> and <b>TargetID</b> is on a different SCSI bus than the changer itself. </td> </tr> <tr>
    ///<td width="40%"><a id="ELEMENT_STATUS_PVOLTAG"></a><a id="element_status_pvoltag"></a><dl>
    ///<dt><b>ELEMENT_STATUS_PVOLTAG</b></dt> <dt>0x10000000</dt> </dl> </td> <td width="60%"> Primary volume
    ///information in the <b>PrimaryVolumeID</b> member is valid. </td> </tr> <tr> <td width="40%"><a
    ///id="ELEMENT_STATUS_SVALID"></a><a id="element_status_svalid"></a><dl> <dt><b>ELEMENT_STATUS_SVALID</b></dt>
    ///<dt>0x00800000</dt> </dl> </td> <td width="60%"> The <b>SourceElement</b> member and ELEMENT_STATUS_INVERT are
    ///both valid. </td> </tr> </table>
    uint            Flags;
    ///An exception code that indicates that the element is in an abnormal state. This member is valid only if the
    ///<b>Flags</b> member includes ELEMENT_STATUS_EXCEPT. This member can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ERROR_DRIVE_NOT_INSTALLED"></a><a
    ///id="error_drive_not_installed"></a><dl> <dt><b>ERROR_DRIVE_NOT_INSTALLED</b></dt> <dt>0x00000008</dt> </dl> </td>
    ///<td width="60%"> The drive at this element address is absent. </td> </tr> <tr> <td width="40%"><a
    ///id="ERROR_LABEL_QUESTIONABLE"></a><a id="error_label_questionable"></a><dl>
    ///<dt><b>ERROR_LABEL_QUESTIONABLE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The label might be
    ///invalid due to a unit attention condition. </td> </tr> <tr> <td width="40%"><a id="ERROR_LABEL_UNREADABLE"></a><a
    ///id="error_label_unreadable"></a><dl> <dt><b>ERROR_LABEL_UNREADABLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> The changer's barcode reader could not read the bar code label on the piece of media in this
    ///element, because the media is missing, damaged, improperly positioned, or upside down. </td> </tr> <tr> <td
    ///width="40%"><a id="ERROR_SLOT_NOT_PRESENT"></a><a id="error_slot_not_present"></a><dl>
    ///<dt><b>ERROR_SLOT_NOT_PRESENT</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The slot at this element
    ///address is currently not installed in the changer. Each slot in a removable magazine is reported not present to
    ///indicate that the magazine has been removed. </td> </tr> <tr> <td width="40%"><a
    ///id="ERROR_TRAY_MALFUNCTION"></a><a id="error_tray_malfunction"></a><dl> <dt><b>ERROR_TRAY_MALFUNCTION</b></dt>
    ///<dt>0x00000010</dt> </dl> </td> <td width="60%"> The drive at this element address has a tray that must be
    ///extended to load or remove media, and the tray is not extending as required. </td> </tr> <tr> <td width="40%"><a
    ///id="ERROR_UNHANDLED_ERROR"></a><a id="error_unhandled_error"></a><dl> <dt><b>ERROR_UNHANDLED_ERROR</b></dt>
    ///<dt>0xFFFFFFFF</dt> </dl> </td> <td width="60%"> Unknown error condition. </td> </tr> </table>
    uint            ExceptionCode;
    ///For a SCSI changer, specifies the SCSI target ID of the drive at this element address. This member is valid only
    ///if the <b>ElementType</b> member of the <b>Element</b> structure is ChangerDrive and the <b>Flags</b> member
    ///includes ELEMENT_STATUS_ID_VALID.
    ubyte           TargetId;
    ///The SCSI logical unit number of the drive at this element address. This member is valid only if the
    ///<b>ElementType</b> member of the <b>Element</b> structure is ChangerDrive and the <b>Flags</b> member includes
    ///ELEMENT_STATUS_LUN_VALID.
    ubyte           Lun;
    ///Reserved for future use. The value of this member must be zero.
    ushort          Reserved;
    ///The primary volume identifier for the media. If the changer supports a barcode reader and the reader is installed
    ///(as indicated by CHANGER_BAR_CODE_SCANNER_INSTALLED in the <b>Features0</b> member of GET_CHANGER_PARAMETERS),
    ///<b>PrimaryVolumeID</b> is the bar code of the media. If the changer does not support a barcode reader,
    ///<b>PrimaryVolumeID</b> is the value previously assigned to the media. This member is valid only if the
    ///<b>Flags</b> member includes ELEMENT_STATUS_PVOLTAG. If the volume identifier is missing or unreadable, this
    ///member is cleared.
    ubyte[36]       PrimaryVolumeID;
    ///An alternate volume identification for the media. This member is valid only for two-sided media, and pertains to
    ///the ID of the inverted side. It never represents a bar code. This member is valid only if the <b>Flags</b> member
    ///includes ELEMENT_STATUS_AVOLTAG.
    ubyte[36]       AlternateVolumeID;
}

///Represents the status of the specified element.
struct CHANGER_ELEMENT_STATUS_EX
{
    ///A CHANGER_ELEMENT structure that represents the element to which this structure refers.
    CHANGER_ELEMENT Element;
    ///A CHANGER_ELEMENT structure that represents the element from which the media currently in this element was most
    ///recently moved. This member is valid only if the <b>Flags</b> member includes ELEMENT_STATUS_SVALID.
    CHANGER_ELEMENT SrcElementAddress;
    ///The element status. This member can be one or more of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ELEMENT_STATUS_ACCESS"></a><a
    ///id="element_status_access"></a><dl> <dt><b>ELEMENT_STATUS_ACCESS</b></dt> <dt>0x00000008</dt> </dl> </td> <td
    ///width="60%"> The changer's transport element can access the piece of media in this element. The media is not
    ///accessible in the following circumstances: (1) If the element type is ChangerSlot, the slot is not present in the
    ///changer (for example, the magazine containing the slot has been physically removed). (2) If the element type is
    ///ChangerDrive, the drive is broken or has been removed. (3) If the element type is ChangerIEPort, the changer's
    ///insert/eject port is extended. </td> </tr> <tr> <td width="40%"><a id="ELEMENT_STATUS_AVOLTAG"></a><a
    ///id="element_status_avoltag"></a><dl> <dt><b>ELEMENT_STATUS_AVOLTAG</b></dt> <dt>0x20000000</dt> </dl> </td> <td
    ///width="60%"> Alternate volume information in the <b>AlternateVolumeID</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="ELEMENT_STATUS_EXCEPT"></a><a id="element_status_except"></a><dl>
    ///<dt><b>ELEMENT_STATUS_EXCEPT</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The element is in an
    ///abnormal state. Check the <b>ExceptionCode</b> member for more information. </td> </tr> <tr> <td width="40%"><a
    ///id="ELEMENT_STATUS_EXENAB"></a><a id="element_status_exenab"></a><dl> <dt><b>ELEMENT_STATUS_EXENAB</b></dt>
    ///<dt>0x00000010</dt> </dl> </td> <td width="60%"> The element supports export of media through the changer's
    ///insert/eject port. </td> </tr> <tr> <td width="40%"><a id="ELEMENT_STATUS_FULL"></a><a
    ///id="element_status_full"></a><dl> <dt><b>ELEMENT_STATUS_FULL</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> The element contains a piece of media. Note that this value is valid only if the element type is
    ///ChangerDrive, ChangerSlot, or ChangerTransport. If the element type is ChangerIEPort, this value is valid only if
    ///the <b>Features0</b> member of GET_CHANGER_PARAMETERS includes CHANGER_REPORT_IEPORT_STATE. </td> </tr> <tr> <td
    ///width="40%"><a id="ELEMENT_STATUS_ID_VALID"></a><a id="element_status_id_valid"></a><dl>
    ///<dt><b>ELEMENT_STATUS_ID_VALID</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> The SCSI target ID in
    ///the <b>TargetID</b> member is valid. This value is valid only if the element type is ChangerDrive. </td> </tr>
    ///<tr> <td width="40%"><a id="ELEMENT_STATUS_IMPEXP"></a><a id="element_status_impexp"></a><dl>
    ///<dt><b>ELEMENT_STATUS_IMPEXP</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The media in this element
    ///was placed there by an operator. This value is valid only if the element type is ChangerIEPort. </td> </tr> <tr>
    ///<td width="40%"><a id="ELEMENT_STATUS_INENAB"></a><a id="element_status_inenab"></a><dl>
    ///<dt><b>ELEMENT_STATUS_INENAB</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> The element supports
    ///import of media through the changer's insert/eject port. </td> </tr> <tr> <td width="40%"><a
    ///id="ELEMENT_STATUS_INVERT"></a><a id="element_status_invert"></a><dl> <dt><b>ELEMENT_STATUS_INVERT</b></dt>
    ///<dt>0x00400000</dt> </dl> </td> <td width="60%"> The media in the element was flipped. This value is valid only
    ///if ELEMENT_STATUS_SVALID is also included. </td> </tr> <tr> <td width="40%"><a
    ///id="ELEMENT_STATUS_LUN_VALID"></a><a id="element_status_lun_valid"></a><dl>
    ///<dt><b>ELEMENT_STATUS_LUN_VALID</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> The logical unit number
    ///in the <b>Lun</b> member is valid. This value is valid only if the element type is ChangerDrive. </td> </tr> <tr>
    ///<td width="40%"><a id="ELEMENT_STATUS_NOT_BUS"></a><a id="element_status_not_bus"></a><dl>
    ///<dt><b>ELEMENT_STATUS_NOT_BUS</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> The drive at the address
    ///indicated by <b>Lun</b> and <b>TargetID</b> is on a different SCSI bus than the changer itself. </td> </tr> <tr>
    ///<td width="40%"><a id="ELEMENT_STATUS_PRODUCT_DATA"></a><a id="element_status_product_data"></a><dl>
    ///<dt><b>ELEMENT_STATUS_PRODUCT_DATA</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The serial number in
    ///the <b>SerialNumber</b> member is valid. </td> </tr> <tr> <td width="40%"><a id="ELEMENT_STATUS_PVOLTAG"></a><a
    ///id="element_status_pvoltag"></a><dl> <dt><b>ELEMENT_STATUS_PVOLTAG</b></dt> <dt>0x10000000</dt> </dl> </td> <td
    ///width="60%"> Primary volume information in the <b>PrimaryVolumeID</b> member is valid. </td> </tr> <tr> <td
    ///width="40%"><a id="ELEMENT_STATUS_SVALID"></a><a id="element_status_svalid"></a><dl>
    ///<dt><b>ELEMENT_STATUS_SVALID</b></dt> <dt>0x00800000</dt> </dl> </td> <td width="60%"> The <b>SourceElement</b>
    ///member and ELEMENT_STATUS_INVERT are both valid. </td> </tr> </table>
    uint            Flags;
    ///An exception code that indicates that the element is in an abnormal state. This member is valid only if the
    ///<b>Flags</b> member includes ELEMENT_STATUS_EXCEPT. This member can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ERROR_DRIVE_NOT_INSTALLED"></a><a
    ///id="error_drive_not_installed"></a><dl> <dt><b>ERROR_DRIVE_NOT_INSTALLED</b></dt> <dt>0x00000008</dt> </dl> </td>
    ///<td width="60%"> The drive at this element address is absent. </td> </tr> <tr> <td width="40%"><a
    ///id="ERROR_INIT_STATUS_NEEDED"></a><a id="error_init_status_needed"></a><dl>
    ///<dt><b>ERROR_INIT_STATUS_NEEDED</b></dt> <dt>0x00000011</dt> </dl> </td> <td width="60%"> An Initialize Element
    ///Status command is needed. </td> </tr> <tr> <td width="40%"><a id="ERROR_LABEL_QUESTIONABLE"></a><a
    ///id="error_label_questionable"></a><dl> <dt><b>ERROR_LABEL_QUESTIONABLE</b></dt> <dt>0x00000002</dt> </dl> </td>
    ///<td width="60%"> The label might be invalid due to a unit attention condition. </td> </tr> <tr> <td
    ///width="40%"><a id="ERROR_LABEL_UNREADABLE"></a><a id="error_label_unreadable"></a><dl>
    ///<dt><b>ERROR_LABEL_UNREADABLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The changer's barcode
    ///reader could not read the bar code label on the piece of media in this element, because the media is missing,
    ///damaged, improperly positioned, or upside down. </td> </tr> <tr> <td width="40%"><a
    ///id="ERROR_SLOT_NOT_PRESENT"></a><a id="error_slot_not_present"></a><dl> <dt><b>ERROR_SLOT_NOT_PRESENT</b></dt>
    ///<dt>0x00000004</dt> </dl> </td> <td width="60%"> The slot at this element address is currently not installed in
    ///the changer. Each slot in a removable magazine is reported not present to indicate that the magazine has been
    ///removed. </td> </tr> <tr> <td width="40%"><a id="ERROR_TRAY_MALFUNCTION"></a><a
    ///id="error_tray_malfunction"></a><dl> <dt><b>ERROR_TRAY_MALFUNCTION</b></dt> <dt>0x00000010</dt> </dl> </td> <td
    ///width="60%"> The drive at this element address has a tray that must be extended to load or remove media, and the
    ///tray is not extending as required. </td> </tr> <tr> <td width="40%"><a id="ERROR_UNHANDLED_ERROR"></a><a
    ///id="error_unhandled_error"></a><dl> <dt><b>ERROR_UNHANDLED_ERROR</b></dt> <dt>0xFFFFFFFF</dt> </dl> </td> <td
    ///width="60%"> Unknown error condition. </td> </tr> </table>
    uint            ExceptionCode;
    ///For a SCSI changer, specifies the SCSI target ID of the drive at this element address. This member is valid only
    ///if the <b>ElementType</b> member of the <b>Element</b> structure is ChangerDrive and the <b>Flags</b> member
    ///includes ELEMENT_STATUS_ID_VALID.
    ubyte           TargetId;
    ///The SCSI logical unit number of the drive at this element address. This member is valid only if the
    ///<b>ElementType</b> member of the <b>Element</b> structure is ChangerDrive and the <b>Flags</b> member includes
    ///ELEMENT_STATUS_LUN_VALID.
    ubyte           Lun;
    ///Reserved for future use. The value of this member must be zero.
    ushort          Reserved;
    ///The primary volume identifier for the media. If the changer supports a barcode reader and the reader is installed
    ///(as indicated by CHANGER_BAR_CODE_SCANNER_INSTALLED in the <b>Features0</b> member of GET_CHANGER_PARAMETERS),
    ///<b>PrimaryVolumeID</b> is the bar code of the media. If the changer does not support a barcode reader,
    ///<b>PrimaryVolumeID</b> is the value previously assigned to the media. This member is valid only if the
    ///<b>Flags</b> member includes ELEMENT_STATUS_PVOLTAG. If the volume identifier is missing or unreadable, this
    ///member is cleared.
    ubyte[36]       PrimaryVolumeID;
    ///An alternate volume identification for the media. This member is valid for two-sided media only, and pertains to
    ///the ID of the inverted side. It never represents a bar code. This member is valid only if the <b>Flags</b> member
    ///includes ELEMENT_STATUS_AVOLTAG.
    ubyte[36]       AlternateVolumeID;
    ///The vendor identifier.
    ubyte[8]        VendorIdentification;
    ///The product identifier.
    ubyte[16]       ProductIdentification;
    ///The serial number for the drive.
    ubyte[32]       SerialNumber;
}

///Represents the status of all media changer elements or the specified elements of a particular type.
struct CHANGER_INITIALIZE_ELEMENT_STATUS
{
    ///A CHANGER_ELEMENT_LIST structure that lists the elements and range on which to initialize. If
    ///CHANGER_INIT_ELEM_STAT_WITH_RANGE is set in the <b>Features0</b> member of GET_CHANGER_PARAMETERS, the changer
    ///supports initializing a range of elements. In this case, the <b>ElementType</b> member can be one of the
    ///following: ChangerTransport, ChangerSlot, ChangerDrive, or ChangerIEPort. Otherwise, the element type must be
    ///AllElements and the <b>NumberOfElements</b> member is ignored.
    CHANGER_ELEMENT_LIST ElementList;
    ///If this member is <b>TRUE</b>, a bar-code scan should be used. Otherwise, it should not. If the changer has
    ///nonvolatile RAM, using a bar-code scan is an optimization. This member is applicable only if
    ///CHANGER_BAR_CODE_SCANNER_INSTALLED is set in the <b>Features0</b> member of GET_CHANGER_PARAMETERS.
    ubyte                BarCodeScan;
}

///Contains information needed by the IOCTL_CHANGER_SET_POSITION control code to set the changer's robotic transport
///mechanism to the specified element address.
struct CHANGER_SET_POSITION
{
    ///A CHANGER_ELEMENT structure that indicates the transport to be moved. The <b>ElementType</b> member must be
    ///ChangerTransport.
    CHANGER_ELEMENT Transport;
    ///A CHANGER_ELEMENT structure that indicates the final destination of the transport. The <b>ElementType</b> member
    ///must be one of the following values: ChangerSlot, ChangerDrive, or ChangerIEPort.
    CHANGER_ELEMENT Destination;
    ///If this member is <b>TRUE</b>, the media currently carried by <b>Transport</b> should be flipped. Otherwise, it
    ///should not. This member is valid only if the <b>Features0</b> member of the GET_CHANGER_PARAMETERS structure is
    ///CHANGER_MEDIUM_FLIP.
    ubyte           Flip;
}

///Contains information the IOCTL_CHANGER_EXCHANGE_MEDIUM control code uses to move a piece of media to a destination,
///and the piece of media originally in the first destination to a second destination.
struct CHANGER_EXCHANGE_MEDIUM
{
    ///A CHANGER_ELEMENT structure that indicates which transport element to use for the exchange operation. The
    ///<b>ElementType</b> member of this structure must be ChangerTransport.
    CHANGER_ELEMENT Transport;
    ///A CHANGER_ELEMENT structure that indicates the element that contains the media that is to be moved.
    CHANGER_ELEMENT Source;
    ///A CHANGER_ELEMENT structure that indicates the element that is the destination of the media originally at
    ///<b>Source</b>.
    CHANGER_ELEMENT Destination1;
    ///A CHANGER_ELEMENT structure that indicates the element that is the destination of the media originally at
    ///<b>Destination1</b>.
    CHANGER_ELEMENT Destination2;
    ///If this member is <b>TRUE</b>, the medium at <b>Destination1</b> should be flipped. Otherwise, it should not.
    ///This member is valid only if the <b>Features0</b> member of the GET_CHANGER_PARAMETERS structure is
    ///CHANGER_MEDIUM_FLIP.
    ubyte           Flip1;
    ///If this member is <b>TRUE</b>, the medium at <b>Destination2</b> should be flipped. Otherwise, it should not.
    ///This member is valid only if the <b>Features0</b> member of the GET_CHANGER_PARAMETERS structure is
    ///CHANGER_MEDIUM_FLIP.
    ubyte           Flip2;
}

///Contains information that the IOCTL_CHANGER_MOVE_MEDIUM control code uses to move a piece of media to a destination.
struct CHANGER_MOVE_MEDIUM
{
    ///A CHANGER_ELEMENT structure that indicates which transport element to use for the move operation.
    CHANGER_ELEMENT Transport;
    ///A CHANGER_ELEMENT structure that indicates the element that contains the media that is to be moved.
    CHANGER_ELEMENT Source;
    ///A CHANGER_ELEMENT structure that indicates the element that is the destination of the media originally at
    ///<b>Source</b>.
    CHANGER_ELEMENT Destination;
    ///If this member is <b>TRUE</b>, the media should be flipped. Otherwise, it should not. This member is valid only
    ///if the <b>Features0</b> member of the GET_CHANGER_PARAMETERS structure is CHANGER_MEDIUM_FLIP.
    ubyte           Flip;
}

///Contains information that the IOCTL_CHANGER_QUERY_VOLUME_TAGS control code uses to determine the volume information
///to be retrieved.
struct CHANGER_SEND_VOLUME_TAG_INFORMATION
{
    ///A CHANGER_ELEMENT structure that represents the starting element for which information is to be retrieved.
    CHANGER_ELEMENT StartingElement;
    ///The action to be performed. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ASSERT_ALTERNATE"></a><a id="assert_alternate"></a><dl> <dt><b>ASSERT_ALTERNATE</b></dt> <dt>0x9</dt> </dl>
    ///</td> <td width="60%"> Define the alternate volume tag of a volume that currently has none defined. Requires that
    ///<b>Features0</b> is CHANGER_VOLUME_ASSERT. </td> </tr> <tr> <td width="40%"><a id="ASSERT_PRIMARY"></a><a
    ///id="assert_primary"></a><dl> <dt><b>ASSERT_PRIMARY</b></dt> <dt>0x8</dt> </dl> </td> <td width="60%"> Define the
    ///primary volume tag of a volume that currently has none defined. Requires that <b>Features0</b> is
    ///CHANGER_VOLUME_ASSERT. </td> </tr> <tr> <td width="40%"><a id="REPLACE_ALTERNATE"></a><a
    ///id="replace_alternate"></a><dl> <dt><b>REPLACE_ALTERNATE</b></dt> <dt>0xB</dt> </dl> </td> <td width="60%">
    ///Replace the alternate volume tag with a new tag. Requires that <b>Features0</b> is CHANGER_VOLUME_REPLACE. </td>
    ///</tr> <tr> <td width="40%"><a id="REPLACE_PRIMARY"></a><a id="replace_primary"></a><dl>
    ///<dt><b>REPLACE_PRIMARY</b></dt> <dt>0xA</dt> </dl> </td> <td width="60%"> Replace the primary volume tag with a
    ///new tag. Requires that <b>Features0</b> is CHANGER_VOLUME_REPLACE. </td> </tr> <tr> <td width="40%"><a
    ///id="SEARCH_ALL"></a><a id="search_all"></a><dl> <dt><b>SEARCH_ALL</b></dt> <dt>0x0</dt> </dl> </td> <td
    ///width="60%"> Search all defined volume tags. Requires that <b>Features0</b> is CHANGER_VOLUME_SEARCH. </td> </tr>
    ///<tr> <td width="40%"><a id="SEARCH_ALL_NO_SEQ"></a><a id="search_all_no_seq"></a><dl>
    ///<dt><b>SEARCH_ALL_NO_SEQ</b></dt> <dt>0x4</dt> </dl> </td> <td width="60%"> Search all defined volume tags, but
    ///ignore sequence numbers. Requires that <b>Features0</b> is CHANGER_VOLUME_SEARCH. </td> </tr> <tr> <td
    ///width="40%"><a id="SEARCH_ALT_NO_SEQ"></a><a id="search_alt_no_seq"></a><dl> <dt><b>SEARCH_ALT_NO_SEQ</b></dt>
    ///<dt>0x6</dt> </dl> </td> <td width="60%"> Search only alternate volume tags, but ignore sequence numbers.
    ///Requires that <b>Features0</b> is CHANGER_VOLUME_SEARCH. </td> </tr> <tr> <td width="40%"><a
    ///id="SEARCH_ALTERNATE"></a><a id="search_alternate"></a><dl> <dt><b>SEARCH_ALTERNATE</b></dt> <dt>02</dt> </dl>
    ///</td> <td width="60%"> Search only alternate volume tags. Requires that <b>Features0</b> is
    ///CHANGER_VOLUME_SEARCH. </td> </tr> <tr> <td width="40%"><a id="SEARCH_PRI_NO_SEQ"></a><a
    ///id="search_pri_no_seq"></a><dl> <dt><b>SEARCH_PRI_NO_SEQ</b></dt> <dt>05</dt> </dl> </td> <td width="60%"> Search
    ///only primary volume tags but ignore sequence numbers. Requires that <b>Features0</b> is CHANGER_VOLUME_SEARCH.
    ///</td> </tr> <tr> <td width="40%"><a id="SEARCH_PRIMARY"></a><a id="search_primary"></a><dl>
    ///<dt><b>SEARCH_PRIMARY</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> Search only primary volume tags.
    ///Requires that <b>Features0</b> is CHANGER_VOLUME_SEARCH. </td> </tr> <tr> <td width="40%"><a
    ///id="UNDEFINE_ALTERNATE"></a><a id="undefine_alternate"></a><dl> <dt><b>UNDEFINE_ALTERNATE</b></dt> <dt>0xD</dt>
    ///</dl> </td> <td width="60%"> Clear the alternate volume tag. Requires that <b>Features0</b> is
    ///CHANGER_VOLUME_UNDEFINE. </td> </tr> <tr> <td width="40%"><a id="UNDEFINE_PRIMARY"></a><a
    ///id="undefine_primary"></a><dl> <dt><b>UNDEFINE_PRIMARY</b></dt> <dt>0xC</dt> </dl> </td> <td width="60%"> Clear
    ///the primary volume tag. Requires that <b>Features0</b> is CHANGER_VOLUME_UNDEFINE. </td> </tr> </table>
    uint            ActionCode;
    ///The template that the device uses to search for volume IDs. For search operations, the template can include
    ///wildcard characters to search for volumes that match the template. Supported wildcard characters include the
    ///asterisk (*) and question mark (?). For other operations, the template must specify a single volume.
    ubyte[40]       VolumeIDTemplate;
}

///Represents the volume tag information. It is used by the IOCTL_CHANGER_QUERY_VOLUME_TAGS control code.
struct READ_ELEMENT_ADDRESS_INFO
{
    ///The number of elements matching criteria set forth by the <b>ActionCode</b> member of
    ///CHANGER_SEND_VOLUME_TAG_INFORMATION. For information on compatibility with the current device, see the
    ///<b>Features0</b> member of GET_CHANGER_PARAMETERS.
    uint NumberOfElements;
    ///An array of CHANGER_ELEMENT_STATUS structures, one for each element that corresponded with the information passed
    ///in with the CHANGER_SEND_VOLUME_TAG_INFORMATION structure.
    CHANGER_ELEMENT_STATUS[1] ElementStatus;
}

struct PATHNAME_BUFFER
{
    uint      PathNameLength;
    ushort[1] Name;
}

struct FSCTL_QUERY_FAT_BPB_BUFFER
{
    ubyte[36] First0x24BytesOfBootSector;
}

struct REFS_VOLUME_DATA_BUFFER
{
    uint             ByteCount;
    uint             MajorVersion;
    uint             MinorVersion;
    uint             BytesPerPhysicalSector;
    LARGE_INTEGER    VolumeSerialNumber;
    LARGE_INTEGER    NumberSectors;
    LARGE_INTEGER    TotalClusters;
    LARGE_INTEGER    FreeClusters;
    LARGE_INTEGER    TotalReserved;
    uint             BytesPerSector;
    uint             BytesPerCluster;
    LARGE_INTEGER    MaximumSizeOfResidentFile;
    ushort           FastTierDataFillRatio;
    ushort           SlowTierDataFillRatio;
    uint             DestagesFastTierToSlowTierRate;
    LARGE_INTEGER[9] Reserved;
}

struct STARTING_LCN_INPUT_BUFFER_EX
{
    LARGE_INTEGER StartingLcn;
    uint          Flags;
}

struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER
{
    uint          ExtentCount;
    LARGE_INTEGER StartingVcn;
struct
    {
        LARGE_INTEGER NextVcn;
        LARGE_INTEGER Lcn;
        uint          ReferenceCount;
    }
}

struct RETRIEVAL_POINTER_COUNT
{
    uint ExtentCount;
}

struct MOVE_FILE_RECORD_DATA
{
    HANDLE        FileHandle;
    LARGE_INTEGER SourceFileRecord;
    LARGE_INTEGER TargetFileRecord;
}

union USN_RECORD_UNION
{
    USN_RECORD_COMMON_HEADER Header;
    USN_RECORD_V2 V2;
    USN_RECORD_V3 V3;
    USN_RECORD_V4 V4;
}

struct BULK_SECURITY_TEST_DATA
{
    uint    DesiredAccess;
    uint[1] SecurityIds;
}

struct FILE_PREFETCH
{
    uint     Type;
    uint     Count;
    ulong[1] Prefetch;
}

struct FILE_PREFETCH_EX
{
    uint     Type;
    uint     Count;
    void*    Context;
    ulong[1] Prefetch;
}

struct FILE_ZERO_DATA_INFORMATION_EX
{
    LARGE_INTEGER FileOffset;
    LARGE_INTEGER BeyondFinalZero;
    uint          Flags;
}

struct ENCRYPTION_BUFFER
{
    uint     EncryptionOperation;
    ubyte[1] Private;
}

struct DECRYPTION_STATUS_BUFFER
{
    ubyte NoEncryptedStreams;
}

struct REQUEST_RAW_ENCRYPTED_DATA
{
    long FileOffset;
    uint Length;
}

struct ENCRYPTED_DATA_INFO
{
    ulong   StartingFileOffset;
    uint    OutputBufferOffset;
    uint    BytesWithinFileSize;
    uint    BytesWithinValidDataLength;
    ushort  CompressionFormat;
    ubyte   DataUnitShift;
    ubyte   ChunkShift;
    ubyte   ClusterShift;
    ubyte   EncryptionFormat;
    ushort  NumberOfDataBlocks;
    uint[1] DataBlockSize;
}

struct EXTENDED_ENCRYPTED_DATA_INFO
{
    uint ExtendedCode;
    uint Length;
    uint Flags;
    uint Reserved;
}

struct SI_COPYFILE
{
    uint      SourceFileNameLength;
    uint      DestinationFileNameLength;
    uint      Flags;
    ushort[1] FileNameBuffer;
}

struct FILE_INITIATE_REPAIR_OUTPUT_BUFFER
{
    ulong Hint1;
    ulong Hint2;
    ulong Clsn;
    uint  Status;
}

struct TXFS_ROLLFORWARD_REDO_INFORMATION
{
    LARGE_INTEGER LastVirtualClock;
    ulong         LastRedoLsn;
    ulong         HighestRecoveryLsn;
    uint          Flags;
}

struct TXFS_START_RM_INFORMATION
{
    uint      Flags;
    ulong     LogContainerSize;
    uint      LogContainerCountMin;
    uint      LogContainerCountMax;
    uint      LogGrowthIncrement;
    uint      LogAutoShrinkPercentage;
    uint      TmLogPathOffset;
    ushort    TmLogPathLength;
    ushort    LoggingMode;
    ushort    LogPathLength;
    ushort    Reserved;
    ushort[1] LogPath;
}

struct FILE_FS_PERSISTENT_VOLUME_INFORMATION
{
    uint VolumeFlags;
    uint FlagMask;
    uint Version;
    uint Reserved;
}

struct STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST
{
    uint RequestLevel;
    uint RequestFlags;
}

struct STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY
{
    uint                 EntryLength;
    uint                 DependencyTypeFlags;
    uint                 ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
}

struct STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY
{
    uint                 EntryLength;
    uint                 DependencyTypeFlags;
    uint                 ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    uint                 AncestorLevel;
    uint                 HostVolumeNameOffset;
    uint                 HostVolumeNameSize;
    uint                 DependentVolumeNameOffset;
    uint                 DependentVolumeNameSize;
    uint                 RelativePathOffset;
    uint                 RelativePathSize;
    uint                 DependentDeviceNameOffset;
    uint                 DependentDeviceNameSize;
}

struct STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE
{
    uint ResponseLevel;
    uint NumberEntries;
union
    {
        STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY Lev1Depends;
        STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY Lev2Depends;
    }
}

struct SD_CHANGE_MACHINE_SID_INPUT
{
    ushort CurrentMachineSIDOffset;
    ushort CurrentMachineSIDLength;
    ushort NewMachineSIDOffset;
    ushort NewMachineSIDLength;
}

struct SD_CHANGE_MACHINE_SID_OUTPUT
{
    ulong NumSDChangedSuccess;
    ulong NumSDChangedFail;
    ulong NumSDUnused;
    ulong NumSDTotal;
    ulong NumMftSDChangedSuccess;
    ulong NumMftSDChangedFail;
    ulong NumMftSDTotal;
}

struct SD_QUERY_STATS_INPUT
{
    uint Reserved;
}

struct SD_QUERY_STATS_OUTPUT
{
    ulong SdsStreamSize;
    ulong SdsAllocationSize;
    ulong SiiStreamSize;
    ulong SiiAllocationSize;
    ulong SdhStreamSize;
    ulong SdhAllocationSize;
    ulong NumSDTotal;
    ulong NumSDUnused;
}

struct SD_ENUM_SDS_INPUT
{
    ulong StartingOffset;
    ulong MaxSDEntriesToReturn;
}

struct SD_ENUM_SDS_ENTRY
{
    uint     Hash;
    uint     SecurityId;
    ulong    Offset;
    uint     Length;
    ubyte[1] Descriptor;
}

struct SD_ENUM_SDS_OUTPUT
{
    ulong                NextOffset;
    ulong                NumSDEntriesReturned;
    ulong                NumSDBytesReturned;
    SD_ENUM_SDS_ENTRY[1] SDEntry;
}

struct SD_GLOBAL_CHANGE_INPUT
{
    uint Flags;
    uint ChangeType;
union
    {
        SD_CHANGE_MACHINE_SID_INPUT SdChange;
        SD_QUERY_STATS_INPUT SdQueryStats;
        SD_ENUM_SDS_INPUT    SdEnumSds;
    }
}

struct SD_GLOBAL_CHANGE_OUTPUT
{
    uint Flags;
    uint ChangeType;
union
    {
        SD_CHANGE_MACHINE_SID_OUTPUT SdChange;
        SD_QUERY_STATS_OUTPUT SdQueryStats;
        SD_ENUM_SDS_OUTPUT SdEnumSds;
    }
}

struct FILE_TYPE_NOTIFICATION_INPUT
{
    uint    Flags;
    uint    NumFileTypeIDs;
    GUID[1] FileTypeID;
}

struct CSV_MGMT_LOCK
{
    uint Flags;
}

struct CSV_QUERY_FILE_REVISION_FILE_ID_128
{
    FILE_ID_128 FileId;
    long[3]     FileRevision;
}

struct CSV_QUERY_VOLUME_REDIRECT_STATE
{
    uint  MdsNodeId;
    uint  DsNodeId;
    ubyte IsDiskConnected;
    ubyte ClusterEnableDirectIo;
    CSVFS_DISK_CONNECTIVITY DiskConnectivity;
}

struct CSV_QUERY_MDS_PATH_V2
{
    long Version;
    uint RequiredSize;
    uint MdsNodeId;
    uint DsNodeId;
    uint Flags;
    CSVFS_DISK_CONNECTIVITY DiskConnectivity;
    GUID VolumeId;
    uint IpAddressOffset;
    uint IpAddressLength;
    uint PathOffset;
    uint PathLength;
}

struct CLUSTER_RANGE
{
    LARGE_INTEGER StartingCluster;
    LARGE_INTEGER ClusterCount;
}

struct FILE_REFERENCE_RANGE
{
    ulong StartingFileReferenceNumber;
    ulong EndingFileReferenceNumber;
}

struct QUERY_FILE_LAYOUT_INPUT
{
union
    {
        uint FilterEntryCount;
        uint NumberOfPairs;
    }
    uint Flags;
    QUERY_FILE_LAYOUT_FILTER_TYPE FilterType;
    uint Reserved;
union Filter
    {
        CLUSTER_RANGE[1] ClusterRanges;
        FILE_REFERENCE_RANGE[1] FileReferenceRanges;
        STORAGE_RESERVE_ID[1] StorageReserveIds;
    }
}

struct QUERY_FILE_LAYOUT_OUTPUT
{
    uint FileEntryCount;
    uint FirstFileOffset;
    uint Flags;
    uint Reserved;
}

struct FILE_LAYOUT_ENTRY
{
    uint  Version;
    uint  NextFileOffset;
    uint  Flags;
    uint  FileAttributes;
    ulong FileReferenceNumber;
    uint  FirstNameOffset;
    uint  FirstStreamOffset;
    uint  ExtraInfoOffset;
    uint  ExtraInfoLength;
}

struct FILE_LAYOUT_NAME_ENTRY
{
    uint      NextNameOffset;
    uint      Flags;
    ulong     ParentFileReferenceNumber;
    uint      FileNameLength;
    uint      Reserved;
    ushort[1] FileName;
}

struct FILE_LAYOUT_INFO_ENTRY
{
struct BasicInformation
    {
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        uint          FileAttributes;
    }
    uint               OwnerId;
    uint               SecurityId;
    long               Usn;
    STORAGE_RESERVE_ID StorageReserveId;
}

struct STREAM_LAYOUT_ENTRY
{
    uint          Version;
    uint          NextStreamOffset;
    uint          Flags;
    uint          ExtentInformationOffset;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    uint          StreamInformationOffset;
    uint          AttributeTypeCode;
    uint          AttributeFlags;
    uint          StreamIdentifierLength;
    ushort[1]     StreamIdentifier;
}

struct STREAM_EXTENT_ENTRY
{
    uint Flags;
union ExtentInformation
    {
        RETRIEVAL_POINTERS_BUFFER RetrievalPointers;
    }
}

struct FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX
{
    ubyte    EnableIntegrity;
    ubyte    KeepIntegrityStateUnchanged;
    ushort   Reserved;
    uint     Flags;
    ubyte    Version;
    ubyte[7] Reserved2;
}

struct FSCTL_OFFLOAD_READ_INPUT
{
    uint  Size;
    uint  Flags;
    uint  TokenTimeToLive;
    uint  Reserved;
    ulong FileOffset;
    ulong CopyLength;
}

struct FSCTL_OFFLOAD_READ_OUTPUT
{
    uint       Size;
    uint       Flags;
    ulong      TransferLength;
    ubyte[512] Token;
}

struct FSCTL_OFFLOAD_WRITE_INPUT
{
    uint       Size;
    uint       Flags;
    ulong      FileOffset;
    ulong      CopyLength;
    ulong      TransferOffset;
    ubyte[512] Token;
}

struct FSCTL_OFFLOAD_WRITE_OUTPUT
{
    uint  Size;
    uint  Flags;
    ulong LengthWritten;
}

struct SET_PURGE_FAILURE_MODE_INPUT
{
    uint Flags;
}

struct FILE_REGION_INFO
{
    long FileOffset;
    long Length;
    uint Usage;
    uint Reserved;
}

struct FILE_REGION_OUTPUT
{
    uint                Flags;
    uint                TotalRegionEntryCount;
    uint                RegionEntryCount;
    uint                Reserved;
    FILE_REGION_INFO[1] Region;
}

struct FILE_REGION_INPUT
{
    long FileOffset;
    long Length;
    uint DesiredUsage;
}

struct WRITE_USN_REASON_INPUT
{
    uint Flags;
    uint UsnReasonToWrite;
}

struct STREAM_INFORMATION_ENTRY
{
    uint Version;
    uint Flags;
union StreamInformation
    {
struct DesiredStorageClass
        {
            FILE_STORAGE_TIER_CLASS Class;
            uint Flags;
        }
struct DataStream
        {
            ushort Length;
            ushort Flags;
            uint   Reserved;
            ulong  Vdl;
        }
struct Reparse
        {
            ushort Length;
            ushort Flags;
            uint   ReparseDataSize;
            uint   ReparseDataOffset;
        }
struct Ea
        {
            ushort Length;
            ushort Flags;
            uint   EaSize;
            uint   EaInformationOffset;
        }
    }
}

struct FILE_DESIRED_STORAGE_CLASS_INFORMATION
{
    FILE_STORAGE_TIER_CLASS Class;
    uint Flags;
}

struct DUPLICATE_EXTENTS_DATA_EX
{
    size_t        Size;
    HANDLE        FileHandle;
    LARGE_INTEGER SourceFileOffset;
    LARGE_INTEGER TargetFileOffset;
    LARGE_INTEGER ByteCount;
    uint          Flags;
}

struct REFS_SMR_VOLUME_INFO_OUTPUT
{
    uint          Version;
    uint          Flags;
    LARGE_INTEGER SizeOfRandomlyWritableTier;
    LARGE_INTEGER FreeSpaceInRandomlyWritableTier;
    LARGE_INTEGER SizeofSMRTier;
    LARGE_INTEGER FreeSpaceInSMRTier;
    LARGE_INTEGER UsableFreeSpaceInSMRTier;
    REFS_SMR_VOLUME_GC_STATE VolumeGcState;
    uint          VolumeGcLastStatus;
    ulong[7]      Unused;
}

struct REFS_SMR_VOLUME_GC_PARAMETERS
{
    uint     Version;
    uint     Flags;
    REFS_SMR_VOLUME_GC_ACTION Action;
    REFS_SMR_VOLUME_GC_METHOD Method;
    uint     IoGranularity;
    uint     CompressionFormat;
    ulong[8] Unused;
}

struct STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER
{
    uint OptimalWriteSize;
    uint StreamGranularitySize;
    uint StreamIdMin;
    uint StreamIdMax;
}

struct STREAMS_ASSOCIATE_ID_INPUT_BUFFER
{
    uint Flags;
    uint StreamId;
}

struct STREAMS_QUERY_ID_OUTPUT_BUFFER
{
    uint StreamId;
}

struct QUERY_BAD_RANGES_INPUT_RANGE
{
    ulong StartOffset;
    ulong LengthInBytes;
}

struct QUERY_BAD_RANGES_INPUT
{
    uint Flags;
    uint NumRanges;
    QUERY_BAD_RANGES_INPUT_RANGE[1] Ranges;
}

struct QUERY_BAD_RANGES_OUTPUT_RANGE
{
    uint  Flags;
    uint  Reserved;
    ulong StartOffset;
    ulong LengthInBytes;
}

struct QUERY_BAD_RANGES_OUTPUT
{
    uint  Flags;
    uint  NumBadRanges;
    ulong NextOffsetToLookUp;
    QUERY_BAD_RANGES_OUTPUT_RANGE[1] BadRanges;
}

struct SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT
{
    uint  Flags;
    uint  AlignmentShift;
    ulong FileOffsetToAlign;
    uint  FallbackAlignmentShift;
}

struct VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT
{
    uint Size;
    VIRTUAL_STORAGE_BEHAVIOR_CODE BehaviorCode;
}

struct ENCRYPTION_KEY_CTRL_INPUT
{
    uint   HeaderSize;
    uint   StructureSize;
    ushort KeyOffset;
    ushort KeySize;
    uint   DplLock;
    ulong  DplUserId;
    ulong  DplCredentialId;
}

struct WOF_EXTERNAL_INFO
{
    uint Version;
    uint Provider;
}

struct WOF_EXTERNAL_FILE_ID
{
    FILE_ID_128 FileId;
}

struct WOF_VERSION_INFO
{
    uint WofVersion;
}

struct WIM_PROVIDER_EXTERNAL_INFO
{
    uint          Version;
    uint          Flags;
    LARGE_INTEGER DataSourceId;
    ubyte[20]     ResourceHash;
}

struct WIM_PROVIDER_ADD_OVERLAY_INPUT
{
    uint WimType;
    uint WimIndex;
    uint WimFileNameOffset;
    uint WimFileNameLength;
}

struct WIM_PROVIDER_UPDATE_OVERLAY_INPUT
{
    LARGE_INTEGER DataSourceId;
    uint          WimFileNameOffset;
    uint          WimFileNameLength;
}

struct WIM_PROVIDER_REMOVE_OVERLAY_INPUT
{
    LARGE_INTEGER DataSourceId;
}

struct WIM_PROVIDER_SUSPEND_OVERLAY_INPUT
{
    LARGE_INTEGER DataSourceId;
}

struct WIM_PROVIDER_OVERLAY_ENTRY
{
    uint          NextEntryOffset;
    LARGE_INTEGER DataSourceId;
    GUID          WimGuid;
    uint          WimFileNameOffset;
    uint          WimType;
    uint          WimIndex;
    uint          Flags;
}

struct FILE_PROVIDER_EXTERNAL_INFO_V0
{
    uint Version;
    uint Algorithm;
}

struct FILE_PROVIDER_EXTERNAL_INFO_V1
{
    uint Version;
    uint Algorithm;
    uint Flags;
}

struct CONTAINER_VOLUME_STATE
{
    uint Flags;
}

struct CONTAINER_ROOT_INFO_INPUT
{
    uint Flags;
}

struct CONTAINER_ROOT_INFO_OUTPUT
{
    ushort   ContainerRootIdLength;
    ubyte[1] ContainerRootId;
}

struct VIRTUALIZATION_INSTANCE_INFO_INPUT
{
    uint NumberOfWorkerThreads;
    uint Flags;
}

struct VIRTUALIZATION_INSTANCE_INFO_INPUT_EX
{
    ushort HeaderSize;
    uint   Flags;
    uint   NotificationInfoSize;
    ushort NotificationInfoOffset;
    ushort ProviderMajorVersion;
}

struct VIRTUALIZATION_INSTANCE_INFO_OUTPUT
{
    GUID VirtualizationInstanceID;
}

struct GET_FILTER_FILE_IDENTIFIER_INPUT
{
    ushort    AltitudeLength;
    ushort[1] Altitude;
}

struct GET_FILTER_FILE_IDENTIFIER_OUTPUT
{
    ushort   FilterFileIdentifierLength;
    ubyte[1] FilterFileIdentifier;
}

struct IO_IRP_EXT_TRACK_OFFSET_HEADER
{
    ushort Validation;
    ushort Flags;
    PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK TrackedOffsetCallback;
}

struct SCARD_IO_REQUEST
{
    uint dwProtocol;
    uint cbPciLength;
}

struct SCARD_T0_COMMAND
{
    ubyte bCla;
    ubyte bIns;
    ubyte bP1;
    ubyte bP2;
    ubyte bP3;
}

struct SCARD_T0_REQUEST
{
    SCARD_IO_REQUEST ioRequest;
    ubyte            bSw1;
    ubyte            bSw2;
union
    {
        SCARD_T0_COMMAND CmdBytes;
        ubyte[5]         rgbHeader;
    }
}

struct SCARD_T1_REQUEST
{
    SCARD_IO_REQUEST ioRequest;
}

struct PRINTER_INFO_1A
{
    uint Flags;
    PSTR pDescription;
    PSTR pName;
    PSTR pComment;
}

struct PRINTER_INFO_1W
{
    uint  Flags;
    PWSTR pDescription;
    PWSTR pName;
    PWSTR pComment;
}

struct PRINTER_INFO_2A
{
    PSTR      pServerName;
    PSTR      pPrinterName;
    PSTR      pShareName;
    PSTR      pPortName;
    PSTR      pDriverName;
    PSTR      pComment;
    PSTR      pLocation;
    DEVMODEA* pDevMode;
    PSTR      pSepFile;
    PSTR      pPrintProcessor;
    PSTR      pDatatype;
    PSTR      pParameters;
    void*     pSecurityDescriptor;
    uint      Attributes;
    uint      Priority;
    uint      DefaultPriority;
    uint      StartTime;
    uint      UntilTime;
    uint      Status;
    uint      cJobs;
    uint      AveragePPM;
}

struct PRINTER_INFO_2W
{
    PWSTR     pServerName;
    PWSTR     pPrinterName;
    PWSTR     pShareName;
    PWSTR     pPortName;
    PWSTR     pDriverName;
    PWSTR     pComment;
    PWSTR     pLocation;
    DEVMODEW* pDevMode;
    PWSTR     pSepFile;
    PWSTR     pPrintProcessor;
    PWSTR     pDatatype;
    PWSTR     pParameters;
    void*     pSecurityDescriptor;
    uint      Attributes;
    uint      Priority;
    uint      DefaultPriority;
    uint      StartTime;
    uint      UntilTime;
    uint      Status;
    uint      cJobs;
    uint      AveragePPM;
}

struct PRINTER_INFO_3
{
    void* pSecurityDescriptor;
}

struct PRINTER_INFO_4A
{
    PSTR pPrinterName;
    PSTR pServerName;
    uint Attributes;
}

struct PRINTER_INFO_4W
{
    PWSTR pPrinterName;
    PWSTR pServerName;
    uint  Attributes;
}

struct PRINTER_INFO_5A
{
    PSTR pPrinterName;
    PSTR pPortName;
    uint Attributes;
    uint DeviceNotSelectedTimeout;
    uint TransmissionRetryTimeout;
}

struct PRINTER_INFO_5W
{
    PWSTR pPrinterName;
    PWSTR pPortName;
    uint  Attributes;
    uint  DeviceNotSelectedTimeout;
    uint  TransmissionRetryTimeout;
}

struct PRINTER_INFO_6
{
    uint dwStatus;
}

struct PRINTER_INFO_7A
{
    PSTR pszObjectGUID;
    uint dwAction;
}

struct PRINTER_INFO_7W
{
    PWSTR pszObjectGUID;
    uint  dwAction;
}

struct PRINTER_INFO_8A
{
    DEVMODEA* pDevMode;
}

struct PRINTER_INFO_8W
{
    DEVMODEW* pDevMode;
}

struct PRINTER_INFO_9A
{
    DEVMODEA* pDevMode;
}

struct PRINTER_INFO_9W
{
    DEVMODEW* pDevMode;
}

struct JOB_INFO_1A
{
    uint       JobId;
    PSTR       pPrinterName;
    PSTR       pMachineName;
    PSTR       pUserName;
    PSTR       pDocument;
    PSTR       pDatatype;
    PSTR       pStatus;
    uint       Status;
    uint       Priority;
    uint       Position;
    uint       TotalPages;
    uint       PagesPrinted;
    SYSTEMTIME Submitted;
}

struct JOB_INFO_1W
{
    uint       JobId;
    PWSTR      pPrinterName;
    PWSTR      pMachineName;
    PWSTR      pUserName;
    PWSTR      pDocument;
    PWSTR      pDatatype;
    PWSTR      pStatus;
    uint       Status;
    uint       Priority;
    uint       Position;
    uint       TotalPages;
    uint       PagesPrinted;
    SYSTEMTIME Submitted;
}

struct JOB_INFO_2A
{
    uint       JobId;
    PSTR       pPrinterName;
    PSTR       pMachineName;
    PSTR       pUserName;
    PSTR       pDocument;
    PSTR       pNotifyName;
    PSTR       pDatatype;
    PSTR       pPrintProcessor;
    PSTR       pParameters;
    PSTR       pDriverName;
    DEVMODEA*  pDevMode;
    PSTR       pStatus;
    void*      pSecurityDescriptor;
    uint       Status;
    uint       Priority;
    uint       Position;
    uint       StartTime;
    uint       UntilTime;
    uint       TotalPages;
    uint       Size;
    SYSTEMTIME Submitted;
    uint       Time;
    uint       PagesPrinted;
}

struct JOB_INFO_2W
{
    uint       JobId;
    PWSTR      pPrinterName;
    PWSTR      pMachineName;
    PWSTR      pUserName;
    PWSTR      pDocument;
    PWSTR      pNotifyName;
    PWSTR      pDatatype;
    PWSTR      pPrintProcessor;
    PWSTR      pParameters;
    PWSTR      pDriverName;
    DEVMODEW*  pDevMode;
    PWSTR      pStatus;
    void*      pSecurityDescriptor;
    uint       Status;
    uint       Priority;
    uint       Position;
    uint       StartTime;
    uint       UntilTime;
    uint       TotalPages;
    uint       Size;
    SYSTEMTIME Submitted;
    uint       Time;
    uint       PagesPrinted;
}

struct JOB_INFO_3
{
    uint JobId;
    uint NextJobId;
    uint Reserved;
}

struct JOB_INFO_4A
{
    uint       JobId;
    PSTR       pPrinterName;
    PSTR       pMachineName;
    PSTR       pUserName;
    PSTR       pDocument;
    PSTR       pNotifyName;
    PSTR       pDatatype;
    PSTR       pPrintProcessor;
    PSTR       pParameters;
    PSTR       pDriverName;
    DEVMODEA*  pDevMode;
    PSTR       pStatus;
    void*      pSecurityDescriptor;
    uint       Status;
    uint       Priority;
    uint       Position;
    uint       StartTime;
    uint       UntilTime;
    uint       TotalPages;
    uint       Size;
    SYSTEMTIME Submitted;
    uint       Time;
    uint       PagesPrinted;
    int        SizeHigh;
}

struct JOB_INFO_4W
{
    uint       JobId;
    PWSTR      pPrinterName;
    PWSTR      pMachineName;
    PWSTR      pUserName;
    PWSTR      pDocument;
    PWSTR      pNotifyName;
    PWSTR      pDatatype;
    PWSTR      pPrintProcessor;
    PWSTR      pParameters;
    PWSTR      pDriverName;
    DEVMODEW*  pDevMode;
    PWSTR      pStatus;
    void*      pSecurityDescriptor;
    uint       Status;
    uint       Priority;
    uint       Position;
    uint       StartTime;
    uint       UntilTime;
    uint       TotalPages;
    uint       Size;
    SYSTEMTIME Submitted;
    uint       Time;
    uint       PagesPrinted;
    int        SizeHigh;
}

struct ADDJOB_INFO_1A
{
    PSTR Path;
    uint JobId;
}

struct ADDJOB_INFO_1W
{
    PWSTR Path;
    uint  JobId;
}

struct DRIVER_INFO_1A
{
    PSTR pName;
}

struct DRIVER_INFO_1W
{
    PWSTR pName;
}

struct DRIVER_INFO_2A
{
    uint cVersion;
    PSTR pName;
    PSTR pEnvironment;
    PSTR pDriverPath;
    PSTR pDataFile;
    PSTR pConfigFile;
}

struct DRIVER_INFO_2W
{
    uint  cVersion;
    PWSTR pName;
    PWSTR pEnvironment;
    PWSTR pDriverPath;
    PWSTR pDataFile;
    PWSTR pConfigFile;
}

struct DRIVER_INFO_3A
{
    uint cVersion;
    PSTR pName;
    PSTR pEnvironment;
    PSTR pDriverPath;
    PSTR pDataFile;
    PSTR pConfigFile;
    PSTR pHelpFile;
    PSTR pDependentFiles;
    PSTR pMonitorName;
    PSTR pDefaultDataType;
}

struct DRIVER_INFO_3W
{
    uint  cVersion;
    PWSTR pName;
    PWSTR pEnvironment;
    PWSTR pDriverPath;
    PWSTR pDataFile;
    PWSTR pConfigFile;
    PWSTR pHelpFile;
    PWSTR pDependentFiles;
    PWSTR pMonitorName;
    PWSTR pDefaultDataType;
}

struct DRIVER_INFO_4A
{
    uint cVersion;
    PSTR pName;
    PSTR pEnvironment;
    PSTR pDriverPath;
    PSTR pDataFile;
    PSTR pConfigFile;
    PSTR pHelpFile;
    PSTR pDependentFiles;
    PSTR pMonitorName;
    PSTR pDefaultDataType;
    PSTR pszzPreviousNames;
}

struct DRIVER_INFO_4W
{
    uint  cVersion;
    PWSTR pName;
    PWSTR pEnvironment;
    PWSTR pDriverPath;
    PWSTR pDataFile;
    PWSTR pConfigFile;
    PWSTR pHelpFile;
    PWSTR pDependentFiles;
    PWSTR pMonitorName;
    PWSTR pDefaultDataType;
    PWSTR pszzPreviousNames;
}

struct DRIVER_INFO_5A
{
    uint cVersion;
    PSTR pName;
    PSTR pEnvironment;
    PSTR pDriverPath;
    PSTR pDataFile;
    PSTR pConfigFile;
    uint dwDriverAttributes;
    uint dwConfigVersion;
    uint dwDriverVersion;
}

struct DRIVER_INFO_5W
{
    uint  cVersion;
    PWSTR pName;
    PWSTR pEnvironment;
    PWSTR pDriverPath;
    PWSTR pDataFile;
    PWSTR pConfigFile;
    uint  dwDriverAttributes;
    uint  dwConfigVersion;
    uint  dwDriverVersion;
}

struct DRIVER_INFO_6A
{
    uint     cVersion;
    PSTR     pName;
    PSTR     pEnvironment;
    PSTR     pDriverPath;
    PSTR     pDataFile;
    PSTR     pConfigFile;
    PSTR     pHelpFile;
    PSTR     pDependentFiles;
    PSTR     pMonitorName;
    PSTR     pDefaultDataType;
    PSTR     pszzPreviousNames;
    FILETIME ftDriverDate;
    ulong    dwlDriverVersion;
    PSTR     pszMfgName;
    PSTR     pszOEMUrl;
    PSTR     pszHardwareID;
    PSTR     pszProvider;
}

struct DRIVER_INFO_6W
{
    uint     cVersion;
    PWSTR    pName;
    PWSTR    pEnvironment;
    PWSTR    pDriverPath;
    PWSTR    pDataFile;
    PWSTR    pConfigFile;
    PWSTR    pHelpFile;
    PWSTR    pDependentFiles;
    PWSTR    pMonitorName;
    PWSTR    pDefaultDataType;
    PWSTR    pszzPreviousNames;
    FILETIME ftDriverDate;
    ulong    dwlDriverVersion;
    PWSTR    pszMfgName;
    PWSTR    pszOEMUrl;
    PWSTR    pszHardwareID;
    PWSTR    pszProvider;
}

struct DRIVER_INFO_8A
{
    uint     cVersion;
    PSTR     pName;
    PSTR     pEnvironment;
    PSTR     pDriverPath;
    PSTR     pDataFile;
    PSTR     pConfigFile;
    PSTR     pHelpFile;
    PSTR     pDependentFiles;
    PSTR     pMonitorName;
    PSTR     pDefaultDataType;
    PSTR     pszzPreviousNames;
    FILETIME ftDriverDate;
    ulong    dwlDriverVersion;
    PSTR     pszMfgName;
    PSTR     pszOEMUrl;
    PSTR     pszHardwareID;
    PSTR     pszProvider;
    PSTR     pszPrintProcessor;
    PSTR     pszVendorSetup;
    PSTR     pszzColorProfiles;
    PSTR     pszInfPath;
    uint     dwPrinterDriverAttributes;
    PSTR     pszzCoreDriverDependencies;
    FILETIME ftMinInboxDriverVerDate;
    ulong    dwlMinInboxDriverVerVersion;
}

struct DRIVER_INFO_8W
{
    uint     cVersion;
    PWSTR    pName;
    PWSTR    pEnvironment;
    PWSTR    pDriverPath;
    PWSTR    pDataFile;
    PWSTR    pConfigFile;
    PWSTR    pHelpFile;
    PWSTR    pDependentFiles;
    PWSTR    pMonitorName;
    PWSTR    pDefaultDataType;
    PWSTR    pszzPreviousNames;
    FILETIME ftDriverDate;
    ulong    dwlDriverVersion;
    PWSTR    pszMfgName;
    PWSTR    pszOEMUrl;
    PWSTR    pszHardwareID;
    PWSTR    pszProvider;
    PWSTR    pszPrintProcessor;
    PWSTR    pszVendorSetup;
    PWSTR    pszzColorProfiles;
    PWSTR    pszInfPath;
    uint     dwPrinterDriverAttributes;
    PWSTR    pszzCoreDriverDependencies;
    FILETIME ftMinInboxDriverVerDate;
    ulong    dwlMinInboxDriverVerVersion;
}

struct DOC_INFO_1A
{
    PSTR pDocName;
    PSTR pOutputFile;
    PSTR pDatatype;
}

struct DOC_INFO_1W
{
    PWSTR pDocName;
    PWSTR pOutputFile;
    PWSTR pDatatype;
}

struct FORM_INFO_1A
{
    uint  Flags;
    PSTR  pName;
    SIZE  Size;
    RECTL ImageableArea;
}

struct FORM_INFO_1W
{
    uint  Flags;
    PWSTR pName;
    SIZE  Size;
    RECTL ImageableArea;
}

struct FORM_INFO_2A
{
    uint        Flags;
    const(PSTR) pName;
    SIZE        Size;
    RECTL       ImageableArea;
    const(PSTR) pKeyword;
    uint        StringType;
    const(PSTR) pMuiDll;
    uint        dwResourceId;
    const(PSTR) pDisplayName;
    ushort      wLangId;
}

struct FORM_INFO_2W
{
    uint         Flags;
    const(PWSTR) pName;
    SIZE         Size;
    RECTL        ImageableArea;
    const(PSTR)  pKeyword;
    uint         StringType;
    const(PWSTR) pMuiDll;
    uint         dwResourceId;
    const(PWSTR) pDisplayName;
    ushort       wLangId;
}

struct DOC_INFO_2A
{
    PSTR pDocName;
    PSTR pOutputFile;
    PSTR pDatatype;
    uint dwMode;
    uint JobId;
}

struct DOC_INFO_2W
{
    PWSTR pDocName;
    PWSTR pOutputFile;
    PWSTR pDatatype;
    uint  dwMode;
    uint  JobId;
}

struct DOC_INFO_3A
{
    PSTR pDocName;
    PSTR pOutputFile;
    PSTR pDatatype;
    uint dwFlags;
}

struct DOC_INFO_3W
{
    PWSTR pDocName;
    PWSTR pOutputFile;
    PWSTR pDatatype;
    uint  dwFlags;
}

struct PRINTPROCESSOR_INFO_1A
{
    PSTR pName;
}

struct PRINTPROCESSOR_INFO_1W
{
    PWSTR pName;
}

struct PRINTPROCESSOR_CAPS_1
{
    uint dwLevel;
    uint dwNupOptions;
    uint dwPageOrderFlags;
    uint dwNumberOfCopies;
}

struct PRINTPROCESSOR_CAPS_2
{
    uint dwLevel;
    uint dwNupOptions;
    uint dwPageOrderFlags;
    uint dwNumberOfCopies;
    uint dwDuplexHandlingCaps;
    uint dwNupDirectionCaps;
    uint dwNupBorderCaps;
    uint dwBookletHandlingCaps;
    uint dwScalingCaps;
}

struct PORT_INFO_1A
{
    PSTR pName;
}

struct PORT_INFO_1W
{
    PWSTR pName;
}

struct PORT_INFO_2A
{
    PSTR pPortName;
    PSTR pMonitorName;
    PSTR pDescription;
    uint fPortType;
    uint Reserved;
}

struct PORT_INFO_2W
{
    PWSTR pPortName;
    PWSTR pMonitorName;
    PWSTR pDescription;
    uint  fPortType;
    uint  Reserved;
}

struct PORT_INFO_3A
{
    uint dwStatus;
    PSTR pszStatus;
    uint dwSeverity;
}

struct PORT_INFO_3W
{
    uint  dwStatus;
    PWSTR pszStatus;
    uint  dwSeverity;
}

struct MONITOR_INFO_1A
{
    PSTR pName;
}

struct MONITOR_INFO_1W
{
    PWSTR pName;
}

struct MONITOR_INFO_2A
{
    PSTR pName;
    PSTR pEnvironment;
    PSTR pDLLName;
}

struct MONITOR_INFO_2W
{
    PWSTR pName;
    PWSTR pEnvironment;
    PWSTR pDLLName;
}

struct DATATYPES_INFO_1A
{
    PSTR pName;
}

struct DATATYPES_INFO_1W
{
    PWSTR pName;
}

struct PRINTER_DEFAULTSA
{
    PSTR      pDatatype;
    DEVMODEA* pDevMode;
    uint      DesiredAccess;
}

struct PRINTER_DEFAULTSW
{
    PWSTR     pDatatype;
    DEVMODEW* pDevMode;
    uint      DesiredAccess;
}

struct PRINTER_ENUM_VALUESA
{
    PSTR   pValueName;
    uint   cbValueName;
    uint   dwType;
    ubyte* pData;
    uint   cbData;
}

struct PRINTER_ENUM_VALUESW
{
    PWSTR  pValueName;
    uint   cbValueName;
    uint   dwType;
    ubyte* pData;
    uint   cbData;
}

struct PRINTER_NOTIFY_OPTIONS_TYPE
{
    ushort  Type;
    ushort  Reserved0;
    uint    Reserved1;
    uint    Reserved2;
    uint    Count;
    ushort* pFields;
}

struct PRINTER_NOTIFY_OPTIONS
{
    uint Version;
    uint Flags;
    uint Count;
    PRINTER_NOTIFY_OPTIONS_TYPE* pTypes;
}

struct PRINTER_NOTIFY_INFO_DATA
{
    ushort Type;
    ushort Field;
    uint   Reserved;
    uint   Id;
union NotifyData
    {
        uint[2] adwData;
struct Data
        {
            uint  cbBuf;
            void* pBuf;
        }
    }
}

struct PRINTER_NOTIFY_INFO
{
    uint Version;
    uint Flags;
    uint Count;
    PRINTER_NOTIFY_INFO_DATA[1] aData;
}

struct BINARY_CONTAINER
{
    uint   cbBuf;
    ubyte* pData;
}

struct BIDI_DATA
{
    uint dwBidiType;
union u
    {
        BOOL             bData;
        int              iData;
        PWSTR            sData;
        float            fData;
        BINARY_CONTAINER biData;
    }
}

struct BIDI_REQUEST_DATA
{
    uint      dwReqNumber;
    PWSTR     pSchema;
    BIDI_DATA data;
}

struct BIDI_REQUEST_CONTAINER
{
    uint                 Version;
    uint                 Flags;
    uint                 Count;
    BIDI_REQUEST_DATA[1] aData;
}

struct BIDI_RESPONSE_DATA
{
    uint      dwResult;
    uint      dwReqNumber;
    PWSTR     pSchema;
    BIDI_DATA data;
}

struct BIDI_RESPONSE_CONTAINER
{
    uint Version;
    uint Flags;
    uint Count;
    BIDI_RESPONSE_DATA[1] aData;
}

struct PROVIDOR_INFO_1A
{
    PSTR pName;
    PSTR pEnvironment;
    PSTR pDLLName;
}

struct PROVIDOR_INFO_1W
{
    PWSTR pName;
    PWSTR pEnvironment;
    PWSTR pDLLName;
}

struct PROVIDOR_INFO_2A
{
    PSTR pOrder;
}

struct PROVIDOR_INFO_2W
{
    PWSTR pOrder;
}

struct PRINTER_OPTIONSA
{
    uint cbSize;
    uint dwFlags;
}

struct PRINTER_OPTIONSW
{
    uint cbSize;
    uint dwFlags;
}

struct PRINTER_CONNECTION_INFO_1A
{
    uint dwFlags;
    PSTR pszDriverName;
}

struct PRINTER_CONNECTION_INFO_1W
{
    uint  dwFlags;
    PWSTR pszDriverName;
}

struct CORE_PRINTER_DRIVERA
{
    GUID      CoreDriverGUID;
    FILETIME  ftDriverDate;
    ulong     dwlDriverVersion;
    byte[260] szPackageID;
}

struct CORE_PRINTER_DRIVERW
{
    GUID        CoreDriverGUID;
    FILETIME    ftDriverDate;
    ulong       dwlDriverVersion;
    ushort[260] szPackageID;
}

struct PrintPropertyValue
{
    EPrintPropertyType ePropertyType;
union value
    {
        ubyte propertyByte;
        PWSTR propertyString;
        int   propertyInt32;
        long  propertyInt64;
struct propertyBlob
        {
            uint  cbBuf;
            void* pBuf;
        }
    }
}

struct PrintNamedProperty
{
    PWSTR              propertyName;
    PrintPropertyValue propertyValue;
}

struct PrintPropertiesCollection
{
    uint                numberOfProperties;
    PrintNamedProperty* propertiesCollection;
}

struct PRINT_EXECUTION_DATA
{
    PRINT_EXECUTION_CONTEXT context;
    uint clientAppPID;
}

///Contains information about the capabilities of a modem.
struct MODEMDEVCAPS
{
    ///The size of the data actually returned to the application, in bytes. This member may be less than the
    ///<b>dwRequiredSize</b> member, if an application did not allocate enough space for the variable-length portion of
    ///the structure.
    uint     dwActualSize;
    ///The number of bytes required for the entire <b>MODEMDEVCAPS</b> structure, including the variable-length portion.
    uint     dwRequiredSize;
    ///The offset of the provider-defined portion of the structure, in bytes relative to the beginning of the structure.
    uint     dwDevSpecificOffset;
    ///The size of the provider-defined portion of the structure, in bytes.
    uint     dwDevSpecificSize;
    ///The version of the service provider. The format and use of this member depends on the service provider.
    uint     dwModemProviderVersion;
    ///The offset of a text string that contains the name of the modem manufacturer, in bytes relative to the beginning
    ///of the structure.
    uint     dwModemManufacturerOffset;
    ///The length of the modem manufacturer name, in bytes. The string is not null-terminated.
    uint     dwModemManufacturerSize;
    ///The offset of a text string that contains the model of the modem, in bytes relative to the beginning of the
    ///structure.
    uint     dwModemModelOffset;
    ///The length of the model name, in bytes. The string is not null-terminated.
    uint     dwModemModelSize;
    ///The offset of a text string that gives the version and revision of the attached modem, if the provider could
    ///determine the information. The offset is specified in bytes relative to the beginning of the structure.
    uint     dwModemVersionOffset;
    ///The length of the modem version string, in bytes. The string is not null-terminated.
    uint     dwModemVersionSize;
    ///The dialing options supported by the modem device. This member can be zero or more of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DIALOPTION_BILLING"></a><a
    ///id="dialoption_billing"></a><dl> <dt><b>DIALOPTION_BILLING</b></dt> <dt>0x00000040</dt> </dl> </td> <td
    ///width="60%"> The modem supports waiting for billing tone (bong). </td> </tr> <tr> <td width="40%"><a
    ///id="DIALOPTION_DIALTONE"></a><a id="dialoption_dialtone"></a><dl> <dt><b>DIALOPTION_DIALTONE</b></dt>
    ///<dt>0x00000100</dt> </dl> </td> <td width="60%"> The modem supports waiting for a dial tone. </td> </tr> <tr> <td
    ///width="40%"><a id="DIALOPTION_QUIET"></a><a id="dialoption_quiet"></a><dl> <dt><b>DIALOPTION_QUIET</b></dt>
    ///<dt>0x00000080</dt> </dl> </td> <td width="60%"> The modem supports waiting for quiet. </td> </tr> </table>
    uint     dwDialOptions;
    ///The maximum call setup timeout supported by the modem, in seconds. This is the largest value that can be
    ///specified for the corresponding member of the MODEMSETTINGS structure.
    uint     dwCallSetupFailTimer;
    ///The maximum inactivity timeout supported by the modem, in tenths of seconds. This is the largest value that can
    ///be specified for the corresponding member of the MODEMSETTINGS structure.
    uint     dwInactivityTimeout;
    ///The speaker volume settings supported by the modem. This member can be zero or more of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MDMVOLFLAG_HIGH"></a><a
    ///id="mdmvolflag_high"></a><dl> <dt><b>MDMVOLFLAG_HIGH</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%">
    ///The modem supports high (MDMVOL_HIGH) volume. </td> </tr> <tr> <td width="40%"><a id="MDMVOLFLAG_LOW"></a><a
    ///id="mdmvolflag_low"></a><dl> <dt><b>MDMVOLFLAG_LOW</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The
    ///modem supports low (MDMVOL_LOW) volume. </td> </tr> <tr> <td width="40%"><a id="MDMVOLFLAG_MEDIUM"></a><a
    ///id="mdmvolflag_medium"></a><dl> <dt><b>MDMVOLFLAG_MEDIUM</b></dt> <dt>0x00000002</dt> </dl> </td> <td
    ///width="60%"> The modem supports medium (MDMVOL_MEDIUM) volume. </td> </tr> </table>
    uint     dwSpeakerVolume;
    ///The speaker mode settings supported by the modem. This member can be zero or more of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MDMSPKRFLAG_CALLSETUP"></a><a
    ///id="mdmspkrflag_callsetup"></a><dl> <dt><b>MDMSPKRFLAG_CALLSETUP</b></dt> <dt>0x00000008</dt> </dl> </td> <td
    ///width="60%"> The modem supports the MDMSPKR_CALLSETUP speaker mode. </td> </tr> <tr> <td width="40%"><a
    ///id="MDMSPKRFLAG_DIAL"></a><a id="mdmspkrflag_dial"></a><dl> <dt><b>MDMSPKRFLAG_DIAL</b></dt> <dt>0x00000002</dt>
    ///</dl> </td> <td width="60%"> The modem supports the MDMSPKR_DIAL speaker mode. </td> </tr> <tr> <td
    ///width="40%"><a id="MDMSPKRFLAG_OFF"></a><a id="mdmspkrflag_off"></a><dl> <dt><b>MDMSPKRFLAG_OFF</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> The modem supports the MDMSPKR_OFF speaker mode. </td> </tr>
    ///<tr> <td width="40%"><a id="MDMSPKRFLAG_ON"></a><a id="mdmspkrflag_on"></a><dl> <dt><b>MDMSPKRFLAG_ON</b></dt>
    ///<dt>0x00000004</dt> </dl> </td> <td width="60%"> The modem supports the MDMSPKR_ON speaker mode. </td> </tr>
    ///</table>
    uint     dwSpeakerMode;
    ///The modem options. This member can be zero or more of the following values.
    uint     dwModemOptions;
    ///The maximum DTE rate in bits per second.
    uint     dwMaxDTERate;
    ///The maximum DCE rate in bits per second.
    uint     dwMaxDCERate;
    ///Variable-length information, including strings and any provider-defined information.
    ubyte[1] abVariablePortion;
}

///Contains information about a modem's configuration.
struct MODEMSETTINGS
{
    ///The size of the data actually returned to the application, in bytes. This member may be less than the
    ///<b>dwRequiredSize</b> member if an application did not allocate enough space for the variable-length portion of
    ///the structure.
    uint     dwActualSize;
    ///The number of bytes required for the entire MODEMDEVCAPS structure, including the variable-length portion.
    uint     dwRequiredSize;
    ///The offset of the provider-defined portion of the structure, in bytes relative to the beginning of the structure.
    uint     dwDevSpecificOffset;
    ///The size of the provider-defined portion of the structure, in bytes.
    uint     dwDevSpecificSize;
    ///The maximum number of seconds the modem should wait, after dialing is completed, for an indication that a
    ///modem-to-modem connection has been established. If a connection is not established in this interval, the call is
    ///assumed to have failed. This member is equivalent to register S7 in Hayes® compatible modems.
    uint     dwCallSetupFailTimer;
    ///The maximum number of seconds of inactivity allowed after a connection is established. If no data is either
    ///transmitted or received for this period of time, the call is automatically terminated. This time-out is used to
    ///avoid excessive long-distance charges or online service charges if an application unexpectedly locks up or the
    ///user leaves.
    uint     dwInactivityTimeout;
    ///The volume level of the monitor speaker when the speaker is on. This member can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MDMVOL_HIGH"></a><a
    ///id="mdmvol_high"></a><dl> <dt><b>MDMVOL_HIGH</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> High
    ///volume. </td> </tr> <tr> <td width="40%"><a id="MDMVOL_LOW"></a><a id="mdmvol_low"></a><dl>
    ///<dt><b>MDMVOL_LOW</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Low volume. </td> </tr> <tr> <td
    ///width="40%"><a id="MDMVOL_MEDIUM"></a><a id="mdmvol_medium"></a><dl> <dt><b>MDMVOL_MEDIUM</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> Medium volume. </td> </tr> </table> The MODEMDEVCAPS structure
    ///specifies the speaker volumes a modem supports. Actual volumes are hardware-specific.
    uint     dwSpeakerVolume;
    ///The speaker mode. This member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="MDMSPKR_CALLSETUP"></a><a id="mdmspkr_callsetup"></a><dl>
    ///<dt><b>MDMSPKR_CALLSETUP</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The speaker is on until a
    ///connection is established. </td> </tr> <tr> <td width="40%"><a id="MDMSPKR_DIAL"></a><a
    ///id="mdmspkr_dial"></a><dl> <dt><b>MDMSPKR_DIAL</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The
    ///speaker is on until a connection is established, except that it is off while the modem is actually dialing. </td>
    ///</tr> <tr> <td width="40%"><a id="MDMSPKR_OFF"></a><a id="mdmspkr_off"></a><dl> <dt><b>MDMSPKR_OFF</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> The speaker is always off. </td> </tr> <tr> <td width="40%"><a
    ///id="MDMSPKR_ON"></a><a id="mdmspkr_on"></a><dl> <dt><b>MDMSPKR_ON</b></dt> <dt>0x00000004</dt> </dl> </td> <td
    ///width="60%"> The speaker is always on. </td> </tr> </table>
    uint     dwSpeakerMode;
    ///The modem options requested by the application. The local and remote modems negotiate modem options during call
    ///setup; this member specifies the initial negotiating position of the local modem. The <b>dwModemOptions</b>
    ///member of the MODEMDEVCAPS structure specifies the modem options supported by the local modem. For a list of
    ///modem options, see the description of the <b>MODEMDEVCAPS</b> structure.
    uint     dwPreferredModemOptions;
    ///The modem options that are actually in effect. This member is filled in after a connection is established and the
    ///local and remote modems negotiate modem options. The <b>dwModemOptions</b> member of the MODEMDEVCAPS structure
    ///specifies the modem options supported by the local modem. For a list of modem options, see the description of the
    ///<b>MODEMDEVCAPS</b> structure.
    uint     dwNegotiatedModemOptions;
    ///The DCE rate in effect. This member is filled in after a connection is established and the local and remote
    ///modems negotiate modem modulations.
    uint     dwNegotiatedDCERate;
    ///Optional provider-defined information.
    ubyte[1] abVariablePortion;
}

///Specifies the threading and apartment type for a new DispatcherQueueController.
struct DispatcherQueueOptions
{
    ///Size of this <b>DispatcherQueueOptions</b> structure.
    uint dwSize;
    ///Thread affinity for the created DispatcherQueueController.
    DISPATCHERQUEUE_THREAD_TYPE threadType;
    ///Specifies whether to initialize COM apartment on the new thread as an application single-threaded apartment
    ///(ASTA) or single-threaded apartment (STA). This field is only relevant if <b>threadType</b> is
    ///<b>DQTYPE_THREAD_DEDICATED</b>. Use <b>DQTAT_COM_NONE</b> when <b>DispatcherQueueOptions.threadType</b> is
    ///<b>DQTYPE_THREAD_CURRENT</b>.
    DISPATCHERQUEUE_THREAD_APARTMENTTYPE apartmentType;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines a storage device using a particular code set and type.
struct VDS_STORAGE_IDENTIFIER
{
    ///The encoding type of <b>m_rgbIdentifier</b> enumerated by VDS_STORAGE_IDENTIFIER_CODE_SET.
    VDS_STORAGE_IDENTIFIER_CODE_SET m_CodeSet;
    ///The type of <b>m_rgbIdentifier</b> enumerated by VDS_STORAGE_IDENTIFIER_TYPE.
    VDS_STORAGE_IDENTIFIER_TYPE m_Type;
    ///The size of the <b>m_rgbIdentifier</b> array, in bytes.
    uint   m_cbIdentifier;
    ///Pointer to the identifier data.
    ubyte* m_rgbIdentifier;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines one or more storage identifiers for a storage device
///(typically an instance, as opposed to a class, of device).
struct VDS_STORAGE_DEVICE_ID_DESCRIPTOR
{
    ///The version of this structure.
    uint m_version;
    ///The number of identifiers specified in <b>m_rgIdentifiers</b>.
    uint m_cIdentifiers;
    ///Pointer to VDS_STORAGE_IDENTIFIER structure.
    VDS_STORAGE_IDENTIFIER* m_rgIdentifiers;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the address data of a physical interconnect.
struct VDS_INTERCONNECT
{
    ///The interconnect address type enumerated by VDS_INTERCONNECT_ADDRESS_TYPE.
    VDS_INTERCONNECT_ADDRESS_TYPE m_addressType;
    ///The size of the interconnect address data for the LUN port (<b>m_pbPort</b>), in bytes.
    uint   m_cbPort;
    ///Pointer to the interconnect address data for the LUN port.
    ubyte* m_pbPort;
    ///The size of the interconnect address data for the LUN (<b>m_pbAddress</b>), in bytes.
    uint   m_cbAddress;
    ///Pointer to the interconnect address data for the LUN.
    ubyte* m_pbAddress;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines information about a LUN or disk. Applications can use this
///structure to uniquely identify a LUN at all times.
struct VDS_LUN_INFORMATION
{
    ///The version of this structure. The current value is the constant <b>VER_VDS_LUN_INFORMATION</b>.
    uint                 m_version;
    ///The SCSI-2 device type of the LUN.
    ubyte                m_DeviceType;
    ///The SCSI-2 device type modifier of the LUN. For LUNs that have no device type modifier, the value is zero.
    ubyte                m_DeviceTypeModifier;
    ///If <b>TRUE</b>, the LUN supports multiple outstanding commands; otherwise, <b>FALSE</b>. The synchronization of
    ///the queue is the responsibility of the port driver.
    BOOL                 m_bCommandQueueing;
    ///The bus type of the LUN enumerated by VDS_STORAGE_BUS_TYPE.
    VDS_STORAGE_BUS_TYPE m_BusType;
    ///Pointer to the LUN vendor identifier; a zero-terminated, human-readable string. For devices that have no vendor
    ///identifier, the value is zero.
    ubyte*               m_szVendorId;
    ///Pointer to the LUN product identifier, typically a model number; a zero-terminated, human-readable string. For
    ///devices that have no product identifier, the value is zero.
    ubyte*               m_szProductId;
    ///Pointer to the LUN product revision; a zero-terminated, human-readable string. For devices that have no product
    ///revision, the value is zero.
    ubyte*               m_szProductRevision;
    ///Pointer to the LUN serial number; a zero-terminated, human-readable string. For devices that have no serial
    ///number, the value is zero.
    ubyte*               m_szSerialNumber;
    ///The signature of the LUN. For disks that use the Master Boot Record (MBR) partitioning structure, the first 32
    ///bits of the GUID comprise the disk signature, and the remaining bits are zeros. For disks that use the GUID
    ///Partition Table (GPT) partitioning structure, the GUID consists of the GPT disk identifier. If this value is
    ///zero, the disk is uninitialized or the hardware provider was unable to retrieve the signature.
    GUID                 m_diskSignature;
    ///Array containing the LUN descriptor in various formats, such as "VDSStorageIdTypeFCPHName" and
    ///"VDSStorageIdTypeVendorSpecific". Providers can use "VDSStorageIdTypeVendorSpecific" to store an arbitrary byte
    ///string of the vendor's choosing to uniquely identify the LUN. See the VDS_STORAGE_DEVICE_ID_DESCRIPTOR structure
    ///and the VDS_STORAGE_IDENTIFIER structure.
    VDS_STORAGE_DEVICE_ID_DESCRIPTOR m_deviceIdDescriptor;
    ///The number of interconnect ports specified in <b>m_rgInterconnects</b>.
    uint                 m_cInterconnects;
    ///Pointer to an array of the interconnect ports by which the LUN can be accessed. See the VDS_INTERCONNECT
    ///structure.
    VDS_INTERCONNECT*    m_rgInterconnects;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of pack events.
struct VDS_PACK_NOTIFICATION
{
    ///Determines the pack event for which an application will be notified, as one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_PACK_ARRIVE"></a><a
    ///id="vds_nf_pack_arrive"></a><dl> <dt><b>VDS_NF_PACK_ARRIVE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> A new
    ///pack arrived. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_PACK_DEPART"></a><a id="vds_nf_pack_depart"></a><dl>
    ///<dt><b>VDS_NF_PACK_DEPART</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> An existing pack was removed. </td>
    ///</tr> <tr> <td width="40%"><a id="VDS_NF_PACK_MODIFY"></a><a id="vds_nf_pack_modify"></a><dl>
    ///<dt><b>VDS_NF_PACK_MODIFY</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> A member of the VDS_PACK_PROP
    ///structure for the pack was changed. </td> </tr> </table>
    uint ulEvent;
    ///The GUID for the pack that triggered the event.
    GUID packId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of disk events.
struct VDS_DISK_NOTIFICATION
{
    ///Determines the disk event for which an application will be notified, as one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_DISK_ARRIVE"></a><a
    ///id="vds_nf_disk_arrive"></a><dl> <dt><b>VDS_NF_DISK_ARRIVE</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> A
    ///disk was inserted, or a RAID controller surfaced a LUN that is local to the host. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_NF_DISK_DEPART"></a><a id="vds_nf_disk_depart"></a><dl> <dt><b>VDS_NF_DISK_DEPART</b></dt>
    ///<dt>9</dt> </dl> </td> <td width="60%"> A disk was removed, or a RAID controller unbound a LUN. </td> </tr> <tr>
    ///<td width="40%"><a id="VDS_NF_DISK_MODIFY"></a><a id="vds_nf_disk_modify"></a><dl>
    ///<dt><b>VDS_NF_DISK_MODIFY</b></dt> <dt>10</dt> </dl> </td> <td width="60%"> A member of the VDS_DISK_PROP
    ///structure changed, or an extent on a disk changed. </td> </tr> </table>
    uint ulEvent;
    ///The GUID of the disk object that triggered the event.
    GUID diskId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of volume events.
struct VDS_VOLUME_NOTIFICATION
{
    ///Determines the volume event for which an application will be notified, as one of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_VOLUME_ARRIVE"></a><a
    ///id="vds_nf_volume_arrive"></a><dl> <dt><b>VDS_NF_VOLUME_ARRIVE</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> A
    ///new volume arrived. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_VOLUME_DEPART"></a><a
    ///id="vds_nf_volume_depart"></a><dl> <dt><b>VDS_NF_VOLUME_DEPART</b></dt> <dt>5</dt> </dl> </td> <td width="60%">
    ///An existing volume was removed. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_VOLUME_MODIFY"></a><a
    ///id="vds_nf_volume_modify"></a><dl> <dt><b>VDS_NF_VOLUME_MODIFY</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> A
    ///member of the VDS_VOLUME_PROP structure changed. This value can also indicate a change in one of the plexes
    ///associated with the volume, such as the addition, removal, or repair of a plex. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_NF_VOLUME_REBUILDING_PROGRESS"></a><a id="vds_nf_volume_rebuilding_progress"></a><dl>
    ///<dt><b>VDS_NF_VOLUME_REBUILDING_PROGRESS</b></dt> <dt>7</dt> </dl> </td> <td width="60%"> A volume is being
    ///rebuilt. </td> </tr> </table>
    uint ulEvent;
    ///The <b>VDS_OBJECT_ID</b> of the volume that triggered the event.
    GUID volumeId;
    ///The <b>VDS_OBJECT_ID</b> of a volume plex. VDS applies this identifier during the rebuild operation, which can
    ///execute on multiple plexes at different rates.
    GUID plexId;
    ///The degree to which the operation is complete.
    uint ulPercentCompleted;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of partition events.
struct VDS_PARTITION_NOTIFICATION
{
    ///Determines the partition event for which an application will be notified, as one of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_PARTITION_ARRIVE"></a><a
    ///id="vds_nf_partition_arrive"></a><dl> <dt><b>VDS_NF_PARTITION_ARRIVE</b></dt> <dt>11</dt> </dl> </td> <td
    ///width="60%"> A new partition arrived. If the partition is a volume, the event also triggers a volume-arrival
    ///notification. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_PARTITION_DEPART"></a><a
    ///id="vds_nf_partition_depart"></a><dl> <dt><b>VDS_NF_PARTITION_DEPART</b></dt> <dt>12</dt> </dl> </td> <td
    ///width="60%"> An existing partition was removed. If the partition is a volume, the event also triggers a
    ///volume-departure notification. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_PARTITION_MODIFY"></a><a
    ///id="vds_nf_partition_modify"></a><dl> <dt><b>VDS_NF_PARTITION_MODIFY</b></dt> <dt>13</dt> </dl> </td> <td
    ///width="60%"> A member was changed in the VDS_PARTITION_PROP structure for the partition. If the partition is a
    ///volume, and if the properties of the partition have changed, a <b>VDS_NF_VOLUME_MODIFY</b> notification is also
    ///sent. </td> </tr> </table>
    uint  ulEvent;
    ///The GUID of the disk containing the partition that triggered the event.
    GUID  diskId;
    ///The Partition offset.
    ulong ullOffset;
}

struct VDS_SERVICE_NOTIFICATION
{
    uint               ulEvent;
    VDS_RECOVER_ACTION action;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of drive-letter events.
struct VDS_DRIVE_LETTER_NOTIFICATION
{
    ///Determines the drive-letter event for which an application will be notified, as one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_DRIVE_LETTER_FREE"></a><a
    ///id="vds_nf_drive_letter_free"></a><dl> <dt><b>VDS_NF_DRIVE_LETTER_FREE</b></dt> <dt>201</dt> </dl> </td> <td
    ///width="60%"> The drive letter of an uninitialized disk is free. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_NF_DRIVE_LETTER_ASSIGN"></a><a id="vds_nf_drive_letter_assign"></a><dl>
    ///<dt><b>VDS_NF_DRIVE_LETTER_ASSIGN</b></dt> <dt>202</dt> </dl> </td> <td width="60%"> The drive letter of an
    ///uninitialized disk is assigned. </td> </tr> </table>
    uint   ulEvent;
    ///The drive letter that triggered the event.
    ushort wcLetter;
    ///The GUID of the volume to which the drive letter is assigned. If the drive letter is freed, the volume identifier
    ///is GUID_NULL.
    GUID   volumeId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of file-system events.
struct VDS_FILE_SYSTEM_NOTIFICATION
{
    ///Determines the file-system event for which an application will be notified, as one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_FILE_SYSTEM_MODIFY"></a><a
    ///id="vds_nf_file_system_modify"></a><dl> <dt><b>VDS_NF_FILE_SYSTEM_MODIFY</b></dt> <dt>203</dt> </dl> </td> <td
    ///width="60%"> A member was changed in the VDS_FILE_SYSTEM_PROP structure for the file system. For example, a
    ///volume received a new label, or a file system was extended or shrunk; does not include a change to the
    ///file-system compression flags. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS"></a><a
    ///id="vds_nf_file_system_format_progress"></a><dl> <dt><b>VDS_NF_FILE_SYSTEM_FORMAT_PROGRESS</b></dt> <dt>204</dt>
    ///</dl> </td> <td width="60%"> A file system volume is being formatted. </td> </tr> </table>
    uint ulEvent;
    ///The GUID of the volume object containing the file system that triggered the event.
    GUID volumeId;
    ///The completed format progress as a percentage of the whole.
    uint dwPercentCompleted;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Represents notification information that was returned by the basic
///or dynamic software provider because a drive letter or volume GUID path changed.
struct VDS_MOUNT_POINT_NOTIFICATION
{
    ///Determines the event for which an application will be notified, as the following value. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_MOUNT_POINTS_CHANGE"></a><a
    ///id="vds_nf_mount_points_change"></a><dl> <dt><b>VDS_NF_MOUNT_POINTS_CHANGE</b></dt> <dt>205</dt> </dl> </td> <td
    ///width="60%"> The drive letter or volume GUID path changed. </td> </tr> </table>
    uint ulEvent;
    ///The GUID of the volume object associated with the drive letter or volume GUID path that triggered the event.
    GUID volumeId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of subsystem events.
struct VDS_SUB_SYSTEM_NOTIFICATION
{
    ///Determines the subsystem event for which an application will be notified, as one of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_SUB_SYSTEM_ARRIVE"></a><a
    ///id="vds_nf_sub_system_arrive"></a><dl> <dt><b>VDS_NF_SUB_SYSTEM_ARRIVE</b></dt> <dt>101</dt> </dl> </td> <td
    ///width="60%"> A new subsystem was connected to the server or network. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_NF_SUB_SYSTEM_DEPART"></a><a id="vds_nf_sub_system_depart"></a><dl>
    ///<dt><b>VDS_NF_SUB_SYSTEM_DEPART</b></dt> <dt>102</dt> </dl> </td> <td width="60%"> An existing subsystem was
    ///disconnected. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_SUB_SYSTEM_MODIFY"></a><a
    ///id="vds_nf_sub_system_modify"></a><dl> <dt><b>VDS_NF_SUB_SYSTEM_MODIFY</b></dt> <dt>151</dt> </dl> </td> <td
    ///width="60%"> A member of the VDS_SUB_SYSTEM_PROP structure was changed. </td> </tr> </table>
    uint ulEvent;
    ///The subsystem's GUID.
    GUID subSystemId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of controller events.
struct VDS_CONTROLLER_NOTIFICATION
{
    ///Determines the controller event for which an application will be notified, as one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_CONTROLLER_ARRIVE"></a><a
    ///id="vds_nf_controller_arrive"></a><dl> <dt><b>VDS_NF_CONTROLLER_ARRIVE</b></dt> <dt>103</dt> </dl> </td> <td
    ///width="60%"> A controller is reported as physically present on the subsystem. The VDS_CONTROLLER_STATUS value
    ///associated with this notification should be any value except <b>VDS_CS_REMOVED</b>. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_NF_CONTROLLER_DEPART"></a><a id="vds_nf_controller_depart"></a><dl>
    ///<dt><b>VDS_NF_CONTROLLER_DEPART</b></dt> <dt>104</dt> </dl> </td> <td width="60%"> A controller was physically
    ///removed from the subsystem. The VDS_CONTROLLER_STATUS value should be <b>VDS_CS_UNKNOWN</b> or
    ///<b>VDS_CS_REMOVED</b>. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_CONTROLLER_MODIFY"></a><a
    ///id="vds_nf_controller_modify"></a><dl> <dt><b>VDS_NF_CONTROLLER_MODIFY</b></dt> <dt>350</dt> </dl> </td> <td
    ///width="60%"> A member of the VDS_CONTROLLER_PROP structure changed. <b>Windows Server 2008, Windows Vista and
    ///Windows Server 2003: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_NF_CONTROLLER_REMOVED"></a><a id="vds_nf_controller_removed"></a><dl>
    ///<dt><b>VDS_NF_CONTROLLER_REMOVED</b></dt> <dt>351</dt> </dl> </td> <td width="60%"> A controller is physically
    ///present but not available for use. The VDS_CONTROLLER_STATUS value should be <b>VDS_CS_FAILED</b> (removed from
    ///use because of failure), <b>VDS_CS_ONLINE</b> (not failed, but not in use either), <b>VDS_CS_NOT_READY</b>, or
    ///<b>VDS_CS_UNKNOWN</b>. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b>This value is not
    ///supported. </td> </tr> </table>
    uint ulEvent;
    ///The GUID of the controller that triggered the event.
    GUID controllerId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of drive events.
struct VDS_DRIVE_NOTIFICATION
{
    ///Determines the drive event for which an application will be notified, as one of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_DRIVE_ARRIVE"></a><a
    ///id="vds_nf_drive_arrive"></a><dl> <dt><b>VDS_NF_DRIVE_ARRIVE</b></dt> <dt>105</dt> </dl> </td> <td width="60%"> A
    ///drive is reported as physically present on the subsystem. The VDS_DRIVE_STATUS value associated with this
    ///notification should be any value except <b>VDS_DRS_REMOVED</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_NF_DRIVE_DEPART"></a><a id="vds_nf_drive_depart"></a><dl> <dt><b>VDS_NF_DRIVE_DEPART</b></dt>
    ///<dt>106</dt> </dl> </td> <td width="60%"> A drive was physically removed from the subsystem. The VDS_DRIVE_STATUS
    ///value should be <b>VDS_DRS_UNKNOWN</b> or <b>VDS_DRS_REMOVED</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_NF_DRIVE_MODIFY"></a><a id="vds_nf_drive_modify"></a><dl> <dt><b>VDS_NF_DRIVE_MODIFY</b></dt>
    ///<dt>107</dt> </dl> </td> <td width="60%"> A member of the VDS_DRIVE_PROP structure changed, or an extent on a
    ///drive changed. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_DRIVE_REMOVED"></a><a
    ///id="vds_nf_drive_removed"></a><dl> <dt><b>VDS_NF_DRIVE_REMOVED</b></dt> <dt>354</dt> </dl> </td> <td width="60%">
    ///A drive that was in use as part of a RAID group or storage pool is no longer in use as part of the RAID group or
    ///storage pool. For example, if a RAID group drive was detected as failing and was replaced with a hot spare, the
    ///VDS_DRIVE_STATUS value should be <b>VDS_DRS_FAILED</b> (removed from use because of failure),
    ///<b>VDS_DRS_OFFLINE</b> (not failed, but not in use), <b>VDS_DRS_NOT_READY</b>, or <b>VDS_DRS_UNKNOWN</b>. If the
    ///drive was removed as part of rebalancing the storage, the drive is not failing, and the <b>VDS_DRIVE_STATUS</b>
    ///value should be <b>VDS_DRS_OFFLINE</b> or <b>VDS_DRS_NOT_READY</b>. <b>Windows Server 2008, Windows Vista and
    ///Windows Server 2003: </b>This value is not supported. </td> </tr> </table>
    uint ulEvent;
    ///The GUID of the drive that triggered the event.
    GUID driveId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of a LUN notification.
struct VDS_LUN_NOTIFICATION
{
    ///Determines the LUN event for which an application will be notified, as one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_LUN_ARRIVE"></a><a
    ///id="vds_nf_lun_arrive"></a><dl> <dt><b><b>VDS_NF_LUN_ARRIVE</b></b></dt> <dt>108</dt> </dl> </td> <td
    ///width="60%"> A new LUN has been created. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_LUN_DEPART"></a><a
    ///id="vds_nf_lun_depart"></a><dl> <dt><b><b>VDS_NF_LUN_DEPART</b></b></dt> <dt>109</dt> </dl> </td> <td
    ///width="60%"> An existing LUN has been deleted. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_LUN_MODIFY"></a><a
    ///id="vds_nf_lun_modify"></a><dl> <dt><b><b>VDS_NF_LUN_MODIFY</b></b></dt> <dt>110</dt> </dl> </td> <td
    ///width="60%"> A member was changed in the VDS_LUN_PROP structure for an external LUN. Examples of changes that
    ///trigger this notification include changes to the <b>VDS_LUN_PROP</b>structure and the addition of a plex to the
    ///LUN. Applications are responsible for determining the precise nature of the change. </td> </tr> </table>
    uint ulEvent;
    ///The GUID of the LUN.
    GUID LunId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of controller port events.
struct VDS_PORT_NOTIFICATION
{
    ///Determines the controller port event for which an application will be notified, as one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_PORT_ARRIVE"></a><a
    ///id="vds_nf_port_arrive"></a><dl> <dt><b>VDS_NF_PORT_ARRIVE</b></dt> <dt>121</dt> </dl> </td> <td width="60%"> A
    ///controller port is reported as physically present on the subsystem. The VDS_PORT_STATUS value associated with
    ///this notification should be any value except <b>VDS_PRS_REMOVED</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_NF_PORT_DEPART"></a><a id="vds_nf_port_depart"></a><dl> <dt><b>VDS_NF_PORT_DEPART</b></dt> <dt>122</dt>
    ///</dl> </td> <td width="60%"> A controller, and therefore its port, were physically unplugged from the subsystem.
    ///The VDS_PORT_STATUS value should be <b>VDS_PRS_UNKNOWN</b> or <b>VDS_PRS_REMOVED</b>. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_NF_PORT_MODIFY"></a><a id="vds_nf_port_modify"></a><dl> <dt><b>VDS_NF_PORT_MODIFY</b></dt>
    ///<dt>352</dt> </dl> </td> <td width="60%"> A member of the VDS_PORT_PROP structure changed. <b>Windows Server
    ///2008, Windows Vista and Windows Server 2003 R2: </b>This value is not supported. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_NF_PORT_REMOVED"></a><a id="vds_nf_port_removed"></a><dl>
    ///<dt><b>VDS_NF_PORT_REMOVED</b></dt> <dt>353</dt> </dl> </td> <td width="60%"> A controller port is physically
    ///present but not available for use. For example, either the controller or the port itself is set to inactive. The
    ///VDS_PORT_STATUS value should be <b>VDS_PRS_FAILED</b> (removed from use because of failure),
    ///<b>VDS_PRS_OFFLINE</b> (not failed, but not in use either), <b>VDS_PRS_NOT_READY</b>, or <b>VDS_PRS_UNKNOWN</b>.
    ///<b>Windows Server 2008, Windows Vista and Windows Server 2003 R2: </b>This value is not supported. </td> </tr>
    ///</table>
    uint ulEvent;
    ///The <b>VDS_OBJECT_ID</b> of the controller port that triggered the event.
    GUID portId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of iSCSI portal events.
struct VDS_PORTAL_NOTIFICATION
{
    ///Determines the iSCSI portal event for which an application will be notified, as one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_PORTAL_ARRIVE"></a><a
    ///id="vds_nf_portal_arrive"></a><dl> <dt><b>VDS_NF_PORTAL_ARRIVE</b></dt> <dt>123</dt> </dl> </td> <td width="60%">
    ///An iSCSI portal has been created. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_PORTAL_DEPART"></a><a
    ///id="vds_nf_portal_depart"></a><dl> <dt><b>VDS_NF_PORTAL_DEPART</b></dt> <dt>124</dt> </dl> </td> <td width="60%">
    ///An existing iSCSI portal has been removed. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_PORTAL_MODIFY"></a><a
    ///id="vds_nf_portal_modify"></a><dl> <dt><b>VDS_NF_PORTAL_MODIFY</b></dt> <dt>125</dt> </dl> </td> <td width="60%">
    ///An existing iSCSI portal has changed. An example of change that triggers this notification would be changes to
    ///the VDS_ISCSI_PORTAL_PROP structure. Applications are responsible for determining the nature of any changes.
    ///</td> </tr> </table>
    uint ulEvent;
    ///The <b>VDS_OBJECT_ID</b> of the iSCSI portal that triggered the event.
    GUID portalId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of iSCSI target events.
struct VDS_TARGET_NOTIFICATION
{
    ///Determines the iSCSI target event for which an application will be notified, as one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NF_TARGET_ARRIVE"></a><a
    ///id="vds_nf_target_arrive"></a><dl> <dt><b>VDS_NF_TARGET_ARRIVE</b></dt> <dt>126</dt> </dl> </td> <td width="60%">
    ///An iSCSI target has been created. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_TARGET_DEPART"></a><a
    ///id="vds_nf_target_depart"></a><dl> <dt><b>VDS_NF_TARGET_DEPART</b></dt> <dt>127</dt> </dl> </td> <td width="60%">
    ///An existing iSCSI target has been deleted. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_TARGET_MODIFY"></a><a
    ///id="vds_nf_target_modify"></a><dl> <dt><b>VDS_NF_TARGET_MODIFY</b></dt> <dt>128</dt> </dl> </td> <td width="60%">
    ///An existing iSCSI target has changed. An example of change that triggers this notification would be changes to
    ///the VDS_ISCSI_TARGET_PROP structure. Applications are responsible for determining the nature of any changes.
    ///</td> </tr> </table>
    uint ulEvent;
    ///The <b>VDS_OBJECT_ID</b> of the iSCSI target that triggered the event.
    GUID targetId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the details of iSCSI portal events.
struct VDS_PORTAL_GROUP_NOTIFICATION
{
    ///Determines the iSCSI portal group event for which an application will be notified, as one of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="VDS_NF_PORTAL_GROUP_ARRIVE"></a><a id="vds_nf_portal_group_arrive"></a><dl>
    ///<dt><b>VDS_NF_PORTAL_GROUP_ARRIVE</b></dt> <dt>129</dt> </dl> </td> <td width="60%"> An iSCSI portal group has
    ///been created. </td> </tr> <tr> <td width="40%"><a id="VDS_NF_PORTAL_GROUP_DEPART"></a><a
    ///id="vds_nf_portal_group_depart"></a><dl> <dt><b>VDS_NF_PORTAL_GROUP_DEPART</b></dt> <dt>130</dt> </dl> </td> <td
    ///width="60%"> An existing iSCSI portal group has been deleted. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_NF_PORTAL_GROUP_MODIFY"></a><a id="vds_nf_portal_group_modify"></a><dl>
    ///<dt><b>VDS_NF_PORTAL_GROUP_MODIFY</b></dt> <dt>131</dt> </dl> </td> <td width="60%"> An existing iSCSI portal
    ///group has changed. An example of change that triggers this notification would be changes to the
    ///VDS_ISCSI_PORTALGROUP_PROP structure. Applications are responsible for determining the nature of any changes.
    ///</td> </tr> </table>
    uint ulEvent;
    ///The <b>VDS_OBJECT_ID</b> of the iSCSI portal that triggered the event.
    GUID portalGroupId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the VDS notification structures specific to each
///notification target type (subject).
struct VDS_NOTIFICATION
{
    ///Discriminant for the union enumerated by VDS_NOTIFICATION_TARGET_TYPE. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_NTT_PACK"></a><a id="vds_ntt_pack"></a><dl>
    ///<dt><b><b>VDS_NTT_PACK</b></b></dt> <dt>10</dt> </dl> </td> <td width="60%"> The subject of the notification is a
    ///disk pack. Use the <b>Pack</b> member structure. </td> </tr> <tr> <td width="40%"><a id="VDS_NTT_DISK"></a><a
    ///id="vds_ntt_disk"></a><dl> <dt><b><b>VDS_NTT_DISK</b></b></dt> <dt>13</dt> </dl> </td> <td width="60%"> The
    ///subject of the notification is a disk. Use the <b>Disk</b> member structure. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_NTT_VOLUME"></a><a id="vds_ntt_volume"></a><dl> <dt><b><b>VDS_NTT_VOLUME</b></b></dt> <dt>11</dt> </dl>
    ///</td> <td width="60%"> The subject of the notification is a volume. Use the <b>Volume</b> member structure. </td>
    ///</tr> <tr> <td width="40%"><a id="VDS_NTT_PARTITION"></a><a id="vds_ntt_partition"></a><dl>
    ///<dt><b><b>VDS_NTT_PARTITION</b></b></dt> <dt>60</dt> </dl> </td> <td width="60%"> The subject of the notification
    ///is a partition. Use the <b>Partition</b> member structure. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_NTT_DRIVE_LETTER"></a><a id="vds_ntt_drive_letter"></a><dl> <dt><b><b>VDS_NTT_DRIVE_LETTER</b></b></dt>
    ///<dt>61</dt> </dl> </td> <td width="60%"> The subject of the notification is a drive letter. Use the <b>Letter</b>
    ///member structure. </td> </tr> <tr> <td width="40%"><a id="VDS_NTT_FILE_SYSTEM"></a><a
    ///id="vds_ntt_file_system"></a><dl> <dt><b><b>VDS_NTT_FILE_SYSTEM</b></b></dt> <dt>62</dt> </dl> </td> <td
    ///width="60%"> The subject of the notification is a file system. Use the <b>FileSystem</b> member structure. </td>
    ///</tr> <tr> <td width="40%"><a id="VDS_NTT_MOUNT_POINT"></a><a id="vds_ntt_mount_point"></a><dl>
    ///<dt><b><b>VDS_NTT_MOUNT_POINT</b></b></dt> <dt>63</dt> </dl> </td> <td width="60%"> The subject of the
    ///notification is a drive letter or volume GUID path. Use the <b>MountPoint</b> member structure. </td> </tr> <tr>
    ///<td width="40%"><a id="VDS_NTT_SUB_SYSTEM"></a><a id="vds_ntt_sub_system"></a><dl>
    ///<dt><b><b>VDS_NTT_SUB_SYSTEM</b></b></dt> <dt>30</dt> </dl> </td> <td width="60%"> Used by hardware providers.
    ///The subject of the notification is a subsystem. Use the <b>SubSystem</b> member structure. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_NTT_CONTROLLER"></a><a id="vds_ntt_controller"></a><dl>
    ///<dt><b><b>VDS_NTT_CONTROLLER</b></b></dt> <dt>31</dt> </dl> </td> <td width="60%"> Used by hardware providers.
    ///The subject of the notification is a controller. Use the <b>Controller</b> member structure. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_NTT_DRIVE"></a><a id="vds_ntt_drive"></a><dl> <dt><b><b>VDS_NTT_DRIVE</b></b></dt>
    ///<dt>32</dt> </dl> </td> <td width="60%"> Used by hardware providers. The subject of the notification is a drive.
    ///Use the <b>Drive</b> member structure. </td> </tr> <tr> <td width="40%"><a id="VDS_NTT_LUN"></a><a
    ///id="vds_ntt_lun"></a><dl> <dt><b><b>VDS_NTT_LUN</b></b></dt> <dt>33</dt> </dl> </td> <td width="60%"> Used by
    ///hardware providers. The subject of the notification is a LUN. Use the <b>Lun</b> member structure. </td> </tr>
    ///<tr> <td width="40%"><a id="VDS_NTT_PORT"></a><a id="vds_ntt_port"></a><dl> <dt><b><b>VDS_NTT_PORT</b></b></dt>
    ///<dt>35</dt> </dl> </td> <td width="60%"> The subject of the notification is a controller port. Use the
    ///<b>Port</b> member structure. </td> </tr> <tr> <td width="40%"><a id="VDS_NTT_PORTAL"></a><a
    ///id="vds_ntt_portal"></a><dl> <dt><b><b>VDS_NTT_PORTAL</b></b></dt> <dt>36</dt> </dl> </td> <td width="60%"> The
    ///subject of the notification is an iSCSI portal. Use the <b>Portal</b> member structure. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_NTT_TARGET"></a><a id="vds_ntt_target"></a><dl> <dt><b><b>VDS_NTT_TARGET</b></b></dt>
    ///<dt>37</dt> </dl> </td> <td width="60%"> The subject of the notification is an iSCSI target. Use the
    ///<b>Target</b> member structure. </td> </tr> <tr> <td width="40%"><a id="VDS_NTT_PORTAL_GROUP"></a><a
    ///id="vds_ntt_portal_group"></a><dl> <dt><b><b>VDS_NTT_PORTAL_GROUP</b></b></dt> <dt>38</dt> </dl> </td> <td
    ///width="60%"> The subject of the notification is an iSCSI portal group. Use the <b>PortalGroup</b> member
    ///structure. </td> </tr> </table>
    VDS_NOTIFICATION_TARGET_TYPE objectType;
union
    {
        VDS_PACK_NOTIFICATION Pack;
        VDS_DISK_NOTIFICATION Disk;
        VDS_VOLUME_NOTIFICATION Volume;
        VDS_PARTITION_NOTIFICATION Partition;
        VDS_DRIVE_LETTER_NOTIFICATION Letter;
        VDS_FILE_SYSTEM_NOTIFICATION FileSystem;
        VDS_MOUNT_POINT_NOTIFICATION MountPoint;
        VDS_SUB_SYSTEM_NOTIFICATION SubSystem;
        VDS_CONTROLLER_NOTIFICATION Controller;
        VDS_DRIVE_NOTIFICATION Drive;
        VDS_LUN_NOTIFICATION Lun;
        VDS_PORT_NOTIFICATION Port;
        VDS_PORTAL_NOTIFICATION Portal;
        VDS_TARGET_NOTIFICATION Target;
        VDS_PORTAL_GROUP_NOTIFICATION PortalGroup;
        VDS_SERVICE_NOTIFICATION Service;
    }
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the output of an async object. Output elements vary
///depending on the operation type.
struct VDS_ASYNC_OUTPUT
{
    ///Discriminant for the union enumerated by VDS_ASYNC_OUTPUT_TYPE. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="VDS_ASYNCOUT_CREATEPARTITION"></a><a id="vds_asyncout_createpartition"></a><dl>
    ///<dt><b><b>VDS_ASYNCOUT_CREATEPARTITION</b></b></dt> <dt>10</dt> </dl> </td> <td width="60%"> See the following
    ///description of the <b>cp</b> structure. </td> </tr> <tr> <td width="40%"><a id="VDS_ASYNCOUT_CREATEVOLUME"></a><a
    ///id="vds_asyncout_createvolume"></a><dl> <dt><b><b>VDS_ASYNCOUT_CREATEVOLUME</b></b></dt> <dt>1</dt> </dl> </td>
    ///<td width="60%"> See the following description of the <b>cv</b> structure. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_ASYNCOUT_BREAKVOLUMEPLEX"></a><a id="vds_asyncout_breakvolumeplex"></a><dl>
    ///<dt><b><b>VDS_ASYNCOUT_BREAKVOLUMEPLEX</b></b></dt> <dt>5</dt> </dl> </td> <td width="60%"> See the following
    ///description of the <b>bvp</b> structure. </td> </tr> <tr> <td width="40%"><a id="VDS_ASYNCOUT_CREATELUN"></a><a
    ///id="vds_asyncout_createlun"></a><dl> <dt><b><b>VDS_ASYNCOUT_CREATELUN</b></b></dt> <dt>50</dt> </dl> </td> <td
    ///width="60%"> See the following description of the <b>cl</b> structure. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_ASYNCOUT_CREATETARGET"></a><a id="vds_asyncout_createtarget"></a><dl>
    ///<dt><b><b>VDS_ASYNCOUT_CREATETARGET</b></b></dt> <dt>62</dt> </dl> </td> <td width="60%"> See the following
    ///description of the <b>ct</b> structure. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_ASYNCOUT_CREATEPORTALGROUP"></a><a id="vds_asyncout_createportalgroup"></a><dl>
    ///<dt><b><b>VDS_ASYNCOUT_CREATEPORTALGROUP</b></b></dt> <dt>63</dt> </dl> </td> <td width="60%"> See the following
    ///description of the <b>cpg</b> structure. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_ASYNCOUT_CREATE_VDISK"></a><a id="vds_asyncout_create_vdisk"></a><dl>
    ///<dt><b><b>VDS_ASYNCOUT_CREATE_VDISK</b></b></dt> <dt>200</dt> </dl> </td> <td width="60%"> See the following
    ///description of the <b>cvd</b> structure. </td> </tr> </table>
    VDS_ASYNC_OUTPUT_TYPE type;
union
    {
struct cp
        {
            ulong ullOffset;
            GUID  volumeId;
        }
struct cv
        {
            IUnknown pVolumeUnk;
        }
struct bvp
        {
            IUnknown pVolumeUnk;
        }
struct sv
        {
            ulong ullReclaimedBytes;
        }
struct cl
        {
            IUnknown pLunUnk;
        }
struct ct
        {
            IUnknown pTargetUnk;
        }
struct cpg
        {
            IUnknown pPortalGroupUnk;
        }
struct cvd
        {
            IUnknown pVDiskUnk;
        }
    }
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines a unique identification for a path.
struct VDS_PATH_ID
{
    ///The source ID for the path. If this is an MPIO path, the source ID is the unique DSM ID.
    ulong ullSourceId;
    ///The ID of the path given by the MPIO DSM.
    ulong ullPathId;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines a world-wide name (WWN). This structure corresponds to the
///HBA_WWN structure defined by the ANSI HBA API.
struct VDS_WWN
{
    ///An array of 8 bytes that together specify the 64-bit WWN value. The first element of the array is the most
    ///significant byte of the WWN, with the most significant bit of that byte being the most significant bit of the
    ///WWN.
    ubyte[8] rguchWwn;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines an IP address and port.
struct VDS_IPADDRESS
{
    ///The type of address as enumerated by VDS_IPADDRESS_TYPE.
    VDS_IPADDRESS_TYPE type;
    ///If the <b>type</b> member is <b>VDS_IPT_IPV4</b>, then this contains the binary IPv4 address in network byte
    ///order. The field 3 byte value is contained in bits 0 through 7. The field 2 byte value is contained in bits 8
    ///through 15. The field 1 byte value is contained in bits 16 through 23. The field 0 byte value is contained in
    ///bits 24 through 31.
    uint               ipv4Address;
    ///If the <b>type</b> member is <b>VDS_IPT_IPV6</b>, then this contains the binary IPv6 address in network byte
    ///order.
    ubyte[16]          ipv6Address;
    ///If the <b>type</b> member is <b>VDS_IPT_IPV6</b>, then this contains the flow information as defined in version 6
    ///of the IP protocol.
    uint               ulIpv6FlowInfo;
    ///If the <b>type</b> member is <b>VDS_IPT_IPV6</b>, then this contains the scope ID as defined in version 6 of the
    ///IP protocol.
    uint               ulIpv6ScopeId;
    ///If the <b>type</b> member is <b>VDS_IPT_TEXT</b>, then this contains the text address, either a DNS address or
    ///dotted address, in host byte order.
    ushort[257]        wszTextAddress;
    ///The TCP port number.
    uint               ulPort;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Not supported. This structure is reserved for future use.
struct VDS_ISCSI_IPSEC_KEY
{
    ///Reserved for future use.
    ubyte* pKey;
    uint   ulKeySize;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines a CHAP shared secret.
struct VDS_ISCSI_SHARED_SECRET
{
    ///A pointer to an array of bytes that contains the CHAP shared secret. If a shared secret is not necessary, this
    ///parameter should be <b>NULL</b>.
    ubyte* pSharedSecret;
    ///The number of bytes in the array that the <b>pSharedSecret</b> member points to. If the <b>pSharedSecret</b>
    ///member is <b>NULL</b>, this parameter must be zero. If <b>pSharedSecret</b> is not <b>NULL</b>, this parameter
    ///must be greater than or equal to 12 and less than or equal to 16.
    uint   ulSharedSecretSize;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of an HBA port.
struct VDS_HBAPORT_PROP
{
    ///The GUID assigned to the HBA port. This ID is used by the VDS service only; hardware providers should ignore this
    ///field.
    GUID               id;
    ///The node WWN of the HBA port.
    VDS_WWN            wwnNode;
    ///The port WWN of the HBA port.
    VDS_WWN            wwnPort;
    ///The type of the HBA port enumerated by VDS_HBAPORT_TYPE.
    VDS_HBAPORT_TYPE   type;
    ///The status of the HBA port enumerated by VDS_HBAPORT_STATUS.
    VDS_HBAPORT_STATUS status;
    ///The speed of the HBA port enumerated by VDS_HBAPORT_SPEED_FLAG.
    uint               ulPortSpeed;
    ///The set of supported speeds of the HBA port, one bit set for each of the supported speeds enumerated by
    ///VDS_HBAPORT_SPEED_FLAG.
    uint               ulSupportedPortSpeed;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of an iSCSI initiator adapter.
struct VDS_ISCSI_INITIATOR_ADAPTER_PROP
{
    ///The <b>VDS_OBJECT_ID</b> assigned to the initiator adapter.
    GUID  id;
    ///A null-terminated, human-readable string that is the name of the initiator adapter.
    PWSTR pwszName;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of an iSCSI initiator portal.
struct VDS_ISCSI_INITIATOR_PORTAL_PROP
{
    ///The <b>VDS_OBJECT_ID</b> assigned to the initiator portal.
    GUID          id;
    ///The IP address and port of the portal.
    VDS_IPADDRESS address;
    ///The port index assigned to the portal by the iSCSI initiator service.
    uint          ulPortIndex;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a provider object.
struct VDS_PROVIDER_PROP
{
    ///The GUID of the provider object.
    GUID              id;
    ///A string representing the name of the provider.
    PWSTR             pwszName;
    ///The version-specific GUID of the provider.
    GUID              guidVersionId;
    ///A string representing the version of the provider.
    PWSTR             pwszVersion;
    ///The provider types enumerated by VDS_PROVIDER_TYPE.
    VDS_PROVIDER_TYPE type;
    ///The provider flags enumerated by VDS_PROVIDER_FLAG.
    uint              ulFlags;
    ///The size of a stripe to be used across multiple disks managed by a software provider. A stripe size must be a
    ///power of 2. Each bit in the 32-bit integer represents a size, in bytes. For example, if the <i>n</i>th bit is
    ///set, then VDS supports stripe size of 2^<i>n</i>. Thus, bits 0 through 31 can specify 2^0 through 2^31. The basic
    ///provider sets this value to zero. The dynamic stripe size can be any power of 2 ranging from 512 to 1MB.
    ///<b>Windows Server 2003: </b>The dynamic provider sets this value to 64k.
    uint              ulStripeSizeFlags;
    ///The rebuild priority used by software providers to specify the regeneration order when a mirrored or striped with
    ///parity (RAID-5) volume requires rebuilding. Priority levels are 0 (lowest priority) to 15 (highest priority). VDS
    ///propagates the priority to all new volumes created by the provider. Thus, all volumes managed by a provider have
    ///the same rebuild priority. This member does not apply to the basic provider and is zero for the dynamic provider.
    short             sRebuildPriority;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the information for a LUN path. This structure is returned
///in the <i>ppPaths</i> parameter of the IVdsLunMpio::GetPathInfo method.
struct VDS_PATH_INFO
{
    ///The unique ID of the path used by MPIO.
    VDS_PATH_ID         pathId;
    ///The type of interconnect that the hardware provider supports for this LUN path. VDS_HWT_HYBRID is not a valid
    ///value for this member, even if the provider is a hybrid provider.
    VDS_HWPROVIDER_TYPE type;
    ///The status of the path, enumerated by VDS_PATH_STATUS.
    VDS_PATH_STATUS     status;
union
    {
        GUID controllerPortId;
        GUID targetPortalId;
    }
union
    {
        GUID hbaPortId;
        GUID initiatorAdapterId;
    }
union
    {
        VDS_HBAPORT_PROP* pHbaPortProp;
        VDS_IPADDRESS*    pInitiatorPortalIpAddr;
    }
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the load balance policy as it applies to a particular
///path.
struct VDS_PATH_POLICY
{
    ///The ID of the path used by MPIO.
    VDS_PATH_ID pathId;
    ///If set, indicates that the path is a primary path for MPIO.
    BOOL        bPrimaryPath;
    ///The weight assigned to the path. This is only relevant if the load balance policy for the LUN is
    ///<b>VDS_LBP_WEIGHTED_PATHS</b>.
    uint        ulWeight;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the automagic hints for a LUN or LUN plex.
struct VDS_HINTS
{
    ///The LUN hint mask. Each of the <b>BOOL</b> members of this structure has a corresponding hint flag that can be
    ///set in the mask. If the hint flag is set, the corresponding hint is considered. If the hint flag is not set, the
    ///hint is ignored. The hint flags are described in the following table. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_HINT_FASTCRASHRECOVERYREQUIRED"></a><a
    ///id="vds_hint_fastcrashrecoveryrequired"></a><dl> <dt><b>VDS_HINT_FASTCRASHRECOVERYREQUIRED</b></dt>
    ///<dt>0x0000000000000001L</dt> </dl> </td> <td width="60%"> The provider limits the time that is required for
    ///recovery. To support fast recovery, the provider uses a change log that enables the provider to recover the LUN
    ///without comparing the entire contents of the LUN. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_MOSTLYREADS"></a><a id="vds_hint_mostlyreads"></a><dl> <dt><b>VDS_HINT_MOSTLYREADS</b></dt>
    ///<dt>0x0000000000000002L</dt> </dl> </td> <td width="60%"> The provider optimizes the LUN for a read-mostly usage
    ///pattern, typically by using mirroring rather than parity striping. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_OPTIMIZEFORSEQUENTIALREADS"></a><a id="vds_hint_optimizeforsequentialreads"></a><dl>
    ///<dt><b>VDS_HINT_OPTIMIZEFORSEQUENTIALREADS</b></dt> <dt>0x0000000000000004L</dt> </dl> </td> <td width="60%"> The
    ///provider optimizes the LUN for a sequential-read usage pattern. If this flag is not set and
    ///VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES is also not set, the LUN is optimized for random I/O. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES"></a><a
    ///id="vds_hint_optimizeforsequentialwrites"></a><dl> <dt><b>VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES</b></dt>
    ///<dt>0x0000000000000008L</dt> </dl> </td> <td width="60%"> The provider optimizes the LUN for a sequential-write
    ///usage pattern. If this flag is not set and VDS_HINT_OPTIMIZEFORSEQUENTIALREADS is also not set, the LUN is
    ///optimized for random I/O. </td> </tr> <tr> <td width="40%"><a id="VDS_HINT_READBACKVERIFYENABLED"></a><a
    ///id="vds_hint_readbackverifyenabled"></a><dl> <dt><b>VDS_HINT_READBACKVERIFYENABLED</b></dt>
    ///<dt>0x0000000000000010L</dt> </dl> </td> <td width="60%"> The provider verifies the writes to the LUN by using
    ///readback. </td> </tr> <tr> <td width="40%"><a id="VDS_HINT_REMAPENABLED"></a><a
    ///id="vds_hint_remapenabled"></a><dl> <dt><b>VDS_HINT_REMAPENABLED</b></dt> <dt>0x0000000000000020L</dt> </dl>
    ///</td> <td width="60%"> The mapping of LUN extents to drive extents is created and updated automatically by the
    ///provider. If this flag is not set, the mapping remains fixed after configuration, except when proactive actions
    ///are taken to avoid drive failures. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_WRITETHROUGHCACHINGENABLED"></a><a id="vds_hint_writethroughcachingenabled"></a><dl>
    ///<dt><b>VDS_HINT_WRITETHROUGHCACHINGENABLED</b></dt> <dt>0x0000000000000040L</dt> </dl> </td> <td width="60%"> The
    ///provider enables the write-through caching policy on the LUN. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_HARDWARECHECKSUMENABLED"></a><a id="vds_hint_hardwarechecksumenabled"></a><dl>
    ///<dt><b>VDS_HINT_HARDWARECHECKSUMENABLED</b></dt> <dt>0x0000000000000080L</dt> </dl> </td> <td width="60%"> The
    ///provider enables a hardware checksum on the LUN. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_ISYANKABLE"></a><a id="vds_hint_isyankable"></a><dl> <dt><b>VDS_HINT_ISYANKABLE</b></dt>
    ///<dt>0x0000000000000100L</dt> </dl> </td> <td width="60%"> The provider configures LUN so that the drives that
    ///contribute to it can be physically removed with minimal system disruption. This is normally accomplished by
    ///ensuring that the LUN occupies as few drives as possible. </td> </tr> </table>
    ulong ullHintMask;
    ///The maximum size to which the LUN is expected to grow, in bytes. The value can be equal to, greater than, or less
    ///than the value specified in <i>ullSizeInBytes</i> when the IVdsSubSystem::CreateLun method is called. Some
    ///providers use this value to reserve space for the LUN. Providers that are unable to reserve space typically
    ///ignore this parameter.
    ulong ullExpectedMaximumSize;
    ///The optimal read size for the LUN, in bytes. Zero indicates no optimal read size.
    uint  ulOptimalReadSize;
    ///The optimal read alignment with respect to the first logical block of the LUN. Zero indicates no optimal read
    ///alignment.
    uint  ulOptimalReadAlignment;
    ///The optimal write size for the LUN, in bytes. Zero indicates no optimal write size.
    uint  ulOptimalWriteSize;
    ///The optimal write alignment with respect to the first logical block of the LUN. Zero indicates no optimal write
    ///alignment.
    uint  ulOptimalWriteAlignment;
    ///The maximum number of drives to contribute to the LUN. Zero indicates no maximum drive count. This value can be
    ///used to limit the number of stripe interleaves in a stripe set.
    uint  ulMaximumDriveCount;
    ///The mirror or parity stripe interleave size, in bytes. Zero leaves the stripe size unspecified.
    uint  ulStripeSize;
    ///If this member is TRUE, the recovery time is limited. Set the <b>VDS_HINT_FASTCRASHRECOVERYREQUIRED</b> flag in
    ///the <b>ullHintMask</b> member to indicate interest in this member.
    BOOL  bFastCrashRecoveryRequired;
    ///To optimize for a mostly-reads usage pattern (for example, through mirroring rather than parity striping), set
    ///this member to TRUE. Otherwise, set it to <b>FALSE</b>. Set the <b>VDS_HINT_MOSTLYREADS</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL  bMostlyReads;
    ///To optimize for a sequential-reads usage pattern, set this member to <b>TRUE</b>. Otherwise, set it to
    ///<b>FALSE</b>. Setting the <b>bOptimizeForSequentialReads</b> and <b>bOptimizeForSequentialWrites</b> members both
    ///to <b>FALSE</b> optimizes for random I/O. Set the <b>VDS_HINT_OPTIMIZEFORSEQUENTIALREADS</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL  bOptimizeForSequentialReads;
    ///To optimize for a sequential-writes usage pattern, set to this member to <b>TRUE</b>. Otherwise, set it to
    ///<b>FALSE</b>. Setting the <b>bOptimizeForSequentialReads</b> and <b>bOptimizeForSequentialWrites</b> members both
    ///to <b>FALSE</b> optimizes for random I/O. Set the <b>VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL  bOptimizeForSequentialWrites;
    ///If this member is <b>TRUE</b>, the provider remaps LUN extents to drive extents automatically. If it is
    ///<b>FALSE</b>, the mapping of LUN extents to drive extents remains fixed after LUN configuration unless extents
    ///are explicitly remapped to avoid corrupted blocks. Set the <b>VDS_HINT_REMAPENABLED</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL  bRemapEnabled;
    ///If this member is set to <b>TRUE</b>, the provider verifies the writes to the LUN by readback. If it is set to
    ///<b>FALSE</b>, the provider does not verify writes. Set the <b>VDS_HINT_READBACKVERIFYENABLED</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL  bReadBackVerifyEnabled;
    ///If this member is <b>TRUE</b>, the provider enables write-through caching on the LUN. If it is <b>FALSE</b>, the
    ///provider does not enable write-through caching. Set the <b>VDS_HINT_WRITETHROUGHCACHINGENABLED</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL  bWriteThroughCachingEnabled;
    ///If this member is <b>TRUE</b>, the provider enables a checksum on the LUN. Set the
    ///<b>VDS_HINT_HARDWARECHECKSUMENABLED</b> flag in the <b>ullHintMask</b> member to indicate interest in this
    ///member.
    BOOL  bHardwareChecksumEnabled;
    ///If this member is <b>TRUE</b>, the drives that contribute to the LUN can be physically removed without
    ///significant disruption to the system (this is typically true when the LUN is composed of extents from only a few
    ///drives). If it is <b>FALSE</b>, the LUN cannot be removed without significant disruption to the system. Set the
    ///<b>VDS_HINT_ISYANKABLE</b> flag in the <b>ullHintMask</b> member to indicate interest in this member.
    BOOL  bIsYankable;
    ///The rebuild priority for the LUN. The value can range from 0 (lowest priority) through 15 (highest priority).
    short sRebuildPriority;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Contains the automagic hints for a LUN in a storage pool.
struct VDS_HINTS2
{
    ///The LUN hint mask. Each of the <b>BOOL</b> members of this structure has a corresponding hint flag that can be
    ///set in the mask. If the hint flag is set, the corresponding hint is considered. If the hint flag is not set, the
    ///hint is ignored. The hint flags are described in the following table. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="VDS_HINT_FASTCRASHRECOVERYREQUIRED"></a><a
    ///id="vds_hint_fastcrashrecoveryrequired"></a><dl> <dt><b>VDS_HINT_FASTCRASHRECOVERYREQUIRED</b></dt>
    ///<dt>0x0000000000000001L</dt> </dl> </td> <td width="60%"> The provider limits the time that is required for
    ///recovery. To support fast recovery, the provider uses a change log that enables the provider to recover the LUN
    ///without comparing the entire contents of the LUN. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_MOSTLYREADS"></a><a id="vds_hint_mostlyreads"></a><dl> <dt><b>VDS_HINT_MOSTLYREADS</b></dt>
    ///<dt>0x0000000000000002L</dt> </dl> </td> <td width="60%"> The provider optimizes the LUN for a read-mostly usage
    ///pattern, typically by using mirroring rather than parity striping. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_OPTIMIZEFORSEQUENTIALREADS"></a><a id="vds_hint_optimizeforsequentialreads"></a><dl>
    ///<dt><b>VDS_HINT_OPTIMIZEFORSEQUENTIALREADS</b></dt> <dt>0x0000000000000004L</dt> </dl> </td> <td width="60%"> The
    ///provider optimizes the LUN for a sequential-read usage pattern. If this flag is not set and
    ///VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES is also not set, the LUN is optimized for random I/O. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES"></a><a
    ///id="vds_hint_optimizeforsequentialwrites"></a><dl> <dt><b>VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES</b></dt>
    ///<dt>0x0000000000000008L</dt> </dl> </td> <td width="60%"> The provider optimizes the LUN for a sequential-write
    ///usage pattern. If this flag is not set and VDS_HINT_OPTIMIZEFORSEQUENTIALREADS is also not set, the LUN is
    ///optimized for random I/O. </td> </tr> <tr> <td width="40%"><a id="VDS_HINT_READBACKVERIFYENABLED"></a><a
    ///id="vds_hint_readbackverifyenabled"></a><dl> <dt><b>VDS_HINT_READBACKVERIFYENABLED</b></dt>
    ///<dt>0x0000000000000010L</dt> </dl> </td> <td width="60%"> The provider verifies the writes to the LUN by using
    ///readback. </td> </tr> <tr> <td width="40%"><a id="VDS_HINT_REMAPENABLED"></a><a
    ///id="vds_hint_remapenabled"></a><dl> <dt><b>VDS_HINT_REMAPENABLED</b></dt> <dt>0x0000000000000020L</dt> </dl>
    ///</td> <td width="60%"> The mapping of LUN extents to drive extents is created and updated automatically by the
    ///provider. If this flag is not set, the mapping remains fixed after configuration, except when proactive actions
    ///are taken to avoid drive failures. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_WRITETHROUGHCACHINGENABLED"></a><a id="vds_hint_writethroughcachingenabled"></a><dl>
    ///<dt><b>VDS_HINT_WRITETHROUGHCACHINGENABLED</b></dt> <dt>0x0000000000000040L</dt> </dl> </td> <td width="60%"> The
    ///provider enables the write-through caching policy on the LUN. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_HARDWARECHECKSUMENABLED"></a><a id="vds_hint_hardwarechecksumenabled"></a><dl>
    ///<dt><b>VDS_HINT_HARDWARECHECKSUMENABLED</b></dt> <dt>0x0000000000000080L</dt> </dl> </td> <td width="60%"> The
    ///provider enables a hardware checksum on the LUN. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_ISYANKABLE"></a><a id="vds_hint_isyankable"></a><dl> <dt><b>VDS_HINT_ISYANKABLE</b></dt>
    ///<dt>0x0000000000000100L</dt> </dl> </td> <td width="60%"> The provider configures the LUN so that the drives that
    ///contribute to it can be physically removed with minimal system disruption. This is normally accomplished by
    ///ensuring that the LUN occupies as few drives as possible. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_ALLOCATEHOTSPARE"></a><a id="vds_hint_allocatehotspare"></a><dl>
    ///<dt><b>VDS_HINT_ALLOCATEHOTSPARE</b></dt> <dt>0x0000000000000200L</dt> </dl> </td> <td width="60%"> The provider
    ///allocates a hot spare for the LUN. For more information, see Hot Sparing, VDS_DRIVE_FLAG, and VDS_DISK_FLAG.
    ///</td> </tr> <tr> <td width="40%"><a id="VDS_HINT_BUSTYPE"></a><a id="vds_hint_bustype"></a><dl>
    ///<dt><b>VDS_HINT_BUSTYPE</b></dt> <dt>0x0000000000000400L</dt> </dl> </td> <td width="60%"> The provider uses the
    ///specified bus type on the LUN. For more information, see VDS_STORAGE_BUS_TYPE. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_HINT_USEMIRROREDCACHE"></a><a id="vds_hint_usemirroredcache"></a><dl>
    ///<dt><b>VDS_HINT_USEMIRROREDCACHE</b></dt> <dt>0x0000000000000800L</dt> </dl> </td> <td width="60%"> The provider
    ///uses a mirrored cache on the LUN. See the <b>VDS_SF_SUPPORTS_MIRRORED_CACHE</b> value of the VDS_SUB_SYSTEM_FLAG
    ///enumeration. </td> </tr> <tr> <td width="40%"><a id="VDS_HINT_READCACHINGENABLED"></a><a
    ///id="vds_hint_readcachingenabled"></a><dl> <dt><b>VDS_HINT_READCACHINGENABLED</b></dt>
    ///<dt>0x0000000000001000L</dt> </dl> </td> <td width="60%"> The provider enables read caching on the LUN. See the
    ///<b>VDS_LF_READ_CACHE_ENABLED</b> value of the VDS_LUN_FLAG enumeration and the <b>VDS_SF_READ_CACHING_CAPABLE</b>
    ///value of the VDS_SUB_SYSTEM_FLAG enumeration. </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_HINT_WRITECACHINGENABLED"></a><a id="vds_hint_writecachingenabled"></a><dl>
    ///<dt><b>VDS_HINT_WRITECACHINGENABLED</b></dt> <dt>0x0000000000002000L</dt> </dl> </td> <td width="60%"> The
    ///provider enables write caching on the LUN. See the <b>VDS_LF_WRITE_CACHE_ENABLED</b> value of the VDS_LUN_FLAG
    ///enumeration and the <b>VDS_SF_WRITE_CACHING_CAPABLE</b> value of the VDS_SUB_SYSTEM_FLAG enumeration. </td> </tr>
    ///<tr> <td width="40%"><a id="VDS_HINT_MEDIASCANENABLED"></a><a id="vds_hint_mediascanenabled"></a><dl>
    ///<dt><b>VDS_HINT_MEDIASCANENABLED</b></dt> <dt>0x0000000000004000L</dt> </dl> </td> <td width="60%"> The provider
    ///enables media scanning on the LUN. See the <b>VDS_LF_MEDIA_SCAN_ENABLED</b> value of the VDS_LUN_FLAG enumeration
    ///and the <b>VDS_SF_MEDIA_SCAN_CAPABLE</b> value of the VDS_SUB_SYSTEM_FLAG enumeration. </td> </tr> <tr> <td
    ///width="40%"><a id="VDS_HINT_CONSISTENCYCHECKENABLED"></a><a id="vds_hint_consistencycheckenabled"></a><dl>
    ///<dt><b>VDS_HINT_CONSISTENCYCHECKENABLED</b></dt> <dt>0x0000000000008000L</dt> </dl> </td> <td width="60%"> The
    ///provider enables consistency checking on the LUN. See the <b>VDS_LF_CONSISTENCY_CHECK_ENABLED</b> value of the
    ///VDS_LUN_FLAG enumeration and the <b>VDS_SF_CONSISTENCY_CHECK_CAPABLE</b> value of the VDS_SUB_SYSTEM_FLAG
    ///enumeration. </td> </tr> </table>
    ulong                ullHintMask;
    ///The maximum size to which the LUN is expected to grow, in bytes. The value can be equal to, greater than, or less
    ///than the value specified in the <i>ullSizeInBytes</i> parameter when the
    ///IVdsHwProviderStoragePools::CreateLunInStoragePool method is called. Some providers use this value to reserve
    ///space for the LUN. Providers that are unable to reserve space typically ignore this parameter.
    ulong                ullExpectedMaximumSize;
    ///The optimal read size for the LUN, in bytes. Zero indicates no optimal read size.
    uint                 ulOptimalReadSize;
    ///The optimal read alignment with respect to the first logical block of the LUN. Zero indicates no optimal read
    ///alignment.
    uint                 ulOptimalReadAlignment;
    ///The optimal write size for the LUN, in bytes. Zero indicates no optimal write size.
    uint                 ulOptimalWriteSize;
    ///The optimal write alignment with respect to the first logical block of the LUN. Zero indicates no optimal write
    ///alignment.
    uint                 ulOptimalWriteAlignment;
    ///The maximum number of drives to contribute to the LUN. Zero indicates no maximum drive count. This value can be
    ///used to limit the number of stripe interleaves in a stripe set.
    uint                 ulMaximumDriveCount;
    ///The mirror or parity stripe interleave size, in bytes. Zero leaves the stripe size unspecified.
    uint                 ulStripeSize;
    ///This member is reserved for future use. Do not use.
    uint                 ulReserved1;
    ///This member is reserved for future use. Do not use.
    uint                 ulReserved2;
    ///This member is reserved for future use. Do not use.
    uint                 ulReserved3;
    ///If this member is <b>TRUE</b>, the recovery time is limited. Set the <b>VDS_HINT_FASTCRASHRECOVERYREQUIRED</b>
    ///flag in the <b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bFastCrashRecoveryRequired;
    ///To optimize for a mostly-reads usage pattern (for example, through mirroring rather than parity striping), set
    ///this member to <b>TRUE</b>. Otherwise, set it to <b>FALSE</b>. Set the <b>VDS_HINT_MOSTLYREADS</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bMostlyReads;
    ///To optimize for a sequential-reads usage pattern, set this member to <b>TRUE</b>. Otherwise, set it to
    ///<b>FALSE</b>. Setting the <b>bOptimizeForSequentialReads</b> and <b>bOptimizeForSequentialWrites</b> members both
    ///to <b>FALSE</b> optimizes for random I/O. Set the <b>VDS_HINT_OPTIMIZEFORSEQUENTIALREADS</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bOptimizeForSequentialReads;
    ///To optimize for a sequential-writes usage pattern, set this member to <b>TRUE</b>. Otherwise, set it to
    ///<b>FALSE</b>. Setting the <b>bOptimizeForSequentialReads</b> and <b>bOptimizeForSequentialWrites</b> members both
    ///to <b>FALSE</b> optimizes for random I/O. Set the <b>VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bOptimizeForSequentialWrites;
    ///If this member is <b>TRUE</b>, the provider remaps LUN extents to drive extents automatically. If it is
    ///<b>FALSE</b>, the mapping of LUN extents to drive extents remains fixed after LUN configuration unless extents
    ///are explicitly remapped to avoid corrupted blocks. Set the <b>VDS_HINT_REMAPENABLED</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bRemapEnabled;
    ///If this member is <b>TRUE</b>, the provider verifies the writes to the LUN by readback. If it is <b>FALSE</b>,
    ///the provider does not verify writes. Set the <b>VDS_HINT_READBACKVERIFYENABLED</b> flag in the <b>ullHintMask</b>
    ///member to indicate interest in this member.
    BOOL                 bReadBackVerifyEnabled;
    ///If this member is <b>TRUE</b>, the provider enables write-through caching on the LUN; if it is <b>FALSE</b>, the
    ///provider does not enable write-through caching. Set the <b>VDS_HINT_WRITETHROUGHCACHINGENABLED</b> flag in the
    ///<b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bWriteThroughCachingEnabled;
    ///If this member is <b>TRUE</b>, the provider enables a checksum on the LUN. Set the
    ///<b>VDS_HINT_HARDWARECHECKSUMENABLED</b> flag in the <b>ullHintMask</b> member to indicate interest in this
    ///member.
    BOOL                 bHardwareChecksumEnabled;
    ///If this member is <b>TRUE</b>, the drives that contribute to the LUN can be physically removed without
    ///significant disruption to the system (this is typically true when the LUN is composed of extents from only a few
    ///drives). If it is <b>FALSE</b>, the LUN cannot be removed without significant disruption to the system. Set the
    ///<b>VDS_HINT_ISYANKABLE</b> flag in the <b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bIsYankable;
    ///<b>TRUE</b> if the client wants to allocate a hot spare drive for this LUN, or <b>FALSE</b> otherwise. Set the
    ///<b>VDS_HINT_ALLOCATEHOTSPARE</b> flag in the <b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bAllocateHotSpare;
    ///<b>TRUE</b> if the client wants this LUN to use a mirrored cache, or <b>FALSE</b> otherwise. Set the
    ///<b>VDS_HINT_USEMIRROREDCACHE</b> flag in the <b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bUseMirroredCache;
    ///<b>TRUE</b> if the client wants the LUN to use read caching, or <b>FALSE</b> otherwise. Set the
    ///<b>VDS_HINT_READCACHINGENABLED</b> flag in the <b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bReadCachingEnabled;
    ///<b>TRUE</b> if the client wants the LUN to use write caching, or <b>FALSE</b> otherwise. Set the
    ///<b>VDS_HINT_WRITECACHINGENABLED</b> flag in the <b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bWriteCachingEnabled;
    ///<b>TRUE</b> if the client wants to enable media scanning for this LUN, or <b>FALSE</b> otherwise. Set the
    ///<b>VDS_HINT_MEDIASCANENABLED</b> flag in the <b>ullHintMask</b> member to indicate interest in this member.
    BOOL                 bMediaScanEnabled;
    ///<b>TRUE</b> if the client wants to enable consistency checking for this LUN, or <b>FALSE</b> otherwise. Set the
    ///<b>VDS_HINT_CONSISTENCYCHECKENABLED</b> flag in the <b>ullHintMask</b> member to indicate interest in this
    ///member.
    BOOL                 bConsistencyCheckEnabled;
    ///A VDS_STORAGE_BUS_TYPE enumeration value that specifies the bus type for the LUN. Set the <b>VDS_HINT_BUSTYPE</b>
    ///flag in the <b>ullHintMask</b> member to indicate interest in this member.
    VDS_STORAGE_BUS_TYPE BusType;
    ///This member is reserved for future use. Do not use.
    BOOL                 bReserved1;
    ///This member is reserved for future use. Do not use.
    BOOL                 bReserved2;
    ///This member is reserved for future use. Do not use.
    BOOL                 bReserved3;
    ///The rebuild priority for the LUN. The value can range from 0 (lowest priority) through 15 (highest priority).
    short                sRebuildPriority;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a subsystem object.
struct VDS_SUB_SYSTEM_PROP
{
    ///The GUID of the subsystem object.
    GUID       id;
    ///The name of the subsystem, typically a brand name and a model name; a zero-terminated, human-readable string.
    PWSTR      pwszFriendlyName;
    ///The subsystem identifier; a zero-terminated, human-readable string.
    PWSTR      pwszIdentification;
    ///A bitmask of one or more VDS_SUB_SYSTEM_FLAG enumeration values.
    uint       ulFlags;
    ///The set of stripe sizes supported by a provider for striped volumes and/or LUNs. A stripe size must be a power of
    ///2. Each bit in the 32-bit integer represents a size, in bytes. For example, if the <i>n</i>th bit is set, then
    ///VDS supports stripe size of 2^<i>n</i>. Thus, bits 0 through 31 can specify 2^0 through 2^31.
    uint       ulStripeSizeFlags;
    ///A VDS_SUB_SYSTEM_STATUS enumeration value that specifies the status of the subsystem object.
    VDS_SUB_SYSTEM_STATUS status;
    ///A VDS_HEALTH enumeration value that specifies the health state of the subsystem. The following are the valid
    ///values for this member.
    VDS_HEALTH health;
    ///The number of buses (or "channels") that the subsystem contains.
    short      sNumberOfInternalBuses;
    ///The maximum number of slots that each of the buses can include. Each slot can accommodate one drive. The
    ///subsystem model assumes that each bus has the same maximum number of slots.
    short      sMaxNumberOfSlotsEachBus;
    ///The maximum number of controllers that the subsystem can contain.
    short      sMaxNumberOfControllers;
    ///The rebuild priority of the LUNs that belong to the subsystem. This value can range from 0 (lowest priority)
    ///through 15 (highest priority).
    short      sRebuildPriority;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a subsystem object. This structure is
///identical to the VDS_SUB_SYSTEM_PROP structure, except that it includes the supported RAID types and number of
///enclosures as members.
struct VDS_SUB_SYSTEM_PROP2
{
    ///The GUID of the subsystem object.
    GUID       id;
    ///A pointer to a <b>NULL</b>-terminated wide-character string containing the name of the subsystem, typically a
    ///brand name and a model name.
    PWSTR      pwszFriendlyName;
    ///A pointer to a <b>NULL</b>-terminated wide-character string containing a combination of the disk array's serial
    ///number and the subsystem identifier.
    PWSTR      pwszIdentification;
    ///A bitmask of one or more VDS_SUB_SYSTEM_FLAG enumeration values.
    uint       ulFlags;
    ///The set of stripe sizes supported by a provider for striped volumes and/or LUNs. A stripe size must be a power of
    ///2. Each bit in the 32-bit integer represents a size, in bytes. For example, if the <i>n</i>th bit is set, then
    ///VDS supports stripe size of 2^<i>n</i>. Thus, bits 0 through 31 can specify 2^0 through 2^31.
    uint       ulStripeSizeFlags;
    ///A bitmask of VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG enumeration values specifying the RAID levels that the
    ///subsystem supports. The default value for this member is zero. A value of zero means that no RAID levels are
    ///supported.
    uint       ulSupportedRaidTypeFlags;
    ///A VDS_SUB_SYSTEM_STATUS enumeration value that specifies the status of the subsystem object.
    VDS_SUB_SYSTEM_STATUS status;
    ///A VDS_HEALTH enumeration value that specifies the health state of the subsystem. The following are the valid
    ///values for this member.
    VDS_HEALTH health;
    ///The number of buses (or "channels") that the subsystem contains.
    short      sNumberOfInternalBuses;
    ///The maximum number of slots that each of the buses can include. Each slot can accommodate one drive. The
    ///subsystem model assumes that each bus has the same maximum number of slots.
    short      sMaxNumberOfSlotsEachBus;
    ///The maximum number of controllers that the subsystem can contain.
    short      sMaxNumberOfControllers;
    ///The rebuild priority of the LUNs that belong to the subsystem. This value can range from 0 (lowest priority)
    ///through 15 (highest priority).
    short      sRebuildPriority;
    ///The number of enclosures in the subsystem. The default value for this member is zero. A value of zero indicates
    ///that this property is not available for this subsystem.
    uint       ulNumberOfEnclosures;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a controller object.
struct VDS_CONTROLLER_PROP
{
    ///The GUID of the controller object.
    GUID       id;
    ///The name of the controller; a zero-terminated, human-readable string.
    PWSTR      pwszFriendlyName;
    ///The subsystem identifier, typically a serial number; a zero-terminated, human-readable string.
    PWSTR      pwszIdentification;
    ///A VDS_CONTROLLER_STATUS enumeration value that specifies the status of the controller.
    VDS_CONTROLLER_STATUS status;
    ///A VDS_HEALTH enumeration value that specifies the health state of the controller. The following are the valid
    ///values for this member. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b><b>VDS_H_REPLACED</b>
    ///and <b>VDS_H_DEGRADED</b> are not supported.
    VDS_HEALTH health;
    ///The number of ports that the controller contains. Ports are numbered from zero. Hardware providers should set
    ///this member to zero for PCI RAID cards.
    short      sNumberOfPorts;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a drive object.
struct VDS_DRIVE_PROP
{
    ///The GUID of the drive object.
    GUID             id;
    ///The size of the drive, in bytes.
    ulong            ullSize;
    ///A <b>NULL</b>-terminated wide-character string that contains the name of the drive.
    PWSTR            pwszFriendlyName;
    ///A <b>NULL</b>-terminated wide-character string that contains the drive identifier.
    PWSTR            pwszIdentification;
    ///A bitmask of VDS_DRIVE_FLAG enumeration values.
    uint             ulFlags;
    ///A VDS_DRIVE_STATUS enumeration value that specifies the status of the drive.
    VDS_DRIVE_STATUS status;
    ///A VDS_HEALTH enumeration value that specifies the health status of the drive. The following are the valid values
    ///for this member. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b><b>VDS_H_REPLACED</b> and
    ///<b>VDS_H_PENDING_FAILURE</b> are not supported.
    VDS_HEALTH       health;
    ///The number of the bus to which the drive is connected. This number is an implementer-assigned value that uniquely
    ///identifies the bus within the subsystem. It is not constrained by the number of buses that the subsystem
    ///contains, and it is not related to the value of the <b>sNumberOfInternalBuses</b> member of the
    ///VDS_SUB_SYSTEM_PROP structure.
    short            sInternalBusNumber;
    ///The number of the slot that the drive occupies. This number is an implementer-assigned value that uniquely
    ///identifies the slot within the bus. It is not constrained by the number of slots that the bus contains, and it is
    ///not related to the value of the <b>sMaxNumberOfSlotsEachBus</b> member of the VDS_SUB_SYSTEM_PROP structure.
    short            sSlotNumber;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a drive object. This structure is
///identical to the VDS_DRIVE_PROP structure, except that it includes the enclosure number, bus type, and spindle speed
///as members.
struct VDS_DRIVE_PROP2
{
    ///The GUID of the drive object.
    GUID                 id;
    ///The size of the drive, in bytes.
    ulong                ullSize;
    ///A <b>NULL</b>-terminated wide-character string that contains the name of the drive.
    PWSTR                pwszFriendlyName;
    ///A <b>NULL</b>-terminated wide-character string that contains the drive identifier.
    PWSTR                pwszIdentification;
    ///A bitmask of VDS_DRIVE_FLAG enumeration values.
    uint                 ulFlags;
    ///A VDS_DRIVE_STATUS enumeration value that specifies the status of the drive.
    VDS_DRIVE_STATUS     status;
    ///A VDS_HEALTH enumeration value that specifies the health status of the drive. The following are the valid values
    ///for this member. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b><b>VDS_H_REPLACED</b> and
    ///<b>VDS_H_PENDING_FAILURE</b> are not supported.
    VDS_HEALTH           health;
    ///The number of the bus to which the drive is connected. This number is an implementer-assigned value that uniquely
    ///identifies the bus within the subsystem. It is not constrained by the number of buses that the subsystem
    ///contains, and it is not related to the value of the <b>sNumberOfInternalBuses</b> member of the
    ///VDS_SUB_SYSTEM_PROP structure.
    short                sInternalBusNumber;
    ///The number of the slot that the drive occupies. This number is an implementer-assigned value that uniquely
    ///identifies the slot within the bus. It is not constrained by the number of slots that the bus contains, and it is
    ///not related to the value of the <b>sMaxNumberOfSlotsEachBus</b> member of the VDS_SUB_SYSTEM_PROP structure.
    short                sSlotNumber;
    ///The number of the enclosure that contains the drive. A value of ULONG_MAX indicates that this number is not
    ///defined for the drive. Because some enclosure numbering schemes are zero-based, zero is a valid value for this
    ///member. This member corresponds to the <i>ulEnclosureNumber</i> parameter of the IVdsSubSystem2::GetDrive2
    ///method.
    uint                 ulEnclosureNumber;
    ///A VDS_STORAGE_BUS_TYPE value that specifies the bus type of the drive. A value of zero means that the bus type is
    ///unknown.
    VDS_STORAGE_BUS_TYPE busType;
    ///The spindle speed of the drive, in RPM. The default value for this member is zero. A value of zero means that the
    ///spindle speed is unknown. A value of 1 means that the drive does not have rotating media. (For example, it might
    ///be a solid-state drive.)
    uint                 ulSpindleSpeed;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a drive extent.
struct VDS_DRIVE_EXTENT
{
    ///The <b>VDS_OBJECT_ID</b> of the drive.
    GUID  id;
    ///The <b>VDS_OBJECT_ID</b> of the LUN that is associated with the drive extent.
    GUID  LunId;
    ///The size of the extent, in bytes.
    ulong ullSize;
    ///If <b>TRUE</b>, the extent is allocated to a LUN plex. If <b>FALSE</b>, the extent is unallocated.
    BOOL  bUsed;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a LUN object.
struct VDS_LUN_PROP
{
    ///The GUID of the LUN object.
    GUID                 id;
    ///The size of the LUN, in bytes.
    ulong                ullSize;
    ///The name of the LUN; a zero-terminated, human-readable string.
    PWSTR                pwszFriendlyName;
    ///The unique LUN identifier; a zero-terminated, human-readable string.
    PWSTR                pwszIdentification;
    ///A list specifying the computers on the network to be granted access the LUN; a semicolon-delimited,
    ///NULL-terminated, human-readable string. If the value is "*", all computers on the network are to be granted
    ///access to the LUN. If the value is "", no computers are to be granted access to the LUN. <div
    ///class="alert"><b>Note</b> In practice, if the value is "*", most hardware providers only grant the ports and
    ///initiators on the local computer access to the LUN.</div> <div> </div> If "*" or "" is specified, no other value
    ///can be specified. For Fibre Channel networks and serial attached SCSI (SAS) networks, each entry is a 64-bit
    ///World-Wide Name (WWN) of each port to which the LUN is unmasked, formatted as a hexadecimal string (16 characters
    ///long), most significant byte first. For example, a WWN address of 01:23:45:67:89:AB:CD:EF is represented as
    ///"0123456789ABCDEF". For more information, see the T10 specifications for <a href="https://t10.org/drafts.htm
    PWSTR                pwszUnmaskingList;
    ///The LUN flags enumerated by VDS_LUN_FLAG.
    uint                 ulFlags;
    ///The LUN type enumerated by VDS_LUN_TYPE.
    VDS_LUN_TYPE         type;
    ///The status of the LUN object enumerated by VDS_LUN_STATUS.
    VDS_LUN_STATUS       status;
    ///A VDS_HEALTH enumeration value that specifies the health state of the LUN. The following are the valid values for
    ///this member.
    VDS_HEALTH           health;
    ///The transition state of the LUN enumerated by VDS_TRANSITION_STATE.
    VDS_TRANSITION_STATE TransitionState;
    ///The rebuild priority of the LUN object. A value between 0 (lowest priority) and 15 (highest priority).
    short                sRebuildPriority;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a LUN plex object.
struct VDS_LUN_PLEX_PROP
{
    ///The GUID of the plex object.
    GUID                 id;
    ///The size of the plex, in bytes. The size of the plex can be equal to or greater than that of the LUN to which the
    ///plex belongs. The plex cannot be smaller than the LUN.
    ulong                ullSize;
    ///A VDS_LUN_PLEX_TYPE enumeration value that specifies the type of the plex. The type of the plex is not required
    ///to match the type of the LUN to which it belongs.
    VDS_LUN_PLEX_TYPE    type;
    ///A VDS_LUN_PLEX_STATUS enumeration value that specifies the status of the plex. The status of the plex is not
    ///required to match the status of the LUN to which it belongs.
    VDS_LUN_PLEX_STATUS  status;
    ///VDS_HEALTH
    VDS_HEALTH           health;
    ///A VDS_TRANSITION_STATE enumeration value that specifies the transition state of the plex. The transition state of
    ///the plex is not required to match that of the LUN to which the plex belongs.
    VDS_TRANSITION_STATE TransitionState;
    ///A bitmask of VDS_LUN_PLEX_FLAG enumeration values that describe the plex.
    uint                 ulFlags;
    ///The stripe interleave size, in bytes. This member is valid only for plexes of type <b>VDS_LPT_STRIPE</b>
    ///(striped) and <b>VDS_LPT_PARITY</b> (striped with parity). For other plex types, this member should be zero.
    uint                 ulStripeSize;
    ///The rebuild priority of the plex. This value must be greater than or equal to 0 (lowest priority) and less than
    ///or equal to 15 (highest priority).
    short                sRebuildPriority;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a port on a controller object.
struct VDS_PORT_PROP
{
    ///The <b>VDS_OBJECT_ID</b> assigned to the port.
    GUID            id;
    ///The name of the port; a zero-terminated, human-readable string.
    PWSTR           pwszFriendlyName;
    ///The port identifier or address, typically a world wide name (WWN); a zero-terminated, human-readable string. For
    ///Fibre Channel networks, this member should be the WWN for the port, formatted as a hexadecimal string (16
    ///characters long), most significant byte first. For example, a WWN address of 01:23:45:67:89:AB:CD:EF should be
    ///represented as "0123456789ABCDEF".
    PWSTR           pwszIdentification;
    ///The status of the port enumerated by VDS_PORT_STATUS.
    VDS_PORT_STATUS status;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of an iSCSI portal.
struct VDS_ISCSI_PORTAL_PROP
{
    ///The <b>VDS_OBJECT_ID</b> of the portal.
    GUID          id;
    ///The IP address and port of the portal.
    VDS_IPADDRESS address;
    ///The status of the portal, enumerated by VDS_ISCSI_PORTAL_STATUS.
    VDS_ISCSI_PORTAL_STATUS status;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of an iSCSI target.
struct VDS_ISCSI_TARGET_PROP
{
    ///The <b>VDS_OBJECT_ID</b> of the target.
    GUID  id;
    ///A null-terminated, human-readable string that is the iSCSI name of the target.
    PWSTR pwszIscsiName;
    ///A null-terminated, human-readable string that is the friendly name of the target. This corresponds to the iSCSI
    ///alias.
    PWSTR pwszFriendlyName;
    ///If <b>TRUE</b>, a CHAP shared secret is required to login to this target.
    BOOL  bChapEnabled;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of an iSCSI portal group.
struct VDS_ISCSI_PORTALGROUP_PROP
{
    ///The VDS_OBJECT_ID assigned to the portal group.
    GUID   id;
    ///The portal group tag that is assigned by the provider to the portal group. For more information about portal
    ///group tags, see the iSCSI specification at https://go.microsoft.com/fwlink/p/?linkid=158752.
    ushort tag;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines a custom attribute of a storage pool. This structure is
///used in the pPoolCustomAttributes member of the <b>VDS_POOL_ATTRIBUTES</b> structure.
struct VDS_POOL_CUSTOM_ATTRIBUTES
{
    ///A string containing the name of the custom attribute.
    PWSTR pwszName;
    ///A string containing the value of the custom attribute.
    PWSTR pwszValue;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the attributes of a storage pool.
struct VDS_POOL_ATTRIBUTES
{
    ///A mask that specifies the attributes in the structure that are defined by this storage pool. The list of valid
    ///attribute flags is as follows. Each flag corresponds to a member in the <b>VDS_POOL_ATTRIBUTES</b> structure.
    ///Unused bits are reserved. <table> <tr> <th>Value</th> <th>Attribute defined by the storage pool</th> </tr> <tr>
    ///<td width="40%"><a id="VDS_POOL_ATTRIB_RAIDTYPE"></a><a id="vds_pool_attrib_raidtype"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_RAIDTYPE</b></dt> <dt>0x1L</dt> </dl> </td> <td width="60%"> <b>raidType</b> </td> </tr>
    ///<tr> <td width="40%"><a id="VDS_POOL_ATTRIB_BUSTYPE"></a><a id="vds_pool_attrib_bustype"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_BUSTYPE</b></dt> <dt>0x2L</dt> </dl> </td> <td width="60%"> <b>busType</b> </td> </tr>
    ///<tr> <td width="40%"><a id="VDS_POOL_ATTRIB_ALLOW_SPINDOWN"></a><a id="vds_pool_attrib_allow_spindown"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_ALLOW_SPINDOWN</b></dt> <dt>0x4L</dt> </dl> </td> <td width="60%"> <b>bSpinDown</b> </td>
    ///</tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_THIN_PROVISION"></a><a
    ///id="vds_pool_attrib_thin_provision"></a><dl> <dt><b>VDS_POOL_ATTRIB_THIN_PROVISION</b></dt> <dt>0x8L</dt> </dl>
    ///</td> <td width="60%"> <b>bIsThinProvisioned</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_NO_SINGLE_POF"></a><a id="vds_pool_attrib_no_single_pof"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_NO_SINGLE_POF</b></dt> <dt>0x10L</dt> </dl> </td> <td width="60%">
    ///<b>bNoSinglePointOfFailure</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_DATA_RDNCY_MAX"></a><a
    ///id="vds_pool_attrib_data_rdncy_max"></a><dl> <dt><b>VDS_POOL_ATTRIB_DATA_RDNCY_MAX</b></dt> <dt>0x20L</dt> </dl>
    ///</td> <td width="60%"> <b>ulDataRedundancyMax</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_DATA_RDNCY_MIN"></a><a id="vds_pool_attrib_data_rdncy_min"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_DATA_RDNCY_MIN</b></dt> <dt>0x40L</dt> </dl> </td> <td width="60%">
    ///<b>ulDataRedundancyMin</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_DATA_RDNCY_DEF"></a><a
    ///id="vds_pool_attrib_data_rdncy_def"></a><dl> <dt><b>VDS_POOL_ATTRIB_DATA_RDNCY_DEF</b></dt> <dt>0x80L</dt> </dl>
    ///</td> <td width="60%"> <b>ulDataRedundancyDefault</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_PKG_RDNCY_MAX"></a><a id="vds_pool_attrib_pkg_rdncy_max"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_PKG_RDNCY_MAX</b></dt> <dt>0x100L</dt> </dl> </td> <td width="60%">
    ///<b>ulPackageRedundancyDefault</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_PKG_RDNCY_MIN"></a><a
    ///id="vds_pool_attrib_pkg_rdncy_min"></a><dl> <dt><b>VDS_POOL_ATTRIB_PKG_RDNCY_MIN</b></dt> <dt>0x200L</dt> </dl>
    ///</td> <td width="60%"> <b>ulPackageRedundancyMin</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_PKG_RDNCY_DEF"></a><a id="vds_pool_attrib_pkg_rdncy_def"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_PKG_RDNCY_DEF</b></dt> <dt>0x400L</dt> </dl> </td> <td width="60%">
    ///<b>ulPackageRedundancyDefault</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_STRIPE_SIZE"></a><a
    ///id="vds_pool_attrib_stripe_size"></a><dl> <dt><b>VDS_POOL_ATTRIB_STRIPE_SIZE</b></dt> <dt>0x800L</dt> </dl> </td>
    ///<td width="60%"> <b>ulStripeSize</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_STRIPE_SIZE_MAX"></a><a id="vds_pool_attrib_stripe_size_max"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_STRIPE_SIZE_MAX</b></dt> <dt>0x1000L</dt> </dl> </td> <td width="60%">
    ///<b>ulStripeSizeMax</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_STRIPE_SIZE_MIN"></a><a
    ///id="vds_pool_attrib_stripe_size_min"></a><dl> <dt><b>VDS_POOL_ATTRIB_STRIPE_SIZE_MIN</b></dt> <dt>0x2000L</dt>
    ///</dl> </td> <td width="60%"> <b>ulStripeSizeMin</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_STRIPE_SIZE_DEF"></a><a id="vds_pool_attrib_stripe_size_def"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_STRIPE_SIZE_DEF</b></dt> <dt>0x4000L</dt> </dl> </td> <td width="60%">
    ///<b>ulDefaultStripeSize</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_NUM_CLMNS"></a><a
    ///id="vds_pool_attrib_num_clmns"></a><dl> <dt><b>VDS_POOL_ATTRIB_NUM_CLMNS</b></dt> <dt>0x8000L</dt> </dl> </td>
    ///<td width="60%"> <b>ulNumberOfColumns</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_NUM_CLMNS_MAX"></a><a id="vds_pool_attrib_num_clmns_max"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_NUM_CLMNS_MAX</b></dt> <dt>0x10000L</dt> </dl> </td> <td width="60%">
    ///<b>ulNumberOfColumnsMax</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_NUM_CLMNS_MIN"></a><a
    ///id="vds_pool_attrib_num_clmns_min"></a><dl> <dt><b>VDS_POOL_ATTRIB_NUM_CLMNS_MIN</b></dt> <dt>0x20000L</dt> </dl>
    ///</td> <td width="60%"> <b>ulNumberOfColumnsMin</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_NUM_CLMNS_DEF"></a><a id="vds_pool_attrib_num_clmns_def"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_NUM_CLMNS_DEF</b></dt> <dt>0x40000L</dt> </dl> </td> <td width="60%">
    ///<b>ulDefaultNumberofColumns</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_DATA_AVL_HINT"></a><a
    ///id="vds_pool_attrib_data_avl_hint"></a><dl> <dt><b>VDS_POOL_ATTRIB_DATA_AVL_HINT</b></dt> <dt>0x80000L</dt> </dl>
    ///</td> <td width="60%"> <b>ulDataAvailabilityHint</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_ACCS_RNDM_HINT"></a><a id="vds_pool_attrib_accs_rndm_hint"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_ACCS_RNDM_HINT</b></dt> <dt>0x100000L</dt> </dl> </td> <td width="60%">
    ///<b>ulAccessRandomnessHint</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_ACCS_DIR_HINT"></a><a
    ///id="vds_pool_attrib_accs_dir_hint"></a><dl> <dt><b>VDS_POOL_ATTRIB_ACCS_DIR_HINT</b></dt> <dt>0x200000L</dt>
    ///</dl> </td> <td width="60%"> <b>ulAccessDirectionHint</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_ACCS_SIZE_HINT"></a><a id="vds_pool_attrib_accs_size_hint"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_ACCS_SIZE_HINT</b></dt> <dt>0x400000L</dt> </dl> </td> <td width="60%">
    ///<b>ulAccessSizeHint</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_ACCS_LTNCY_HINT"></a><a
    ///id="vds_pool_attrib_accs_ltncy_hint"></a><dl> <dt><b>VDS_POOL_ATTRIB_ACCS_LTNCY_HINT</b></dt> <dt>0x800000L</dt>
    ///</dl> </td> <td width="60%"> <b>ulAccessLatencyHint</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_ACCS_BDW_WT_HINT"></a><a id="vds_pool_attrib_accs_bdw_wt_hint"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_ACCS_BDW_WT_HINT</b></dt> <dt>0x1000000L</dt> </dl> </td> <td width="60%">
    ///<b>ulAccessBandwidthWeightHint</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_STOR_COST_HINT"></a><a
    ///id="vds_pool_attrib_stor_cost_hint"></a><dl> <dt><b>VDS_POOL_ATTRIB_STOR_COST_HINT</b></dt> <dt>0x2000000L</dt>
    ///</dl> </td> <td width="60%"> <b>ulStorageCostHint</b> </td> </tr> <tr> <td width="40%"><a
    ///id="VDS_POOL_ATTRIB_STOR_EFFCY_HINT"></a><a id="vds_pool_attrib_stor_effcy_hint"></a><dl>
    ///<dt><b>VDS_POOL_ATTRIB_STOR_EFFCY_HINT</b></dt> <dt>0x4000000L</dt> </dl> </td> <td width="60%">
    ///<b>ulStorageEfficiencyHint</b> </td> </tr> <tr> <td width="40%"><a id="VDS_POOL_ATTRIB_CUSTOM_ATTRIB"></a><a
    ///id="vds_pool_attrib_custom_attrib"></a><dl> <dt><b>VDS_POOL_ATTRIB_CUSTOM_ATTRIB</b></dt> <dt>0x8000000L</dt>
    ///</dl> </td> <td width="60%"> <b>pPoolCustomAttributes</b> </td> </tr> </table>
    ulong                ullAttributeMask;
    ///A VDS_RAID_TYPE enumeration value that specifies the RAID type of the storage pool. If the storage pool does not
    ///have a specific RAID type, set this member to <b>VDS_RT_UNKNOWN</b> and clear the <b>VDS_POOL_ATTRIB_RAIDTYPE</b>
    ///attribute flag in the <b>ullAttributeMask</b> member.
    VDS_RAID_TYPE        raidType;
    ///A VDS_STORAGE_BUS_TYPE enumeration value that specifies the bus type of the drives in the storage pool.
    VDS_STORAGE_BUS_TYPE busType;
    ///A string that specifies the usage of the storage pool. Typically, this may indicate the application that is using
    ///the storage pool (for example, "SQL" or "Exchange") or the business function that is using the storage pool (for
    ///example, "Finance" or "Human Resources").
    PWSTR                pwszIntendedUsage;
    ///<b>TRUE</b> if the drives in the storage pool spin down automatically to reduce power usage, or <b>FALSE</b>
    ///otherwise.
    BOOL                 bSpinDown;
    ///<b>TRUE</b> if the storage pool is thin provisioned, or <b>FALSE</b> otherwise. If the pool is thin provisioned,
    ///the number of bytes in the consumed space of the pool could be less than the number of bytes in the provisioned
    ///space of the pool. (The number of bytes in the provisioned space is stored in the <b>ullProvisionedSpace</b>
    ///member of this structure. The number of bytes in the consumed space is stored in the <b>ullTotalConsumedSpace</b>
    ///member of the VDS_STORAGE_POOL_PROP structure.) When a hardware provider sets this member to <b>TRUE</b>, it must
    ///also set the <b>type</b> member of the <b>VDS_STORAGE_POOL_PROP</b> structure to <b>VDS_SPT_CONCRETE</b>.
    BOOL                 bIsThinProvisioned;
    ///If the pool is thin provisioned, this member specifies the space, in bytes, that is provisioned for the pool. The
    ///value of this member must be greater than or equal to the value of the <b>ullTotalConsumedSpace</b> member of the
    ///VDS_STORAGE_POOL_PROP structure.
    ulong                ullProvisionedSpace;
    ///<b>TRUE</b> if there is no single point of failure in the pool, or <b>FALSE</b> otherwise.
    BOOL                 bNoSinglePointOfFailure;
    ///The maximum number of complete copies of the data that can be maintained in this storage pool.
    uint                 ulDataRedundancyMax;
    ///The minimum number of complete copies of the data that can be maintained in this storage pool.
    uint                 ulDataRedundancyMin;
    ///The default number of complete copies of the data that are maintained in this storage pool.
    uint                 ulDataRedundancyDefault;
    ///The maximum number of drives that can be used in the storage pool to ensure package redundancy. Package
    ///redundancy indicates the number of drives that can fail in the storage pool without resulting in a data loss.
    uint                 ulPackageRedundancyMax;
    ///The minimum number of drives that can be used in the storage pool to ensure package redundancy. Package
    ///redundancy indicates the number of drives that can fail in the storage pool without resulting in a data loss.
    uint                 ulPackageRedundancyMin;
    ///The default number of drives that are used in the storage pool to ensure package redundancy. Package redundancy
    ///indicates the number of drives that can fail in the storage pool without resulting in a data loss.
    uint                 ulPackageRedundancyDefault;
    ///The mirror or parity stripe size, in bytes, of the storage pool if the pool is striped (with or without parity).
    uint                 ulStripeSize;
    ///The maximum stripe size, in bytes, that is supported by the storage pool.
    uint                 ulStripeSizeMax;
    ///The minimum stripe size, in bytes, that is supported by the storage pool.
    uint                 ulStripeSizeMin;
    ///The default stripe size, in bytes, that is supported by the storage pool.
    uint                 ulDefaultStripeSize;
    ///The number of columns of the storage pool if the pool is striped (with or without parity).
    uint                 ulNumberOfColumns;
    ///The maximum number of columns supported by the storage pool.
    uint                 ulNumberOfColumnsMax;
    ///The minimum number of columns supported by the storage pool.
    uint                 ulNumberOfColumnsMin;
    ///The default number of columns supported by the storage pool.
    uint                 ulDefaultNumberofColumns;
    ///A hint from the client that indicates the importance placed on data availability. Values range from 0 (Not
    ///Important) to 10 (Very Important).
    uint                 ulDataAvailabilityHint;
    ///A hint from the client that indicates the randomness of data access. Values range from 0 (Entirely Sequential) to
    ///10 (Entirely Random).
    uint                 ulAccessRandomnessHint;
    ///A hint from the client that indicates the direction of data access. Values range from 0 (Entirely Read) to 10
    ///(Entirely Write).
    uint                 ulAccessDirectionHint;
    ///A hint from the client that indicates the optimal access size in megabytes.
    uint                 ulAccessSizeHint;
    ///A hint from the client that indicates the importance of access latency to the client. Values range from 0 (Not
    ///Important) to 10 (Very Important).
    uint                 ulAccessLatencyHint;
    ///A hint from the client that indicates the importance of high bandwidth. Values range from 0 (Not Important) to 10
    ///(Very Important).
    uint                 ulAccessBandwidthWeightHint;
    ///A hint from the client that indicates the importance of storage cost to the client. Values range from 0 (Not
    ///Important) to 10 (Very Important). If the storage cost is very important to the client, a value of 10 indicates
    ///that the client would prefer to provision the pool using lower cost storage.
    uint                 ulStorageCostHint;
    ///A hint from the client that indicates the importance of storage efficiency to the client. Values range from 0
    ///(Not Important) to 10 (Very Important).
    uint                 ulStorageEfficiencyHint;
    ///The number of custom attributes defined for the storage pool.
    uint                 ulNumOfCustomAttributes;
    ///An array of VDS_POOL_CUSTOM_ATTRIBUTES structures. Each structure contains a custom attribute that is defined for
    ///the storage pool.
    VDS_POOL_CUSTOM_ATTRIBUTES* pPoolCustomAttributes;
    ///This member is reserved for future use. Do not use.
    BOOL                 bReserved1;
    ///This member is reserved for future use. Do not use.
    BOOL                 bReserved2;
    ///This member is reserved for future use. Do not use.
    uint                 ulReserved1;
    ///This member is reserved for future use. Do not use.
    uint                 ulReserved2;
    ///This member is reserved for future use. Do not use.
    ulong                ullReserved1;
    ///This member is reserved for future use. Do not use.
    ulong                ullReserved2;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines the properties of a storage pool object.
struct VDS_STORAGE_POOL_PROP
{
    ///A VDS_OBJECT_ID value that identifies the storage pool object.
    GUID       id;
    ///A VDS_STORAGE_POOL_STATUS enumeration value that specifies the status of the storage pool.
    VDS_STORAGE_POOL_STATUS status;
    ///A VDS_HEALTH enumeration value that specifies the health of the storage pool. The following are the valid values
    ///for this member. <b>Windows Server 2008, Windows Vista and Windows Server 2003: </b><b>VDS_H_DEGRADED</b> is not
    ///supported.
    VDS_HEALTH health;
    ///A VDS_STORAGE_POOL_TYPE enumeration value that specifies the type of the storage pool.
    VDS_STORAGE_POOL_TYPE type;
    ///A string that specifies the name of the storage pool.
    PWSTR      pwszName;
    ///A string that contains a description of the storage pool.
    PWSTR      pwszDescription;
    ///The amount of physical storage backing the storage pool, in bytes. The value of this member must be less than or
    ///equal to the value of the <b>ullProvisionedSpace</b> member of the VDS_POOL_ATTRIBUTES structure.
    ulong      ullTotalConsumedSpace;
    ///The space, in bytes, in this storage pool that can be allocated to create child storage elements (LUNs or pools),
    ///including space that has already been allocated. Depending on the way the storage pool is configured, the value
    ///of this member can be much less than the value of the <b>ullTotalConsumedSpace</b> member. For example, if the
    ///storage pool is configured as a mirrored pool, the value of <b>ullTotalManagedSpace</b> is only half as large as
    ///the value of the <b>ullTotalConsumedSpace</b> member.
    ulong      ullTotalManagedSpace;
    ///The maximum size that may be used to create new LUNs or child storage pools from this pool, or to expand existing
    ///LUNs or child storage pools. To calculate the amount of managed space that has already been allocated to existing
    ///LUNs or child storage pools, subtract the value of this member from the value of the <b>ullTotalManagedSpace</b>
    ///member.
    ulong      ullRemainingFreeSpace;
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Defines a drive extent that could be used by a storage pool.
struct VDS_STORAGE_POOL_DRIVE_EXTENT
{
    ///A VDS_OBJECT_ID value that identifies the drive object.
    GUID  id;
    ///Size, in bytes, of the drive extent.
    ulong ullSize;
    ///<b>TRUE</b> if the drive extent is currently being used by the storage pool, <b>FALSE</b> otherwise.
    BOOL  bUsed;
}

///The <b>VSS_SNAPSHOT_PROP</b> structure contains the properties of a shadow copy or shadow copy set.
struct VSS_SNAPSHOT_PROP
{
    ///A VSS_ID (GUID) uniquely identifying the shadow copy identifier.
    GUID               m_SnapshotId;
    ///A VSS_ID (GUID) uniquely identifying the shadow copy set containing the shadow copy.
    GUID               m_SnapshotSetId;
    ///Number of volumes included with the shadow copy in the shadow copy set when it was created. Because it is
    ///possible for applications to release individual shadow copies without releasing the shadow copy set, at any given
    ///time the number of shadow copies in the shadow copy set may be less than <b>m_LSnapshotsCount</b>. The maximum
    ///number of shadow-copied volumes permitted in a shadow copy set is 64.
    int                m_lSnapshotsCount;
    ///Null-terminated wide character string containing the name of the device object for the shadow copy of the volume.
    ///The device object can be thought of as the root of a shadow copy of a volume. Requesters will use this device
    ///name when accessing files on a shadow-copied volume that it needs to work with. The device name does not contain
    ///a trailing "\".
    ushort*            m_pwszSnapshotDeviceObject;
    ///Null-terminated wide character string containing the name of the volume that had been shadow copied.
    ushort*            m_pwszOriginalVolumeName;
    ///Null-terminated wide character string containing the name of the machine containing the original volume.
    ushort*            m_pwszOriginatingMachine;
    ///Null-terminated wide character string containing the name of the machine running the Volume Shadow Copy Service
    ///that created the shadow copy.
    ushort*            m_pwszServiceMachine;
    ///Null-terminated wide character string containing the name of the shadow copy when it is exposed. This is a drive
    ///letter or mounted folder (if the shadow copy is exposed as a local volume), or a share name. Corresponds to the
    ///<i>wszExpose</i> parameter of the IVssBackupComponents::ExposeSnapshot method.
    ushort*            m_pwszExposedName;
    ///Null-terminated wide character string indicating the portion of the shadow copy of a volume made available if it
    ///is exposed as a share. Corresponds to the <i>wszPathFromRoot</i> parameter of the
    ///IVssBackupComponents::ExposeSnapshot method.
    ushort*            m_pwszExposedPath;
    ///A VSS_ID (GUID) uniquely identifying the provider used to create this shadow copy.
    GUID               m_ProviderId;
    ///The attributes of the shadow copy expressed as a bit mask (or bitwise OR) of members of the
    ///_VSS_VOLUME_SNAPSHOT_ATTRIBUTES enumeration.
    int                m_lSnapshotAttributes;
    ///Time stamp indicating when the shadow copy was created. The exact time is determined by the provider. See
    ///VSS_TIMESTAMP for information about the time-stamp format.
    long               m_tsCreationTimestamp;
    ///Current shadow copy creation status. See VSS_SNAPSHOT_STATE.
    VSS_SNAPSHOT_STATE m_eStatus;
}

///The <b>VSS_PROVIDER_PROP</b> structure specifies shadow copy provider properties.
struct VSS_PROVIDER_PROP
{
    ///Identifies the provider who supports shadow copies of this class.
    GUID              m_ProviderId;
    ///Null-terminated wide character string containing the provider name.
    ushort*           m_pwszProviderName;
    ///Provider type. See VSS_PROVIDER_TYPE for more information.
    VSS_PROVIDER_TYPE m_eProviderType;
    ///Null-terminated wide character string containing the provider version in readable format.
    ushort*           m_pwszProviderVersion;
    ///A VSS_ID (GUID) uniquely identifying the version of a provider.
    GUID              m_ProviderVersionId;
    ///Class identifier of the component registered in the local machine's COM catalog.
    GUID              m_ClassId;
}

union __MIDL___MIDL_itf_vss_0000_0000_0001
{
    VSS_SNAPSHOT_PROP Snap;
    VSS_PROVIDER_PROP Prov;
}

///The <b>VSS_OBJECT_PROP</b> structure defines the properties of a provider, volume, shadow copy, or shadow copy set.
struct VSS_OBJECT_PROP
{
    ///Object type. Refer to VSS_OBJECT_TYPE.
    VSS_OBJECT_TYPE Type;
    ///Object properties: a union of VSS_SNAPSHOT_PROP and VSS_PROVIDER_PROP structures. (See VSS_OBJECT_UNION.) It
    ///contains information for an object of the type specified by the <b>Type</b> member of the <b>VSS_OBJECT_PROP</b>
    ///structure. Objects can be providers, volumes, shadow copies, or shadow copy sets.
    __MIDL___MIDL_itf_vss_0000_0000_0001 Obj;
}

///The <b>IVssExamineWriterMetadata</b> interface is a C++ (not COM) interface that allows a requester to examine the
///metadata of a specific writer instance. This metadata may come from a currently executing (live) writer, or it may
///have been stored as an XML document. An <b>IVssExamineWriterMetadata</b> interface to a live writer's metadata is
///obtained by a call to IVssBackupComponents::GetWriterMetadata. Metadata obtained from a stored XML document can be
///examined by an instance of <b>IVssExamineWriterMetadata</b> obtained by a call to CreateVssExamineWriterMetadata.
struct IVssExamineWriterMetadata
{
}

///The <b>VSS_VOLUME_PROP</b> structure contains the properties of a shadow copy source volume.
struct VSS_VOLUME_PROP
{
    ///The volume name, in \\?&
    ushort* m_pwszVolumeName;
    ///A pointer to a null-terminated Unicode string that contains the shortest mount point that can be displayed to the
    ///user. The mount point can be a drive letter, for example, C:\, or a mounted folder, for example,
    ///C:\WriterData\Archive.
    ushort* m_pwszVolumeDisplayName;
}

///The <b>VSS_DIFF_VOLUME_PROP</b> structure describes a shadow copy storage area volume.
struct VSS_DIFF_VOLUME_PROP
{
    ///The shadow copy storage area volume name, in <b>\\\\?\\</b><i>Volume</i><b>{</b><i>GUID</i><b>}\\</b> format.
    ushort* m_pwszVolumeName;
    ///Points to a null-terminated Unicode string that can be displayed to a user, for example <i>C</i><b>:\\</b>, for
    ///the shadow copy storage area volume.
    ushort* m_pwszVolumeDisplayName;
    ///Free space, in bytes, on the shadow copy storage area volume.
    long    m_llVolumeFreeSpace;
    ///Total space, in bytes, on the shadow copy storage area volume.
    long    m_llVolumeTotalSpace;
}

///The <b>VSS_DIFF_AREA_PROP</b> structure describes associations between volumes containing the original file data and
///volumes containing the shadow copy storage area (also known as the diff area).
struct VSS_DIFF_AREA_PROP
{
    ///The original volume name.
    ushort* m_pwszVolumeName;
    ///The shadow copy storage area volume name.
    ushort* m_pwszDiffAreaVolumeName;
    ///Maximum space used on the shadow copy storage area volume for this association.
    long    m_llMaximumDiffSpace;
    ///Allocated space on the shadow copy storage area volume by this association. This must be less than or equal to
    ///<i>m_llMaximumDiffSpace</i>.
    long    m_llAllocatedDiffSpace;
    ///Used space from the allocated area above. This must be less than or equal to <i>m_llAllocatedDiffSpace</i>.
    long    m_llUsedDiffSpace;
}

union __MIDL___MIDL_itf_vsmgmt_0000_0000_0001
{
    VSS_VOLUME_PROP      Vol;
    VSS_DIFF_VOLUME_PROP DiffVol;
    VSS_DIFF_AREA_PROP   DiffArea;
}

///The <b>VSS_MGMT_OBJECT_PROP</b> structure defines the properties of a volume, shadow copy storage volume, or a shadow
///copy storage area.
struct VSS_MGMT_OBJECT_PROP
{
    ///Object type. For more information, see VSS_MGMT_OBJECT_TYPE.
    VSS_MGMT_OBJECT_TYPE Type;
    ///Management object properties: a union of VSS_VOLUME_PROP, VSS_DIFF_VOLUME_PROP, and VSS_DIFF_AREA_PROP
    ///structures. (For more information, see VSS_MGMT_OBJECT_UNION.) It contains information for an object of the type
    ///specified by the <b>Type</b> member. Management objects can be volumes, shadow copy storage volumes, or shadow
    ///copy storage areas.
    __MIDL___MIDL_itf_vsmgmt_0000_0000_0001 Obj;
}

///Contains information about a volume's shadow copy protection level.
struct VSS_VOLUME_PROTECTION_INFO
{
    ///A value from the VSS_PROTECTION_LEVEL enumeration that specifies the target protection level for the volume.
    VSS_PROTECTION_LEVEL m_protectionLevel;
    ///TRUE if the volume is offline due to a protection fault, or <b>FALSE</b> otherwise.
    BOOL                 m_volumeIsOfflineForProtection;
    ///A value from the VSS_PROTECTION_FAULT enumeration that describes the shadow copy protection fault that caused the
    ///volume to go offline.
    VSS_PROTECTION_FAULT m_protectionFault;
    ///The internal failure status code.
    int                  m_failureStatus;
    ///TRUE if the volume has unused shadow copy storage area files, or <b>FALSE</b> otherwise.
    BOOL                 m_volumeHasUnusedDiffArea;
    ///Reserved for system use.
    uint                 m_reserved;
}

struct IDDVideoPortContainer
{
}

struct IDirectDrawVideoPort
{
}

struct IDirectDrawVideoPortNotify
{
}

struct IDDVideoPortContainerVtbl
{
}

struct IDirectDrawVideoPortVtbl
{
}

struct IDirectDrawVideoPortNotifyVtbl
{
}

struct DDVIDEOPORTSTATUS
{
    uint               dwSize;
    BOOL               bInUse;
    uint               dwFlags;
    uint               dwReserved1;
    DDVIDEOPORTCONNECT VideoPortType;
    size_t             dwReserved2;
    size_t             dwReserved3;
}

struct DDVIDEOPORTNOTIFY
{
    LARGE_INTEGER ApproximateTimeStamp;
    int           lField;
    uint          dwSurfaceIndex;
    int           lDone;
}

struct _DD_DESTROYDRIVERDATA
{
}

struct _DD_SETMODEDATA
{
}

struct _DD_GETVPORTAUTOFLIPSURFACEDATA
{
}

struct DD_MORECAPS
{
    uint dwSize;
    uint dwAlphaCaps;
    uint dwSVBAlphaCaps;
    uint dwVSBAlphaCaps;
    uint dwSSBAlphaCaps;
    uint dwFilterCaps;
    uint dwSVBFilterCaps;
    uint dwVSBFilterCaps;
    uint dwSSBFilterCaps;
}

struct DDNTCORECAPS
{
    uint    dwSize;
    uint    dwCaps;
    uint    dwCaps2;
    uint    dwCKeyCaps;
    uint    dwFXCaps;
    uint    dwFXAlphaCaps;
    uint    dwPalCaps;
    uint    dwSVCaps;
    uint    dwAlphaBltConstBitDepths;
    uint    dwAlphaBltPixelBitDepths;
    uint    dwAlphaBltSurfaceBitDepths;
    uint    dwAlphaOverlayConstBitDepths;
    uint    dwAlphaOverlayPixelBitDepths;
    uint    dwAlphaOverlaySurfaceBitDepths;
    uint    dwZBufferBitDepths;
    uint    dwVidMemTotal;
    uint    dwVidMemFree;
    uint    dwMaxVisibleOverlays;
    uint    dwCurrVisibleOverlays;
    uint    dwNumFourCCCodes;
    uint    dwAlignBoundarySrc;
    uint    dwAlignSizeSrc;
    uint    dwAlignBoundaryDest;
    uint    dwAlignSizeDest;
    uint    dwAlignStrideAlign;
    uint[8] dwRops;
    DDSCAPS ddsCaps;
    uint    dwMinOverlayStretch;
    uint    dwMaxOverlayStretch;
    uint    dwMinLiveVideoStretch;
    uint    dwMaxLiveVideoStretch;
    uint    dwMinHwCodecStretch;
    uint    dwMaxHwCodecStretch;
    uint    dwReserved1;
    uint    dwReserved2;
    uint    dwReserved3;
    uint    dwSVBCaps;
    uint    dwSVBCKeyCaps;
    uint    dwSVBFXCaps;
    uint[8] dwSVBRops;
    uint    dwVSBCaps;
    uint    dwVSBCKeyCaps;
    uint    dwVSBFXCaps;
    uint[8] dwVSBRops;
    uint    dwSSBCaps;
    uint    dwSSBCKeyCaps;
    uint    dwSSBFXCaps;
    uint[8] dwSSBRops;
    uint    dwMaxVideoPorts;
    uint    dwCurrVideoPorts;
    uint    dwSVBCaps2;
}

struct DD_HALINFO_V4
{
    uint              dwSize;
    VIDEOMEMORYINFO   vmiData;
    DDNTCORECAPS      ddCaps;
    PDD_GETDRIVERINFO GetDriverInfo;
    uint              dwFlags;
}

struct DD_SETCLIPLISTDATA
{
    DD_DIRECTDRAW_GLOBAL* lpDD;
    DD_SURFACE_LOCAL* lpDDSurface;
    HRESULT           ddRVal;
    void*             SetClipList;
}

struct DD_DRVSETCOLORKEYDATA
{
    DD_SURFACE_LOCAL* lpDDSurface;
    uint              dwFlags;
    DDCOLORKEY        ckNew;
    HRESULT           ddRVal;
    void*             SetColorKey;
}

struct DD_DESTROYDDLOCALDATA
{
    uint                 dwFlags;
    DD_DIRECTDRAW_LOCAL* pDDLcl;
    HRESULT              ddRVal;
}

struct D3DRECT
{
union
    {
        int x1;
        int lX1;
    }
union
    {
        int y1;
        int lY1;
    }
union
    {
        int x2;
        int lX2;
    }
union
    {
        int y2;
        int lY2;
    }
}

struct D3DVECTOR
{
union
    {
        float x;
        float dvX;
    }
union
    {
        float y;
        float dvY;
    }
union
    {
        float z;
        float dvZ;
    }
}

struct D3DHVERTEX
{
    uint dwFlags;
union
    {
        float hx;
        float dvHX;
    }
union
    {
        float hy;
        float dvHY;
    }
union
    {
        float hz;
        float dvHZ;
    }
}

struct D3DTLVERTEX
{
union
    {
        float sx;
        float dvSX;
    }
union
    {
        float sy;
        float dvSY;
    }
union
    {
        float sz;
        float dvSZ;
    }
union
    {
        float rhw;
        float dvRHW;
    }
union
    {
        uint color;
        uint dcColor;
    }
union
    {
        uint specular;
        uint dcSpecular;
    }
union
    {
        float tu;
        float dvTU;
    }
union
    {
        float tv;
        float dvTV;
    }
}

struct D3DLVERTEX
{
union
    {
        float x;
        float dvX;
    }
union
    {
        float y;
        float dvY;
    }
union
    {
        float z;
        float dvZ;
    }
    uint dwReserved;
union
    {
        uint color;
        uint dcColor;
    }
union
    {
        uint specular;
        uint dcSpecular;
    }
union
    {
        float tu;
        float dvTU;
    }
union
    {
        float tv;
        float dvTV;
    }
}

struct D3DVERTEX
{
union
    {
        float x;
        float dvX;
    }
union
    {
        float y;
        float dvY;
    }
union
    {
        float z;
        float dvZ;
    }
union
    {
        float nx;
        float dvNX;
    }
union
    {
        float ny;
        float dvNY;
    }
union
    {
        float nz;
        float dvNZ;
    }
union
    {
        float tu;
        float dvTU;
    }
union
    {
        float tv;
        float dvTV;
    }
}

struct D3DVIEWPORT
{
    uint  dwSize;
    uint  dwX;
    uint  dwY;
    uint  dwWidth;
    uint  dwHeight;
    float dvScaleX;
    float dvScaleY;
    float dvMaxX;
    float dvMaxY;
    float dvMinZ;
    float dvMaxZ;
}

struct D3DVIEWPORT2
{
    uint  dwSize;
    uint  dwX;
    uint  dwY;
    uint  dwWidth;
    uint  dwHeight;
    float dvClipX;
    float dvClipY;
    float dvClipWidth;
    float dvClipHeight;
    float dvMinZ;
    float dvMaxZ;
}

struct D3DVIEWPORT7
{
    uint  dwX;
    uint  dwY;
    uint  dwWidth;
    uint  dwHeight;
    float dvMinZ;
    float dvMaxZ;
}

struct D3DTRANSFORMDATA
{
    uint        dwSize;
    void*       lpIn;
    uint        dwInSize;
    void*       lpOut;
    uint        dwOutSize;
    D3DHVERTEX* lpHOut;
    uint        dwClip;
    uint        dwClipIntersection;
    uint        dwClipUnion;
    D3DRECT     drExtent;
}

struct D3DLIGHTINGELEMENT
{
    D3DVECTOR dvPosition;
    D3DVECTOR dvNormal;
}

struct D3DMATERIAL
{
    uint dwSize;
union
    {
        DXGI_RGBA diffuse;
        DXGI_RGBA dcvDiffuse;
    }
union
    {
        DXGI_RGBA ambient;
        DXGI_RGBA dcvAmbient;
    }
union
    {
        DXGI_RGBA specular;
        DXGI_RGBA dcvSpecular;
    }
union
    {
        DXGI_RGBA emissive;
        DXGI_RGBA dcvEmissive;
    }
union
    {
        float power;
        float dvPower;
    }
    uint hTexture;
    uint dwRampSize;
}

struct D3DMATERIAL7
{
union
    {
        DXGI_RGBA diffuse;
        DXGI_RGBA dcvDiffuse;
    }
union
    {
        DXGI_RGBA ambient;
        DXGI_RGBA dcvAmbient;
    }
union
    {
        DXGI_RGBA specular;
        DXGI_RGBA dcvSpecular;
    }
union
    {
        DXGI_RGBA emissive;
        DXGI_RGBA dcvEmissive;
    }
union
    {
        float power;
        float dvPower;
    }
}

struct D3DLIGHT
{
    uint         dwSize;
    D3DLIGHTTYPE dltType;
    DXGI_RGBA    dcvColor;
    D3DVECTOR    dvPosition;
    D3DVECTOR    dvDirection;
    float        dvRange;
    float        dvFalloff;
    float        dvAttenuation0;
    float        dvAttenuation1;
    float        dvAttenuation2;
    float        dvTheta;
    float        dvPhi;
}

struct D3DLIGHT7
{
    D3DLIGHTTYPE dltType;
    DXGI_RGBA    dcvDiffuse;
    DXGI_RGBA    dcvSpecular;
    DXGI_RGBA    dcvAmbient;
    D3DVECTOR    dvPosition;
    D3DVECTOR    dvDirection;
    float        dvRange;
    float        dvFalloff;
    float        dvAttenuation0;
    float        dvAttenuation1;
    float        dvAttenuation2;
    float        dvTheta;
    float        dvPhi;
}

struct D3DLIGHT2
{
    uint         dwSize;
    D3DLIGHTTYPE dltType;
    DXGI_RGBA    dcvColor;
    D3DVECTOR    dvPosition;
    D3DVECTOR    dvDirection;
    float        dvRange;
    float        dvFalloff;
    float        dvAttenuation0;
    float        dvAttenuation1;
    float        dvAttenuation2;
    float        dvTheta;
    float        dvPhi;
    uint         dwFlags;
}

struct D3DLIGHTDATA
{
    uint                dwSize;
    D3DLIGHTINGELEMENT* lpIn;
    uint                dwInSize;
    D3DTLVERTEX*        lpOut;
    uint                dwOutSize;
}

struct D3DINSTRUCTION
{
    ubyte  bOpcode;
    ubyte  bSize;
    ushort wCount;
}

struct D3DTEXTURELOAD
{
    uint hDestTexture;
    uint hSrcTexture;
}

struct D3DPICKRECORD
{
    ubyte bOpcode;
    ubyte bPad;
    uint  dwOffset;
    float dvZ;
}

struct D3DLINEPATTERN
{
    ushort wRepeatFactor;
    ushort wLinePattern;
}

struct D3DSTATE
{
union
    {
        D3DTRANSFORMSTATETYPE dtstTransformStateType;
        D3DLIGHTSTATETYPE  dlstLightStateType;
        D3DRENDERSTATETYPE drstRenderStateType;
    }
union
    {
        uint[1]  dwArg;
        float[1] dvArg;
    }
}

struct D3DMATRIXLOAD
{
    uint hDestMatrix;
    uint hSrcMatrix;
}

struct D3DMATRIXMULTIPLY
{
    uint hDestMatrix;
    uint hSrcMatrix1;
    uint hSrcMatrix2;
}

struct D3DPROCESSVERTICES
{
    uint   dwFlags;
    ushort wStart;
    ushort wDest;
    uint   dwCount;
    uint   dwReserved;
}

struct D3DTRIANGLE
{
union
    {
        ushort v1;
        ushort wV1;
    }
union
    {
        ushort v2;
        ushort wV2;
    }
union
    {
        ushort v3;
        ushort wV3;
    }
    ushort wFlags;
}

struct D3DLINE
{
union
    {
        ushort v1;
        ushort wV1;
    }
union
    {
        ushort v2;
        ushort wV2;
    }
}

struct D3DSPAN
{
    ushort wCount;
    ushort wFirst;
}

struct D3DPOINT
{
    ushort wCount;
    ushort wFirst;
}

struct D3DBRANCH
{
    uint dwMask;
    uint dwValue;
    BOOL bNegate;
    uint dwOffset;
}

struct D3DSTATUS
{
    uint    dwFlags;
    uint    dwStatus;
    D3DRECT drExtent;
}

struct D3DCLIPSTATUS
{
    uint  dwFlags;
    uint  dwStatus;
    float minx;
    float maxx;
    float miny;
    float maxy;
    float minz;
    float maxz;
}

struct D3DSTATS
{
    uint dwSize;
    uint dwTrianglesDrawn;
    uint dwLinesDrawn;
    uint dwPointsDrawn;
    uint dwSpansDrawn;
    uint dwVerticesProcessed;
}

struct D3DEXECUTEDATA
{
    uint      dwSize;
    uint      dwVertexOffset;
    uint      dwVertexCount;
    uint      dwInstructionOffset;
    uint      dwInstructionLength;
    uint      dwHVertexOffset;
    D3DSTATUS dsStatus;
}

struct D3DVERTEXBUFFERDESC
{
    uint dwSize;
    uint dwCaps;
    uint dwFVF;
    uint dwNumVertices;
}

struct D3DDP_PTRSTRIDE
{
    void* lpvData;
    uint  dwStride;
}

struct D3DDRAWPRIMITIVESTRIDEDDATA
{
    D3DDP_PTRSTRIDE    position;
    D3DDP_PTRSTRIDE    normal;
    D3DDP_PTRSTRIDE    diffuse;
    D3DDP_PTRSTRIDE    specular;
    D3DDP_PTRSTRIDE[8] textureCoords;
}

struct D3DTRANSFORMCAPS
{
    uint dwSize;
    uint dwCaps;
}

struct D3DLIGHTINGCAPS
{
    uint dwSize;
    uint dwCaps;
    uint dwLightingModel;
    uint dwNumLights;
}

struct _D3DPrimCaps
{
    uint dwSize;
    uint dwMiscCaps;
    uint dwRasterCaps;
    uint dwZCmpCaps;
    uint dwSrcBlendCaps;
    uint dwDestBlendCaps;
    uint dwAlphaCmpCaps;
    uint dwShadeCaps;
    uint dwTextureCaps;
    uint dwTextureFilterCaps;
    uint dwTextureBlendCaps;
    uint dwTextureAddressCaps;
    uint dwStippleWidth;
    uint dwStippleHeight;
}

struct _D3DDeviceDesc
{
    uint             dwSize;
    uint             dwFlags;
    uint             dcmColorModel;
    uint             dwDevCaps;
    D3DTRANSFORMCAPS dtcTransformCaps;
    BOOL             bClipping;
    D3DLIGHTINGCAPS  dlcLightingCaps;
    _D3DPrimCaps     dpcLineCaps;
    _D3DPrimCaps     dpcTriCaps;
    uint             dwDeviceRenderBitDepth;
    uint             dwDeviceZBufferBitDepth;
    uint             dwMaxBufferSize;
    uint             dwMaxVertexCount;
    uint             dwMinTextureWidth;
    uint             dwMinTextureHeight;
    uint             dwMaxTextureWidth;
    uint             dwMaxTextureHeight;
    uint             dwMinStippleWidth;
    uint             dwMaxStippleWidth;
    uint             dwMinStippleHeight;
    uint             dwMaxStippleHeight;
    uint             dwMaxTextureRepeat;
    uint             dwMaxTextureAspectRatio;
    uint             dwMaxAnisotropy;
    float            dvGuardBandLeft;
    float            dvGuardBandTop;
    float            dvGuardBandRight;
    float            dvGuardBandBottom;
    float            dvExtentsAdjust;
    uint             dwStencilCaps;
    uint             dwFVFCaps;
    uint             dwTextureOpCaps;
    ushort           wMaxTextureBlendStages;
    ushort           wMaxSimultaneousTextures;
}

struct _D3DDeviceDesc7
{
    uint         dwDevCaps;
    _D3DPrimCaps dpcLineCaps;
    _D3DPrimCaps dpcTriCaps;
    uint         dwDeviceRenderBitDepth;
    uint         dwDeviceZBufferBitDepth;
    uint         dwMinTextureWidth;
    uint         dwMinTextureHeight;
    uint         dwMaxTextureWidth;
    uint         dwMaxTextureHeight;
    uint         dwMaxTextureRepeat;
    uint         dwMaxTextureAspectRatio;
    uint         dwMaxAnisotropy;
    float        dvGuardBandLeft;
    float        dvGuardBandTop;
    float        dvGuardBandRight;
    float        dvGuardBandBottom;
    float        dvExtentsAdjust;
    uint         dwStencilCaps;
    uint         dwFVFCaps;
    uint         dwTextureOpCaps;
    ushort       wMaxTextureBlendStages;
    ushort       wMaxSimultaneousTextures;
    uint         dwMaxActiveLights;
    float        dvMaxVertexW;
    GUID         deviceGUID;
    ushort       wMaxUserClipPlanes;
    ushort       wMaxVertexBlendMatrices;
    uint         dwVertexProcessingCaps;
    uint         dwReserved1;
    uint         dwReserved2;
    uint         dwReserved3;
    uint         dwReserved4;
}

struct D3DFINDDEVICESEARCH
{
    uint         dwSize;
    uint         dwFlags;
    BOOL         bHardware;
    uint         dcmColorModel;
    GUID         guid;
    uint         dwCaps;
    _D3DPrimCaps dpcPrimCaps;
}

struct D3DFINDDEVICERESULT
{
    uint           dwSize;
    GUID           guid;
    _D3DDeviceDesc ddHwDesc;
    _D3DDeviceDesc ddSwDesc;
}

struct _D3DExecuteBufferDesc
{
    uint  dwSize;
    uint  dwFlags;
    uint  dwCaps;
    uint  dwBufferSize;
    void* lpData;
}

struct D3DDEVINFO_TEXTUREMANAGER
{
    BOOL bThrashing;
    uint dwApproxBytesDownloaded;
    uint dwNumEvicts;
    uint dwNumVidCreates;
    uint dwNumTexturesUsed;
    uint dwNumUsedTexInVid;
    uint dwWorkingSet;
    uint dwWorkingSetBytes;
    uint dwTotalManaged;
    uint dwTotalBytes;
    uint dwLastPri;
}

struct D3DDEVINFO_TEXTURING
{
    uint dwNumLoads;
    uint dwApproxBytesLoaded;
    uint dwNumPreLoads;
    uint dwNumSet;
    uint dwNumCreates;
    uint dwNumDestroys;
    uint dwNumSetPriorities;
    uint dwNumSetLODs;
    uint dwNumLocks;
    uint dwNumGetDCs;
}

struct _D3DNTHALDeviceDesc_V1
{
    uint             dwSize;
    uint             dwFlags;
    uint             dcmColorModel;
    uint             dwDevCaps;
    D3DTRANSFORMCAPS dtcTransformCaps;
    BOOL             bClipping;
    D3DLIGHTINGCAPS  dlcLightingCaps;
    _D3DPrimCaps     dpcLineCaps;
    _D3DPrimCaps     dpcTriCaps;
    uint             dwDeviceRenderBitDepth;
    uint             dwDeviceZBufferBitDepth;
    uint             dwMaxBufferSize;
    uint             dwMaxVertexCount;
}

struct _D3DNTHALDeviceDesc_V2
{
    uint             dwSize;
    uint             dwFlags;
    uint             dcmColorModel;
    uint             dwDevCaps;
    D3DTRANSFORMCAPS dtcTransformCaps;
    BOOL             bClipping;
    D3DLIGHTINGCAPS  dlcLightingCaps;
    _D3DPrimCaps     dpcLineCaps;
    _D3DPrimCaps     dpcTriCaps;
    uint             dwDeviceRenderBitDepth;
    uint             dwDeviceZBufferBitDepth;
    uint             dwMaxBufferSize;
    uint             dwMaxVertexCount;
    uint             dwMinTextureWidth;
    uint             dwMinTextureHeight;
    uint             dwMaxTextureWidth;
    uint             dwMaxTextureHeight;
    uint             dwMinStippleWidth;
    uint             dwMaxStippleWidth;
    uint             dwMinStippleHeight;
    uint             dwMaxStippleHeight;
}

struct _D3DNTDeviceDesc_V3
{
    uint             dwSize;
    uint             dwFlags;
    uint             dcmColorModel;
    uint             dwDevCaps;
    D3DTRANSFORMCAPS dtcTransformCaps;
    BOOL             bClipping;
    D3DLIGHTINGCAPS  dlcLightingCaps;
    _D3DPrimCaps     dpcLineCaps;
    _D3DPrimCaps     dpcTriCaps;
    uint             dwDeviceRenderBitDepth;
    uint             dwDeviceZBufferBitDepth;
    uint             dwMaxBufferSize;
    uint             dwMaxVertexCount;
    uint             dwMinTextureWidth;
    uint             dwMinTextureHeight;
    uint             dwMaxTextureWidth;
    uint             dwMaxTextureHeight;
    uint             dwMinStippleWidth;
    uint             dwMaxStippleWidth;
    uint             dwMinStippleHeight;
    uint             dwMaxStippleHeight;
    uint             dwMaxTextureRepeat;
    uint             dwMaxTextureAspectRatio;
    uint             dwMaxAnisotropy;
    float            dvGuardBandLeft;
    float            dvGuardBandTop;
    float            dvGuardBandRight;
    float            dvGuardBandBottom;
    float            dvExtentsAdjust;
    uint             dwStencilCaps;
    uint             dwFVFCaps;
    uint             dwTextureOpCaps;
    ushort           wMaxTextureBlendStages;
    ushort           wMaxSimultaneousTextures;
}

struct D3DNTHAL_GLOBALDRIVERDATA
{
    uint           dwSize;
    _D3DNTHALDeviceDesc_V1 hwCaps;
    uint           dwNumVertices;
    uint           dwNumClipVertices;
    uint           dwNumTextureFormats;
    DDSURFACEDESC* lpTextureFormats;
}

struct D3DNTHAL_D3DDX6EXTENDEDCAPS
{
    uint   dwSize;
    uint   dwMinTextureWidth;
    uint   dwMaxTextureWidth;
    uint   dwMinTextureHeight;
    uint   dwMaxTextureHeight;
    uint   dwMinStippleWidth;
    uint   dwMaxStippleWidth;
    uint   dwMinStippleHeight;
    uint   dwMaxStippleHeight;
    uint   dwMaxTextureRepeat;
    uint   dwMaxTextureAspectRatio;
    uint   dwMaxAnisotropy;
    float  dvGuardBandLeft;
    float  dvGuardBandTop;
    float  dvGuardBandRight;
    float  dvGuardBandBottom;
    float  dvExtentsAdjust;
    uint   dwStencilCaps;
    uint   dwFVFCaps;
    uint   dwTextureOpCaps;
    ushort wMaxTextureBlendStages;
    ushort wMaxSimultaneousTextures;
}

struct D3DNTHAL_D3DEXTENDEDCAPS
{
    uint   dwSize;
    uint   dwMinTextureWidth;
    uint   dwMaxTextureWidth;
    uint   dwMinTextureHeight;
    uint   dwMaxTextureHeight;
    uint   dwMinStippleWidth;
    uint   dwMaxStippleWidth;
    uint   dwMinStippleHeight;
    uint   dwMaxStippleHeight;
    uint   dwMaxTextureRepeat;
    uint   dwMaxTextureAspectRatio;
    uint   dwMaxAnisotropy;
    float  dvGuardBandLeft;
    float  dvGuardBandTop;
    float  dvGuardBandRight;
    float  dvGuardBandBottom;
    float  dvExtentsAdjust;
    uint   dwStencilCaps;
    uint   dwFVFCaps;
    uint   dwTextureOpCaps;
    ushort wMaxTextureBlendStages;
    ushort wMaxSimultaneousTextures;
    uint   dwMaxActiveLights;
    float  dvMaxVertexW;
    ushort wMaxUserClipPlanes;
    ushort wMaxVertexBlendMatrices;
    uint   dwVertexProcessingCaps;
    uint   dwReserved1;
    uint   dwReserved2;
    uint   dwReserved3;
    uint   dwReserved4;
}

struct D3DNTHAL_CONTEXTCREATEDATA
{
union
    {
        DD_DIRECTDRAW_GLOBAL* lpDDGbl;
        DD_DIRECTDRAW_LOCAL* lpDDLcl;
    }
union
    {
        DD_SURFACE_LOCAL* lpDDS;
        DD_SURFACE_LOCAL* lpDDSLcl;
    }
union
    {
        DD_SURFACE_LOCAL* lpDDSZ;
        DD_SURFACE_LOCAL* lpDDSZLcl;
    }
    uint    dwPID;
    size_t  dwhContext;
    HRESULT ddrval;
}

struct D3DNTHAL_CONTEXTDESTROYDATA
{
    size_t  dwhContext;
    HRESULT ddrval;
}

struct D3DNTHAL_CONTEXTDESTROYALLDATA
{
    uint    dwPID;
    HRESULT ddrval;
}

struct D3DNTHAL_SCENECAPTUREDATA
{
    size_t  dwhContext;
    uint    dwFlag;
    HRESULT ddrval;
}

struct D3DNTHAL_TEXTURECREATEDATA
{
    size_t  dwhContext;
    HANDLE  hDDS;
    size_t  dwHandle;
    HRESULT ddrval;
}

struct D3DNTHAL_TEXTUREDESTROYDATA
{
    size_t  dwhContext;
    size_t  dwHandle;
    HRESULT ddrval;
}

struct D3DNTHAL_TEXTURESWAPDATA
{
    size_t  dwhContext;
    size_t  dwHandle1;
    size_t  dwHandle2;
    HRESULT ddrval;
}

struct D3DNTHAL_TEXTUREGETSURFDATA
{
    size_t  dwhContext;
    HANDLE  hDDS;
    size_t  dwHandle;
    HRESULT ddrval;
}

struct D3DNTHAL_CALLBACKS
{
    uint   dwSize;
    LPD3DNTHAL_CONTEXTCREATECB ContextCreate;
    LPD3DNTHAL_CONTEXTDESTROYCB ContextDestroy;
    LPD3DNTHAL_CONTEXTDESTROYALLCB ContextDestroyAll;
    LPD3DNTHAL_SCENECAPTURECB SceneCapture;
    void*  dwReserved10;
    void*  dwReserved11;
    void*  dwReserved22;
    void*  dwReserved23;
    size_t dwReserved;
    LPD3DNTHAL_TEXTURECREATECB TextureCreate;
    LPD3DNTHAL_TEXTUREDESTROYCB TextureDestroy;
    LPD3DNTHAL_TEXTURESWAPCB TextureSwap;
    LPD3DNTHAL_TEXTUREGETSURFCB TextureGetSurf;
    void*  dwReserved12;
    void*  dwReserved13;
    void*  dwReserved14;
    void*  dwReserved15;
    void*  dwReserved16;
    void*  dwReserved17;
    void*  dwReserved18;
    void*  dwReserved19;
    void*  dwReserved20;
    void*  dwReserved21;
    void*  dwReserved24;
    size_t dwReserved0;
    size_t dwReserved1;
    size_t dwReserved2;
    size_t dwReserved3;
    size_t dwReserved4;
    size_t dwReserved5;
    size_t dwReserved6;
    size_t dwReserved7;
    size_t dwReserved8;
    size_t dwReserved9;
}

struct D3DNTHAL_SETRENDERTARGETDATA
{
    size_t            dwhContext;
    DD_SURFACE_LOCAL* lpDDS;
    DD_SURFACE_LOCAL* lpDDSZ;
    HRESULT           ddrval;
}

struct D3DNTHAL_CALLBACKS2
{
    uint  dwSize;
    uint  dwFlags;
    LPD3DNTHAL_SETRENDERTARGETCB SetRenderTarget;
    void* dwReserved1;
    void* dwReserved2;
    void* dwReserved3;
    void* dwReserved4;
}

struct D3DNTHAL_CLEAR2DATA
{
    size_t   dwhContext;
    uint     dwFlags;
    uint     dwFillColor;
    float    dvFillDepth;
    uint     dwFillStencil;
    D3DRECT* lpRects;
    uint     dwNumRects;
    HRESULT  ddrval;
}

struct D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA
{
    size_t  dwhContext;
    uint    dwFlags;
    size_t  dwReserved;
    uint    dwNumPasses;
    HRESULT ddrval;
}

struct D3DNTHAL_DP2COMMAND
{
    ubyte bCommand;
    ubyte bReserved;
union
    {
        ushort wPrimitiveCount;
        ushort wStateCount;
    }
}

struct D3DNTHAL_DP2POINTS
{
    ushort wCount;
    ushort wVStart;
}

struct D3DNTHAL_DP2STARTVERTEX
{
    ushort wVStart;
}

struct D3DNTHAL_DP2LINELIST
{
    ushort wVStart;
}

struct D3DNTHAL_DP2INDEXEDLINELIST
{
    ushort wV1;
    ushort wV2;
}

struct D3DNTHAL_DP2LINESTRIP
{
    ushort wVStart;
}

struct D3DNTHAL_DP2INDEXEDLINESTRIP
{
    ushort[2] wV;
}

struct D3DNTHAL_DP2TRIANGLELIST
{
    ushort wVStart;
}

struct D3DNTHAL_DP2INDEXEDTRIANGLELIST
{
    ushort wV1;
    ushort wV2;
    ushort wV3;
    ushort wFlags;
}

struct D3DNTHAL_DP2INDEXEDTRIANGLELIST2
{
    ushort wV1;
    ushort wV2;
    ushort wV3;
}

struct D3DNTHAL_DP2TRIANGLESTRIP
{
    ushort wVStart;
}

struct D3DNTHAL_DP2INDEXEDTRIANGLESTRIP
{
    ushort[3] wV;
}

struct D3DNTHAL_DP2TRIANGLEFAN
{
    ushort wVStart;
}

struct D3DNTHAL_DP2INDEXEDTRIANGLEFAN
{
    ushort[3] wV;
}

struct D3DNTHAL_DP2TRIANGLEFAN_IMM
{
    uint dwEdgeFlags;
}

struct D3DNTHAL_DP2RENDERSTATE
{
    D3DRENDERSTATETYPE RenderState;
union
    {
        float fState;
        uint  dwState;
    }
}

struct D3DNTHAL_DP2TEXTURESTAGESTATE
{
    ushort wStage;
    ushort TSState;
    uint   dwValue;
}

struct D3DNTHAL_DP2VIEWPORTINFO
{
    uint dwX;
    uint dwY;
    uint dwWidth;
    uint dwHeight;
}

struct D3DNTHAL_DP2WINFO
{
    float dvWNear;
    float dvWFar;
}

struct D3DNTHAL_DP2SETPALETTE
{
    uint dwPaletteHandle;
    uint dwPaletteFlags;
    uint dwSurfaceHandle;
}

struct D3DNTHAL_DP2UPDATEPALETTE
{
    uint   dwPaletteHandle;
    ushort wStartIndex;
    ushort wNumEntries;
}

struct D3DNTHAL_DP2SETRENDERTARGET
{
    uint hRenderTarget;
    uint hZBuffer;
}

struct D3DNTHAL_DP2STATESET
{
    uint              dwOperation;
    uint              dwParam;
    D3DSTATEBLOCKTYPE sbType;
}

struct D3DNTHAL_DP2ZRANGE
{
    float dvMinZ;
    float dvMaxZ;
}

struct D3DNTHAL_DP2SETLIGHT
{
    uint dwIndex;
union
    {
        uint lightData;
        uint dwDataType;
    }
}

struct D3DNTHAL_DP2SETCLIPPLANE
{
    uint     dwIndex;
    float[4] plane;
}

struct D3DNTHAL_DP2CREATELIGHT
{
    uint dwIndex;
}

struct D3DNTHAL_DP2SETTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX matrix;
}

struct D3DNTHAL_DP2EXT
{
    uint dwExtToken;
    uint dwSize;
}

struct D3DNTHAL_DP2TEXBLT
{
    uint  dwDDDestSurface;
    uint  dwDDSrcSurface;
    POINT pDest;
    RECTL rSrc;
    uint  dwFlags;
}

struct D3DNTHAL_DP2SETPRIORITY
{
    uint dwDDDestSurface;
    uint dwPriority;
}

struct D3DNTHAL_DP2CLEAR
{
    uint    dwFlags;
    uint    dwFillColor;
    float   dvFillDepth;
    uint    dwFillStencil;
    RECT[1] Rects;
}

struct D3DNTHAL_DP2SETTEXLOD
{
    uint dwDDSurface;
    uint dwLOD;
}

struct D3DNTHAL_DRAWPRIMITIVES2DATA
{
    size_t            dwhContext;
    uint              dwFlags;
    uint              dwVertexType;
    DD_SURFACE_LOCAL* lpDDCommands;
    uint              dwCommandOffset;
    uint              dwCommandLength;
union
    {
        DD_SURFACE_LOCAL* lpDDVertex;
        void*             lpVertices;
    }
    uint              dwVertexOffset;
    uint              dwVertexLength;
    uint              dwReqVertexBufSize;
    uint              dwReqCommandBufSize;
    uint*             lpdwRStates;
union
    {
        uint    dwVertexSize;
        HRESULT ddrval;
    }
    uint              dwErrorOffset;
}

struct D3DNTHAL_CALLBACKS3
{
    uint                dwSize;
    uint                dwFlags;
    LPD3DNTHAL_CLEAR2CB Clear2;
    void*               lpvReserved;
    LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB ValidateTextureStageState;
    LPD3DNTHAL_DRAWPRIMITIVES2CB DrawPrimitives2;
}

struct POINTE
{
    uint x;
    uint y;
}

union FLOAT_LONG
{
    uint e;
    int  l;
}

struct POINTFIX
{
    int x;
    int y;
}

struct RECTFX
{
    int xLeft;
    int yTop;
    int xRight;
    int yBottom;
}

struct HBM__
{
    int unused;
}

struct HDEV__
{
    int unused;
}

struct DHSURF__
{
    int unused;
}

struct DHPDEV__
{
    int unused;
}

struct LIGATURE
{
    uint    culSize;
    PWSTR   pwsz;
    uint    chglyph;
    uint[1] ahglyph;
}

struct FD_LIGATURE
{
    uint        culThis;
    uint        ulType;
    uint        cLigatures;
    LIGATURE[1] alig;
}

struct POINTQF
{
    LARGE_INTEGER x;
    LARGE_INTEGER y;
}

struct CDDDXGK_REDIRBITMAPPRESENTINFO
{
    uint          NumDirtyRects;
    RECT*         DirtyRect;
    uint          NumContexts;
    ptrdiff_t[65] hContext;
    ubyte         bDoNotSynchronizeWithDxContent;
}

struct XFORMOBJ
{
    uint ulReserved;
}

struct EMFINFO
{
    uint   nSize;
    HDC    hdc;
    ubyte* pvEMF;
    ubyte* pvCurrentRecord;
}

struct DRH_APIBITMAPDATA
{
    SURFOBJ* pso;
    BOOL     b;
}

struct DEVICE_EVENT_MOUNT
{
    uint Version;
    uint Flags;
    uint FileSystemNameLength;
    uint FileSystemNameOffset;
}

struct DEVICE_EVENT_BECOMING_READY
{
    uint Version;
    uint Reason;
    uint Estimated100msToReady;
}

struct DEVICE_EVENT_EXTERNAL_REQUEST
{
    uint          Version;
    uint          DeviceClass;
    ushort        ButtonStatus;
    ushort        Request;
    LARGE_INTEGER SystemTime;
}

struct DEVICE_EVENT_GENERIC_DATA
{
    uint EventNumber;
}

struct DEVICE_EVENT_RBC_DATA
{
    uint  EventNumber;
    ubyte SenseQualifier;
    ubyte SenseCode;
    ubyte SenseKey;
    ubyte Reserved;
    uint  Information;
}

struct GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION
{
    uint DiskNumber;
}

struct DISK_HEALTH_NOTIFICATION_DATA
{
    GUID DeviceGuid;
}

struct DEVPROPKEY
{
    GUID fmtid;
    uint pid;
}

struct DEVPROPCOMPKEY
{
    DEVPROPKEY   Key;
    DEVPROPSTORE Store;
    const(PWSTR) LocaleName;
}

struct DEVPROPERTY
{
    DEVPROPCOMPKEY CompKey;
    uint           Type;
    uint           BufferSize;
    void*          Buffer;
}

struct REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO
{
    uint Version;
    uint Accurate;
    uint Supported;
    uint AccurateMask0;
}

///Serves as a standard header for information related to a device event reported through the WM_DEVICECHANGE message.
///The members of the <b>DEV_BROADCAST_HDR</b> structure are contained in each device management structure. To determine
///which structure you have received through WM_DEVICECHANGE, treat the structure as a <b>DEV_BROADCAST_HDR</b>
///structure and check its <b>dbch_devicetype</b> member.
struct DEV_BROADCAST_HDR
{
    ///The size of this structure, in bytes. If this is a user-defined event, this member must be the size of this
    ///header, plus the size of the variable-length data in the _DEV_BROADCAST_USERDEFINED structure.
    uint dbch_size;
    ///The device type, which determines the event-specific information that follows the first three members. This
    ///member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="DBT_DEVTYP_DEVICEINTERFACE"></a><a id="dbt_devtyp_deviceinterface"></a><dl>
    ///<dt><b>DBT_DEVTYP_DEVICEINTERFACE</b></dt> <dt>0x00000005</dt> </dl> </td> <td width="60%"> Class of devices.
    ///This structure is a DEV_BROADCAST_DEVICEINTERFACE structure. </td> </tr> <tr> <td width="40%"><a
    ///id="DBT_DEVTYP_HANDLE"></a><a id="dbt_devtyp_handle"></a><dl> <dt><b>DBT_DEVTYP_HANDLE</b></dt>
    ///<dt>0x00000006</dt> </dl> </td> <td width="60%"> File system handle. This structure is a DEV_BROADCAST_HANDLE
    ///structure. </td> </tr> <tr> <td width="40%"><a id="DBT_DEVTYP_OEM"></a><a id="dbt_devtyp_oem"></a><dl>
    ///<dt><b>DBT_DEVTYP_OEM</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> OEM- or IHV-defined device type.
    ///This structure is a DEV_BROADCAST_OEM structure. </td> </tr> <tr> <td width="40%"><a id="DBT_DEVTYP_PORT"></a><a
    ///id="dbt_devtyp_port"></a><dl> <dt><b>DBT_DEVTYP_PORT</b></dt> <dt>0x00000003</dt> </dl> </td> <td width="60%">
    ///Port device (serial or parallel). This structure is a DEV_BROADCAST_PORT structure. </td> </tr> <tr> <td
    ///width="40%"><a id="DBT_DEVTYP_VOLUME"></a><a id="dbt_devtyp_volume"></a><dl> <dt><b>DBT_DEVTYP_VOLUME</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> Logical volume. This structure is a DEV_BROADCAST_VOLUME
    ///structure. </td> </tr> </table>
    uint dbch_devicetype;
    ///Reserved; do not use.
    uint dbch_reserved;
}

struct VolLockBroadcast
{
    DEV_BROADCAST_HDR vlb_dbh;
    uint              vlb_owner;
    ubyte             vlb_perms;
    ubyte             vlb_lockType;
    ubyte             vlb_drive;
    ubyte             vlb_flags;
}

struct _DEV_BROADCAST_HEADER
{
    uint dbcd_size;
    uint dbcd_devicetype;
    uint dbcd_reserved;
}

///Contains information about a OEM-defined device type.
struct DEV_BROADCAST_OEM
{
    ///The size of this structure, in bytes.
    uint dbco_size;
    ///Set to <b>DBT_DEVTYP_OEM</b>.
    uint dbco_devicetype;
    ///Reserved; do not use.
    uint dbco_reserved;
    ///The OEM-specific identifier for the device.
    uint dbco_identifier;
    ///The OEM-specific function value. Possible values depend on the device.
    uint dbco_suppfunc;
}

struct DEV_BROADCAST_DEVNODE
{
    uint dbcd_size;
    uint dbcd_devicetype;
    uint dbcd_reserved;
    uint dbcd_devnode;
}

///Contains information about a logical volume.
struct DEV_BROADCAST_VOLUME
{
    ///The size of this structure, in bytes.
    uint   dbcv_size;
    ///Set to <b>DBT_DEVTYP_VOLUME</b> (2).
    uint   dbcv_devicetype;
    ///Reserved; do not use.
    uint   dbcv_reserved;
    ///The logical unit mask identifying one or more logical units. Each bit in the mask corresponds to one logical
    ///drive. Bit 0 represents drive A, bit 1 represents drive B, and so on.
    uint   dbcv_unitmask;
    ///This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="DBTF_MEDIA"></a><a id="dbtf_media"></a><dl> <dt><b>DBTF_MEDIA</b></dt> <dt>0x0001</dt> </dl>
    ///</td> <td width="60%"> Change affects media in drive. If not set, change affects physical device or drive. </td>
    ///</tr> <tr> <td width="40%"><a id="DBTF_NET"></a><a id="dbtf_net"></a><dl> <dt><b>DBTF_NET</b></dt>
    ///<dt>0x0002</dt> </dl> </td> <td width="60%"> Indicated logical volume is a network volume. </td> </tr> </table>
    ushort dbcv_flags;
}

///Contains information about a modem, serial, or parallel port.
struct DEV_BROADCAST_PORT_A
{
    ///The size of this structure, in bytes. This is the size of the members plus the actual length of the
    ///<b>dbcp_name</b> string (the null character is accounted for by the declaration of <b>dbcp_name</b> as a
    ///one-character array.)
    uint    dbcp_size;
    ///Set to <b>DBT_DEVTYP_PORT</b>.
    uint    dbcp_devicetype;
    ///Reserved; do not use.
    uint    dbcp_reserved;
    ///A null-terminated string specifying the friendly name of the port or the device connected to the port. Friendly
    ///names are intended to help the user quickly and accurately identify the device—for example, "COM1" and
    ///"Standard 28800 bps Modem" are considered friendly names.
    byte[1] dbcp_name;
}

///Contains information about a modem, serial, or parallel port.
struct DEV_BROADCAST_PORT_W
{
    ///The size of this structure, in bytes. This is the size of the members plus the actual length of the
    ///<b>dbcp_name</b> string (the null character is accounted for by the declaration of <b>dbcp_name</b> as a
    ///one-character array.)
    uint      dbcp_size;
    ///Set to <b>DBT_DEVTYP_PORT</b>.
    uint      dbcp_devicetype;
    ///Reserved; do not use.
    uint      dbcp_reserved;
    ///A null-terminated string specifying the friendly name of the port or the device connected to the port. Friendly
    ///names are intended to help the user quickly and accurately identify the device—for example, "COM1" and
    ///"Standard 28800 bps Modem" are considered friendly names.
    ushort[1] dbcp_name;
}

struct DEV_BROADCAST_NET
{
    uint dbcn_size;
    uint dbcn_devicetype;
    uint dbcn_reserved;
    uint dbcn_resource;
    uint dbcn_flags;
}

///Contains information about a class of devices.
struct DEV_BROADCAST_DEVICEINTERFACE_A
{
    ///The size of this structure, in bytes. This is the size of the members plus the actual length of the
    ///<b>dbcc_name</b> string (the null character is accounted for by the declaration of <b>dbcc_name</b> as a
    ///one-character array.)
    uint    dbcc_size;
    ///Set to <b>DBT_DEVTYP_DEVICEINTERFACE</b>.
    uint    dbcc_devicetype;
    ///Reserved; do not use.
    uint    dbcc_reserved;
    ///The GUID for the interface device class.
    GUID    dbcc_classguid;
    ///A null-terminated string that specifies the name of the device. When this structure is returned to a window
    ///through the WM_DEVICECHANGE message, the <b>dbcc_name</b> string is converted to ANSI as appropriate. Services
    ///always receive a Unicode string, whether they call <b>RegisterDeviceNotificationW</b> or
    ///<b>RegisterDeviceNotificationA</b>.
    byte[1] dbcc_name;
}

///Contains information about a class of devices.
struct DEV_BROADCAST_DEVICEINTERFACE_W
{
    ///The size of this structure, in bytes. This is the size of the members plus the actual length of the
    ///<b>dbcc_name</b> string (the null character is accounted for by the declaration of <b>dbcc_name</b> as a
    ///one-character array.)
    uint      dbcc_size;
    ///Set to <b>DBT_DEVTYP_DEVICEINTERFACE</b>.
    uint      dbcc_devicetype;
    ///Reserved; do not use.
    uint      dbcc_reserved;
    ///The GUID for the interface device class.
    GUID      dbcc_classguid;
    ///A null-terminated string that specifies the name of the device. When this structure is returned to a window
    ///through the WM_DEVICECHANGE message, the <b>dbcc_name</b> string is converted to ANSI as appropriate. Services
    ///always receive a Unicode string, whether they call <b>RegisterDeviceNotificationW</b> or
    ///<b>RegisterDeviceNotificationA</b>.
    ushort[1] dbcc_name;
}

///Contains information about a file system handle.
struct DEV_BROADCAST_HANDLE
{
    ///The size of this structure, in bytes.
    uint     dbch_size;
    ///Set to DBT_DEVTYP_HANDLE.
    uint     dbch_devicetype;
    ///Reserved; do not use.
    uint     dbch_reserved;
    ///A handle to the device to be checked.
    HANDLE   dbch_handle;
    ///A handle to the device notification. This handle is returned by RegisterDeviceNotification.
    void*    dbch_hdevnotify;
    ///The GUID for the custom event. For more information, see Device Events. Valid only for DBT_CUSTOMEVENT.
    GUID     dbch_eventguid;
    ///The offset of an optional string buffer. Valid only for DBT_CUSTOMEVENT.
    int      dbch_nameoffset;
    ///Optional binary data. This member is valid only for DBT_CUSTOMEVENT.
    ubyte[1] dbch_data;
}

struct DEV_BROADCAST_HANDLE32
{
    uint     dbch_size;
    uint     dbch_devicetype;
    uint     dbch_reserved;
    uint     dbch_handle;
    uint     dbch_hdevnotify;
    GUID     dbch_eventguid;
    int      dbch_nameoffset;
    ubyte[1] dbch_data;
}

struct DEV_BROADCAST_HANDLE64
{
    uint     dbch_size;
    uint     dbch_devicetype;
    uint     dbch_reserved;
    ulong    dbch_handle;
    ulong    dbch_hdevnotify;
    GUID     dbch_eventguid;
    int      dbch_nameoffset;
    ubyte[1] dbch_data;
}

///Contains the user-defined event and optional data associated with the DBT_USERDEFINED device event.
struct _DEV_BROADCAST_USERDEFINED
{
    ///Information about the device affected by a WM_DEVICECHANGE message as specified by the DEV_BROADCAST_HDR
    ///structure. Because <b>_DEV_BROADCAST_USERDEFINED</b> is variable length, the <b>dbch_size</b> member of the
    ///<b>dbud_dbh</b> structure must be the size in bytes of the entire structure, including the variable length
    ///portion.
    DEV_BROADCAST_HDR dbud_dbh;
    ///A pointer to a case-sensitive, null-terminated string that names the message. The string must consist of the
    ///vendor name, a backslash, followed by arbitrary user-defined null-terminated text.
    byte[1]           dbud_szName;
}

///Represents the static information that characterizes a Pulse Width Modulation (PWM) controller.
struct PWM_CONTROLLER_INFO
{
    ///The size of the structure, which includes the <b>Size</b> member. The structure byte size is used for versioning.
    size_t Size;
    ///The number of available pins or channels of the controller, which must be greater than zero (0).
    uint   PinCount;
    ///The minimum supported output signal period, in picoseconds, for the controller. This value must be greater than
    ///zero and less than or equal the <b>MaximumPeriod</b> value.
    ulong  MinimumPeriod;
    ///The maximum supported output signal period, in picoseconds, for the controller. This value must be greater than
    ///zero and greater than or equal the <b>MinimumPeriod</b> value.
    ulong  MaximumPeriod;
}

struct PWM_CONTROLLER_GET_ACTUAL_PERIOD_OUTPUT
{
    ulong ActualPeriod;
}

///Contains an input value for a suggested signal period for the Pulse Width Modulation (PWM) controller.
struct PWM_CONTROLLER_SET_DESIRED_PERIOD_INPUT
{
    ///The desired output signal period, in picoseconds, for the controller. This value must be greater than zero (0).
    ///It must be in the controller supported range of periods, which is between the <b>MinimumPeriod</b> and
    ///<b>MaximumPeriod</b> values, inclusive, which you can obtain by using IOCTL_PWM_CONTROLLER_GET_INFO. If the value
    ///is not valid, the request is completed with a STATUS_INVALID_PARAMETER value.
    ulong DesiredPeriod;
}

///Contains the effective output signal period of the Pulse Width Modulation (PWM) controller.
struct PWM_CONTROLLER_SET_DESIRED_PERIOD_OUTPUT
{
    ///The effective output signal period, in picoseconds, of the controller.
    ulong ActualPeriod;
}

struct PWM_PIN_GET_ACTIVE_DUTY_CYCLE_PERCENTAGE_OUTPUT
{
    ulong Percentage;
}

struct PWM_PIN_SET_ACTIVE_DUTY_CYCLE_PERCENTAGE_INPUT
{
    ulong Percentage;
}

struct PWM_PIN_GET_POLARITY_OUTPUT
{
    PWM_POLARITY Polarity;
}

///Contains a desired value for polarity of a pin or channel.
struct PWM_PIN_SET_POLARITY_INPUT
{
    ///The desired polarity for the pin or channel as a PWM_POLARITY value. The polarity is either Active High or Active
    ///Low.
    PWM_POLARITY Polarity;
}

struct PWM_PIN_IS_STARTED_OUTPUT
{
    ubyte IsStarted;
}

struct AtlThunkData_t
{
}

///Describes the identity of the primary module of an enclave.
struct ENCLAVE_IDENTITY
{
align (1):
    ///The identifier of the owner for the enclave.
    ubyte[32] OwnerId;
    ///The unique identifier of the primary module for the enclave.
    ubyte[32] UniqueId;
    ///The author identifier of the primary module for the enclave.
    ubyte[32] AuthorId;
    ///The family identifier of the primary module for the enclave.
    ubyte[16] FamilyId;
    ///The image identifier of the primary module for the enclave.
    ubyte[16] ImageId;
    ///The security version number of the primary module for the enclave.
    uint      EnclaveSvn;
    ///The security version number of the Virtual Secure Mode (VSM) kernel.
    uint      SecureKernelSvn;
    ///The security version number of the platform that hosts the enclave.
    uint      PlatformSvn;
    ///Flags that describe the runtime policy for the enclave. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="ENCLAVE_FLAG_FULL_DEBUG_ENABLED"></a><a id="enclave_flag_full_debug_enabled"></a><dl>
    ///<dt><b>ENCLAVE_FLAG_FULL_DEBUG_ENABLED</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The enclave
    ///supports debugging. </td> </tr> <tr> <td width="40%"><a id="ENCLAVE_FLAG_DYNAMIC_DEBUG_ENABLED"></a><a
    ///id="enclave_flag_dynamic_debug_enabled"></a><dl> <dt><b>ENCLAVE_FLAG_DYNAMIC_DEBUG_ENABLED</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The enclave supports dynamic debugging. </td> </tr> <tr> <td
    ///width="40%"><a id="ENCLAVE_FLAG_DYNAMIC_DEBUG_ACTIVE"></a><a id="enclave_flag_dynamic_debug_active"></a><dl>
    ///<dt><b>ENCLAVE_FLAG_DYNAMIC_DEBUG_ACTIVE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Dynamic
    ///debugging is turned on for the enclave. </td> </tr> </table>
    uint      Flags;
    ///The signing level of the primary module for the enclave.
    uint      SigningLevel;
    uint      EnclaveType;
}

///Describes the contents of a report generated by calling the EnclaveGetAttestationReport function.
struct VBS_ENCLAVE_REPORT_PKG_HEADER
{
align (1):
    ///The sum of the sizes of the <b>VBS_ENCLAVE_REPORT_PKG_HEADER</b> structure, the signed statement, and the
    ///signature contained in a report generated by calling the EnclaveGetAttestationReport function, in bytes.
    uint PackageSize;
    ///The version of the <b>VBS_ENCLAVE_REPORT_PKG_HEADER</b> structure in a report generated by calling the
    ///EnclaveGetAttestationReport function. The only version currently supported is
    ///<b>VBS_ENCLAVE_REPORT_PKG_HEADER_VERSION_CURRENT</b>, which equals 1.
    uint Version;
    ///The scheme used for the signature in a report generated by calling the EnclaveGetAttestationReport function.
    uint SignatureScheme;
    ///The size of the signed data contained in a report generated by calling the EnclaveGetAttestationReport function,
    ///in bytes.
    uint SignedStatementSize;
    ///The size of the signature contained in a report generated by calling the EnclaveGetAttestationReport function, in
    ///bytes.
    uint SignatureSize;
    ///Reserved.
    uint Reserved;
}

///Describes the format of the signed statement contained in a report generated by calling the
///EnclaveGetAttestationReport function.
struct VBS_ENCLAVE_REPORT
{
align (1):
    ///The total size of the signed statement in the report, including the sizes of the <b>VBS_ENCLAVE_REPORT</b>
    ///structure and of all the variable data blocks, in bytes.
    uint             ReportSize;
    ///The version of the report format. The only currently available version is
    ///<b>VBS_ENCLAVE_REPORT_VERSION_CURRENT</b>, which equals 1.
    uint             ReportVersion;
    ///The 64 bytes that were provided in <i>EnclaveData</i> parameter of the EnclaveGetAttestationReport function.
    ubyte[64]        EnclaveData;
    ///An ENCLAVE_IDENTITY structure that describes the identity of the primary module of the enclave.
    ENCLAVE_IDENTITY EnclaveIdentity;
}

///Describes the format of a variable data block contained in a report that the EnclaveGetAttestationReport function
///generates.
struct VBS_ENCLAVE_REPORT_VARDATA_HEADER
{
align (1):
    ///The type of the variable data block. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="VBS_ENCLAVE_VARDATA_INVALID"></a><a id="vbs_enclave_vardata_invalid"></a><dl>
    ///<dt><b>VBS_ENCLAVE_VARDATA_INVALID</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> The variable data
    ///block is not valid. </td> </tr> <tr> <td width="40%"><a id="VBS_ENCLAVE_VARDATA_MODULE"></a><a
    ///id="vbs_enclave_vardata_module"></a><dl> <dt><b>VBS_ENCLAVE_VARDATA_MODULE</b></dt> <dt>0x00000001</dt> </dl>
    ///</td> <td width="60%"> The variable data block is a module. </td> </tr> </table>
    uint DataType;
    ///The size of this variable data block, including the header, in bytes.
    uint Size;
}

///Describes a module loaded for the enclave. The report contains one <b>VBS_ENCLAVE_REPORT_MODULE</b> structure for
///every module loaded for the enclave except the primary module for the enclave, which is described in the
///<b>EnclaveIdentity</b> member of the VBS_ENCLAVE_REPORT structure.
struct VBS_ENCLAVE_REPORT_MODULE
{
align (1):
    ///The variable data header for the report.
    VBS_ENCLAVE_REPORT_VARDATA_HEADER Header;
    ///The enclave unique identifier of the module.
    ubyte[32] UniqueId;
    ///The author identifier of the module.
    ubyte[32] AuthorId;
    ///The family identifier of the module.
    ubyte[16] FamilyId;
    ///The image identifier of the module.
    ubyte[16] ImageId;
    ///The security version number of the module.
    uint      Svn;
    ///A NULL-terminated string that contains the name of the module as it was loaded into the enclave.
    ushort[1] ModuleName;
}

///Contains information about the currently executing enclave.
struct ENCLAVE_INFORMATION
{
    ///The architecture type of the enclave. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ENCLAVE_TYPE_SGX"></a><a id="enclave_type_sgx"></a><dl> <dt><b><b>ENCLAVE_TYPE_SGX</b></b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> An enclave for the Intel Software Guard Extensions (SGX)
    ///architecture extension. </td> </tr> <tr> <td width="40%"><a id="ENCLAVE_TYPE_VBS"></a><a
    ///id="enclave_type_vbs"></a><dl> <dt><b>ENCLAVE_TYPE_VBS</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">
    ///A VBS enclave. </td> </tr> </table>
    uint             EnclaveType;
    ///Reserved.
    uint             Reserved;
    ///A pointer to the base address of the enclave.
    void*            BaseAddress;
    ///The size of the enclave, in bytes.
    size_t           Size;
    ///The identity of the primary module of an enclave.
    ENCLAVE_IDENTITY Identity;
}

struct VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32
{
    uint[4] ThreadContext;
    uint    EntryPoint;
    uint    StackPointer;
    uint    ExceptionEntryPoint;
    uint    ExceptionStack;
    uint    ExceptionActive;
}

struct VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR64
{
    ulong[4] ThreadContext;
    ulong    EntryPoint;
    ulong    StackPointer;
    ulong    ExceptionEntryPoint;
    ulong    ExceptionStack;
    uint     ExceptionActive;
}

struct VBS_BASIC_ENCLAVE_EXCEPTION_AMD64
{
    uint      ExceptionCode;
    uint      NumberParameters;
    size_t[3] ExceptionInformation;
    size_t    ExceptionRAX;
    size_t    ExceptionRCX;
    size_t    ExceptionRIP;
    size_t    ExceptionRFLAGS;
    size_t    ExceptionRSP;
}

struct ENCLAVE_VBS_BASIC_KEY_REQUEST
{
    uint RequestSize;
    uint Flags;
    uint EnclaveSVN;
    uint SystemKeyID;
    uint CurrentSystemKeyID;
}

struct VBS_BASIC_ENCLAVE_SYSCALL_PAGE
{
    VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE* ReturnFromEnclave;
    VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION* ReturnFromException;
    VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD* TerminateThread;
    VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD* InterruptThread;
    VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES* CommitPages;
    VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES* DecommitPages;
    VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES* ProtectPages;
    VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD* CreateThread;
    VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION* GetEnclaveInformation;
    VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY* GenerateKey;
    VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT* GenerateReport;
    VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT* VerifyReport;
    VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA* GenerateRandomData;
}

///Contains global computer power policy settings that apply to all power schemes for all users. This structure is part
///of the GLOBAL_POWER_POLICY structure.
struct GLOBAL_MACHINE_POWER_POLICY
{
    ///The current structure revision level. Set this value by calling GetCurrentPowerPolicies or ReadGlobalPwrPolicy
    ///before using a <b>GLOBAL_MACHINE_POWER_POLICY</b> structure to set power policy.
    uint               Revision;
    ///The maximum power state (highest Sx value) from which a lid-open event should wake the system when running on AC
    ///power. This member must be one of the SYSTEM_POWER_STATE enumeration type values. A value of
    ///<b>PowerSystemUnspecified</b> indicates that a lid-open event does not wake the system.
    SYSTEM_POWER_STATE LidOpenWakeAc;
    ///The maximum power state (highest Sx value) from which a lid-open event should wake the system when running on
    ///battery. This member must be one of the SYSTEM_POWER_STATE enumeration type values. A value of
    ///<b>PowerSystemUnspecified</b> indicates that a lid-open event does not wake the system.
    SYSTEM_POWER_STATE LidOpenWakeDc;
    ///The resolution of change in the current battery capacity that should cause the system to be notified of a system
    ///power state changed event.
    uint               BroadcastCapacityResolution;
}

///Contains global user power policy settings that apply to all power schemes for a user. This structure is part of the
///GLOBAL_POWER_POLICY structure.
struct GLOBAL_USER_POWER_POLICY
{
    ///The current structure revision level. Set this value by calling GetCurrentPowerPolicies or ReadGlobalPwrPolicy
    ///before using a <b>GLOBAL_USER_POWER_POLICY</b> structure to set power policy.
    uint                Revision;
    ///A POWER_ACTION_POLICY structure that defines the action to take when the power button is pressed and the system
    ///is running on AC power.
    POWER_ACTION_POLICY PowerButtonAc;
    ///A POWER_ACTION_POLICY structure that defines the action to take when the power button is pressed and the system
    ///is running on battery power.
    POWER_ACTION_POLICY PowerButtonDc;
    ///A POWER_ACTION_POLICY structure that defines the action to take when the sleep button is pressed and the system
    ///is running on AC power.
    POWER_ACTION_POLICY SleepButtonAc;
    ///A POWER_ACTION_POLICY structure that defines the action to take when the sleep button is pressed and the system
    ///is running on battery power.
    POWER_ACTION_POLICY SleepButtonDc;
    ///A POWER_ACTION_POLICY structure that defines the action to take when the lid is closed and the system is running
    ///on AC power.
    POWER_ACTION_POLICY LidCloseAc;
    ///A POWER_ACTION_POLICY structure that defines the action to take when the lid is closed and the system is running
    ///on battery power.
    POWER_ACTION_POLICY LidCloseDc;
    ///An array of SYSTEM_POWER_LEVEL structures that defines the actions to take at system battery discharge events.
    SYSTEM_POWER_LEVEL[4] DischargePolicy;
    ///A flag that enables or disables miscellaneous user power policy settings. This member can be one or more of the
    ///values described in Global Flags Constants.
    uint                GlobalFlags;
}

///Contains global power policy settings that apply to all power schemes.
struct GLOBAL_POWER_POLICY
{
    ///A GLOBAL_USER_POWER_POLICY structure that defines the global user power policy settings.
    GLOBAL_USER_POWER_POLICY user;
    ///A GLOBAL_MACHINE_POWER_POLICY structure that defines the global computer power policy settings.
    GLOBAL_MACHINE_POWER_POLICY mach;
}

///Contains computer power policy settings that are unique to each power scheme on the computer. This structure is part
///of the POWER_POLICY structure.
struct MACHINE_POWER_POLICY
{
    ///The current structure revision level. Set this value by calling GetCurrentPowerPolicies or ReadPwrScheme before
    ///using a <b>MACHINE_POWER_POLICY</b> structure to set power policy.
    uint                Revision;
    ///The minimum system power state (lowest Sx value) to enter on a system sleep action when running on AC power. This
    ///member must be one of the SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE  MinSleepAc;
    ///The minimum system power state (lowest Sx value) to enter on a system sleep action when running on battery power.
    ///This member must be one of the SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE  MinSleepDc;
    ///The maximum system power state (highest Sx value) to enter on a system sleep action when running on AC power, and
    ///when there are outstanding latency requirements. This member must be one of the SYSTEM_POWER_STATE enumeration
    ///type values. If an application calls RequestWakeupLatency with LT_LOWEST_LATENCY, <b>ReducedLatencySleepAc</b> is
    ///used in place of <b>MaxSleepAc</b>.
    SYSTEM_POWER_STATE  ReducedLatencySleepAc;
    ///The maximum system power state (highest Sx value) to enter on a system sleep action when running on battery
    ///power, and when there are outstanding latency requirements. This member must be one of the SYSTEM_POWER_STATE
    ///enumeration type values. If an application calls RequestWakeupLatency with LT_LOWEST_LATENCY,
    ///<b>ReducedLatencySleepAc</b> is used in place of <b>MaxSleepAc</b>.
    SYSTEM_POWER_STATE  ReducedLatencySleepDc;
    ///This member is ignored.
    uint                DozeTimeoutAc;
    ///This member is ignored.
    uint                DozeTimeoutDc;
    ///Time to wait between entering the suspend state and entering the hibernate sleeping state when the system is
    ///running on AC power, in seconds. A value of zero indicates never hibernate.
    uint                DozeS4TimeoutAc;
    ///Time to wait between entering the suspend state and entering the hibernate sleeping state when the system is
    ///running on battery power, in seconds. A value of zero indicates never hibernate.
    uint                DozeS4TimeoutDc;
    ///The minimum throttle setting allowed before being overthrottled when the system is running on AC power. Thermal
    ///conditions would be the only reason for going below the minimum setting. When the processor is overthrottled, the
    ///system will initiate the <b>OverThrottledAc</b> policy. Note that the power policy manager has a hard-coded
    ///policy to initiate a CriticalShutdownOff whenever any thermal zone indicates a critical thermal condition. Range:
    ///0-100.
    ubyte               MinThrottleAc;
    ///The minimum throttle setting allowed before being overthrottled when the system is running on battery power.
    ///Thermal conditions would be the only reason for going below the minimum setting. When the processor is
    ///overthrottled, the system will initiate the <b>OverThrottledDc</b> policy. Note that the power policy manager has
    ///a hard-coded policy to initiate a CriticalShutdownOff whenever any thermal zone indicates a critical thermal
    ///condition. Range: 0-100.
    ubyte               MinThrottleDc;
    ///Reserved.
    ubyte[2]            pad1;
    ///A POWER_ACTION_POLICY structure that defines the action to take when a processor has become overthrottled (as
    ///defined by the <b>MinThrottleAc</b> member) when the system is running on AC power.
    POWER_ACTION_POLICY OverThrottledAc;
    ///A POWER_ACTION_POLICY structure that defines the action to take when a processor has become overthrottled (as
    ///defined by the <b>MinThrottleDc</b> member) when the system is running on battery power.
    POWER_ACTION_POLICY OverThrottledDc;
}

///Contains processor power policy settings that apply while the system is running on AC power or battery power.
struct MACHINE_PROCESSOR_POWER_POLICY
{
    ///The current structure revision level. Set this value by calling ReadProcessorPwrScheme before using a
    ///<b>MACHINE_PROCESSOR_POWER_POLICY</b> structure to set power policy.
    uint Revision;
    ///A PROCESSOR_POWER_POLICY structure that defines the processor power policy settings used while the computer is
    ///running on AC power.
    PROCESSOR_POWER_POLICY ProcessorPolicyAc;
    ///A PROCESSOR_POWER_POLICY structure that defines the processor power policy settings used while the computer is
    ///running on battery power.
    PROCESSOR_POWER_POLICY ProcessorPolicyDc;
}

///Contains power policy settings that are unique to each power scheme for a user. This structure is part of the
///POWER_POLICY structure.
struct USER_POWER_POLICY
{
    ///The current structure revision level. Set this value by calling GetCurrentPowerPolicies or ReadPwrScheme before
    ///using a <b>USER_POWER_POLICY</b> structure to set power policy.
    uint                Revision;
    ///A POWER_ACTION_POLICY structure that defines the system power action to initiate when the system is running on AC
    ///(utility) power and the system idle timer expires.
    POWER_ACTION_POLICY IdleAc;
    ///A POWER_ACTION_POLICY structure that defines the system power action to initiate when the system is running on
    ///battery power and the system idle timer expires.
    POWER_ACTION_POLICY IdleDc;
    ///The time that the level of system activity must remain below the idle detection threshold before the system idle
    ///timer expires when running on AC (utility) power, in seconds. This member is ignored if the system is performing
    ///an automated resume because there is no user present. To temporarily keep the system running while an application
    ///is performing a task, use the SetThreadExecutionState function.
    uint                IdleTimeoutAc;
    ///The time that the level of system activity must remain below the idle detection threshold before the system idle
    ///timer expires when running on battery power, in seconds. This member is ignored if the system is performing an
    ///automated resume because there is no user present. To temporarily keep the system running while an application is
    ///performing a task, use the SetThreadExecutionState function.
    uint                IdleTimeoutDc;
    ///The level of system activity that defines the threshold for idle detection when the system is running on AC
    ///(utility) power, expressed as a percentage.
    ubyte               IdleSensitivityAc;
    ///The level of system activity that defines the threshold for idle detection when the system is running on battery
    ///power, expressed as a percentage.
    ubyte               IdleSensitivityDc;
    ///The processor dynamic throttling policy to use when the system is running on AC (utility) power.
    ubyte               ThrottlePolicyAc;
    ///The processor dynamic throttling policy to use when the system is running on battery power.
    ubyte               ThrottlePolicyDc;
    ///The maximum system sleep state when the system is running on AC (utility) power. This member must be one of the
    ///SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE  MaxSleepAc;
    ///The maximum system sleep state when the system is running on battery power. This member must be one of the
    ///SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE  MaxSleepDc;
    ///Reserved.
    uint[2]             Reserved;
    ///The time before the display is turned off when the system is running on AC (utility) power, in seconds.
    uint                VideoTimeoutAc;
    ///The time before the display is turned off when the system is running on battery power, in seconds.
    uint                VideoTimeoutDc;
    ///The time before power to fixed disk drives is turned off when the system is running on AC (utility) power, in
    ///seconds.
    uint                SpindownTimeoutAc;
    ///The time before power to fixed disk drives is turned off when the system is running on battery power, in seconds.
    uint                SpindownTimeoutDc;
    ///If this member is <b>TRUE</b>, the system will turn on cooling fans and run the processor at full speed when
    ///passive cooling is specified and the system is running on AC (utility) power. This causes the operating system to
    ///be biased toward using the fan and running the processor at full speed.
    ubyte               OptimizeForPowerAc;
    ///If this member is <b>TRUE</b>, the system will turn on cooling fans and run the processor at full speed when
    ///passive cooling is specified and the system is running on battery power. This causes the operating system to be
    ///biased toward using the fan and running the processor at full speed.
    ubyte               OptimizeForPowerDc;
    ///The lower limit that the processor may be throttled down to prior to turning on system fans in response to a
    ///thermal event while the system is operating on AC (utility) power, expressed as a percentage.
    ubyte               FanThrottleToleranceAc;
    ///The lower limit that the processor may be throttled down to prior to turning on system fans in response to a
    ///thermal event while the system is operating on battery power, expressed as a percentage.
    ubyte               FanThrottleToleranceDc;
    ///The processor throttle level to be imposed by the system while the computer is running on AC (utility) power,
    ///expressed as a percentage.
    ubyte               ForcedThrottleAc;
    ///The processor throttle level to be imposed by the system while the computer is running on battery power,
    ///expressed as a percentage.
    ubyte               ForcedThrottleDc;
}

///Contains power policy settings that are unique to each power scheme.
struct POWER_POLICY
{
    ///A USER_POWER_POLICY structure that defines user power policy settings.
    USER_POWER_POLICY    user;
    ///A MACHINE_POWER_POLICY structure that defines computer power policy settings.
    MACHINE_POWER_POLICY mach;
}

///Contains parameters used when registering for a power notification.
struct DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS
{
    ///Indicates the callback function that will be called when the application receives the notification.
    PDEVICE_NOTIFY_CALLBACK_ROUTINE Callback;
    ///The context of the application registering for the notification.
    void* Context;
}

///Contains a thermal event.
struct THERMAL_EVENT
{
    ///The current structure version level, <b>THERMAL_EVENT_VERSION</b>.
    uint  Version;
    ///The size of the structure.
    uint  Size;
    ///One of the thermal event values from Ntpoapi.h: <b>THERMAL_EVENT_SHUTDOWN</b>, <b>THERMAL_EVENT_HIBERNATE</b>, or
    ///<b>THERMAL_EVENT_UNSPECIFIED</b>.
    uint  Type;
    ///The temperature, in tenths of a degree Kelvin, that the sensor was at after crossing the trip point (or zero if
    ///unknown).
    uint  Temperature;
    ///The temperature, in tenths of a degree Kelvin, of the trip point (or zero if unknown).
    uint  TripPointTemperature;
    ///A pointer to a NULL-terminated, wide-character string that identifies the sensor whose threshold was crossed.
    PWSTR Initiator;
}

struct BATTERY_QUERY_INFORMATION
{
    uint BatteryTag;
    BATTERY_QUERY_INFORMATION_LEVEL InformationLevel;
    uint AtRate;
}

struct BATTERY_INFORMATION
{
    uint     Capabilities;
    ubyte    Technology;
    ubyte[3] Reserved;
    ubyte[4] Chemistry;
    uint     DesignedCapacity;
    uint     FullChargedCapacity;
    uint     DefaultAlert1;
    uint     DefaultAlert2;
    uint     CriticalBias;
    uint     CycleCount;
}

struct BATTERY_CHARGING_SOURCE
{
    BATTERY_CHARGING_SOURCE_TYPE Type;
    uint MaxCurrent;
}

struct BATTERY_CHARGING_SOURCE_INFORMATION
{
    BATTERY_CHARGING_SOURCE_TYPE Type;
    ubyte SourceOnline;
}

struct BATTERY_SET_INFORMATION
{
    uint     BatteryTag;
    BATTERY_SET_INFORMATION_LEVEL InformationLevel;
    ubyte[1] Buffer;
}

struct BATTERY_CHARGER_STATUS
{
    BATTERY_CHARGING_SOURCE_TYPE Type;
    uint[1] VaData;
}

struct BATTERY_USB_CHARGER_STATUS
{
    BATTERY_CHARGING_SOURCE_TYPE Type;
    uint             Reserved;
    uint             Flags;
    uint             MaxCurrent;
    uint             Voltage;
    USB_CHARGER_PORT PortType;
    ulong            PortId;
    void*            PowerSourceInformation;
    GUID             OemCharger;
}

struct BATTERY_WAIT_STATUS
{
    uint BatteryTag;
    uint Timeout;
    uint PowerState;
    uint LowCapacity;
    uint HighCapacity;
}

struct BATTERY_STATUS
{
    uint PowerState;
    uint Capacity;
    uint Voltage;
    int  Rate;
}

struct BATTERY_MANUFACTURE_DATE
{
    ubyte  Day;
    ubyte  Month;
    ushort Year;
}

struct THERMAL_INFORMATION
{
    uint     ThermalStamp;
    uint     ThermalConstant1;
    uint     ThermalConstant2;
    size_t   Processors;
    uint     SamplingPeriod;
    uint     CurrentTemperature;
    uint     PassiveTripPoint;
    uint     CriticalTripPoint;
    ubyte    ActiveTripPointCount;
    uint[10] ActiveTripPoint;
}

struct THERMAL_WAIT_READ
{
    uint Timeout;
    uint LowTemperature;
    uint HighTemperature;
}

struct THERMAL_POLICY
{
    uint  Version;
    ubyte WaitForUpdate;
    ubyte Hibernate;
    ubyte Critical;
    ubyte ThermalStandby;
    uint  ActivationReasons;
    uint  PassiveLimit;
    uint  ActiveLevel;
    ubyte OverThrottled;
}

struct PROCESSOR_OBJECT_INFO
{
    uint  PhysicalID;
    uint  PBlkAddress;
    ubyte PBlkLength;
}

struct PROCESSOR_OBJECT_INFO_EX
{
    uint  PhysicalID;
    uint  PBlkAddress;
    ubyte PBlkLength;
    uint  InitialApicId;
}

struct WAKE_ALARM_INFORMATION
{
    uint TimerIdentifier;
    uint Timeout;
}

struct ACPI_REAL_TIME
{
    ushort   Year;
    ubyte    Month;
    ubyte    Day;
    ubyte    Hour;
    ubyte    Minute;
    ubyte    Second;
    ubyte    Valid;
    ushort   Milliseconds;
    short    TimeZone;
    ubyte    DayLight;
    ubyte[3] Reserved1;
}

struct INDIRECT_DISPLAY_INFO
{
    LUID DisplayAdapterLuid;
    uint Flags;
    uint NumMonitors;
    uint DisplayAdapterTargetBase;
}

struct VIDEO_VDM
{
    HANDLE ProcessHandle;
}

struct VIDEO_REGISTER_VDM
{
    uint MinimumStateSize;
}

struct VIDEO_MONITOR_DESCRIPTOR
{
    uint     DescriptorSize;
    ubyte[1] Descriptor;
}

struct DXGK_WIN32K_PARAM_DATA
{
    void* PathsArray;
    void* ModesArray;
    uint  NumPathArrayElements;
    uint  NumModeArrayElements;
    uint  SDCFlags;
}

struct VIDEO_WIN32K_CALLBACKS_PARAMS
{
    VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE CalloutType;
    void*  PhysDisp;
    size_t Param;
    int    Status;
    ubyte  LockUserSession;
    ubyte  IsPostDevice;
    ubyte  SurpriseRemoval;
    ubyte  WaitForQueueReady;
}

struct VIDEO_WIN32K_CALLBACKS
{
    void*  PhysDisp;
    PVIDEO_WIN32K_CALLOUT Callout;
    uint   bACPI;
    HANDLE pPhysDeviceObject;
    uint   DualviewFlags;
}

struct VIDEO_DEVICE_SESSION_STATUS
{
    uint bEnable;
    uint bSuccess;
}

struct VIDEO_HARDWARE_STATE_HEADER
{
    uint      Length;
    ubyte[48] PortValue;
    uint      AttribIndexDataState;
    uint      BasicSequencerOffset;
    uint      BasicCrtContOffset;
    uint      BasicGraphContOffset;
    uint      BasicAttribContOffset;
    uint      BasicDacOffset;
    uint      BasicLatchesOffset;
    uint      ExtendedSequencerOffset;
    uint      ExtendedCrtContOffset;
    uint      ExtendedGraphContOffset;
    uint      ExtendedAttribContOffset;
    uint      ExtendedDacOffset;
    uint      ExtendedValidatorStateOffset;
    uint      ExtendedMiscDataOffset;
    uint      PlaneLength;
    uint      Plane1Offset;
    uint      Plane2Offset;
    uint      Plane3Offset;
    uint      Plane4Offset;
    uint      VGAStateFlags;
    uint      DIBOffset;
    uint      DIBBitsPerPixel;
    uint      DIBXResolution;
    uint      DIBYResolution;
    uint      DIBXlatOffset;
    uint      DIBXlatLength;
    uint      VesaInfoOffset;
    void*     FrameBufferData;
}

struct VIDEO_HARDWARE_STATE
{
    VIDEO_HARDWARE_STATE_HEADER* StateHeader;
    uint StateLength;
}

struct VIDEO_NUM_MODES
{
    uint NumModes;
    uint ModeInformationLength;
}

struct VIDEO_MODE
{
    uint RequestedMode;
}

struct VIDEO_MODE_INFORMATION
{
    uint Length;
    uint ModeIndex;
    uint VisScreenWidth;
    uint VisScreenHeight;
    uint ScreenStride;
    uint NumberOfPlanes;
    uint BitsPerPlane;
    uint Frequency;
    uint XMillimeter;
    uint YMillimeter;
    uint NumberRedBits;
    uint NumberGreenBits;
    uint NumberBlueBits;
    uint RedMask;
    uint GreenMask;
    uint BlueMask;
    uint AttributeFlags;
    uint VideoMemoryBitmapWidth;
    uint VideoMemoryBitmapHeight;
    uint DriverSpecificAttributeFlags;
}

struct VIDEO_LOAD_FONT_INFORMATION
{
    ushort   WidthInPixels;
    ushort   HeightInPixels;
    uint     FontSize;
    ubyte[1] Font;
}

struct VIDEO_PALETTE_DATA
{
    ushort    NumEntries;
    ushort    FirstEntry;
    ushort[1] Colors;
}

struct VIDEO_CLUTDATA
{
    ubyte Red;
    ubyte Green;
    ubyte Blue;
    ubyte Unused;
}

struct VIDEO_CLUT
{
    ushort NumEntries;
    ushort FirstEntry;
union
    {
        VIDEO_CLUTDATA RgbArray;
        uint           RgbLong;
    }
}

struct VIDEO_CURSOR_POSITION
{
    short Column;
    short Row;
}

struct VIDEO_CURSOR_ATTRIBUTES
{
    ushort Width;
    ushort Height;
    short  Column;
    short  Row;
    ubyte  Rate;
    ubyte  Enable;
}

struct VIDEO_POINTER_POSITION
{
    short Column;
    short Row;
}

struct VIDEO_POINTER_ATTRIBUTES
{
    uint     Flags;
    uint     Width;
    uint     Height;
    uint     WidthInBytes;
    uint     Enable;
    short    Column;
    short    Row;
    ubyte[1] Pixels;
}

struct VIDEO_POINTER_CAPABILITIES
{
    uint Flags;
    uint MaxWidth;
    uint MaxHeight;
    uint HWPtrBitmapStart;
    uint HWPtrBitmapEnd;
}

struct VIDEO_BANK_SELECT
{
    uint Length;
    uint Size;
    uint BankingFlags;
    uint BankingType;
    uint PlanarHCBankingType;
    uint BitmapWidthInBytes;
    uint BitmapSize;
    uint Granularity;
    uint PlanarHCGranularity;
    uint CodeOffset;
    uint PlanarHCBankCodeOffset;
    uint PlanarHCEnableCodeOffset;
    uint PlanarHCDisableCodeOffset;
}

struct VIDEO_MEMORY
{
    void* RequestedVirtualAddress;
}

struct VIDEO_SHARE_MEMORY
{
    HANDLE ProcessHandle;
    uint   ViewOffset;
    uint   ViewSize;
    void*  RequestedVirtualAddress;
}

struct VIDEO_SHARE_MEMORY_INFORMATION
{
    uint  SharedViewOffset;
    uint  SharedViewSize;
    void* VirtualAddress;
}

struct VIDEO_MEMORY_INFORMATION
{
    void* VideoRamBase;
    uint  VideoRamLength;
    void* FrameBufferBase;
    uint  FrameBufferLength;
}

struct VIDEO_PUBLIC_ACCESS_RANGES
{
    uint  InIoSpace;
    uint  MappedInIoSpace;
    void* VirtualAddress;
}

struct VIDEO_COLOR_CAPABILITIES
{
    uint Length;
    uint AttributeFlags;
    int  RedPhosphoreDecay;
    int  GreenPhosphoreDecay;
    int  BluePhosphoreDecay;
    int  WhiteChromaticity_x;
    int  WhiteChromaticity_y;
    int  WhiteChromaticity_Y;
    int  RedChromaticity_x;
    int  RedChromaticity_y;
    int  GreenChromaticity_x;
    int  GreenChromaticity_y;
    int  BlueChromaticity_x;
    int  BlueChromaticity_y;
    int  WhiteGamma;
    int  RedGamma;
    int  GreenGamma;
    int  BlueGamma;
}

struct VIDEO_POWER_MANAGEMENT
{
    uint Length;
    uint DPMSVersion;
    uint PowerState;
}

struct VIDEO_COLOR_LUT_DATA
{
    uint     Length;
    uint     LutDataFormat;
    ubyte[1] LutData;
}

struct VIDEO_LUT_RGB256WORDS
{
    ushort[256] Red;
    ushort[256] Green;
    ushort[256] Blue;
}

struct BANK_POSITION
{
    uint ReadBankPosition;
    uint WriteBankPosition;
}

struct DISPLAY_BRIGHTNESS
{
    ubyte ucDisplayPolicy;
    ubyte ucACBrightness;
    ubyte ucDCBrightness;
}

struct VIDEO_BRIGHTNESS_POLICY
{
    ubyte DefaultToBiosPolicy;
    ubyte LevelCount;
struct
    {
        ubyte BatteryLevel;
        ubyte Brightness;
    }
}

struct FSCNTL_SCREEN_INFO
{
    COORD Position;
    COORD ScreenSize;
    uint  nNumberOfChars;
}

struct FONT_IMAGE_INFO
{
    COORD  FontSize;
    ubyte* ImageBits;
}

struct CHAR_IMAGE_INFO
{
    CHAR_INFO       CharInfo;
    FONT_IMAGE_INFO FontImageInfo;
}

struct VGA_CHAR
{
    byte Char;
    byte Attributes;
}

struct FSVIDEO_COPY_FRAME_BUFFER
{
    FSCNTL_SCREEN_INFO SrcScreen;
    FSCNTL_SCREEN_INFO DestScreen;
}

struct FSVIDEO_WRITE_TO_FRAME_BUFFER
{
    CHAR_IMAGE_INFO*   SrcBuffer;
    FSCNTL_SCREEN_INFO DestScreen;
}

struct FSVIDEO_REVERSE_MOUSE_POINTER
{
    FSCNTL_SCREEN_INFO Screen;
    uint               dwType;
}

struct FSVIDEO_MODE_INFORMATION
{
    VIDEO_MODE_INFORMATION VideoMode;
    VIDEO_MEMORY_INFORMATION VideoMemory;
}

struct FSVIDEO_SCREEN_INFORMATION
{
    COORD ScreenSize;
    COORD FontSize;
}

struct FSVIDEO_CURSOR_POSITION
{
    VIDEO_CURSOR_POSITION Coord;
    uint dwType;
}

struct ENG_EVENT
{
    void* pKEvent;
    uint  fFlags;
}

struct VIDEO_PERFORMANCE_COUNTER
{
    ulong[10] NbOfAllocationEvicted;
    ulong[10] NbOfAllocationMarked;
    ulong[10] NbOfAllocationRestored;
    ulong[10] KBytesEvicted;
    ulong[10] KBytesMarked;
    ulong[10] KBytesRestored;
    ulong     NbProcessCommited;
    ulong     NbAllocationCommited;
    ulong     NbAllocationMarked;
    ulong     KBytesAllocated;
    ulong     KBytesAvailable;
    ulong     KBytesCurMarked;
    ulong     Reference;
    ulong     Unreference;
    ulong     TrueReference;
    ulong     NbOfPageIn;
    ulong     KBytesPageIn;
    ulong     NbOfPageOut;
    ulong     KBytesPageOut;
    ulong     NbOfRotateOut;
    ulong     KBytesRotateOut;
}

struct VIDEO_QUERY_PERFORMANCE_COUNTER
{
    uint BufferSize;
    VIDEO_PERFORMANCE_COUNTER* Buffer;
}

struct PANEL_QUERY_BRIGHTNESS_CAPS
{
    BRIGHTNESS_INTERFACE_VERSION Version;
union
    {
struct
        {
            uint _bitfield121;
        }
        uint Value;
    }
}

struct BRIGHTNESS_LEVEL
{
    ubyte      Count;
    ubyte[103] Level;
}

struct BRIGHTNESS_NIT_RANGE
{
    uint MinLevelInMillinit;
    uint MaxLevelInMillinit;
    uint StepSizeInMillinit;
}

struct BRIGHTNESS_NIT_RANGES
{
    uint NormalRangeCount;
    uint RangeCount;
    uint PreferredMaximumBrightness;
    BRIGHTNESS_NIT_RANGE[16] SupportedRanges;
}

struct PANEL_QUERY_BRIGHTNESS_RANGES
{
    BRIGHTNESS_INTERFACE_VERSION Version;
union
    {
        BRIGHTNESS_LEVEL BrightnessLevel;
        BRIGHTNESS_NIT_RANGES NitRanges;
    }
}

struct PANEL_GET_BRIGHTNESS
{
    BRIGHTNESS_INTERFACE_VERSION Version;
union
    {
        ubyte Level;
struct
        {
            uint CurrentInMillinits;
            uint TargetInMillinits;
        }
    }
}

struct CHROMATICITY_COORDINATE
{
    float x;
    float y;
}

struct PANEL_BRIGHTNESS_SENSOR_DATA
{
union
    {
struct
        {
            uint _bitfield122;
        }
        uint Value;
    }
    float AlsReading;
    CHROMATICITY_COORDINATE ChromaticityCoordinate;
    float ColorTemperature;
}

struct PANEL_SET_BRIGHTNESS
{
    BRIGHTNESS_INTERFACE_VERSION Version;
union
    {
        ubyte Level;
struct
        {
            uint Millinits;
            uint TransitionTimeInMs;
            PANEL_BRIGHTNESS_SENSOR_DATA SensorData;
        }
    }
}

struct PANEL_SET_BRIGHTNESS_STATE
{
union
    {
struct
        {
            uint _bitfield123;
        }
        uint Value;
    }
}

struct PANEL_SET_BACKLIGHT_OPTIMIZATION
{
    BACKLIGHT_OPTIMIZATION_LEVEL Level;
}

struct BACKLIGHT_REDUCTION_GAMMA_RAMP
{
    ushort[256] R;
    ushort[256] G;
    ushort[256] B;
}

struct PANEL_GET_BACKLIGHT_REDUCTION
{
    ushort BacklightUsersetting;
    ushort BacklightEffective;
    BACKLIGHT_REDUCTION_GAMMA_RAMP GammaRamp;
}

struct COLORSPACE_TRANSFORM_DATA_CAP
{
    COLORSPACE_TRANSFORM_DATA_TYPE DataType;
union
    {
struct
        {
            uint _bitfield124;
        }
struct
        {
            uint _bitfield125;
        }
        uint Value;
    }
    float NumericRangeMin;
    float NumericRangeMax;
}

struct COLORSPACE_TRANSFORM_1DLUT_CAP
{
    uint NumberOfLUTEntries;
    COLORSPACE_TRANSFORM_DATA_CAP DataCap;
}

struct COLORSPACE_TRANSFORM_MATRIX_CAP
{
union
    {
struct
        {
            uint _bitfield126;
        }
        uint Value;
    }
    COLORSPACE_TRANSFORM_DATA_CAP DataCap;
}

struct COLORSPACE_TRANSFORM_TARGET_CAPS
{
    COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION Version;
    COLORSPACE_TRANSFORM_1DLUT_CAP LookupTable1DDegammaCap;
    COLORSPACE_TRANSFORM_MATRIX_CAP ColorMatrix3x3Cap;
    COLORSPACE_TRANSFORM_1DLUT_CAP LookupTable1DRegammaCap;
}

struct GAMMA_RAMP_RGB256x3x16
{
    ushort[256] Red;
    ushort[256] Green;
    ushort[256] Blue;
}

struct GAMMA_RAMP_RGB
{
    float Red;
    float Green;
    float Blue;
}

struct GAMMA_RAMP_DXGI_1
{
    GAMMA_RAMP_RGB       Scale;
    GAMMA_RAMP_RGB       Offset;
    GAMMA_RAMP_RGB[1025] GammaCurve;
}

struct COLORSPACE_TRANSFORM_3x4
{
    float[12]            ColorMatrix3x4;
    float                ScalarMultiplier;
    GAMMA_RAMP_RGB[4096] LookupTable1D;
}

struct OUTPUT_WIRE_FORMAT
{
    OUTPUT_COLOR_ENCODING ColorEncoding;
    uint BitsPerPixel;
}

struct COLORSPACE_TRANSFORM_MATRIX_V2
{
    COLORSPACE_TRANSFORM_STAGE_CONTROL StageControlLookupTable1DDegamma;
    GAMMA_RAMP_RGB[4096] LookupTable1DDegamma;
    COLORSPACE_TRANSFORM_STAGE_CONTROL StageControlColorMatrix3x3;
    float[9]             ColorMatrix3x3;
    COLORSPACE_TRANSFORM_STAGE_CONTROL StageControlLookupTable1DRegamma;
    GAMMA_RAMP_RGB[4096] LookupTable1DRegamma;
}

struct COLORSPACE_TRANSFORM
{
    COLORSPACE_TRANSFORM_TYPE Type;
union Data
    {
        GAMMA_RAMP_RGB256x3x16 Rgb256x3x16;
        GAMMA_RAMP_DXGI_1 Dxgi1;
        COLORSPACE_TRANSFORM_3x4 T3x4;
        COLORSPACE_TRANSFORM_MATRIX_V2 MatrixV2;
    }
}

struct COLORSPACE_TRANSFORM_SET_INPUT
{
    OUTPUT_WIRE_COLOR_SPACE_TYPE OutputWireColorSpaceExpected;
    OUTPUT_WIRE_FORMAT   OutputWireFormatExpected;
    COLORSPACE_TRANSFORM ColorSpaceTransform;
}

struct SET_ACTIVE_COLOR_PROFILE_NAME
{
    ushort[1] ColorProfileName;
}

struct MIPI_DSI_CAPS
{
    ubyte  DSITypeMajor;
    ubyte  DSITypeMinor;
    ubyte  SpecVersionMajor;
    ubyte  SpecVersionMinor;
    ubyte  SpecVersionPatch;
    ushort TargetMaximumReturnPacketSize;
    ubyte  ResultCodeFlags;
    ubyte  ResultCodeStatus;
    ubyte  Revision;
    ubyte  Level;
    ubyte  DeviceClassHi;
    ubyte  DeviceClassLo;
    ubyte  ManufacturerHi;
    ubyte  ManufacturerLo;
    ubyte  ProductHi;
    ubyte  ProductLo;
    ubyte  LengthHi;
    ubyte  LengthLo;
}

struct MIPI_DSI_PACKET
{
union
    {
        ubyte DataId;
struct
        {
            ubyte _bitfield127;
        }
    }
union
    {
struct
        {
            ubyte Data0;
            ubyte Data1;
        }
        ushort LongWriteWordCount;
    }
    ubyte    EccFiller;
    ubyte[8] Payload;
}

struct MIPI_DSI_TRANSMISSION
{
    uint               TotalBufferSize;
    ubyte              PacketCount;
    ubyte              FailedPacket;
struct
    {
        ushort _bitfield128;
    }
    ushort             ReadWordCount;
    ushort             FinalCommandExtraPayload;
    ushort             MipiErrors;
    ushort             HostErrors;
    MIPI_DSI_PACKET[1] Packets;
}

struct MIPI_DSI_RESET
{
    uint Flags;
union
    {
struct
        {
            uint _bitfield129;
        }
        uint Results;
    }
}

///Represents a logical processor in a processor group.
struct PROCESSOR_NUMBER
{
    ///The processor group to which the logical processor is assigned.
    ushort Group;
    ///The number of the logical processor relative to the group.
    ubyte  Number;
    ///This parameter is reserved.
    ubyte  Reserved;
}

///Represents a processor group-specific affinity, such as the affinity of a thread.
struct GROUP_AFFINITY
{
    ///A bitmap that specifies the affinity for zero or more processors within the specified group.
    size_t    Mask;
    ///The processor group number.
    ushort    Group;
    ///This member is reserved.
    ushort[3] Reserved;
}

///Sent with a power setting event and contains data about the specific change. For more information, see <a
///href="/windows/desktop/Power/registering-for-power-events">Registering for Power Events</a> and Power Setting GUIDs.
struct POWERBROADCAST_SETTING
{
    ///Indicates the power setting for which this notification is being delivered. For more info, see Power Setting
    ///GUIDs.
    GUID     PowerSetting;
    ///The size in bytes of the data in the <i>Data</i> member.
    uint     DataLength;
    ///The new value of the power setting. The type and possible values for this member depend on <i>PowerSettng.</i>
    ubyte[1] Data;
}

struct BOOL
{
    int Value;
}

@RAIIFree!DeleteBoundaryDescriptor
struct BoundaryDescriptorHandle
{
    ptrdiff_t Value;
}

@RAIIFree!CloseHandle
struct HANDLE
{
    ptrdiff_t Value;
}

@RAIIFree!FreeLibrary
struct HINSTANCE
{
    ptrdiff_t Value;
}

struct HRSRC
{
    ptrdiff_t Value;
}

struct HSURF
{
    ptrdiff_t Value;
}

struct LRESULT
{
    int Value;
}

struct LSTATUS
{
    int Value;
}

@RAIIFree!ClosePrivateNamespace
struct NamespaceHandle
{
    ptrdiff_t Value;
}

struct NTSTATUS
{
    int Value;
}

struct PSTR
{
    ubyte* Value;
}

@RAIIFree!CloseThreadpool
struct PTP_POOL
{
    ptrdiff_t Value;
}

struct PWSTR
{
    wchar* Value;
}

@RAIIFree!DeleteTimerQueueEx
struct TimerQueueHandle
{
    ptrdiff_t Value;
}

struct FLOAT128
{
    long LowPart;
    long HighPart;
}

///Represents a 64-bit signed integer value. <div class="alert"><b>Note</b> Your C compiler may support 64-bit integers
///natively. For example, Microsoft Visual C++ supports the __int64 sized integer type. For more information, see the
///documentation included with your C compiler.</div><div> </div>
union LARGE_INTEGER
{
struct
    {
        uint LowPart;
        int  HighPart;
    }
struct u
    {
        uint LowPart;
        int  HighPart;
    }
    ///A signed 64-bit integer.
    long QuadPart;
}

///Represents a 64-bit unsigned integer value. <div class="alert"><b>Note</b> Your C compiler may support 64-bit
///integers natively. For example, Microsoft Visual C++ supports the __int64 sized integer type. For more information,
///see the documentation included with your C compiler.</div><div> </div>
union ULARGE_INTEGER
{
struct
    {
        uint LowPart;
        uint HighPart;
    }
struct u
    {
        uint LowPart;
        uint HighPart;
    }
    ///An unsigned 64-bit integer.
    ulong QuadPart;
}

struct M128A
{
    ulong Low;
    long  High;
}

struct XSAVE_FORMAT
{
    ushort     ControlWord;
    ushort     StatusWord;
    ubyte      TagWord;
    ubyte      Reserved1;
    ushort     ErrorOpcode;
    uint       ErrorOffset;
    ushort     ErrorSelector;
    ushort     Reserved2;
    uint       DataOffset;
    ushort     DataSelector;
    ushort     Reserved3;
    uint       MxCsr;
    uint       MxCsr_Mask;
    M128A[8]   FloatRegisters;
    M128A[8]   XmmRegisters;
    ubyte[224] Reserved4;
}

struct XSAVE_CET_U_FORMAT
{
    ulong Ia32CetUMsr;
    ulong Ia32Pl3SspMsr;
}

struct XSAVE_AREA_HEADER
{
    ulong    Mask;
    ulong    CompactionMask;
    ulong[6] Reserved2;
}

struct XSAVE_AREA
{
    XSAVE_FORMAT      LegacyState;
    XSAVE_AREA_HEADER Header;
}

struct XSTATE_CONTEXT
{
    ulong       Mask;
    uint        Length;
    uint        Reserved1;
    XSAVE_AREA* Area;
    uint        Reserved2;
    void*       Buffer;
    uint        Reserved3;
}

struct SCOPE_TABLE_AMD64
{
    uint Count;
struct
    {
        uint BeginAddress;
        uint EndAddress;
        uint HandlerAddress;
        uint JumpTarget;
    }
}

struct SCOPE_TABLE_ARM
{
    uint Count;
struct
    {
        uint BeginAddress;
        uint EndAddress;
        uint HandlerAddress;
        uint JumpTarget;
    }
}

struct SCOPE_TABLE_ARM64
{
    uint Count;
struct
    {
        uint BeginAddress;
        uint EndAddress;
        uint HandlerAddress;
        uint JumpTarget;
    }
}

struct KNONVOLATILE_CONTEXT_POINTERS_ARM64
{
    ulong* X19;
    ulong* X20;
    ulong* X21;
    ulong* X22;
    ulong* X23;
    ulong* X24;
    ulong* X25;
    ulong* X26;
    ulong* X27;
    ulong* X28;
    ulong* Fp;
    ulong* Lr;
    ulong* D8;
    ulong* D9;
    ulong* D10;
    ulong* D11;
    ulong* D12;
    ulong* D13;
    ulong* D14;
    ulong* D15;
}

struct FLOATING_SAVE_AREA
{
    uint      ControlWord;
    uint      StatusWord;
    uint      TagWord;
    uint      ErrorOffset;
    uint      ErrorSelector;
    uint      DataOffset;
    uint      DataSelector;
    ubyte[80] RegisterArea;
    uint      Spare0;
}

struct KNONVOLATILE_CONTEXT_POINTERS
{
    uint Dummy;
}

struct WOW64_DESCRIPTOR_TABLE_ENTRY
{
    uint            Selector;
    WOW64_LDT_ENTRY Descriptor;
}

struct EXCEPTION_RECORD32
{
    uint     ExceptionCode;
    uint     ExceptionFlags;
    uint     ExceptionRecord;
    uint     ExceptionAddress;
    uint     NumberParameters;
    uint[15] ExceptionInformation;
}

union SE_SID
{
    SID       Sid;
    ubyte[68] Buffer;
}

struct SYSTEM_PROCESS_TRUST_LABEL_ACE
{
    ACE_HEADER Header;
    uint       Mask;
    uint       SidStart;
}

struct SYSTEM_ACCESS_FILTER_ACE
{
    ACE_HEADER Header;
    uint       Mask;
    uint       SidStart;
}

struct SECURITY_DESCRIPTOR_RELATIVE
{
    ubyte  Revision;
    ubyte  Sbz1;
    ushort Control;
    uint   Owner;
    uint   Group;
    uint   Sacl;
    uint   Dacl;
}

struct SECURITY_OBJECT_AI_PARAMS
{
    uint Size;
    uint ConstraintMask;
}

struct ACCESS_REASONS
{
    uint[32] Data;
}

struct SE_SECURITY_DESCRIPTOR
{
    uint  Size;
    uint  Flags;
    void* SecurityDescriptor;
}

struct SE_ACCESS_REQUEST
{
    uint              Size;
    SE_SECURITY_DESCRIPTOR* SeSecurityDescriptor;
    uint              DesiredAccess;
    uint              PreviouslyGrantedAccess;
    void*             PrincipalSelfSid;
    GENERIC_MAPPING*  GenericMapping;
    uint              ObjectTypeListCount;
    OBJECT_TYPE_LIST* ObjectTypeList;
}

struct SE_ACCESS_REPLY
{
    uint            Size;
    uint            ResultListCount;
    uint*           GrantedAccess;
    uint*           AccessStatus;
    ACCESS_REASONS* AccessReason;
    PRIVILEGE_SET** Privileges;
}

struct SE_TOKEN_USER
{
union
    {
        TOKEN_USER         TokenUser;
        SID_AND_ATTRIBUTES User;
    }
union
    {
        SID       Sid;
        ubyte[68] Buffer;
    }
}

struct TOKEN_SID_INFORMATION
{
    void* Sid;
}

struct TOKEN_BNO_ISOLATION_INFORMATION
{
    PWSTR IsolationPrefix;
    ubyte IsolationEnabled;
}

struct SE_IMPERSONATION_STATE
{
    void* Token;
    ubyte CopyOnOpen;
    ubyte EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
}

struct JOB_SET_ARRAY
{
    HANDLE JobHandle;
    uint   MemberLevel;
    uint   Flags;
}

struct EXCEPTION_REGISTRATION_RECORD
{
    EXCEPTION_REGISTRATION_RECORD* Next;
    EXCEPTION_ROUTINE Handler;
}

struct NT_TIB
{
    EXCEPTION_REGISTRATION_RECORD* ExceptionList;
    void*   StackBase;
    void*   StackLimit;
    void*   SubSystemTib;
union
    {
        void* FiberData;
        uint  Version;
    }
    void*   ArbitraryUserPointer;
    NT_TIB* Self;
}

struct NT_TIB32
{
    uint ExceptionList;
    uint StackBase;
    uint StackLimit;
    uint SubSystemTib;
union
    {
        uint FiberData;
        uint Version;
    }
    uint ArbitraryUserPointer;
    uint Self;
}

struct NT_TIB64
{
    ulong ExceptionList;
    ulong StackBase;
    ulong StackLimit;
    ulong SubSystemTib;
union
    {
        ulong FiberData;
        uint  Version;
    }
    ulong ArbitraryUserPointer;
    ulong Self;
}

///Specifies attributes for a user-mode scheduling (UMS) worker thread. This structure is used with the
///UpdateProcThreadAttribute function.
struct UMS_CREATE_THREAD_ATTRIBUTES
{
    ///The UMS version for which the application was built. This parameter must be <b>UMS_VERSION</b>.
    uint  UmsVersion;
    ///A pointer to a UMS thread context for the worker thread to be created. This pointer is provided by the
    ///CreateUmsThreadContext function.
    void* UmsContext;
    void* UmsCompletionList;
}

struct WOW64_ARCHITECTURE_INFORMATION
{
    uint _bitfield130;
}

///Contains dynamic exception handling continuation targets. The SetProcessDynamicEHContinuationTargets function uses
///this structure.
struct PROCESS_DYNAMIC_EH_CONTINUATION_TARGET
{
    ///The address of a dynamic exception handling continuation target.
    size_t TargetAddress;
    ///Flags that apply to the dynamic exception handling continuation target in <i>TargetAddress</i>. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DYNAMIC_EH_CONTINUATION_TARGET_ADD"></a><a
    ///id="dynamic_eh_continuation_target_add"></a><dl> <dt><b>DYNAMIC_EH_CONTINUATION_TARGET_ADD</b></dt>
    ///<dt>0x00000001UL</dt> </dl> </td> <td width="60%"> Dynamic exception handling continuation target should be
    ///added. If this flag is not set, the target is removed. This is an input flag. </td> </tr> <tr> <td width="40%"><a
    ///id="DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED"></a><a id="dynamic_eh_continuation_target_processed"></a><dl>
    ///<dt><b>DYNAMIC_EH_CONTINUATION_TARGET_PROCESSED</b></dt> <dt>0x00000002UL</dt> </dl> </td> <td width="60%">
    ///Dynamic exception handling continuation target has been successfully processed (either added or removed). This is
    ///an output flag used to report which targets were successfully processed when processing an array of multiple
    ///targets. </td> </tr> </table>
    size_t Flags;
}

struct PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION
{
    ushort NumberOfTargets;
    ushort Reserved;
    uint   Reserved2;
    PROCESS_DYNAMIC_EH_CONTINUATION_TARGET* Targets;
}

union RATE_QUOTA_LIMIT
{
    uint RateData;
struct
    {
        uint _bitfield131;
    }
}

struct QUOTA_LIMITS_EX
{
    size_t           PagedPoolLimit;
    size_t           NonPagedPoolLimit;
    size_t           MinimumWorkingSetSize;
    size_t           MaximumWorkingSetSize;
    size_t           PagefileLimit;
    LARGE_INTEGER    TimeLimit;
    size_t           WorkingSetLimit;
    size_t           Reserved2;
    size_t           Reserved3;
    size_t           Reserved4;
    uint             Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
}

///Contains I/O accounting information for a process or a job object. For a job object, the counters include all
///operations performed by all processes that have ever been associated with the job, in addition to all processes
///currently associated with the job.
struct IO_COUNTERS
{
    ///The number of read operations performed.
    ulong ReadOperationCount;
    ///The number of write operations performed.
    ulong WriteOperationCount;
    ///The number of I/O operations performed, other than read and write operations.
    ulong OtherOperationCount;
    ///The number of bytes read.
    ulong ReadTransferCount;
    ///The number of bytes written.
    ulong WriteTransferCount;
    ///The number of bytes transferred during operations other than read and write operations.
    ulong OtherTransferCount;
}

///Contains process mitigation policy settings for Address Space Randomization Layout (ASLR). The
///GetProcessMitigationPolicy and SetProcessMitigationPolicy functions use this structure.
struct PROCESS_MITIGATION_ASLR_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield132;
        }
    }
}

///Contains process mitigation policy settings for data execution prevention (DEP). The GetProcessMitigationPolicy and
///SetProcessMitigationPolicy functions use this structure.
struct PROCESS_MITIGATION_DEP_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield133;
        }
    }
    ///DEP is permanently enabled and cannot be disabled if this field is set to TRUE.
    ubyte Permanent;
}

///Used to impose new behavior on handle references that are not valid.
struct PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield134;
        }
    }
}

///Used to impose restrictions on what system calls can be invoked by a process.
struct PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield135;
        }
    }
}

///Contains process mitigation policy settings for legacy extension point DLLs. The GetProcessMitigationPolicy and
///SetProcessMitigationPolicy functions use this structure.
struct PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield136;
        }
    }
}

///Contains process mitigation policy settings for restricting dynamic code generation and modification.
struct PROCESS_MITIGATION_DYNAMIC_CODE_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield137;
        }
    }
}

///Contains process mitigation policy settings for Control Flow Guard (CFG). The GetProcessMitigationPolicy and
///SetProcessMitigationPolicy functions use this structure.
struct PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield138;
        }
    }
}

///Contains process mitigation policy settings for the loading of images depending on the signatures for the image.
struct PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield139;
        }
    }
}

///Contains process mitigation policy settings for the loading of non-system fonts.
struct PROCESS_MITIGATION_FONT_DISABLE_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield140;
        }
    }
}

///Contains process mitigation policy settings for the loading of images from a remote device.
struct PROCESS_MITIGATION_IMAGE_LOAD_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield141;
        }
    }
}

struct PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield142;
        }
    }
}

struct PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield143;
        }
    }
}

struct PROCESS_MITIGATION_CHILD_PROCESS_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield144;
        }
    }
}

///This data structure provides the status of process policies that are related to the mitigation of side channels. This
///can include side channel attacks involving speculative execution and page combining.
struct PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield145;
        }
    }
}

///Contains process mitigation policy settings for user-mode Hardware-enforced Stack Protection (HSP). The
///[GetProcessMitigationPolicy](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getprocessmitigationpolicy)
///and
///[SetProcessMitigationPolicy](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy)
///functions use this structure.
struct PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY
{
union
    {
        uint Flags;
struct
        {
            uint _bitfield146;
        }
    }
}

///Contains basic accounting information for a job object.
struct JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
{
    ///The total amount of user-mode execution time for all active processes associated with the job, as well as all
    ///terminated processes no longer associated with the job, in 100-nanosecond ticks.
    LARGE_INTEGER TotalUserTime;
    ///The total amount of kernel-mode execution time for all active processes associated with the job, as well as all
    ///terminated processes no longer associated with the job, in 100-nanosecond ticks.
    LARGE_INTEGER TotalKernelTime;
    ///The total amount of user-mode execution time for all active processes associated with the job (as well as all
    ///terminated processes no longer associated with the job) since the last call that set a per-job user-mode time
    ///limit, in 100-nanosecond ticks. This member is set to 0 on creation of the job, and each time a per-job user-mode
    ///time limit is established.
    LARGE_INTEGER ThisPeriodTotalUserTime;
    ///The total amount of kernel-mode execution time for all active processes associated with the job (as well as all
    ///terminated processes no longer associated with the job) since the last call that set a per-job kernel-mode time
    ///limit, in 100-nanosecond ticks. This member is set to zero on creation of the job, and each time a per-job
    ///kernel-mode time limit is established.
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    ///The total number of page faults encountered by all active processes associated with the job, as well as all
    ///terminated processes no longer associated with the job.
    uint          TotalPageFaultCount;
    ///The total number of processes associated with the job during its lifetime, including those that have terminated.
    ///For example, when a process is associated with a job, but the association fails because of a limit violation,
    ///this value is incremented.
    uint          TotalProcesses;
    ///The total number of processes currently associated with the job. When a process is associated with a job, but the
    ///association fails because of a limit violation, this value is temporarily incremented. When the terminated
    ///process exits and all references to the process are released, this value is decremented.
    uint          ActiveProcesses;
    ///The total number of processes terminated because of a limit violation.
    uint          TotalTerminatedProcesses;
}

///Contains basic limit information for a job object.
struct JOBOBJECT_BASIC_LIMIT_INFORMATION
{
    ///If <b>LimitFlags</b> specifies <b>JOB_OBJECT_LIMIT_PROCESS_TIME</b>, this member is the per-process user-mode
    ///execution time limit, in 100-nanosecond ticks. Otherwise, this member is ignored. The system periodically checks
    ///to determine whether each process associated with the job has accumulated more user-mode time than the set limit.
    ///If it has, the process is terminated. If the job is nested, the effective limit is the most restrictive limit in
    ///the job chain.
    LARGE_INTEGER    PerProcessUserTimeLimit;
    ///If <b>LimitFlags</b> specifies <b>JOB_OBJECT_LIMIT_JOB_TIME</b>, this member is the per-job user-mode execution
    ///time limit, in 100-nanosecond ticks. Otherwise, this member is ignored. The system adds the current time of the
    ///processes associated with the job to this limit. For example, if you set this limit to 1 minute, and the job has
    ///a process that has accumulated 5 minutes of user-mode time, the limit actually enforced is 6 minutes. The system
    ///periodically checks to determine whether the sum of the user-mode execution time for all processes is greater
    ///than this end-of-job limit. If it is, the action specified in the <b>EndOfJobTimeAction</b> member of the
    ///JOBOBJECT_END_OF_JOB_TIME_INFORMATION structure is carried out. By default, all processes are terminated and the
    ///status code is set to <b>ERROR_NOT_ENOUGH_QUOTA</b>. To register for notification when this limit is exceeded
    ///without terminating processes, use the SetInformationJobObject function with the
    ///<b>JobObjectNotificationLimitInformation</b> information class.
    LARGE_INTEGER    PerJobUserTimeLimit;
    ///The limit flags that are in effect. This member is a bitfield that determines whether other structure members are
    ///used. Any combination of the following values can be specified. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_ACTIVE_PROCESS"></a><a
    ///id="job_object_limit_active_process"></a><dl> <dt><b>JOB_OBJECT_LIMIT_ACTIVE_PROCESS</b></dt> <dt>0x00000008</dt>
    ///</dl> </td> <td width="60%"> Establishes a maximum number of simultaneously active processes associated with the
    ///job. The <b>ActiveProcessLimit</b> member contains additional information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_AFFINITY"></a><a id="job_object_limit_affinity"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_AFFINITY</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Causes all processes
    ///associated with the job to use the same processor affinity. The <b>Affinity</b> member contains additional
    ///information. If the job is nested, the specified processor affinity must be a subset of the effective affinity of
    ///the parent job. If the specified affinity a superset of the affinity of the parent job, it is ignored and the
    ///affinity of the parent job is used. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_BREAKAWAY_OK"></a><a
    ///id="job_object_limit_breakaway_ok"></a><dl> <dt><b>JOB_OBJECT_LIMIT_BREAKAWAY_OK</b></dt> <dt>0x00000800</dt>
    ///</dl> </td> <td width="60%"> If any process associated with the job creates a child process using the
    ///<b>CREATE_BREAKAWAY_FROM_JOB</b> flag while this limit is in effect, the child process is not associated with the
    ///job. This limit requires use of a JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure. Its
    ///<b>BasicLimitInformation</b> member is a <b>JOBOBJECT_BASIC_LIMIT_INFORMATION</b> structure. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION"></a><a
    ///id="job_object_limit_die_on_unhandled_exception"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION</b></dt> <dt>0x00000400</dt> </dl> </td> <td width="60%">
    ///Forces a call to the SetErrorMode function with the <b>SEM_NOGPFAULTERRORBOX</b> flag for each process associated
    ///with the job. If an exception occurs and the system calls the UnhandledExceptionFilter function, the debugger
    ///will be given a chance to act. If there is no debugger, the functions returns <b>EXCEPTION_EXECUTE_HANDLER</b>.
    ///Normally, this will cause termination of the process with the exception code as the exit status. This limit
    ///requires use of a JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure. Its <b>BasicLimitInformation</b> member is a
    ///<b>JOBOBJECT_BASIC_LIMIT_INFORMATION</b> structure. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_MEMORY"></a><a id="job_object_limit_job_memory"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> Causes all processes
    ///associated with the job to limit the job-wide sum of their committed memory. When a process attempts to commit
    ///memory that would exceed the job-wide limit, it fails. If the job object is associated with a completion port, a
    ///<b>JOB_OBJECT_MSG_JOB_MEMORY_LIMIT</b> message is sent to the completion port. This limit requires use of a
    ///JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure. Its <b>BasicLimitInformation</b> member is a
    ///<b>JOBOBJECT_BASIC_LIMIT_INFORMATION</b> structure. To register for notification when this limit is exceeded
    ///while allowing processes to continue to commit memory, use the SetInformationJobObject function with the
    ///<b>JobObjectNotificationLimitInformation</b> information class. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_TIME"></a><a id="job_object_limit_job_time"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_TIME</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Establishes a
    ///user-mode execution time limit for the job. The <b>PerJobUserTimeLimit</b> member contains additional
    ///information. This flag cannot be used with <b>JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME</b>. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE"></a><a id="job_object_limit_kill_on_job_close"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Causes all
    ///processes associated with the job to terminate when the last handle to the job is closed. This limit requires use
    ///of a JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure. Its <b>BasicLimitInformation</b> member is a
    ///<b>JOBOBJECT_BASIC_LIMIT_INFORMATION</b> structure. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME"></a><a id="job_object_limit_preserve_job_time"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> Preserves any
    ///job time limits you previously set. As long as this flag is set, you can establish a per-job time limit once,
    ///then alter other limits in subsequent calls. This flag cannot be used with <b>JOB_OBJECT_LIMIT_JOB_TIME</b>.
    ///</td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_PRIORITY_CLASS"></a><a
    ///id="job_object_limit_priority_class"></a><dl> <dt><b>JOB_OBJECT_LIMIT_PRIORITY_CLASS</b></dt> <dt>0x00000020</dt>
    ///</dl> </td> <td width="60%"> Causes all processes associated with the job to use the same priority class. For
    ///more information, see Scheduling Priorities. The <b>PriorityClass</b> member contains additional information. If
    ///the job is nested, the effective priority class is the lowest priority class in the job chain. </td> </tr> <tr>
    ///<td width="40%"><a id="JOB_OBJECT_LIMIT_PROCESS_MEMORY"></a><a id="job_object_limit_process_memory"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_PROCESS_MEMORY</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Causes all
    ///processes associated with the job to limit their committed memory. When a process attempts to commit memory that
    ///would exceed the per-process limit, it fails. If the job object is associated with a completion port, a
    ///<b>JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT</b> message is sent to the completion port. If the job is nested, the
    ///effective memory limit is the most restrictive memory limit in the job chain. This limit requires use of a
    ///JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure. Its <b>BasicLimitInformation</b> member is a
    ///<b>JOBOBJECT_BASIC_LIMIT_INFORMATION</b> structure. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_PROCESS_TIME"></a><a id="job_object_limit_process_time"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_PROCESS_TIME</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Establishes a
    ///user-mode execution time limit for each currently active process and for all future processes associated with the
    ///job. The <b>PerProcessUserTimeLimit</b> member contains additional information. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT_LIMIT_SCHEDULING_CLASS"></a><a id="job_object_limit_scheduling_class"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_SCHEDULING_CLASS</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> Causes all
    ///processes in the job to use the same scheduling class. The <b>SchedulingClass</b> member contains additional
    ///information. If the job is nested, the effective scheduling class is the lowest scheduling class in the job
    ///chain. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK"></a><a
    ///id="job_object_limit_silent_breakaway_ok"></a><dl> <dt><b>JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK</b></dt>
    ///<dt>0x00001000</dt> </dl> </td> <td width="60%"> Allows any process associated with the job to create child
    ///processes that are not associated with the job. If the job is nested and its immediate job object allows
    ///breakaway, the child process breaks away from the immediate job object and from each job in the parent job chain,
    ///moving up the hierarchy until it reaches a job that does not permit breakaway. If the immediate job object does
    ///not allow breakaway, the child process does not break away even if jobs in its parent job chain allow it. This
    ///limit requires use of a JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure. Its <b>BasicLimitInformation</b> member
    ///is a <b>JOBOBJECT_BASIC_LIMIT_INFORMATION</b> structure. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_SUBSET_AFFINITY"></a><a id="job_object_limit_subset_affinity"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_SUBSET_AFFINITY</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> Allows
    ///processes to use a subset of the processor affinity for all processes associated with the job. This value must be
    ///combined with <b>JOB_OBJECT_LIMIT_AFFINITY</b>. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and
    ///Windows XP: </b>This flag is supported starting with Windows 7 and Windows Server 2008 R2. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT_LIMIT_WORKINGSET"></a><a id="job_object_limit_workingset"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_WORKINGSET</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Causes all processes
    ///associated with the job to use the same minimum and maximum working set sizes. The <b>MinimumWorkingSetSize</b>
    ///and <b>MaximumWorkingSetSize</b> members contain additional information. If the job is nested, the effective
    ///working set size is the smallest working set size in the job chain. </td> </tr> </table>
    JOB_OBJECT_LIMIT LimitFlags;
    ///If <b>LimitFlags</b> specifies <b>JOB_OBJECT_LIMIT_WORKINGSET</b>, this member is the minimum working set size in
    ///bytes for each process associated with the job. Otherwise, this member is ignored. If
    ///<b>MaximumWorkingSetSize</b> is nonzero, <b>MinimumWorkingSetSize</b> cannot be zero.
    size_t           MinimumWorkingSetSize;
    ///If <b>LimitFlags</b> specifies <b>JOB_OBJECT_LIMIT_WORKINGSET</b>, this member is the maximum working set size in
    ///bytes for each process associated with the job. Otherwise, this member is ignored. If
    ///<b>MinimumWorkingSetSize</b> is nonzero, <b>MaximumWorkingSetSize</b> cannot be zero.
    size_t           MaximumWorkingSetSize;
    ///If <b>LimitFlags</b> specifies <b>JOB_OBJECT_LIMIT_ACTIVE_PROCESS</b>, this member is the active process limit
    ///for the job. Otherwise, this member is ignored. If you try to associate a process with a job, and this causes the
    ///active process count to exceed this limit, the process is terminated and the association fails.
    uint             ActiveProcessLimit;
    ///If <b>LimitFlags</b> specifies <b>JOB_OBJECT_LIMIT_AFFINITY</b>, this member is the processor affinity for all
    ///processes associated with the job. Otherwise, this member is ignored. The affinity must be a subset of the system
    ///affinity mask obtained by calling the GetProcessAffinityMask function. The affinity of each thread is set to this
    ///value, but threads are free to subsequently set their affinity, as long as it is a subset of the specified
    ///affinity mask. Processes cannot set their own affinity mask.
    size_t           Affinity;
    ///If <b>LimitFlags</b> specifies <b>JOB_OBJECT_LIMIT_PRIORITY_CLASS</b>, this member is the priority class for all
    ///processes associated with the job. Otherwise, this member is ignored. Processes and threads cannot modify their
    ///priority class. The calling process must enable the <b>SE_INC_BASE_PRIORITY_NAME</b> privilege.
    uint             PriorityClass;
    ///If <b>LimitFlags</b> specifies <b>JOB_OBJECT_LIMIT_SCHEDULING_CLASS</b>, this member is the scheduling class for
    ///all processes associated with the job. Otherwise, this member is ignored. The valid values are 0 to 9. Use 0 for
    ///the least favorable scheduling class relative to other threads, and 9 for the most favorable scheduling class
    ///relative to other threads. By default, this value is 5. To use a scheduling class greater than 5, the calling
    ///process must enable the <b>SE_INC_BASE_PRIORITY_NAME</b> privilege.
    uint             SchedulingClass;
}

///Contains basic and extended limit information for a job object.
struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION
{
    ///A JOBOBJECT_BASIC_LIMIT_INFORMATION structure that contains basic limit information.
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    ///Reserved.
    IO_COUNTERS IoInfo;
    ///If the <b>LimitFlags</b> member of the JOBOBJECT_BASIC_LIMIT_INFORMATION structure specifies the
    ///<b>JOB_OBJECT_LIMIT_PROCESS_MEMORY</b> value, this member specifies the limit for the virtual memory that can be
    ///committed by a process. Otherwise, this member is ignored.
    size_t      ProcessMemoryLimit;
    ///If the <b>LimitFlags</b> member of the JOBOBJECT_BASIC_LIMIT_INFORMATION structure specifies the
    ///<b>JOB_OBJECT_LIMIT_JOB_MEMORY</b> value, this member specifies the limit for the virtual memory that can be
    ///committed for the job. Otherwise, this member is ignored.
    size_t      JobMemoryLimit;
    ///The peak memory used by any process ever associated with the job.
    size_t      PeakProcessMemoryUsed;
    ///The peak memory usage of all processes currently associated with the job.
    size_t      PeakJobMemoryUsed;
}

///Contains the process identifier list for a job object. If the job is nested, the process identifier list consists of
///all processes associated with the job and its child jobs.
struct JOBOBJECT_BASIC_PROCESS_ID_LIST
{
    ///The number of process identifiers to be stored in <b>ProcessIdList</b>.
    uint      NumberOfAssignedProcesses;
    ///The number of process identifiers returned in the <b>ProcessIdList</b> buffer. If this number is less than
    ///<b>NumberOfAssignedProcesses</b>, increase the size of the buffer to accommodate the complete list.
    uint      NumberOfProcessIdsInList;
    ///A variable-length array of process identifiers returned by this call. Array elements 0 through
    ///<b>NumberOfProcessIdsInList</b>– 1 contain valid process identifiers.
    size_t[1] ProcessIdList;
}

///Contains basic user-interface restrictions for a job object.
struct JOBOBJECT_BASIC_UI_RESTRICTIONS
{
    ///The restriction class for the user interface. This member can be one or more of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_UILIMIT_DESKTOP"></a><a
    ///id="job_object_uilimit_desktop"></a><dl> <dt><b>JOB_OBJECT_UILIMIT_DESKTOP</b></dt> <dt>0x00000040</dt> </dl>
    ///</td> <td width="60%"> Prevents processes associated with the job from creating desktops and switching desktops
    ///using the CreateDesktop and SwitchDesktop functions. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_UILIMIT_DISPLAYSETTINGS"></a><a id="job_object_uilimit_displaysettings"></a><dl>
    ///<dt><b>JOB_OBJECT_UILIMIT_DISPLAYSETTINGS</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Prevents
    ///processes associated with the job from calling the ChangeDisplaySettings function. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT_UILIMIT_EXITWINDOWS"></a><a id="job_object_uilimit_exitwindows"></a><dl>
    ///<dt><b>JOB_OBJECT_UILIMIT_EXITWINDOWS</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> Prevents
    ///processes associated with the job from calling the ExitWindows or ExitWindowsEx function. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT_UILIMIT_GLOBALATOMS"></a><a id="job_object_uilimit_globalatoms"></a><dl>
    ///<dt><b>JOB_OBJECT_UILIMIT_GLOBALATOMS</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Prevents
    ///processes associated with the job from accessing global atoms. When this flag is used, each job has its own atom
    ///table. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_UILIMIT_HANDLES"></a><a
    ///id="job_object_uilimit_handles"></a><dl> <dt><b>JOB_OBJECT_UILIMIT_HANDLES</b></dt> <dt>0x00000001</dt> </dl>
    ///</td> <td width="60%"> Prevents processes associated with the job from using USER handles owned by processes not
    ///associated with the same job. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_UILIMIT_READCLIPBOARD"></a><a
    ///id="job_object_uilimit_readclipboard"></a><dl> <dt><b>JOB_OBJECT_UILIMIT_READCLIPBOARD</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> Prevents processes associated with the job from reading data
    ///from the clipboard. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS"></a><a
    ///id="job_object_uilimit_systemparameters"></a><dl> <dt><b>JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS</b></dt>
    ///<dt>0x00000008</dt> </dl> </td> <td width="60%"> Prevents processes associated with the job from changing system
    ///parameters by using the SystemParametersInfo function. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_UILIMIT_WRITECLIPBOARD"></a><a id="job_object_uilimit_writeclipboard"></a><dl>
    ///<dt><b>JOB_OBJECT_UILIMIT_WRITECLIPBOARD</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Prevents
    ///processes associated with the job from writing data to the clipboard. </td> </tr> </table>
    JOB_OBJECT_UILIMIT UIRestrictionsClass;
}

///<p class="CCE_Message">[JOBOBJECT_SECURITY_LIMIT_INFORMATION is available for use in the operating systems specified
///in the Requirements section. Support for this structure was removed starting with Windows Vista. For information, see
///Remarks.] Contains the security limitations for a job object.
struct JOBOBJECT_SECURITY_LIMIT_INFORMATION
{
    ///The security limitations for the job. This member can be one or more of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_SECURITY_FILTER_TOKENS"></a><a
    ///id="job_object_security_filter_tokens"></a><dl> <dt><b>JOB_OBJECT_SECURITY_FILTER_TOKENS</b></dt>
    ///<dt>0x00000008</dt> </dl> </td> <td width="60%"> Applies a filter to the token when a process impersonates a
    ///client. Requires at least one of the following members to be set: <b>SidsToDisable</b>,
    ///<b>PrivilegesToDelete</b>, or <b>RestrictedSids</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_SECURITY_NO_ADMIN"></a><a id="job_object_security_no_admin"></a><dl>
    ///<dt><b>JOB_OBJECT_SECURITY_NO_ADMIN</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Prevents any
    ///process in the job from using a token that specifies the local administrators group. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT_SECURITY_ONLY_TOKEN"></a><a id="job_object_security_only_token"></a><dl>
    ///<dt><b>JOB_OBJECT_SECURITY_ONLY_TOKEN</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Forces processes
    ///in the job to run under a specific token. Requires a token handle in the <b>JobToken</b> member. </td> </tr> <tr>
    ///<td width="40%"><a id="JOB_OBJECT_SECURITY_RESTRICTED_TOKEN"></a><a
    ///id="job_object_security_restricted_token"></a><dl> <dt><b>JOB_OBJECT_SECURITY_RESTRICTED_TOKEN</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> Prevents any process in the job from using a token that was not
    ///created with the CreateRestrictedToken function. </td> </tr> </table>
    JOB_OBJECT_SECURITY SecurityLimitFlags;
    ///A handle to the primary token that represents a user. The handle must have TOKEN_ASSIGN_PRIMARY access. If the
    ///token was created with CreateRestrictedToken, all processes in the job are limited to that token or a further
    ///restricted token. Otherwise, the caller must have the SE_ASSIGNPRIMARYTOKEN_NAME privilege.
    HANDLE              JobToken;
    ///A pointer to a TOKEN_GROUPS structure that specifies the SIDs to disable for access checking, if
    ///<b>SecurityLimitFlags</b> is JOB_OBJECT_SECURITY_FILTER_TOKENS. This member can be NULL if you do not want to
    ///disable any SIDs.
    TOKEN_GROUPS*       SidsToDisable;
    ///A pointer to a TOKEN_PRIVILEGES structure that specifies the privileges to delete from the token, if
    ///<b>SecurityLimitFlags</b> is JOB_OBJECT_SECURITY_FILTER_TOKENS. This member can be NULL if you do not want to
    ///delete any privileges.
    TOKEN_PRIVILEGES*   PrivilegesToDelete;
    ///A pointer to a TOKEN_GROUPS structure that specifies the deny-only SIDs that will be added to the access token,
    ///if <b>SecurityLimitFlags</b> is JOB_OBJECT_SECURITY_FILTER_TOKENS. This member can be NULL if you do not want to
    ///specify any deny-only SIDs.
    TOKEN_GROUPS*       RestrictedSids;
}

///Specifies the action the system will perform when an end-of-job time limit is exceeded.
struct JOBOBJECT_END_OF_JOB_TIME_INFORMATION
{
    ///The action that the system will perform when the end-of-job time limit has been exceeded. This member can be one
    ///of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_TERMINATE_AT_END_OF_JOB"></a><a id="job_object_terminate_at_end_of_job"></a><dl>
    ///<dt><b>JOB_OBJECT_TERMINATE_AT_END_OF_JOB</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Terminates all
    ///processes and sets the exit status to ERROR_NOT_ENOUGH_QUOTA. The processes cannot prevent or delay their own
    ///termination. The job object is set to the signaled state and remains signaled until this limit is reset. No
    ///additional processes can be assigned to the job until the limit is reset. This is the default termination action.
    ///</td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_POST_AT_END_OF_JOB"></a><a
    ///id="job_object_post_at_end_of_job"></a><dl> <dt><b>JOB_OBJECT_POST_AT_END_OF_JOB</b></dt> <dt>1</dt> </dl> </td>
    ///<td width="60%"> Posts a completion packet to the completion port using the PostQueuedCompletionStatus function.
    ///After the completion packet is posted, the system clears the end-of-job time limit, and processes in the job can
    ///continue their execution. If no completion port is associated with the job when the time limit has been exceeded,
    ///the action taken is the same as for JOB_OBJECT_TERMINATE_AT_END_OF_JOB. </td> </tr> </table>
    uint EndOfJobTimeAction;
}

///Contains information used to associate a completion port with a job. You can associate one completion port with a
///job.
struct JOBOBJECT_ASSOCIATE_COMPLETION_PORT
{
    ///The value to use in the <i>dwCompletionKey</i> parameter of PostQueuedCompletionStatus when messages are sent on
    ///behalf of the job.
    void*  CompletionKey;
    ///The completion port to use in the <i>CompletionPort</i> parameter of the PostQueuedCompletionStatus function when
    ///messages are sent on behalf of the job. <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2,
    ///Windows 10 and Windows Server 2016: </b>Specify <b>NULL</b> to remove the association between the current
    ///completion port and the job.
    HANDLE CompletionPort;
}

///Contains basic accounting and I/O accounting information for a job object.
struct JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
{
    ///A JOBOBJECT_BASIC_ACCOUNTING_INFORMATION structure that specifies the basic accounting information for the job.
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    ///An IO_COUNTERS structure that specifies the I/O accounting information for the job. The structure includes
    ///information for all processes that have ever been associated with the job, in addition to the information for all
    ///processes currently associated with the job.
    IO_COUNTERS IoInfo;
}

struct JOBOBJECT_JOBSET_INFORMATION
{
    uint MemberLevel;
}

///Contains information about notification limits for a job object. This structure is used by the
///SetInformationJobObject and QueryInformationJobObject functions with the <b>JobObjectNotificationLimitInformation</b>
///information class.
struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION
{
    ///If the <i>LimitFlags</i> member specifies JOB_OBJECT_LIMIT_JOB_READ_BYTES, this member is the notification limit
    ///for total I/O bytes read by all processes in the job. Otherwise, this member is ignored.
    ulong            IoReadBytesLimit;
    ///If the <i>LimitFlags</i> parameter specifies JOB_OBJECT_LIMIT_JOB_WRITE_BYTES, this member is the notification
    ///limit for total I/O bytes written by all processes in the job. Otherwise, this member is ignored.
    ulong            IoWriteBytesLimit;
    ///If the <i>LimitFlags</i> parameter specifies JOB_OBJECT_LIMIT_JOB_TIME, this member is the notification limit for
    ///per-job user-mode execution time, in 100-nanosecond ticks. Otherwise, this member is ignored. The system adds the
    ///accumulated execution time of processes associated with the job to this limit when the limit is set. For example,
    ///if a process associated with the job has already accumulated 5 minutes of user-mode execution time and the limit
    ///is set to 1 minute, the limit actually enforced is 6 minutes. To specify <b>PerJobUserTimeLimit</b> as an
    ///enforceable limit and terminate processes in jobs that exceed the limit, see the
    ///JOBOBJECT_BASIC_LIMIT_INFORMATION structure.
    LARGE_INTEGER    PerJobUserTimeLimit;
    ///If the <i>LimitFlags</i> parameter specifies JOB_OBJECT_LIMIT_JOB_MEMORY, this member is the notification limit
    ///for total virtual memory that can be committed by all processes in the job, in bytes. Otherwise, this member is
    ///ignored. To specify <b>JobMemoryLimit</b> as an enforceable limit and prevent processes in jobs that exceed the
    ///limit from continuing to commit memory, see the JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure.
    ulong            JobMemoryLimit;
    ///If the <i>LimitFlags</i> parameter specifies JOB_OBJECT_LIMIT_RATE_CONTROL, this member specifies the extent to
    ///which a job can exceed its CPU rate control limits during the interval specified by the
    ///<b>RateControlToleranceInterval</b> member. Otherwise, this member is ignored. This member can be one of the
    ///following values. If no value is specified, <b>ToleranceHigh</b> is used. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ToleranceLow"></a><a id="tolerancelow"></a><a
    ///id="TOLERANCELOW"></a><dl> <dt><b>ToleranceLow</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The job can
    ///exceed its CPU rate control limits for 20% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a
    ///id="ToleranceMedium"></a><a id="tolerancemedium"></a><a id="TOLERANCEMEDIUM"></a><dl>
    ///<dt><b>ToleranceMedium</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The job can exceed its CPU rate control
    ///limits for 40% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a id="ToleranceHigh"></a><a
    ///id="tolerancehigh"></a><a id="TOLERANCEHIGH"></a><dl> <dt><b>ToleranceHigh</b></dt> <dt>3</dt> </dl> </td> <td
    ///width="60%"> The job can exceed its CPU rate control limits for 60% of the tolerance interval. </td> </tr>
    ///</table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    ///If the <i>LimitFlags</i> parameter specifies JOB_OBJECT_LIMIT_RATE_CONTROL, this member specifies the interval
    ///during which a job's CPU usage is monitored to determine whether the job has exceeded its CPU rate control
    ///limits. Otherwise, this member is ignored. This member can be one of the following values. If no value is
    ///specified, <b>ToleranceIntervalShort</b> is used. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="ToleranceIntervalShort"></a><a id="toleranceintervalshort"></a><a
    ///id="TOLERANCEINTERVALSHORT"></a><dl> <dt><b>ToleranceIntervalShort</b></dt> <dt>1</dt> </dl> </td> <td
    ///width="60%"> The tolerance interval is 10 seconds. </td> </tr> <tr> <td width="40%"><a
    ///id="ToleranceIntervalMedium"></a><a id="toleranceintervalmedium"></a><a id="TOLERANCEINTERVALMEDIUM"></a><dl>
    ///<dt><b>ToleranceIntervalMedium</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The tolerance interval is one
    ///minute. </td> </tr> <tr> <td width="40%"><a id="ToleranceIntervalLong"></a><a id="toleranceintervallong"></a><a
    ///id="TOLERANCEINTERVALLONG"></a><dl> <dt><b>ToleranceIntervalLong</b></dt> <dt>3</dt> </dl> </td> <td width="60%">
    ///The tolerance interval is 10 minutes. </td> </tr> </table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
    ///The limit flags that are in effect. This member is a bitfield that determines whether other structure members are
    ///used. Any combination of the following values can be specified. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_MEMORY"></a><a id="job_object_limit_job_memory"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> Establishes the
    ///committed memory limit to the job-wide sum of committed memory for all processes associated with the job. The
    ///<b>JobMemoryLimit</b> member contains additional information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_READ_BYTES"></a><a id="job_object_limit_job_read_bytes"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_READ_BYTES</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> Establishes the
    ///I/O read bytes limit to the job-wide sum of I/O bytes read by all processes associated with the job. The
    ///<b>IoReadBytesLimit</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_WRITE_BYTES"></a><a id="job_object_limit_job_write_bytes"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_WRITE_BYTES</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> Establishes the
    ///I/O write bytes limit to the job-wide sum of I/O bytes written by all processes associated with the job. The
    ///<b>IoWriteBytesLimit</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_TIME"></a><a id="job_object_limit_job_time"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_TIME</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Establishes the limit
    ///for user-mode execution time for the job. The <b>PerJobUserTimeLimit</b> member contains additional information.
    ///</td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_RATE_CONTROL"></a><a
    ///id="job_object_limit_rate_control"></a><dl> <dt><b>JOB_OBJECT_LIMIT_RATE_CONTROL</b></dt> <dt>0x00040000</dt>
    ///</dl> </td> <td width="60%"> Establishes the notification threshold for the CPU rate control limits established
    ///for the job. The <b>RateControlTolerance</b> and <b>RateControlToleranceInterval</b> members contain additional
    ///information. CPU rate control limits are established by calling SetInformationJobObject with the
    ///<b>JobObjectCpuRateInformationClass</b> information class. </td> </tr> </table>
    JOB_OBJECT_LIMIT LimitFlags;
}

///Contains extended information about notification limits for a job object. This structure is used by the
///SetInformationJobObject and QueryInformationJobObject functions with the
///<b>JobObjectNotificationLimitInformation2</b> information class.
struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2
{
    ///If the <i>LimitFlags</i> member specifies <b>JOB_OBJECT_LIMIT_JOB_READ_BYTES</b>, this member is the notification
    ///limit for the total I/O bytes read by all processes in the job. Otherwise, this member is ignored.
    ulong            IoReadBytesLimit;
    ///If the <i>LimitFlags</i> parameter specifies <b>JOB_OBJECT_LIMIT_JOB_WRITE_BYTES</b>, this member is the
    ///notification limit for the total I/O bytes written by all processes in the job. Otherwise, this member is
    ///ignored.
    ulong            IoWriteBytesLimit;
    ///If the <i>LimitFlags</i> parameter specifies <b>JOB_OBJECT_LIMIT_JOB_TIME</b>, this member is the notification
    ///limit for per-job user-mode execution time, in 100-nanosecond ticks. Otherwise, this member is ignored. The
    ///system adds the accumulated execution time of processes associated with the job to this limit when the limit is
    ///set. For example, if a process associated with the job has already accumulated 5 minutes of user-mode execution
    ///time and the limit is set to 1 minute, the limit actually enforced is 6 minutes. To specify
    ///<b>PerJobUserTimeLimit</b> as an enforceable limit and terminate processes in jobs that exceed the limit, see the
    ///JOBOBJECT_BASIC_LIMIT_INFORMATION structure.
    LARGE_INTEGER    PerJobUserTimeLimit;
union
    {
        ulong JobHighMemoryLimit;
        ulong JobMemoryLimit;
    }
union
    {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    }
union
    {
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
        JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL CpuRateControlToleranceInterval;
    }
    ///The limit flags that are in effect. This member is a bitfield that determines whether other structure members are
    ///used. Any combination of the following values can be specified. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH"></a><a
    ///id="job_object_limit_job_memory_high"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH</b></dt>
    ///<dt>0x00000200</dt> </dl> </td> <td width="60%"> Establishes the notification threshold for the job-wide sum of
    ///private committed memory for all processes associated with the job. The <b>JobHighMemoryLimit</b> member contains
    ///additional information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_MEMORY_LOW"></a><a
    ///id="job_object_limit_job_memory_low"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY_LOW</b></dt> <dt>0x00008000</dt>
    ///</dl> </td> <td width="60%"> Establishes the notification minimum for the job-wide sum of private committed
    ///memory for all processes associated with the job. If this value is set, a notification is sent when the amount of
    ///private committed memory falls below this threshold. The <b>JobLowMemoryLimit</b> member contains additional
    ///information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_READ_BYTES"></a><a
    ///id="job_object_limit_job_read_bytes"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_READ_BYTES</b></dt> <dt>0x00010000</dt>
    ///</dl> </td> <td width="60%"> Establishes the I/O read bytes limit to the job-wide sum of I/O bytes read by all
    ///processes associated with the job. The <b>IoReadBytesLimit</b> member contains more information. </td> </tr> <tr>
    ///<td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_WRITE_BYTES"></a><a id="job_object_limit_job_write_bytes"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_WRITE_BYTES</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> Establishes the
    ///I/O write bytes limit to the job-wide sum of I/O bytes written by all processes associated with the job. The
    ///<b>IoWriteBytesLimit</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_TIME"></a><a id="job_object_limit_job_time"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_TIME</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Establishes the limit
    ///for user-mode execution time for the job. The <b>PerJobUserTimeLimit</b> member contains additional information.
    ///</td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_CPU_RATE_CONTROL"></a><a
    ///id="job_object_limit_cpu_rate_control"></a><dl> <dt><b>JOB_OBJECT_LIMIT_CPU_RATE_CONTROL</b></dt>
    ///<dt>0x00040000</dt> </dl> </td> <td width="60%"> Establishes the notification threshold for the CPU rate control
    ///limits established for the job. The <b>CpuRateControlTolerance</b> and <b>CpuRateControlToleranceInterval</b>
    ///members contain additional information. CPU rate control limits are established by calling
    ///SetInformationJobObject with the <b>JobObjectCpuRateInformationClass</b> information class. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT_LIMIT_RATE_CONTROL"></a><a id="job_object_limit_rate_control"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_RATE_CONTROL</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> Establishes the
    ///notification threshold for the CPU rate control limits established for the job. The <b>RateControlTolerance</b>
    ///and <b>RateControlToleranceInterval</b> members contain additional information. CPU rate control limits are
    ///established by calling SetInformationJobObject with the <b>JobObjectCpuRateInformationClass</b> information
    ///class. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_IO_RATE_CONTROL"></a><a
    ///id="job_object_limit_io_rate_control"></a><dl> <dt><b>JOB_OBJECT_LIMIT_IO_RATE_CONTROL</b></dt>
    ///<dt>0x00080000</dt> </dl> </td> <td width="60%"> Establishes the notification threshold for the I/O rate control
    ///limits established for the job. The <b>IoRateControlTolerance</b> and <b>IoRateControlToleranceInterval</b>
    ///members contain additional information. I/O rate control limits are established by calling
    ///SetIoRateControlInformationJobObject. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_NET_RATE_CONTROL"></a><a id="job_object_limit_net_rate_control"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_NET_RATE_CONTROL</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> Establishes
    ///the notification threshold for the network rate control limits established for the job. The
    ///<b>NetRateControlTolerance</b> and <b>NetRateControlToleranceInterval</b> members contain additional information.
    ///Network rate control limits are established by calling SetInformationJobObject with the
    ///<b>JobObjectNetRateInformationClass</b> information class. </td> </tr> </table>
    JOB_OBJECT_LIMIT LimitFlags;
    ///If the <i>LimitFlags</i> parameter specifies <b>JOB_OBJECT_LIMIT_IO_RATE_CONTROL</b>, this member specifies the
    ///extent to which a job can exceed its I/O rate control limits during the interval specified by the
    ///<b>IoRateControlToleranceInterval</b> member. Otherwise, this member is ignored. This member can be one of the
    ///following values. If no value is specified, <b>ToleranceHigh</b> is used. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ToleranceLow"></a><a id="tolerancelow"></a><a
    ///id="TOLERANCELOW"></a><dl> <dt><b>ToleranceLow</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The job can
    ///exceed its I/O rate control limits for 20% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a
    ///id="ToleranceMedium"></a><a id="tolerancemedium"></a><a id="TOLERANCEMEDIUM"></a><dl>
    ///<dt><b>ToleranceMedium</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The job can exceed its I/O rate control
    ///limits for 40% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a id="ToleranceHigh"></a><a
    ///id="tolerancehigh"></a><a id="TOLERANCEHIGH"></a><dl> <dt><b>ToleranceHigh</b></dt> <dt>3</dt> </dl> </td> <td
    ///width="60%"> The job can exceed its I/O rate control limits for 60% of the tolerance interval. </td> </tr>
    ///</table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    ///If the <i>LimitFlags</i> parameter specifies <b>JOB_OBJECT_LIMIT_JOB_MEMORY_LOW</b>, this member is the
    ///notification limit minimum for the total virtual memory that can be committed by all processes in the job, in
    ///bytes. Otherwise, this member is ignored.
    ulong            JobLowMemoryLimit;
    ///If the <i>LimitFlags</i> parameter specifies <b>JOB_OBJECT_IO_LIMIT_RATE_CONTROL</b>, this member specifies the
    ///interval during which a job's I/O usage is monitored to determine whether the job has exceeded its I/O rate
    ///control limits. Otherwise, this member is ignored. This member can be one of the following values. If no value is
    ///specified, <b>ToleranceIntervalShort</b> is used. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="ToleranceIntervalShort"></a><a id="toleranceintervalshort"></a><a
    ///id="TOLERANCEINTERVALSHORT"></a><dl> <dt><b>ToleranceIntervalShort</b></dt> <dt>1</dt> </dl> </td> <td
    ///width="60%"> The tolerance interval is 10 seconds. </td> </tr> <tr> <td width="40%"><a
    ///id="ToleranceIntervalMedium"></a><a id="toleranceintervalmedium"></a><a id="TOLERANCEINTERVALMEDIUM"></a><dl>
    ///<dt><b>ToleranceIntervalMedium</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The tolerance interval is one
    ///minute. </td> </tr> <tr> <td width="40%"><a id="ToleranceIntervalLong"></a><a id="toleranceintervallong"></a><a
    ///id="TOLERANCEINTERVALLONG"></a><dl> <dt><b>ToleranceIntervalLong</b></dt> <dt>3</dt> </dl> </td> <td width="60%">
    ///The tolerance interval is 10 minutes. </td> </tr> </table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL IoRateControlToleranceInterval;
    ///If the <i>LimitFlags</i> parameter specifies <b>JOB_OBJECT_LIMIT_IO_RATE_CONTROL</b>, this member specifies the
    ///extent to which a job can exceed its network rate control limits during the interval specified by the
    ///<b>NetRateControlToleranceInterval</b> member. Otherwise, this member is ignored. This member can be one of the
    ///following values. If no value is specified, <b>ToleranceHigh</b> is used. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ToleranceLow"></a><a id="tolerancelow"></a><a
    ///id="TOLERANCELOW"></a><dl> <dt><b>ToleranceLow</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The job can
    ///exceed its network rate control limits for 20% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a
    ///id="ToleranceMedium"></a><a id="tolerancemedium"></a><a id="TOLERANCEMEDIUM"></a><dl>
    ///<dt><b>ToleranceMedium</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The job can exceed its network rate
    ///control limits for 40% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a id="ToleranceHigh"></a><a
    ///id="tolerancehigh"></a><a id="TOLERANCEHIGH"></a><dl> <dt><b>ToleranceHigh</b></dt> <dt>3</dt> </dl> </td> <td
    ///width="60%"> The job can exceed its network rate control limits for 60% of the tolerance interval. </td> </tr>
    ///</table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    ///If the <i>LimitFlags</i> parameter specifies <b>JOB_OBJECT_NET_LIMIT_RATE_CONTROL</b>, this member specifies the
    ///interval during which a job's network usage is monitored to determine whether the job has exceeded its network
    ///rate control limits. Otherwise, this member is ignored. This member can be one of the following values. If no
    ///value is specified, <b>ToleranceIntervalShort</b> is used. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="ToleranceIntervalShort"></a><a id="toleranceintervalshort"></a><a
    ///id="TOLERANCEINTERVALSHORT"></a><dl> <dt><b>ToleranceIntervalShort</b></dt> <dt>1</dt> </dl> </td> <td
    ///width="60%"> The tolerance interval is 10 seconds. </td> </tr> <tr> <td width="40%"><a
    ///id="ToleranceIntervalMedium"></a><a id="toleranceintervalmedium"></a><a id="TOLERANCEINTERVALMEDIUM"></a><dl>
    ///<dt><b>ToleranceIntervalMedium</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The tolerance interval is one
    ///minute. </td> </tr> <tr> <td width="40%"><a id="ToleranceIntervalLong"></a><a id="toleranceintervallong"></a><a
    ///id="TOLERANCEINTERVALLONG"></a><dl> <dt><b>ToleranceIntervalLong</b></dt> <dt>3</dt> </dl> </td> <td width="60%">
    ///The tolerance interval is 10 minutes. </td> </tr> </table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL NetRateControlToleranceInterval;
}

///Contains information about resource notification limits that have been exceeded for a job object. This structure is
///used with the QueryInformationJobObject function with the <b>JobObjectLimitViolationInformation</b> information
///class.
struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION
{
    ///Flags that identify the notification limits in effect for the job. This member is a bitfield that determines
    ///whether other structure members are used. This member can be any combination of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_MEMORY"></a><a
    ///id="job_object_limit_job_memory"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY</b></dt> <dt>0x00000200</dt> </dl>
    ///</td> <td width="60%"> The job has a committed memory notification limit. The <b>JobMemoryLimit</b> member
    ///contains more information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_READ_BYTES"></a><a
    ///id="job_object_limit_job_read_bytes"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_READ_BYTES</b></dt> <dt>0x00010000</dt>
    ///</dl> </td> <td width="60%"> The job has an I/O read bytes notification limit. The <b>IoReadBytesLimit</b> member
    ///contains more information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_TIME"></a><a
    ///id="job_object_limit_job_time"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_TIME</b></dt> <dt>0x00000004</dt> </dl> </td>
    ///<td width="60%"> The job has a user-mode execution time notification limit. The <b>PerJobUserTimeLimit</b> member
    ///contains more information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_WRITE_BYTES"></a><a
    ///id="job_object_limit_job_write_bytes"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_WRITE_BYTES</b></dt>
    ///<dt>0x00020000</dt> </dl> </td> <td width="60%"> The job has an I/O write bytes notification limit. The
    ///<b>IoWriteBytesLimit</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_RATE_CONTROL"></a><a id="job_object_limit_rate_control"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_RATE_CONTROL</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The extent to
    ///which a job can exceed its CPU rate control limit. The <b>RateControlToleranceLimit</b> member contains more
    ///information. </td> </tr> </table>
    JOB_OBJECT_LIMIT LimitFlags;
    ///Flags that identify the notification limits that have been exceeded. This member is a bitfield that determines
    ///whether other structure members are used. This member can be any combination of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_READ_BYTES"></a><a
    ///id="job_object_limit_read_bytes"></a><dl> <dt><b>JOB_OBJECT_LIMIT_READ_BYTES</b></dt> <dt>0x00010000</dt> </dl>
    ///</td> <td width="60%"> The job's I/O read bytes notification limit has been exceeded. The <b>IoReadBytes</b>
    ///member contains more information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_WRITE_BYTES"></a><a
    ///id="job_object_limit_write_bytes"></a><dl> <dt><b>JOB_OBJECT_LIMIT_WRITE_BYTES</b></dt> <dt>0x00020000</dt> </dl>
    ///</td> <td width="60%"> The job's I/O write bytes notification limit has been exceeded. The <b>IoWriteBytes</b>
    ///member contains more information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_TIME"></a><a
    ///id="job_object_limit_job_time"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_TIME</b></dt> <dt>0x00000004</dt> </dl> </td>
    ///<td width="60%"> The job's user-mode execution time notification limit has been exceeded. The
    ///<b>PerJobUserTime</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_MEMORY"></a><a id="job_object_limit_job_memory"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> The job's committed
    ///memory notification limit has been exceeded. The <b>JobMemory</b> member contains more information. </td> </tr>
    ///<tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_RATE_CONTROL"></a><a id="job_object_limit_rate_control"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_RATE_CONTROL</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The job's CPU rate
    ///control limit has been exceeded. The <b>RateControlTolerance</b> member contains more information. </td> </tr>
    ///</table>
    JOB_OBJECT_LIMIT ViolationLimitFlags;
    ///If the ViolationLimitFlags member specifies JOB_OBJECT_LIMIT_READ_BYTES, this member contains the total I/O read
    ///bytes for all processes in the job at the time the notification was sent.
    ulong            IoReadBytes;
    ///If the LimitFlags member specifies JOB_OBJECT_LIMIT_READ_BYTES, this member contains the I/O read bytes
    ///notification limit in effect for the job.
    ulong            IoReadBytesLimit;
    ///If the ViolationLimitFlags member specifies JOB_OBJECT_LIMIT_WRITE_BYTES, this member contains the total I/O
    ///write bytes for all processes in the job at the time the notification was sent.
    ulong            IoWriteBytes;
    ///If the LimitFlags member specifies JOB_OBJECT_LIMIT_WRITE_BYTES, this member contains the I/O write bytes
    ///notification limit in effect for the job.
    ulong            IoWriteBytesLimit;
    ///If the ViolationLimitFlags member specifies JOB_OBJECT_LIMIT_JOB_TIME, this member contains the total user-mode
    ///execution time for all processes in the job at the time the notification was sent.
    LARGE_INTEGER    PerJobUserTime;
    ///If the LimitFlags member specifies JOB_OBJECT_LIMIT_JOB_TIME, this member contains the user-mode execution
    ///notification limit in effect for the job.
    LARGE_INTEGER    PerJobUserTimeLimit;
    ///If the ViolationLimitFlags member specifies JOB_OBJECT_LIMIT_JOB_MEMORY, this member contains the committed
    ///memory for all processes in the job at the time the notification was sent.
    ulong            JobMemory;
    ///If the LimitFlags member specifies JOB_OBJECT_LIMIT_JOB_MEMORY, this member contains the committed memory limit
    ///in effect for the job.
    ulong            JobMemoryLimit;
    ///If the <i>LimitFlags</i> parameter specifies JOB_OBJECT_LIMIT_RATE_CONTROL, this member specifies the extent to
    ///which the job exceeded its CPU rate control limits at the time the notification was sent. This member can be one
    ///of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ToleranceLow"></a><a id="tolerancelow"></a><a id="TOLERANCELOW"></a><dl> <dt><b>ToleranceLow</b></dt>
    ///<dt>1</dt> </dl> </td> <td width="60%"> The job exceeded its CPU rate control limits for 20% of the tolerance
    ///interval. </td> </tr> <tr> <td width="40%"><a id="ToleranceMedium"></a><a id="tolerancemedium"></a><a
    ///id="TOLERANCEMEDIUM"></a><dl> <dt><b>ToleranceMedium</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The job
    ///exceeded its CPU rate control limits for 40% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a
    ///id="ToleranceHigh"></a><a id="tolerancehigh"></a><a id="TOLERANCEHIGH"></a><dl> <dt><b>ToleranceHigh</b></dt>
    ///<dt>3</dt> </dl> </td> <td width="60%"> The job exceeded its CPU rate control limits for 60% of the tolerance
    ///interval. </td> </tr> </table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    ///If the <i>LimitFlags</i> parameter specifies JOB_OBJECT_LIMIT_RATE_CONTROL, this member contains the CPU rate
    ///control notification limits specified for the job. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="_ToleranceIntervalShort"></a><a id="_toleranceintervalshort"></a><a
    ///id="_TOLERANCEINTERVALSHORT"></a><dl> <dt><b> ToleranceIntervalShort</b></dt> <dt>1</dt> </dl> </td> <td
    ///width="60%"> The tolerance interval is 10 seconds. </td> </tr> <tr> <td width="40%"><a
    ///id="ToleranceIntervalMedium"></a><a id="toleranceintervalmedium"></a><a id="TOLERANCEINTERVALMEDIUM"></a><dl>
    ///<dt><b>ToleranceIntervalMedium</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The tolerance interval is one
    ///minute. </td> </tr> <tr> <td width="40%"><a id="ToleranceIntervalLong"></a><a id="toleranceintervallong"></a><a
    ///id="TOLERANCEINTERVALLONG"></a><dl> <dt><b>ToleranceIntervalLong</b></dt> <dt>3</dt> </dl> </td> <td width="60%">
    ///The tolerance interval is 10 minutes. </td> </tr> </table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
}

///Contains extended information about resource notification limits that have been exceeded for a job object. This
///structure is used with the QueryInformationJobObject function with the <b>JobObjectLimitViolationInformation2</b>
///information class.
struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2
{
    ///Flags that identify the notification limits in effect for the job. This member is a bitfield that determines
    ///whether other structure members are used. This member can be any combination of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH"></a><a
    ///id="job_object_limit_job_memory_high"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH</b></dt>
    ///<dt>0x00000200</dt> </dl> </td> <td width="60%"> The job has a committed memory notification limit. The
    ///<b>JobHighMemoryLimit</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_MEMORY_LOW"></a><a id="job_object_limit_job_memory_low"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY_LOW</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> The job has a
    ///committed minimum memory notification limit. The <b>JobLowMemoryLimit</b> member contains more information. </td>
    ///</tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_READ_BYTES"></a><a
    ///id="job_object_limit_job_read_bytes"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_READ_BYTES</b></dt> <dt>0x00010000</dt>
    ///</dl> </td> <td width="60%"> The job has an I/O read bytes notification limit. The <b>IoReadBytesLimit</b> member
    ///contains more information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_WRITE_BYTES"></a><a
    ///id="job_object_limit_job_write_bytes"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_WRITE_BYTES</b></dt>
    ///<dt>0x00020000</dt> </dl> </td> <td width="60%"> The job has an I/O write bytes notification limit. The
    ///<b>IoWriteBytesLimit</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_TIME"></a><a id="job_object_limit_job_time"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_TIME</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The job has a
    ///user-mode execution time notification limit. The <b>PerJobUserTimeLimit</b> member contains more information.
    ///</td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_RATE_CONTROL"></a><a
    ///id="job_object_limit_rate_control"></a><dl> <dt><b>JOB_OBJECT_LIMIT_RATE_CONTROL</b></dt> <dt>0x00040000</dt>
    ///</dl> </td> <td width="60%"> The job has notification limit for the extent to which a job can exceed its CPU rate
    ///control limit. The <b>RateControlToleranceLimit</b> member contains more information. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT_LIMIT_CPU_RATE_CONTROL"></a><a id="job_object_limit_cpu_rate_control"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_CPU_RATE_CONTROL</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The job has
    ///notification limit for the extent to which a job can exceed its CPU rate control limit. The
    ///<b>CpuRateControlToleranceLimit</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_IO_RATE_CONTROL"></a><a id="job_object_limit_io_rate_control"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_IO_RATE_CONTROL</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> The job has
    ///notification limit for the extent to which a job can exceed its I/O rate control limit. The
    ///<b>IoRateControlToleranceLimit</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_NET_RATE_CONTROL"></a><a id="job_object_limit_net_rate_control"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_NET_RATE_CONTROL</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The job has
    ///notification limit for the extent to which a job can exceed its network rate control limit. The
    ///<b>NetRateControlToleranceLimit</b> member contains more information. </td> </tr> </table>
    JOB_OBJECT_LIMIT LimitFlags;
    ///Flags that identify the notification limits that have been exceeded. This member is a bitfield that determines
    ///whether other structure members are used. This member can be any combination of the following values. <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_READ_BYTES"></a><a
    ///id="job_object_limit_read_bytes"></a><dl> <dt><b>JOB_OBJECT_LIMIT_READ_BYTES</b></dt> <dt>0x00010000</dt> </dl>
    ///</td> <td width="60%"> The job's I/O read bytes notification limit has been exceeded. The <b>IoReadBytes</b>
    ///member contains more information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_WRITE_BYTES"></a><a
    ///id="job_object_limit_write_bytes"></a><dl> <dt><b>JOB_OBJECT_LIMIT_WRITE_BYTES</b></dt> <dt>0x00020000</dt> </dl>
    ///</td> <td width="60%"> The job's I/O write bytes notification limit has been exceeded. The <b>IoWriteBytes</b>
    ///member contains more information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_TIME"></a><a
    ///id="job_object_limit_job_time"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_TIME</b></dt> <dt>0x00000004</dt> </dl> </td>
    ///<td width="60%"> The job's user-mode execution time notification limit has been exceeded. The
    ///<b>PerJobUserTime</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH"></a><a id="job_object_limit_job_memory_high"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> The job's
    ///committed maximum memory notification limit has been exceeded. The <b>JobMemory</b> member contains more
    ///information. </td> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_JOB_MEMORY_LOW"></a><a
    ///id="job_object_limit_job_memory_low"></a><dl> <dt><b>JOB_OBJECT_LIMIT_JOB_MEMORY_LOW</b></dt> <dt>0x00008000</dt>
    ///</dl> </td> <td width="60%"> The job's committed memory has fallen below its minimum notification limit. The
    ///<b>JobMemory</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_RATE_CONTROL"></a><a id="job_object_limit_rate_control"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_RATE_CONTROL</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The job's CPU rate
    ///control limit has been exceeded. The <b>RateControlTolerance</b> member contains more information. </td> </tr>
    ///<tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_CPU_RATE_CONTROL"></a><a
    ///id="job_object_limit_cpu_rate_control"></a><dl> <dt><b>JOB_OBJECT_LIMIT_CPU_RATE_CONTROL</b></dt>
    ///<dt>0x00040000</dt> </dl> </td> <td width="60%"> The job's CPU rate control limit has been exceeded. The
    ///<b>CpuRateControlTolerance</b> member contains more information. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_LIMIT_IO_RATE_CONTROL"></a><a id="job_object_limit_io_rate_control"></a><dl>
    ///<dt><b>JOB_OBJECT_LIMIT_IO_RATE_CONTROL</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> The job's I/O
    ///rate control limit has been exceeded. The <b>IoRateControlTolerance</b> member contains more information. </td>
    ///</tr> <tr> <td width="40%"><a id="JOB_OBJECT_LIMIT_NET_RATE_CONTROL"></a><a
    ///id="job_object_limit_net_rate_control"></a><dl> <dt><b>JOB_OBJECT_LIMIT_NET_RATE_CONTROL</b></dt>
    ///<dt>0x00100000</dt> </dl> </td> <td width="60%"> The job's network rate control limit has been exceeded. The
    ///<b>NetworkRateControlTolerance</b> member contains more information. </td> </tr> </table>
    JOB_OBJECT_LIMIT ViolationLimitFlags;
    ///If the <b>ViolationLimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_READ_BYTES</b>, this member contains the
    ///total I/O read bytes for all processes in the job at the time the notification was sent.
    ulong            IoReadBytes;
    ///If the <b>LimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_READ_BYTES</b>, this member contains the I/O read
    ///bytes notification limit in effect for the job.
    ulong            IoReadBytesLimit;
    ///If the <b>ViolationLimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_WRITE_BYTES</b>, this member contains the
    ///total I/O write bytes for all processes in the job at the time the notification was sent.
    ulong            IoWriteBytes;
    ///If the <b>LimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_WRITE_BYTES</b>, this member contains the I/O write
    ///bytes notification limit in effect for the job.
    ulong            IoWriteBytesLimit;
    ///If the <b>ViolationLimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_JOB_TIME</b>, this member contains the
    ///total user-mode execution time for all processes in the job at the time the notification was sent.
    LARGE_INTEGER    PerJobUserTime;
    ///If the <b>LimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_JOB_TIME</b>, this member contains the user-mode
    ///execution notification limit in effect for the job.
    LARGE_INTEGER    PerJobUserTimeLimit;
    ///If the <b>ViolationLimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH</b> or
    ///<b>JOB_OBJECT_LIMIT_JOB_MEMORY_LOW</b>, this member contains the committed memory for all processes in the job at
    ///the time the notification was sent.
    ulong            JobMemory;
union
    {
        ulong JobHighMemoryLimit;
        ulong JobMemoryLimit;
    }
union
    {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
    }
union
    {
        JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
        JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlToleranceLimit;
    }
    ///If the <b>LimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_JOB_MEMORY_LOW</b>, this member contains the
    ///committed minimum memory limit in effect for the job.
    ulong            JobLowMemoryLimit;
    ///If the <b>LimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_IO_RATE_CONTROL</b>, this member specifies the
    ///extent to which the job exceeded its I/O rate control limits at the time the notification was sent. This member
    ///can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="ToleranceLow"></a><a id="tolerancelow"></a><a id="TOLERANCELOW"></a><dl> <dt><b>ToleranceLow</b></dt>
    ///<dt>1</dt> </dl> </td> <td width="60%"> The job exceeded its I/O rate control limits for 20% of the tolerance
    ///interval. </td> </tr> <tr> <td width="40%"><a id="ToleranceMedium"></a><a id="tolerancemedium"></a><a
    ///id="TOLERANCEMEDIUM"></a><dl> <dt><b>ToleranceMedium</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The job
    ///exceeded its I/O rate control limits for 40% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a
    ///id="ToleranceHigh"></a><a id="tolerancehigh"></a><a id="TOLERANCEHIGH"></a><dl> <dt><b>ToleranceHigh</b></dt>
    ///<dt>3</dt> </dl> </td> <td width="60%"> The job exceeded its I/O rate control limits for 60% of the tolerance
    ///interval. </td> </tr> </table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
    ///If the <i>LimitFlags</i> parameter specifies <b>JOB_OBJECT_LIMIT_IO_RATE_CONTROL</b>, this member contains the
    ///I/O rate control notification limits specified for the job. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="ToleranceLow"></a><a id="tolerancelow"></a><a id="TOLERANCELOW"></a><dl>
    ///<dt><b>ToleranceLow</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The job can exceed its I/O rate control
    ///limits for 20% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a id="ToleranceMedium"></a><a
    ///id="tolerancemedium"></a><a id="TOLERANCEMEDIUM"></a><dl> <dt><b>ToleranceMedium</b></dt> <dt>2</dt> </dl> </td>
    ///<td width="60%"> The job can exceed its I/O rate control limits for 40% of the tolerance interval. </td> </tr>
    ///<tr> <td width="40%"><a id="ToleranceHigh"></a><a id="tolerancehigh"></a><a id="TOLERANCEHIGH"></a><dl>
    ///<dt><b>ToleranceHigh</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The job can exceed its I/O rate control
    ///limits for 60% of the tolerance interval. </td> </tr> </table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlToleranceLimit;
    ///If the <b>LimitFlags</b> member specifies <b>JOB_OBJECT_LIMIT_NET_RATE_CONTROL</b>, this member specifies the
    ///extent to which the job exceeded its network rate control limits at the time the notification was sent. This
    ///member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="ToleranceLow"></a><a id="tolerancelow"></a><a id="TOLERANCELOW"></a><dl>
    ///<dt><b>ToleranceLow</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The job exceeded its network rate control
    ///limits for 20% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a id="ToleranceMedium"></a><a
    ///id="tolerancemedium"></a><a id="TOLERANCEMEDIUM"></a><dl> <dt><b>ToleranceMedium</b></dt> <dt>2</dt> </dl> </td>
    ///<td width="60%"> The job exceeded its network rate control limits for 40% of the tolerance interval. </td> </tr>
    ///<tr> <td width="40%"><a id="ToleranceHigh"></a><a id="tolerancehigh"></a><a id="TOLERANCEHIGH"></a><dl>
    ///<dt><b>ToleranceHigh</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The job exceeded its network rate control
    ///limits for 60% of the tolerance interval. </td> </tr> </table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
    ///If the <i>LimitFlags</i> parameter specifies <b>JOB_OBJECT_LIMIT_NETWORK_RATE_CONTROL</b>, this member contains
    ///the network rate control notification limits specified for the job. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="ToleranceLow"></a><a id="tolerancelow"></a><a id="TOLERANCELOW"></a><dl>
    ///<dt><b>ToleranceLow</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The job can exceed its network rate control
    ///limits for 20% of the tolerance interval. </td> </tr> <tr> <td width="40%"><a id="ToleranceMedium"></a><a
    ///id="tolerancemedium"></a><a id="TOLERANCEMEDIUM"></a><dl> <dt><b>ToleranceMedium</b></dt> <dt>2</dt> </dl> </td>
    ///<td width="60%"> The job can exceed its network rate control limits for 40% of the tolerance interval. </td>
    ///</tr> <tr> <td width="40%"><a id="ToleranceHigh"></a><a id="tolerancehigh"></a><a id="TOLERANCEHIGH"></a><dl>
    ///<dt><b>ToleranceHigh</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The job can exceed its network rate control
    ///limits for 60% of the tolerance interval. </td> </tr> </table>
    JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlToleranceLimit;
}

///Contains CPU rate control information for a job object. This structure is used by the SetInformationJobObject and
///QueryInformationJobObject functions with the <b>JobObjectCpuRateControlInformation</b> information class.
struct JOBOBJECT_CPU_RATE_CONTROL_INFORMATION
{
    ///The scheduling policy for CPU rate control. This member can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_CPU_RATE_CONTROL_ENABLE"></a><a
    ///id="job_object_cpu_rate_control_enable"></a><dl> <dt><b>JOB_OBJECT_CPU_RATE_CONTROL_ENABLE</b></dt> <dt>0x1</dt>
    ///</dl> </td> <td width="60%"> This flag enables the job's CPU rate to be controlled based on weight or hard cap.
    ///You must set this value if you also set <b>JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED</b>,
    ///<b>JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP</b>, or <b>JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE</b>. </td> </tr> <tr>
    ///<td width="40%"><a id="JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED"></a><a
    ///id="job_object_cpu_rate_control_weight_based"></a><dl> <dt><b>JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED</b></dt>
    ///<dt>0x2</dt> </dl> </td> <td width="60%"> The job's CPU rate is calculated based on its relative weight to the
    ///weight of other jobs. If this flag is set, the <b>Weight</b> member contains more information. If this flag is
    ///clear, the <b>CpuRate</b> member contains more information. If you set
    ///<b>JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED</b>, you cannot also set
    ///<b>JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP"></a><a id="job_object_cpu_rate_control_hard_cap"></a><dl>
    ///<dt><b>JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP</b></dt> <dt>0x4</dt> </dl> </td> <td width="60%"> The job's CPU rate
    ///is a hard limit. After the job reaches its CPU cycle limit for the current scheduling interval, no threads
    ///associated with the job will run until the next interval. If you set <b>JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP</b>,
    ///you cannot also set <b>JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY"></a><a id="job_object_cpu_rate_control_notify"></a><dl>
    ///<dt><b>JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY</b></dt> <dt>0x8</dt> </dl> </td> <td width="60%"> Sends messages when
    ///the CPU rate for the job exceeds the rate limits for the job during the tolerance interval. </td> </tr> <tr> <td
    ///width="40%"><a id="JOB_OBJECT__CPU_RATE_CONTROL_MIN_MAX_RATE"></a><a
    ///id="job_object__cpu_rate_control_min_max_rate"></a><dl> <dt><b>JOB_OBJECT_ CPU_RATE_CONTROL_MIN_MAX_RATE</b></dt>
    ///<dt>0x10</dt> </dl> </td> <td width="60%"> The CPU rate for the job is limited by minimum and maximum rates that
    ///you specify in the <b>MinRate</b> and <b>MaxRate</b> members. If you set
    ///<b>JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE</b>, you can set neither
    ///<b>JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED</b> nor <b>JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP</b>. </td> </tr>
    ///</table>
    uint ControlFlags;
union
    {
        uint CpuRate;
        uint Weight;
struct
        {
            ushort MinRate;
            ushort MaxRate;
        }
    }
}

///Contains information used to control the network traffic for a job. This structure is used by the
///SetInformationJobObject and QueryInformationJobObject functions with the <b>JobObjectNetRateControlInformation</b>
///information class.
struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION
{
    ///The maximum bandwidth for outgoing network traffic for the job, in bytes.
    ulong MaxBandwidth;
    ///A combination of JOB_OBJECT_NET_RATE_CONTROL_FLAGS enumeration values that specify the scheduling policy for
    ///network rate control.
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS ControlFlags;
    ///The value to use for the Differentiated Service code point (DSCP) field to turn on network quality of service
    ///(QoS) for all outgoing network traffic generated by the processes of the job object. The valid range is from 0x00
    ///through 0x3F. For information about DSCP, see Differentiated Services.
    ubyte DscpTag;
}

struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE
{
    long   MaxIops;
    long   MaxBandwidth;
    long   ReservationIops;
    PWSTR  VolumeName;
    uint   BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    ushort VolumeNameLength;
}

struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2
{
    long   MaxIops;
    long   MaxBandwidth;
    long   ReservationIops;
    PWSTR  VolumeName;
    uint   BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    ushort VolumeNameLength;
    long   CriticalReservationIops;
    long   ReservationBandwidth;
    long   CriticalReservationBandwidth;
    long   MaxTimePercent;
    long   ReservationTimePercent;
    long   CriticalReservationTimePercent;
}

struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3
{
    long   MaxIops;
    long   MaxBandwidth;
    long   ReservationIops;
    PWSTR  VolumeName;
    uint   BaseIoSize;
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
    ushort VolumeNameLength;
    long   CriticalReservationIops;
    long   ReservationBandwidth;
    long   CriticalReservationBandwidth;
    long   MaxTimePercent;
    long   ReservationTimePercent;
    long   CriticalReservationTimePercent;
    long   SoftMaxIops;
    long   SoftMaxBandwidth;
    long   SoftMaxTimePercent;
    long   LimitExcessNotifyIops;
    long   LimitExcessNotifyBandwidth;
    long   LimitExcessNotifyTimePercent;
}

struct JOBOBJECT_IO_ATTRIBUTION_STATS
{
    size_t IoCount;
    ulong  TotalNonOverlappedQueueTime;
    ulong  TotalNonOverlappedServiceTime;
    ulong  TotalSize;
}

struct JOBOBJECT_IO_ATTRIBUTION_INFORMATION
{
    uint ControlFlags;
    JOBOBJECT_IO_ATTRIBUTION_STATS ReadStats;
    JOBOBJECT_IO_ATTRIBUTION_STATS WriteStats;
}

struct SILOOBJECT_BASIC_INFORMATION
{
    uint     SiloId;
    uint     SiloParentId;
    uint     NumberOfProcesses;
    ubyte    IsInServerSilo;
    ubyte[3] Reserved;
}

struct SERVERSILO_BASIC_INFORMATION
{
    uint             ServiceSessionId;
    SERVERSILO_STATE State;
    uint             ExitStatus;
    ubyte            IsDownlevelContainer;
    void*            ApiSetSchema;
    void*            HostApiSetSchema;
}

///Describes the cache attributes.
struct CACHE_DESCRIPTOR
{
    ///The cache level. This member can currently be one of the following values; other values may be supported in the
    ///future. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>1</dt> </dl> </td> <td
    ///width="60%"> L1 </td> </tr> <tr> <td width="40%"> <dl> <dt>2</dt> </dl> </td> <td width="60%"> L2 </td> </tr>
    ///<tr> <td width="40%"> <dl> <dt>3</dt> </dl> </td> <td width="60%"> L3 </td> </tr> </table>
    ubyte                Level;
    ///The cache associativity. If this member is CACHE_FULLY_ASSOCIATIVE (0xFF), the cache is fully associative.
    ubyte                Associativity;
    ///The cache line size, in bytes.
    ushort               LineSize;
    ///The cache size, in bytes.
    uint                 Size;
    ///The cache type. This member is a PROCESSOR_CACHE_TYPE value.
    PROCESSOR_CACHE_TYPE Type;
}

///Describes the relationship between the specified processor set. This structure is used with the
///GetLogicalProcessorInformation function.
struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION
{
    ///The processor mask identifying the processors described by this structure. A processor mask is a bit vector in
    ///which each set bit represents an active processor in the relationship. At least one bit will be set. On a system
    ///with more than 64 processors, the processor mask identifies processors in a single processor group.
    size_t ProcessorMask;
    ///The relationship between the processors identified by the value of the <b>ProcessorMask</b> member. This member
    ///can be one of the following LOGICAL_PROCESSOR_RELATIONSHIP values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="RelationCache"></a><a id="relationcache"></a><a id="RELATIONCACHE"></a><dl>
    ///<dt><b>RelationCache</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The specified logical processors share a
    ///cache. The <b>Cache</b> member contains additional information. <b>Windows Server 2003: </b>This value is not
    ///supported until Windows Server 2003 with SP1 and Windows XP Professional x64 Edition. </td> </tr> <tr> <td
    ///width="40%"><a id="RelationNumaNode"></a><a id="relationnumanode"></a><a id="RELATIONNUMANODE"></a><dl>
    ///<dt><b>RelationNumaNode</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The specified logical processors are
    ///part of the same NUMA node. The <b>NumaNode</b> member contains additional information. </td> </tr> <tr> <td
    ///width="40%"><a id="RelationProcessorCore"></a><a id="relationprocessorcore"></a><a
    ///id="RELATIONPROCESSORCORE"></a><dl> <dt><b>RelationProcessorCore</b></dt> <dt>0</dt> </dl> </td> <td width="60%">
    ///The specified logical processors share a single processor core. The <b>ProcessorCore</b> member contains
    ///additional information. </td> </tr> <tr> <td width="40%"><a id="RelationProcessorPackage"></a><a
    ///id="relationprocessorpackage"></a><a id="RELATIONPROCESSORPACKAGE"></a><dl>
    ///<dt><b>RelationProcessorPackage</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The specified logical processors
    ///share a physical package. There is no additional information available. <b>Windows Server 2003 and Windows XP
    ///Professional x64 Edition: </b>This value is not supported until Windows Server 2003 with SP1 and Windows XP with
    ///SP3. </td> </tr> </table> Future versions of Windows may support additional values for the <b>Relationship</b>
    ///member.
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
union
    {
struct ProcessorCore
        {
            ubyte Flags;
        }
struct NumaNode
        {
            uint NodeNumber;
        }
        CACHE_DESCRIPTOR Cache;
        ulong[2]         Reserved;
    }
}

///Represents information about affinity within a processor group. This structure is used with the
///GetLogicalProcessorInformationEx function.
struct PROCESSOR_RELATIONSHIP
{
    ///If the <b>Relationship</b> member of the SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structure is
    ///<b>RelationProcessorCore</b>, this member is LTP_PC_SMT if the core has more than one logical processor, or 0 if
    ///the core has one logical processor. If the <b>Relationship</b> member of the
    ///SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structure is <b>RelationProcessorPackage</b>, this member is always 0.
    ubyte             Flags;
    ///If the <b>Relationship</b> member of the SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structure is
    ///<b>RelationProcessorCore</b>, <b>EfficiencyClass</b> specifies the intrinsic tradeoff between performance and
    ///power for the applicable core. A core with a higher value for the efficiency class has intrinsically greater
    ///performance and less efficiency than a core with a lower value for the efficiency class. <b>EfficiencyClass</b>
    ///is only nonzero on systems with a heterogeneous set of cores. If the <b>Relationship</b> member of the
    ///SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structure is <b>RelationProcessorPackage</b>, <b>EfficiencyClass</b> is
    ///always 0. The minimum operating system version that supports this member is Windows 10.
    ubyte             EfficiencyClass;
    ///This member is reserved.
    ubyte[20]         Reserved;
    ///This member specifies the number of entries in the <b>GroupMask</b> array. For more information, see Remarks.
    ushort            GroupCount;
    ///An array of GROUP_AFFINITY structures. The <b>GroupCount</b> member specifies the number of structures in the
    ///array. Each structure in the array specifies a group number and processor affinity within the group.
    GROUP_AFFINITY[1] GroupMask;
}

///Represents information about a NUMA node in a processor group. This structure is used with the
///GetLogicalProcessorInformationEx function.
struct NUMA_NODE_RELATIONSHIP
{
    ///The number of the NUMA node.
    uint           NodeNumber;
    ///This member is reserved.
    ubyte[20]      Reserved;
    ///A GROUP_AFFINITY structure that specifies a group number and processor affinity within the group.
    GROUP_AFFINITY GroupMask;
}

///Describes cache attributes. This structure is used with the GetLogicalProcessorInformationEx function.
struct CACHE_RELATIONSHIP
{
    ///The cache level. This member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"> <dl> <dt>1</dt> </dl> </td> <td width="60%"> L1 </td> </tr> <tr> <td width="40%">
    ///<dl> <dt>2</dt> </dl> </td> <td width="60%"> L2 </td> </tr> <tr> <td width="40%"> <dl> <dt>3</dt> </dl> </td> <td
    ///width="60%"> L3 </td> </tr> </table>
    ubyte                Level;
    ///The cache associativity. If this member is CACHE_FULLY_ASSOCIATIVE (0xFF), the cache is fully associative.
    ubyte                Associativity;
    ///The cache line size, in bytes.
    ushort               LineSize;
    ///The cache size, in bytes.
    uint                 CacheSize;
    ///The cache type. This member is a PROCESSOR_CACHE_TYPE value.
    PROCESSOR_CACHE_TYPE Type;
    ///This member is reserved.
    ubyte[20]            Reserved;
    ///A GROUP_AFFINITY structure that specifies a group number and processor affinity within the group.
    GROUP_AFFINITY       GroupMask;
}

///Represents the number and affinity of processors in a processor group.
struct PROCESSOR_GROUP_INFO
{
    ///The maximum number of processors in the group.
    ubyte     MaximumProcessorCount;
    ///The number of active processors in the group.
    ubyte     ActiveProcessorCount;
    ///This member is reserved.
    ubyte[38] Reserved;
    ///A bitmap that specifies the affinity for zero or more active processors within the group.
    size_t    ActiveProcessorMask;
}

///Represents information about processor groups. This structure is used with the GetLogicalProcessorInformationEx
///function.
struct GROUP_RELATIONSHIP
{
    ///The maximum number of processor groups on the system.
    ushort    MaximumGroupCount;
    ///The number of active groups on the system. This member indicates the number of PROCESSOR_GROUP_INFO structures in
    ///the <b>GroupInfo</b> array.
    ushort    ActiveGroupCount;
    ///This member is reserved.
    ubyte[20] Reserved;
    ///An array of PROCESSOR_GROUP_INFO structures. Each structure represents the number and affinity of processors in
    ///an active group on the system.
    PROCESSOR_GROUP_INFO[1] GroupInfo;
}

///Contains information about the relationships of logical processors and related hardware. The
///GetLogicalProcessorInformationEx function uses this structure.
struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
{
    ///The type of relationship between the logical processors. This parameter can be one of the following
    ///LOGICAL_PROCESSOR_RELATIONSHIP values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="RelationCache"></a><a id="relationcache"></a><a id="RELATIONCACHE"></a><dl> <dt><b>RelationCache</b></dt>
    ///<dt>2</dt> </dl> </td> <td width="60%"> The specified logical processors share a cache. The <b>Cache</b> member
    ///contains additional information. </td> </tr> <tr> <td width="40%"><a id="RelationGroup"></a><a
    ///id="relationgroup"></a><a id="RELATIONGROUP"></a><dl> <dt><b>RelationGroup</b></dt> <dt>4</dt> </dl> </td> <td
    ///width="60%"> The specified logical processors share a processor group. The <b>Group</b> member contains
    ///additional information. </td> </tr> <tr> <td width="40%"><a id="RelationNumaNode"></a><a
    ///id="relationnumanode"></a><a id="RELATIONNUMANODE"></a><dl> <dt><b>RelationNumaNode</b></dt> <dt>1</dt> </dl>
    ///</td> <td width="60%"> The specified logical processors are part of the same NUMA node. The <b>NumaNode</b>
    ///member contains additional information. </td> </tr> <tr> <td width="40%"><a id="RelationProcessorCore"></a><a
    ///id="relationprocessorcore"></a><a id="RELATIONPROCESSORCORE"></a><dl> <dt><b>RelationProcessorCore</b></dt>
    ///<dt>0</dt> </dl> </td> <td width="60%"> The specified logical processors share a single processor core. The
    ///<b>Processor</b> member contains additional information. </td> </tr> <tr> <td width="40%"><a
    ///id="RelationProcessorPackage"></a><a id="relationprocessorpackage"></a><a id="RELATIONPROCESSORPACKAGE"></a><dl>
    ///<dt><b>RelationProcessorPackage</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The specified logical processors
    ///share a physical package. The <b>Processor</b> member contains additional information. </td> </tr> </table>
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    ///The size of the structure.
    uint Size;
union
    {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    }
}

///This structure is returned by GetSystemCpuSetInformation. It is used to enumerate the CPU Sets on the system and
///determine their current state. This is a variable-sized structure designed for future expansion. When iterating over
///this structure, use the size field to determine the offset to the next structure.
struct SYSTEM_CPU_SET_INFORMATION
{
    ///This is the size, in bytes, of this information structure.
    uint Size;
    ///This is the type of information in the structure. Applications should skip any structures with unrecognized
    ///types.
    CPU_SET_INFORMATION_TYPE Type;
union
    {
struct CpuSet
        {
            uint   Id;
            ushort Group;
            ubyte  LogicalProcessorIndex;
            ubyte  CoreIndex;
            ubyte  LastLevelCacheIndex;
            ubyte  NumaNodeIndex;
            ubyte  EfficiencyClass;
union
            {
                ubyte AllFlags;
struct
                {
                    ubyte _bitfield147;
                }
            }
union
            {
                uint  Reserved;
                ubyte SchedulingClass;
            }
            ulong  AllocationTag;
        }
    }
}

struct SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION
{
    ulong CycleTime;
}

struct XSTATE_FEATURE
{
    uint Offset;
    uint Size;
}

struct XSTATE_CONFIGURATION
{
    ulong              EnabledFeatures;
    ulong              EnabledVolatileFeatures;
    uint               Size;
union
    {
        uint ControlFlags;
struct
        {
            uint _bitfield148;
        }
    }
    XSTATE_FEATURE[64] Features;
    ulong              EnabledSupervisorFeatures;
    ulong              AlignedFeatures;
    uint               AllFeatureSize;
    uint[64]           AllFeatures;
    ulong              EnabledUserVisibleSupervisorFeatures;
}

///Contains information about a range of pages in the virtual address space of a process. The VirtualQuery and
///VirtualQueryEx functions use this structure.
struct MEMORY_BASIC_INFORMATION
{
    ///A pointer to the base address of the region of pages.
    void*  BaseAddress;
    ///A pointer to the base address of a range of pages allocated by the VirtualAlloc function. The page pointed to by
    ///the <b>BaseAddress</b> member is contained within this allocation range.
    void*  AllocationBase;
    ///The memory protection option when the region was initially allocated. This member can be one of the memory
    ///protection constants or 0 if the caller does not have access.
    uint   AllocationProtect;
    ///The size of the region beginning at the base address in which all pages have identical attributes, in bytes.
    size_t RegionSize;
    ///The state of the pages in the region. This member can be one of the following values. <table> <tr> <th>State</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_COMMIT"></a><a id="mem_commit"></a><dl>
    ///<dt><b>MEM_COMMIT</b></dt> <dt>0x1000</dt> </dl> </td> <td width="60%"> Indicates committed pages for which
    ///physical storage has been allocated, either in memory or in the paging file on disk. </td> </tr> <tr> <td
    ///width="40%"><a id="MEM_FREE"></a><a id="mem_free"></a><dl> <dt><b>MEM_FREE</b></dt> <dt>0x10000</dt> </dl> </td>
    ///<td width="60%"> Indicates free pages not accessible to the calling process and available to be allocated. For
    ///free pages, the information in the <b>AllocationBase</b>, <b>AllocationProtect</b>, <b>Protect</b>, and
    ///<b>Type</b> members is undefined. </td> </tr> <tr> <td width="40%"><a id="MEM_RESERVE"></a><a
    ///id="mem_reserve"></a><dl> <dt><b>MEM_RESERVE</b></dt> <dt>0x2000</dt> </dl> </td> <td width="60%"> Indicates
    ///reserved pages where a range of the process's virtual address space is reserved without any physical storage
    ///being allocated. For reserved pages, the information in the <b>Protect</b> member is undefined. </td> </tr>
    ///</table>
    uint   State;
    ///The access protection of the pages in the region. This member is one of the values listed for the
    ///<b>AllocationProtect</b> member.
    uint   Protect;
    ///The type of pages in the region. The following types are defined. <table> <tr> <th>Type</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="MEM_IMAGE"></a><a id="mem_image"></a><dl> <dt><b>MEM_IMAGE</b></dt>
    ///<dt>0x1000000</dt> </dl> </td> <td width="60%"> Indicates that the memory pages within the region are mapped into
    ///the view of an image section. </td> </tr> <tr> <td width="40%"><a id="MEM_MAPPED"></a><a id="mem_mapped"></a><dl>
    ///<dt><b>MEM_MAPPED</b></dt> <dt>0x40000</dt> </dl> </td> <td width="60%"> Indicates that the memory pages within
    ///the region are mapped into the view of a section. </td> </tr> <tr> <td width="40%"><a id="MEM_PRIVATE"></a><a
    ///id="mem_private"></a><dl> <dt><b>MEM_PRIVATE</b></dt> <dt>0x20000</dt> </dl> </td> <td width="60%"> Indicates
    ///that the memory pages within the region are private (that is, not shared by other processes). </td> </tr>
    ///</table>
    uint   Type;
}

struct MEMORY_BASIC_INFORMATION32
{
    uint BaseAddress;
    uint AllocationBase;
    uint AllocationProtect;
    uint RegionSize;
    uint State;
    uint Protect;
    uint Type;
}

struct MEMORY_BASIC_INFORMATION64
{
    ulong BaseAddress;
    ulong AllocationBase;
    uint  AllocationProtect;
    uint  __alignment1;
    ulong RegionSize;
    uint  State;
    uint  Protect;
    uint  Type;
    uint  __alignment2;
}

struct CFG_CALL_TARGET_INFO
{
    size_t Offset;
    size_t Flags;
}

///Specifies a lowest and highest base address and alignment as part of an extended parameter to a function that manages
///virtual memory.
struct MEM_ADDRESS_REQUIREMENTS
{
    ///Specifies the lowest acceptable address. Calling VirtualAlloc/MapViewOfFile.
    void*  LowestStartingAddress;
    ///Specifies the highest acceptable address (inclusive). This address must not exceed
    ///<b>lpMaximumApplicationAddress</b> returned by GetSystemInfo. Calling VirtualAlloc/MapViewOfFile.
    void*  HighestEndingAddress;
    ///Specifies power-of-2 alignment. Specifying 0 aligns the returned address on the system allocation granularity.
    size_t Alignment;
}

///Represents an extended parameter for a function that manages virtual memory.
struct MEM_EXTENDED_PARAMETER
{
struct
    {
        ulong _bitfield149;
    }
union
    {
        ulong  ULong64;
        void*  Pointer;
        size_t Size;
        HANDLE Handle;
        uint   ULong;
    }
}

///Contains architecture-specific information to use to create an enclave when the enclave type is
///<b>ENCLAVE_TYPE_SGX</b>, which specifies an enclave for the Intel Software Guard Extensions (SGX) architecture
///extension.
struct ENCLAVE_CREATE_INFO_SGX
{
    ///The SGX enclave control structure (<b>SECS</b>) to use to create the enclave.
    ubyte[4096] Secs;
}

///Contains architecture-specific information to use to initialize an enclave when the enclave type is
///<b>ENCLAVE_TYPE_SGX</b>, which specifies an enclave for the Intel Software Guard Extensions (SGX) architecture
///extension.
struct ENCLAVE_INIT_INFO_SGX
{
    ///The enclave signature structure (<b>SIGSTRUCT</b>) to use to initialize the enclave. This structure specifies
    ///information about the enclave from the enclave signer.
    ubyte[1808] SigStruct;
    ///Not used.
    ubyte[240]  Reserved1;
    ///The EINIT token structure (<b>EINITTOKEN</b>) to use to initialize the enclave. The initialization operation uses
    ///this structure to verify that the enclave has permission to start.
    ubyte[304]  EInitToken;
    ///Not used.
    ubyte[1744] Reserved2;
}

///Contains architecture-specific information to use to create an enclave when the enclave type is
///<b>ENCLAVE_TYPE_VBS</b>, which specifies a virtualization-based security (VBS) enclave.
struct ENCLAVE_CREATE_INFO_VBS
{
    ///A flag that indicates whether the enclave permits debugging. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="ENCLAVE_VBS_FLAG_DEBUG"></a><a id="enclave_vbs_flag_debug"></a><dl>
    ///<dt><b>ENCLAVE_VBS_FLAG_DEBUG</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The enclave permits
    ///debugging. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000000</dt> </dl> </td> <td width="60%"> The enclave
    ///does not permit debugging. </td> </tr> </table>
    uint      Flags;
    ///The identifier of the owner of the enclave.
    ubyte[32] OwnerID;
}

struct ENCLAVE_CREATE_INFO_VBS_BASIC
{
    uint      Flags;
    ubyte[32] OwnerID;
}

struct ENCLAVE_LOAD_DATA_VBS_BASIC
{
    uint PageType;
}

struct ENCLAVE_INIT_INFO_VBS_BASIC
{
    ubyte[16] FamilyId;
    ubyte[16] ImageId;
    ulong     EnclaveSize;
    uint      EnclaveSvn;
    uint      Reserved;
union
    {
        HANDLE SignatureInfoHandle;
        ulong  Unused;
    }
}

///Contains architecture-specific information to use to initialize an enclave when the enclave type is
///<b>ENCLAVE_TYPE_VBS</b>, which specifies a virtualization-based security (VBS) enclave.
struct ENCLAVE_INIT_INFO_VBS
{
    ///The total length of the <b>ENCLAVE_INIT_INFO_VBS</b> structure, in bytes.
    uint Length;
    ///Upon entry to the InitializeEnclave function, specifies the number of threads to create in the enclave. Upon
    ///successful return from <b>InitializeEnclave</b>, contains the number of threads the function actually created.
    uint ThreadCount;
}

union FILE_SEGMENT_ELEMENT
{
    void* Buffer;
    ulong Alignment;
}

struct SCRUB_DATA_INPUT
{
    uint       Size;
    uint       Flags;
    uint       MaximumIos;
    uint[4]    ObjectId;
    uint[25]   Reserved;
    ubyte[816] ResumeContext;
}

struct SCRUB_PARITY_EXTENT
{
    long  Offset;
    ulong Length;
}

struct SCRUB_PARITY_EXTENT_DATA
{
    ushort Size;
    ushort Flags;
    ushort NumberOfParityExtents;
    ushort MaximumNumberOfParityExtents;
    SCRUB_PARITY_EXTENT[1] ParityExtents;
}

struct SCRUB_DATA_OUTPUT
{
    uint       Size;
    uint       Flags;
    uint       Status;
    ulong      ErrorFileOffset;
    ulong      ErrorLength;
    ulong      NumberOfBytesRepaired;
    ulong      NumberOfBytesFailed;
    ulong      InternalFileReference;
    ushort     ResumeContextLength;
    ushort     ParityExtentDataOffset;
    uint[9]    Reserved;
    ulong      NumberOfMetadataBytesProcessed;
    ulong      NumberOfDataBytesProcessed;
    ulong      TotalNumberOfMetadataBytesInUse;
    ulong      TotalNumberOfDataBytesInUse;
    ubyte[816] ResumeContext;
}

struct SHARED_VIRTUAL_DISK_SUPPORT
{
    SharedVirtualDiskSupportType SharedVirtualDiskSupport;
    SharedVirtualDiskHandleState HandleState;
}

struct REARRANGE_FILE_DATA
{
    ulong  SourceStartingOffset;
    ulong  TargetOffset;
    HANDLE SourceFileHandle;
    uint   Length;
    uint   Flags;
}

struct SHUFFLE_FILE_DATA
{
    long StartingOffset;
    long Length;
    uint Flags;
}

struct NETWORK_APP_INSTANCE_EA
{
    GUID AppInstanceID;
    uint CsvFlags;
}

struct CM_Power_Data_s
{
    uint               PD_Size;
    DEVICE_POWER_STATE PD_MostRecentPowerState;
    uint               PD_Capabilities;
    uint               PD_D1Latency;
    uint               PD_D2Latency;
    uint               PD_D3Latency;
    DEVICE_POWER_STATE[7] PD_PowerStateMapping;
    SYSTEM_POWER_STATE PD_DeepestSystemWake;
}

struct POWER_USER_PRESENCE
{
    POWER_USER_PRESENCE_TYPE UserPresence;
}

struct POWER_SESSION_CONNECT
{
    ubyte Connected;
    ubyte Console;
}

struct POWER_SESSION_TIMEOUTS
{
    uint InputTimeout;
    uint DisplayTimeout;
}

struct POWER_SESSION_RIT_STATE
{
    ubyte Active;
    uint  LastInputTime;
}

struct POWER_SESSION_WINLOGON
{
    uint  SessionId;
    ubyte Console;
    ubyte Locked;
}

struct POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES
{
    ubyte IsAllowed;
}

struct POWER_IDLE_RESILIENCY
{
    uint CoalescingTimeout;
    uint IdleResiliencyPeriod;
}

struct POWER_MONITOR_INVOCATION
{
    ubyte Console;
    POWER_MONITOR_REQUEST_REASON RequestReason;
}

struct RESUME_PERFORMANCE
{
    uint  PostTimeMs;
    ulong TotalResumeTimeMs;
    ulong ResumeCompleteTimestamp;
}

struct SET_POWER_SETTING_VALUE
{
    uint     Version;
    GUID     Guid;
    SYSTEM_POWER_CONDITION PowerCondition;
    uint     DataLength;
    ubyte[1] Data;
}

struct NOTIFY_USER_POWER_SETTING
{
    GUID Guid;
}

struct APPLICATIONLAUNCH_SETTING_VALUE
{
    LARGE_INTEGER ActivationTime;
    uint          Flags;
    uint          ButtonInstanceID;
}

struct POWER_PLATFORM_INFORMATION
{
    ubyte AoAc;
}

///Contains the granularity of the battery capacity that is reported by IOCTL_BATTERY_QUERY_STATUS. A variable-length
///array of <b>BATTERY_REPORTING_SCALE</b> structures is returned from IOCTL_BATTERY_QUERY_INFORMATION when the
///<b>InformationLevel</b> is set to <b>BatteryGranularityInformation</b>. Multiple entries are returned when the
///granularity depends on the present capacity of the battery.
struct BATTERY_REPORTING_SCALE
{
    ///The granularity of the capacity reading returned by IOCTL_BATTERY_QUERY_STATUS in milliwatt-hours (mWh).
    ///Granularity may change over time as battery discharge and recharge lowers the range of readings.
    uint Granularity;
    ///The upper capacity limit for <i>Granularity</i>. The value of <i>Granularity</i> is valid for capacities reported
    ///by IOCTL_BATTERY_QUERY_STATUS that are less than or equal to this capacity (mWh), but greater than or equal to
    ///the capacity given in the previous array element, or zero if this is the first array element.
    uint Capacity;
}

struct PPM_WMI_LEGACY_PERFSTATE
{
    uint Frequency;
    uint Flags;
    uint PercentFrequency;
}

struct PPM_WMI_IDLE_STATE
{
    uint  Latency;
    uint  Power;
    uint  TimeCheck;
    ubyte PromotePercent;
    ubyte DemotePercent;
    ubyte StateType;
    ubyte Reserved;
    uint  StateFlags;
    uint  Context;
    uint  IdleHandler;
    uint  Reserved1;
}

struct PPM_WMI_IDLE_STATES
{
    uint  Type;
    uint  Count;
    uint  TargetState;
    uint  OldState;
    ulong TargetProcessors;
    PPM_WMI_IDLE_STATE[1] State;
}

struct PPM_WMI_IDLE_STATES_EX
{
    uint  Type;
    uint  Count;
    uint  TargetState;
    uint  OldState;
    void* TargetProcessors;
    PPM_WMI_IDLE_STATE[1] State;
}

struct PPM_WMI_PERF_STATE
{
    uint  Frequency;
    uint  Power;
    ubyte PercentFrequency;
    ubyte IncreaseLevel;
    ubyte DecreaseLevel;
    ubyte Type;
    uint  IncreaseTime;
    uint  DecreaseTime;
    ulong Control;
    ulong Status;
    uint  HitCount;
    uint  Reserved1;
    ulong Reserved2;
    ulong Reserved3;
}

struct PPM_WMI_PERF_STATES
{
    uint  Count;
    uint  MaxFrequency;
    uint  CurrentState;
    uint  MaxPerfState;
    uint  MinPerfState;
    uint  LowestPerfState;
    uint  ThermalConstraint;
    ubyte BusyAdjThreshold;
    ubyte PolicyType;
    ubyte Type;
    ubyte Reserved;
    uint  TimerInterval;
    ulong TargetProcessors;
    uint  PStateHandler;
    uint  PStateContext;
    uint  TStateHandler;
    uint  TStateContext;
    uint  FeedbackHandler;
    uint  Reserved1;
    ulong Reserved2;
    PPM_WMI_PERF_STATE[1] State;
}

struct PPM_WMI_PERF_STATES_EX
{
    uint  Count;
    uint  MaxFrequency;
    uint  CurrentState;
    uint  MaxPerfState;
    uint  MinPerfState;
    uint  LowestPerfState;
    uint  ThermalConstraint;
    ubyte BusyAdjThreshold;
    ubyte PolicyType;
    ubyte Type;
    ubyte Reserved;
    uint  TimerInterval;
    void* TargetProcessors;
    uint  PStateHandler;
    uint  PStateContext;
    uint  TStateHandler;
    uint  TStateContext;
    uint  FeedbackHandler;
    uint  Reserved1;
    ulong Reserved2;
    PPM_WMI_PERF_STATE[1] State;
}

struct PPM_IDLE_STATE_ACCOUNTING
{
    uint    IdleTransitions;
    uint    FailedTransitions;
    uint    InvalidBucketIndex;
    ulong   TotalTime;
    uint[6] IdleTimeBuckets;
}

struct PPM_IDLE_ACCOUNTING
{
    uint  StateCount;
    uint  TotalTransitions;
    uint  ResetCount;
    ulong StartTime;
    PPM_IDLE_STATE_ACCOUNTING[1] State;
}

struct PPM_IDLE_STATE_BUCKET_EX
{
    ulong TotalTimeUs;
    uint  MinTimeUs;
    uint  MaxTimeUs;
    uint  Count;
}

struct PPM_IDLE_STATE_ACCOUNTING_EX
{
    ulong TotalTime;
    uint  IdleTransitions;
    uint  FailedTransitions;
    uint  InvalidBucketIndex;
    uint  MinTimeUs;
    uint  MaxTimeUs;
    uint  CancelledTransitions;
    PPM_IDLE_STATE_BUCKET_EX[16] IdleTimeBuckets;
}

struct PPM_IDLE_ACCOUNTING_EX
{
    uint  StateCount;
    uint  TotalTransitions;
    uint  ResetCount;
    uint  AbortCount;
    ulong StartTime;
    PPM_IDLE_STATE_ACCOUNTING_EX[1] State;
}

struct PPM_PERFSTATE_EVENT
{
    uint State;
    uint Status;
    uint Latency;
    uint Speed;
    uint Processor;
}

struct PPM_PERFSTATE_DOMAIN_EVENT
{
    uint  State;
    uint  Latency;
    uint  Speed;
    ulong Processors;
}

struct PPM_IDLESTATE_EVENT
{
    uint  NewState;
    uint  OldState;
    ulong Processors;
}

struct PPM_THERMALCHANGE_EVENT
{
    uint  ThermalConstraint;
    ulong Processors;
}

struct PPM_THERMAL_POLICY_EVENT
{
    ubyte Mode;
    ulong Processors;
}

///Contains information used to set the system power state.
struct POWER_ACTION_POLICY
{
    ///The requested system power state. This member must be one of the POWER_ACTION enumeration type values.
    POWER_ACTION Action;
    ///A flag that controls how to switch the power state. This member can be one or more of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="POWER_ACTION_CRITICAL"></a><a
    ///id="power_action_critical"></a><dl> <dt><b>POWER_ACTION_CRITICAL</b></dt> <dt>0x80000000</dt> </dl> </td> <td
    ///width="60%"> Forces a critical suspension. </td> </tr> <tr> <td width="40%"><a
    ///id="POWER_ACTION_DISABLE_WAKES"></a><a id="power_action_disable_wakes"></a><dl>
    ///<dt><b>POWER_ACTION_DISABLE_WAKES</b></dt> <dt>0x40000000</dt> </dl> </td> <td width="60%"> Disables all wake
    ///events. </td> </tr> <tr> <td width="40%"><a id="POWER_ACTION_LIGHTEST_FIRST"></a><a
    ///id="power_action_lightest_first"></a><dl> <dt><b>POWER_ACTION_LIGHTEST_FIRST</b></dt> <dt>0x10000000</dt> </dl>
    ///</td> <td width="60%"> Uses the first lightest available sleep state. </td> </tr> <tr> <td width="40%"><a
    ///id="POWER_ACTION_LOCK_CONSOLE"></a><a id="power_action_lock_console"></a><dl>
    ///<dt><b>POWER_ACTION_LOCK_CONSOLE</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%"> Requires entry of the
    ///system password upon resume from one of the system standby states. </td> </tr> <tr> <td width="40%"><a
    ///id="POWER_ACTION_OVERRIDE_APPS"></a><a id="power_action_override_apps"></a><dl>
    ///<dt><b>POWER_ACTION_OVERRIDE_APPS</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Has no effect. </td>
    ///</tr> <tr> <td width="40%"><a id="POWER_ACTION_QUERY_ALLOWED"></a><a id="power_action_query_allowed"></a><dl>
    ///<dt><b>POWER_ACTION_QUERY_ALLOWED</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Has no effect. </td>
    ///</tr> <tr> <td width="40%"><a id="POWER_ACTION_UI_ALLOWED"></a><a id="power_action_ui_allowed"></a><dl>
    ///<dt><b>POWER_ACTION_UI_ALLOWED</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Applications can prompt
    ///the user for directions on how to prepare for suspension. Sets bit 0 in the <i>Flags</i> parameter passed in the
    ///<i>lParam</i> parameter of WM_POWERBROADCAST. </td> </tr> </table>
    uint         Flags;
    ///The level of user notification. This member can be one or more of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="POWER_FORCE_TRIGGER_RESET"></a><a
    ///id="power_force_trigger_reset"></a><dl> <dt><b>POWER_FORCE_TRIGGER_RESET</b></dt> <dt>0x80000000</dt> </dl> </td>
    ///<td width="60%"> Clears a user power button press. </td> </tr> <tr> <td width="40%"><a
    ///id="POWER_LEVEL_USER_NOTIFY_EXEC"></a><a id="power_level_user_notify_exec"></a><dl>
    ///<dt><b>POWER_LEVEL_USER_NOTIFY_EXEC</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Specifies a program
    ///to be executed. </td> </tr> <tr> <td width="40%"><a id="POWER_LEVEL_USER_NOTIFY_SOUND"></a><a
    ///id="power_level_user_notify_sound"></a><dl> <dt><b>POWER_LEVEL_USER_NOTIFY_SOUND</b></dt> <dt>0x00000002</dt>
    ///</dl> </td> <td width="60%"> User notified using sound. </td> </tr> <tr> <td width="40%"><a
    ///id="POWER_LEVEL_USER_NOTIFY_TEXT"></a><a id="power_level_user_notify_text"></a><dl>
    ///<dt><b>POWER_LEVEL_USER_NOTIFY_TEXT</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> User notified using
    ///the UI. </td> </tr> <tr> <td width="40%"><a id="POWER_USER_NOTIFY_BUTTON"></a><a
    ///id="power_user_notify_button"></a><dl> <dt><b>POWER_USER_NOTIFY_BUTTON</b></dt> <dt>0x00000008</dt> </dl> </td>
    ///<td width="60%"> Indicates that the power action is in response to a user power button press. </td> </tr> <tr>
    ///<td width="40%"><a id="POWER_USER_NOTIFY_SHUTDOWN"></a><a id="power_user_notify_shutdown"></a><dl>
    ///<dt><b>POWER_USER_NOTIFY_SHUTDOWN</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Indicates a power
    ///action of shutdown/off. </td> </tr> </table>
    uint         EventCode;
}

///Contains information about system battery drain policy settings. This structure is part of the
///GLOBAL_USER_POWER_POLICY structure.
struct SYSTEM_POWER_LEVEL
{
    ///If this member is <b>TRUE</b>, the alarm should be activated when the battery discharges below the value set in
    ///<b>BatteryLevel</b>.
    ubyte               Enable;
    ///Reserved.
    ubyte[3]            Spare;
    ///The battery capacity for this battery discharge policy, expressed as a percentage.
    uint                BatteryLevel;
    ///A POWER_ACTION_POLICY structure that defines the action to take for this battery discharge policy.
    POWER_ACTION_POLICY PowerPolicy;
    ///The minimum system sleep state to enter when the battery discharges below the value set in <b>BatteryLevel</b>.
    ///This member must be one of the SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE  MinSystemState;
}

///Contains information about the current system power policy.
struct SYSTEM_POWER_POLICY
{
    ///The current structure revision.
    uint                Revision;
    ///A POWER_ACTION_POLICY structure that defines the system power action to initiate when the system power button is
    ///pressed.
    POWER_ACTION_POLICY PowerButton;
    ///A POWER_ACTION_POLICY structure that defines the system power action to initiate when the system sleep button is
    ///pressed.
    POWER_ACTION_POLICY SleepButton;
    ///A POWER_ACTION_POLICY structure that defines the system power action to initiate when the system lid switch is
    ///closed.
    POWER_ACTION_POLICY LidClose;
    ///The maximum power state (highest Sx value) from which a lid-open event should wake the system. This member must
    ///be one of the SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE  LidOpenWake;
    ///Reserved.
    uint                Reserved;
    ///A POWER_ACTION_POLICY structure that defines the system power action to initiate when the system idle timer
    ///expires.
    POWER_ACTION_POLICY Idle;
    ///The time that the level of system activity must remain below the idle detection threshold before the system idle
    ///timer expires, in seconds.
    uint                IdleTimeout;
    ///The level of system activity that defines the threshold for idle detection, expressed as a percentage.
    ubyte               IdleSensitivity;
    ///The current system processor dynamic throttling policy. This member must be one of the values described in
    ///Processor Performance Control Policy Constants.
    ubyte               DynamicThrottle;
    ///Reserved.
    ubyte[2]            Spare2;
    ///The minimum system sleep state (lowest Sx value) currently supported. This member must be one of the
    ///SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE  MinSleep;
    ///The maximum system sleep state (highest Sx value) currently supported. This member must be one of the
    ///SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE  MaxSleep;
    ///The system power state (Sx value) to enter on a system sleep action when there are outstanding latency
    ///requirements. This member must be one of the SYSTEM_POWER_STATE enumeration type values. If an application calls
    ///RequestWakeupLatency with LT_LOWEST_LATENCY, <b>ReducedLatencySleep</b> will be used in place of <b>MaxSleep</b>.
    SYSTEM_POWER_STATE  ReducedLatencySleep;
    ///This member can be zero or WINLOGON_LOCK_ON_SLEEP (0x00000001).
    uint                WinLogonFlags;
    ///Reserved.
    uint                Spare3;
    ///The time to wait between entering the suspend state and entering the hibernate sleeping state, in seconds. A
    ///value of zero indicates never hibernate.
    uint                DozeS4Timeout;
    ///The resolution of change in current battery capacity that should cause the system to be notified of a system
    ///power state changed event.
    uint                BroadcastCapacityResolution;
    ///An array of SYSTEM_POWER_LEVEL structures that defines the actions to take at system battery discharge events.
    SYSTEM_POWER_LEVEL[4] DischargePolicy;
    ///The time before the display is turned off, in seconds.
    uint                VideoTimeout;
    ///If this member is <b>TRUE</b>, the system includes support for display dimming.
    ubyte               VideoDimDisplay;
    ///Reserved.
    uint[3]             VideoReserved;
    ///The time before power to fixed disk drives is turned off, in seconds.
    uint                SpindownTimeout;
    ///If this member is <b>TRUE</b>, the system will turn on cooling fans and run the processor at full speed when
    ///passive cooling is specified. This causes the operating system to be biased toward using the fan and running the
    ///processor at full speed.
    ubyte               OptimizeForPower;
    ///The lower limit that the processor may be throttled down to prior to turning on system fans in response to a
    ///thermal event, expressed as a percentage.
    ubyte               FanThrottleTolerance;
    ///The processor throttle level to be imposed by the system, expressed as a percentage.
    ubyte               ForcedThrottle;
    ///The minimum processor throttle level, expressed as a percentage.
    ubyte               MinThrottle;
    ///A POWER_ACTION_POLICY structure that defines the system power action to initiate in response to a thermal event
    ///when processor throttling is unable to adequately reduce the system temperature.
    POWER_ACTION_POLICY OverThrottled;
}

struct PROCESSOR_IDLESTATE_INFO
{
    uint     TimeCheck;
    ubyte    DemotePercent;
    ubyte    PromotePercent;
    ubyte[2] Spare;
}

struct PROCESSOR_IDLESTATE_POLICY
{
    ushort Revision;
union Flags
    {
        ushort AsWORD;
struct
        {
            ushort _bitfield150;
        }
    }
    uint   PolicyCount;
    PROCESSOR_IDLESTATE_INFO[3] Policy;
}

///Contains information about processor C-state policy settings. This structure is part of the PROCESSOR_POWER_POLICY
///structure.
struct PROCESSOR_POWER_POLICY_INFO
{
    ///The time that must expire before promotion or demotion is considered, in microseconds.
    uint     TimeCheck;
    ///The minimum amount of time that must be spent in the idle loop to avoid demotion, in microseconds.
    uint     DemoteLimit;
    ///The time that must be exceeded to cause promotion to a deeper idle state, in microseconds.
    uint     PromoteLimit;
    ///The value that scales the threshold at which the power policy manager decreases the performance of the processor,
    ///expressed as a percentage.
    ubyte    DemotePercent;
    ///The value that scales the threshold at which the power policy manager increases the performance of the processor,
    ///expressed as a percentage.
    ubyte    PromotePercent;
    ///Reserved.
    ubyte[2] Spare;
    uint     _bitfield151;
}

///Contains information about processor performance control and C-states.
struct PROCESSOR_POWER_POLICY
{
    ///The current structure revision level. Set this value by calling ReadProcessorPwrScheme before using a
    ///<b>PROCESSOR_POWER_POLICY</b> structure to set power policy.
    uint     Revision;
    ///The current processor performance state policy. This member must be one of the values described in Processor
    ///Performance Control Policy Constants.
    ubyte    DynamicThrottle;
    ///Reserved; set to zero.
    ubyte[3] Spare;
    uint     _bitfield152;
    ///The number of elements in the <b>Policy</b> array.
    uint     PolicyCount;
    ///An array of PROCESSOR_POWER_POLICY_INFO structures that defines values used to apply processor C-state policy
    ///settings. Policy[0] corresponds to ACPI C-state C1, Policy[1] corresponds to C2, and Policy[2] corresponds to C3.
    ///The <b>AllowPromotion</b> member determines whether the processor can be promoted to the state. For example, if
    ///Policy[0].AllowPromotion is 0, the computer cannot transition from C0 to C1.
    PROCESSOR_POWER_POLICY_INFO[3] Policy;
}

struct PROCESSOR_PERFSTATE_POLICY
{
    uint  Revision;
    ubyte MaxThrottle;
    ubyte MinThrottle;
    ubyte BusyAdjThreshold;
union
    {
        ubyte Spare;
union Flags
        {
            ubyte AsBYTE;
struct
            {
                ubyte _bitfield153;
            }
        }
    }
    uint  TimeCheck;
    uint  IncreaseTime;
    uint  DecreaseTime;
    uint  IncreasePercent;
    uint  DecreasePercent;
}

///Represents the administrator override power policy settings.
struct ADMINISTRATOR_POWER_POLICY
{
    ///The minimum system power sleep state. This member must be one of the SYSTEM_POWER_STATE enumeration type values
    ///between <b>PowerSystemSleeping1</b> (power state S1) and <b>PowerSystemHibernate</b> (power state S4).
    SYSTEM_POWER_STATE MinSleep;
    ///The maximum system power sleep state. This member must be one of the SYSTEM_POWER_STATE enumeration type values
    ///between <b>PowerSystemSleeping1</b> (power state S1) and <b>PowerSystemHibernate</b> (power state S4).
    SYSTEM_POWER_STATE MaxSleep;
    ///The minimum allowable video idle time-out before turning the display device off, in seconds.
    uint               MinVideoTimeout;
    ///The maximum allowable video idle time-out before turning the display device off, in seconds.
    uint               MaxVideoTimeout;
    ///The minimum allowable disk idle time before flushing the cache manager and spinning down a hard disk device, in
    ///seconds.
    uint               MinSpindownTimeout;
    ///The maximum allowable disk idle time before flushing the cache manager and spinning down a hard disk device, in
    ///seconds.
    uint               MaxSpindownTimeout;
}

struct HIBERFILE_BUCKET
{
    ulong   MaxPhysicalMemory;
    uint[3] PhysicalMemoryPercent;
}

///Contains information about the power capabilities of the system.
struct SYSTEM_POWER_CAPABILITIES
{
    ///If this member is <b>TRUE</b>, there is a system power button.
    ubyte              PowerButtonPresent;
    ///If this member is <b>TRUE</b>, there is a system sleep button.
    ubyte              SleepButtonPresent;
    ///If this member is <b>TRUE</b>, there is a lid switch.
    ubyte              LidPresent;
    ///If this member is <b>TRUE</b>, the operating system supports sleep state S1.
    ubyte              SystemS1;
    ///If this member is <b>TRUE</b>, the operating system supports sleep state S2.
    ubyte              SystemS2;
    ///If this member is <b>TRUE</b>, the operating system supports sleep state S3.
    ubyte              SystemS3;
    ///If this member is <b>TRUE</b>, the operating system supports sleep state S4 (hibernation).
    ubyte              SystemS4;
    ///If this member is <b>TRUE</b>, the operating system supports power off state S5 (soft off).
    ubyte              SystemS5;
    ///If this member is <b>TRUE</b>, the system hibernation file is present.
    ubyte              HiberFilePresent;
    ///If this member is <b>TRUE</b>, the system supports wake capabilities.
    ubyte              FullWake;
    ///If this member is <b>TRUE</b>, the system supports video display dimming capabilities.
    ubyte              VideoDimPresent;
    ///If this member is <b>TRUE</b>, the system supports APM BIOS power management features.
    ubyte              ApmPresent;
    ///If this member is <b>TRUE</b>, there is an uninterruptible power supply (UPS).
    ubyte              UpsPresent;
    ///If this member is <b>TRUE</b>, the system supports thermal zones.
    ubyte              ThermalControl;
    ///If this member is <b>TRUE</b>, the system supports processor throttling.
    ubyte              ProcessorThrottle;
    ///The minimum level of system processor throttling supported, expressed as a percentage.
    ubyte              ProcessorMinThrottle;
    ///The maximum level of system processor throttling supported, expressed as a percentage.
    ubyte              ProcessorMaxThrottle;
    ///If this member is <b>TRUE</b>, the system supports the hybrid sleep state.
    ubyte              FastSystemS4;
    ubyte              Hiberboot;
    ///If this member is <b>TRUE</b>, the platform has support for ACPI wake alarm devices. For more details on wake
    ///alarm devices, please see the ACPI specification section 9.18.
    ubyte              WakeAlarmPresent;
    ///If this member is <b>TRUE</b>, the system supports the S0 low power idle model.
    ubyte              AoAc;
    ///If this member is <b>TRUE</b>, the system supports allowing the removal of power to fixed disk devices.
    ubyte              DiskSpinDown;
    ubyte              HiberFileType;
    ubyte              AoAcConnectivitySupported;
    ///Reserved.
    ubyte[6]           spare3;
    ///If this member is <b>TRUE</b>, there are one or more batteries in the system.
    ubyte              SystemBatteriesPresent;
    ///If this member is <b>TRUE</b>, the system batteries are short-term. Short-term batteries are used in
    ///uninterruptible power supplies (UPS).
    ubyte              BatteriesAreShortTerm;
    ///A BATTERY_REPORTING_SCALE structure that contains information about how system battery metrics are reported.
    BATTERY_REPORTING_SCALE[3] BatteryScale;
    ///The lowest system sleep state (Sx) that will generate a wake event when the system is on AC power. This member
    ///must be one of the SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE AcOnLineWake;
    ///The lowest system sleep state (Sx) that will generate a wake event via the lid switch. This member must be one of
    ///the SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE SoftLidWake;
    ///The lowest system sleep state (Sx) supported by hardware that will generate a wake event via the Real Time Clock
    ///(RTC). This member must be one of the SYSTEM_POWER_STATE enumeration type values. To wake the computer using the
    ///RTC, the operating system must also support waking from the sleep state the computer is in when the RTC generates
    ///the wake event. Therefore, the effective lowest sleep state from which an RTC wake event can wake the computer is
    ///the lowest sleep state supported by the operating system that is equal to or higher than the value of
    ///<b>RtcWake</b>. To determine the sleep states that the operating system supports, check the <b>SystemS1</b>,
    ///<b>SystemS2</b>, <b>SystemS3</b>, and <b>SystemS4</b> members.
    SYSTEM_POWER_STATE RtcWake;
    ///The minimum allowable system power state supporting wake events. This member must be one of the
    ///SYSTEM_POWER_STATE enumeration type values. Note that this state may change as different device drivers are
    ///installed on the system.
    SYSTEM_POWER_STATE MinDeviceWakeState;
    ///The default system power state used if an application calls RequestWakeupLatency with <b>LT_LOWEST_LATENCY</b>.
    ///This member must be one of the SYSTEM_POWER_STATE enumeration type values.
    SYSTEM_POWER_STATE DefaultLowLatencyWake;
}

///Contains information about the current state of the system battery.
struct SYSTEM_BATTERY_STATE
{
    ///If this member is <b>TRUE</b>, the system battery charger is currently operating on external power.
    ubyte    AcOnLine;
    ///If this member is <b>TRUE</b>, at least one battery is present in the system.
    ubyte    BatteryPresent;
    ///If this member is <b>TRUE</b>, a battery is currently charging.
    ubyte    Charging;
    ///If this member is <b>TRUE</b>, a battery is currently discharging.
    ubyte    Discharging;
    ///Reserved.
    ubyte[3] Spare1;
    ubyte    Tag;
    ///The theoretical capacity of the battery when new.
    uint     MaxCapacity;
    ///The estimated remaining capacity of the battery.
    uint     RemainingCapacity;
    ///The current rate of discharge of the battery, in mW. A nonzero, positive rate indicates charging; a negative rate
    ///indicates discharging. Some batteries report only discharging rates. This value should be treated as a
    ///<b>LONG</b> as it can contain negative values (with the high bit set).
    uint     Rate;
    ///The estimated time remaining on the battery, in seconds.
    uint     EstimatedTime;
    ///The manufacturer's suggestion of a capacity, in mWh, at which a low battery alert should occur. Definitions of
    ///low vary from manufacturer to manufacturer. In general, a warning state will occur before a low state, but you
    ///should not assume that it always will. To reduce risk of data loss, this value is usually used as the default
    ///setting for the critical battery alarm.
    uint     DefaultAlert1;
    ///The manufacturer's suggestion of a capacity, in mWh, at which a warning battery alert should occur. Definitions
    ///of warning vary from manufacturer to manufacturer. In general, a warning state will occur before a low state, but
    ///you should not assume that it always will. To reduce risk of data loss, this value is usually used as the default
    ///setting for the low battery alarm.
    uint     DefaultAlert2;
}

struct IMAGE_DOS_HEADER
{
align (2):
    ushort     e_magic;
    ushort     e_cblp;
    ushort     e_cp;
    ushort     e_crlc;
    ushort     e_cparhdr;
    ushort     e_minalloc;
    ushort     e_maxalloc;
    ushort     e_ss;
    ushort     e_sp;
    ushort     e_csum;
    ushort     e_ip;
    ushort     e_cs;
    ushort     e_lfarlc;
    ushort     e_ovno;
    ushort[4]  e_res;
    ushort     e_oemid;
    ushort     e_oeminfo;
    ushort[10] e_res2;
    int        e_lfanew;
}

struct IMAGE_OS2_HEADER
{
align (2):
    ushort ne_magic;
    byte   ne_ver;
    byte   ne_rev;
    ushort ne_enttab;
    ushort ne_cbenttab;
    int    ne_crc;
    ushort ne_flags;
    ushort ne_autodata;
    ushort ne_heap;
    ushort ne_stack;
    int    ne_csip;
    int    ne_sssp;
    ushort ne_cseg;
    ushort ne_cmod;
    ushort ne_cbnrestab;
    ushort ne_segtab;
    ushort ne_rsrctab;
    ushort ne_restab;
    ushort ne_modtab;
    ushort ne_imptab;
    int    ne_nrestab;
    ushort ne_cmovent;
    ushort ne_align;
    ushort ne_cres;
    ubyte  ne_exetyp;
    ubyte  ne_flagsothers;
    ushort ne_pretthunks;
    ushort ne_psegrefbytes;
    ushort ne_swaparea;
    ushort ne_expver;
}

struct IMAGE_VXD_HEADER
{
align (2):
    ushort    e32_magic;
    ubyte     e32_border;
    ubyte     e32_worder;
    uint      e32_level;
    ushort    e32_cpu;
    ushort    e32_os;
    uint      e32_ver;
    uint      e32_mflags;
    uint      e32_mpages;
    uint      e32_startobj;
    uint      e32_eip;
    uint      e32_stackobj;
    uint      e32_esp;
    uint      e32_pagesize;
    uint      e32_lastpagesize;
    uint      e32_fixupsize;
    uint      e32_fixupsum;
    uint      e32_ldrsize;
    uint      e32_ldrsum;
    uint      e32_objtab;
    uint      e32_objcnt;
    uint      e32_objmap;
    uint      e32_itermap;
    uint      e32_rsrctab;
    uint      e32_rsrccnt;
    uint      e32_restab;
    uint      e32_enttab;
    uint      e32_dirtab;
    uint      e32_dircnt;
    uint      e32_fpagetab;
    uint      e32_frectab;
    uint      e32_impmod;
    uint      e32_impmodcnt;
    uint      e32_impproc;
    uint      e32_pagesum;
    uint      e32_datapage;
    uint      e32_preload;
    uint      e32_nrestab;
    uint      e32_cbnrestab;
    uint      e32_nressum;
    uint      e32_autodata;
    uint      e32_debuginfo;
    uint      e32_debuglen;
    uint      e32_instpreload;
    uint      e32_instdemand;
    uint      e32_heapsize;
    ubyte[12] e32_res3;
    uint      e32_winresoff;
    uint      e32_winreslen;
    ushort    e32_devid;
    ushort    e32_ddkver;
}

///Represents the optional header format.
struct IMAGE_OPTIONAL_HEADER
{
    ///The state of the image file. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IMAGE_NT_OPTIONAL_HDR_MAGIC"></a><a
    ///id="image_nt_optional_hdr_magic"></a><dl> <dt><b>IMAGE_NT_OPTIONAL_HDR_MAGIC</b></dt> </dl> </td> <td
    ///width="60%"> The file is an executable image. This value is defined as <b>IMAGE_NT_OPTIONAL_HDR32_MAGIC</b> in a
    ///32-bit application and as <b>IMAGE_NT_OPTIONAL_HDR64_MAGIC</b> in a 64-bit application. </td> </tr> <tr> <td
    ///width="40%"><a id="IMAGE_NT_OPTIONAL_HDR32_MAGIC"></a><a id="image_nt_optional_hdr32_magic"></a><dl>
    ///<dt><b>IMAGE_NT_OPTIONAL_HDR32_MAGIC</b></dt> <dt>0x10b</dt> </dl> </td> <td width="60%"> The file is an
    ///executable image. </td> </tr> <tr> <td width="40%"><a id="IMAGE_NT_OPTIONAL_HDR64_MAGIC"></a><a
    ///id="image_nt_optional_hdr64_magic"></a><dl> <dt><b>IMAGE_NT_OPTIONAL_HDR64_MAGIC</b></dt> <dt>0x20b</dt> </dl>
    ///</td> <td width="60%"> The file is an executable image. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_ROM_OPTIONAL_HDR_MAGIC"></a><a id="image_rom_optional_hdr_magic"></a><dl>
    ///<dt><b>IMAGE_ROM_OPTIONAL_HDR_MAGIC</b></dt> <dt>0x107</dt> </dl> </td> <td width="60%"> The file is a ROM image.
    ///</td> </tr> </table>
    ushort Magic;
    ///The major version number of the linker.
    ubyte  MajorLinkerVersion;
    ///The minor version number of the linker.
    ubyte  MinorLinkerVersion;
    ///The size of the code section, in bytes, or the sum of all such sections if there are multiple code sections.
    uint   SizeOfCode;
    ///The size of the initialized data section, in bytes, or the sum of all such sections if there are multiple
    ///initialized data sections.
    uint   SizeOfInitializedData;
    ///The size of the uninitialized data section, in bytes, or the sum of all such sections if there are multiple
    ///uninitialized data sections.
    uint   SizeOfUninitializedData;
    ///A pointer to the entry point function, relative to the image base address. For executable files, this is the
    ///starting address. For device drivers, this is the address of the initialization function. The entry point
    ///function is optional for DLLs. When no entry point is present, this member is zero.
    uint   AddressOfEntryPoint;
    ///A pointer to the beginning of the code section, relative to the image base.
    uint   BaseOfCode;
    ///A pointer to the beginning of the data section, relative to the image base.
    uint   BaseOfData;
    ///The preferred address of the first byte of the image when it is loaded in memory. This value is a multiple of 64K
    ///bytes. The default value for DLLs is 0x10000000. The default value for applications is 0x00400000, except on
    ///Windows CE where it is 0x00010000.
    uint   ImageBase;
    ///The alignment of sections loaded in memory, in bytes. This value must be greater than or equal to the
    ///<b>FileAlignment</b> member. The default value is the page size for the system.
    uint   SectionAlignment;
    ///The alignment of the raw data of sections in the image file, in bytes. The value should be a power of 2 between
    ///512 and 64K (inclusive). The default is 512. If the <b>SectionAlignment</b> member is less than the system page
    ///size, this member must be the same as <b>SectionAlignment</b>.
    uint   FileAlignment;
    ///The major version number of the required operating system.
    ushort MajorOperatingSystemVersion;
    ///The minor version number of the required operating system.
    ushort MinorOperatingSystemVersion;
    ///The major version number of the image.
    ushort MajorImageVersion;
    ///The minor version number of the image.
    ushort MinorImageVersion;
    ///The major version number of the subsystem.
    ushort MajorSubsystemVersion;
    ///The minor version number of the subsystem.
    ushort MinorSubsystemVersion;
    ///This member is reserved and must be 0.
    uint   Win32VersionValue;
    ///The size of the image, in bytes, including all headers. Must be a multiple of <b>SectionAlignment</b>.
    uint   SizeOfImage;
    ///The combined size of the following items, rounded to a multiple of the value specified in the
    ///<b>FileAlignment</b> member. <ul> <li><b>e_lfanew</b> member of <b>IMAGE_DOS_HEADER</b></li> <li>4 byte
    ///signature</li> <li>size of IMAGE_FILE_HEADER </li> <li>size of optional header</li> <li>size of all section
    ///headers</li> </ul>
    uint   SizeOfHeaders;
    ///The image file checksum. The following files are validated at load time: all drivers, any DLL loaded at boot
    ///time, and any DLL loaded into a critical system process.
    uint   CheckSum;
    ///The subsystem required to run this image. The following values are defined. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IMAGE_SUBSYSTEM_UNKNOWN"></a><a
    ///id="image_subsystem_unknown"></a><dl> <dt><b>IMAGE_SUBSYSTEM_UNKNOWN</b></dt> <dt>0</dt> </dl> </td> <td
    ///width="60%"> Unknown subsystem. </td> </tr> <tr> <td width="40%"><a id="IMAGE_SUBSYSTEM_NATIVE"></a><a
    ///id="image_subsystem_native"></a><dl> <dt><b>IMAGE_SUBSYSTEM_NATIVE</b></dt> <dt>1</dt> </dl> </td> <td
    ///width="60%"> No subsystem required (device drivers and native system processes). </td> </tr> <tr> <td
    ///width="40%"><a id="IMAGE_SUBSYSTEM_WINDOWS_GUI"></a><a id="image_subsystem_windows_gui"></a><dl>
    ///<dt><b>IMAGE_SUBSYSTEM_WINDOWS_GUI</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Windows graphical user
    ///interface (GUI) subsystem. </td> </tr> <tr> <td width="40%"><a id="IMAGE_SUBSYSTEM_WINDOWS_CUI"></a><a
    ///id="image_subsystem_windows_cui"></a><dl> <dt><b>IMAGE_SUBSYSTEM_WINDOWS_CUI</b></dt> <dt>3</dt> </dl> </td> <td
    ///width="60%"> Windows character-mode user interface (CUI) subsystem. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_SUBSYSTEM_OS2_CUI"></a><a id="image_subsystem_os2_cui"></a><dl> <dt><b>IMAGE_SUBSYSTEM_OS2_CUI</b></dt>
    ///<dt>5</dt> </dl> </td> <td width="60%"> OS/2 CUI subsystem. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_SUBSYSTEM_POSIX_CUI"></a><a id="image_subsystem_posix_cui"></a><dl>
    ///<dt><b>IMAGE_SUBSYSTEM_POSIX_CUI</b></dt> <dt>7</dt> </dl> </td> <td width="60%"> POSIX CUI subsystem. </td>
    ///</tr> <tr> <td width="40%"><a id="IMAGE_SUBSYSTEM_WINDOWS_CE_GUI"></a><a
    ///id="image_subsystem_windows_ce_gui"></a><dl> <dt><b>IMAGE_SUBSYSTEM_WINDOWS_CE_GUI</b></dt> <dt>9</dt> </dl>
    ///</td> <td width="60%"> Windows CE system. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_SUBSYSTEM_EFI_APPLICATION"></a><a id="image_subsystem_efi_application"></a><dl>
    ///<dt><b>IMAGE_SUBSYSTEM_EFI_APPLICATION</b></dt> <dt>10</dt> </dl> </td> <td width="60%"> Extensible Firmware
    ///Interface (EFI) application. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER"></a><a id="image_subsystem_efi_boot_service_driver"></a><dl>
    ///<dt><b>IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER</b></dt> <dt>11</dt> </dl> </td> <td width="60%"> EFI driver with
    ///boot services. </td> </tr> <tr> <td width="40%"><a id="IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER"></a><a
    ///id="image_subsystem_efi_runtime_driver"></a><dl> <dt><b>IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER</b></dt> <dt>12</dt>
    ///</dl> </td> <td width="60%"> EFI driver with run-time services. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_SUBSYSTEM_EFI_ROM"></a><a id="image_subsystem_efi_rom"></a><dl> <dt><b>IMAGE_SUBSYSTEM_EFI_ROM</b></dt>
    ///<dt>13</dt> </dl> </td> <td width="60%"> EFI ROM image. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_SUBSYSTEM_XBOX"></a><a id="image_subsystem_xbox"></a><dl> <dt><b>IMAGE_SUBSYSTEM_XBOX</b></dt>
    ///<dt>14</dt> </dl> </td> <td width="60%"> Xbox system. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION"></a><a id="image_subsystem_windows_boot_application"></a><dl>
    ///<dt><b>IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> Boot
    ///application. </td> </tr> </table>
    ushort Subsystem;
    ///The DLL characteristics of the image. The following values are defined. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0x0001</dt> </dl> </td> <td width="60%"> Reserved. </td>
    ///</tr> <tr> <td width="40%"> <dl> <dt>0x0002</dt> </dl> </td> <td width="60%"> Reserved. </td> </tr> <tr> <td
    ///width="40%"> <dl> <dt>0x0004</dt> </dl> </td> <td width="60%"> Reserved. </td> </tr> <tr> <td width="40%"> <dl>
    ///<dt>0x0008</dt> </dl> </td> <td width="60%"> Reserved. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA"></a><a id="image_dll_characteristics_high_entropy_va"></a><dl>
    ///<dt><b>IMAGE_DLL_CHARACTERISTICS_HIGH_ENTROPY_VA</b></dt> <dt>0x0020</dt> </dl> </td> <td width="60%"> ASLR with
    ///64 bit address space. </td> </tr> <tr> <td width="40%"><a id="IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE"></a><a
    ///id="image_dllcharacteristics_dynamic_base"></a><dl> <dt><b>IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE</b></dt>
    ///<dt>0x0040</dt> </dl> </td> <td width="60%"> The DLL can be relocated at load time. </td> </tr> <tr> <td
    ///width="40%"><a id="IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY"></a><a
    ///id="image_dllcharacteristics_force_integrity"></a><dl> <dt><b>IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY</b></dt>
    ///<dt>0x0080</dt> </dl> </td> <td width="60%"> Code integrity checks are forced. If you set this flag and a section
    ///contains only uninitialized data, set the <b>PointerToRawData</b> member of IMAGE_SECTION_HEADER for that section
    ///to zero; otherwise, the image will fail to load because the digital signature cannot be verified. </td> </tr>
    ///<tr> <td width="40%"><a id="IMAGE_DLLCHARACTERISTICS_NX_COMPAT"></a><a
    ///id="image_dllcharacteristics_nx_compat"></a><dl> <dt><b>IMAGE_DLLCHARACTERISTICS_NX_COMPAT</b></dt>
    ///<dt>0x0100</dt> </dl> </td> <td width="60%"> The image is compatible with data execution prevention (DEP). </td>
    ///</tr> <tr> <td width="40%"><a id="IMAGE_DLLCHARACTERISTICS_NO_ISOLATION"></a><a
    ///id="image_dllcharacteristics_no_isolation"></a><dl> <dt><b>IMAGE_DLLCHARACTERISTICS_NO_ISOLATION</b></dt>
    ///<dt>0x0200</dt> </dl> </td> <td width="60%"> The image is isolation aware, but should not be isolated. </td>
    ///</tr> <tr> <td width="40%"><a id="IMAGE_DLLCHARACTERISTICS_NO_SEH"></a><a
    ///id="image_dllcharacteristics_no_seh"></a><dl> <dt><b>IMAGE_DLLCHARACTERISTICS_NO_SEH</b></dt> <dt>0x0400</dt>
    ///</dl> </td> <td width="60%"> The image does not use structured exception handling (SEH). No handlers can be
    ///called in this image. </td> </tr> <tr> <td width="40%"><a id="IMAGE_DLLCHARACTERISTICS_NO_BIND"></a><a
    ///id="image_dllcharacteristics_no_bind"></a><dl> <dt><b>IMAGE_DLLCHARACTERISTICS_NO_BIND</b></dt> <dt>0x0800</dt>
    ///</dl> </td> <td width="60%"> Do not bind the image. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_DLL_CHARACTERISTICS_APPCONTAINER"></a><a id="image_dll_characteristics_appcontainer"></a><dl>
    ///<dt><b>IMAGE_DLL_CHARACTERISTICS_APPCONTAINER</b></dt> <dt>0x1000</dt> </dl> </td> <td width="60%"> Image should
    ///execute in an AppContainer. </td> </tr> <tr> <td width="40%"><a id="IMAGE_DLLCHARACTERISTICS_WDM_DRIVER"></a><a
    ///id="image_dllcharacteristics_wdm_driver"></a><dl> <dt><b>IMAGE_DLLCHARACTERISTICS_WDM_DRIVER</b></dt>
    ///<dt>0x2000</dt> </dl> </td> <td width="60%"> A WDM driver. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_DLL_CHARACTERISTICS_GUARD_CF"></a><a id="image_dll_characteristics_guard_cf"></a><dl>
    ///<dt><b>IMAGE_DLL_CHARACTERISTICS_GUARD_CF</b></dt> <dt>0x4000</dt> </dl> </td> <td width="60%"> Image supports
    ///Control Flow Guard. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE"></a><a
    ///id="image_dllcharacteristics_terminal_server_aware"></a><dl>
    ///<dt><b>IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE</b></dt> <dt>0x8000</dt> </dl> </td> <td width="60%"> The
    ///image is terminal server aware. </td> </tr> </table>
    ushort DllCharacteristics;
    ///The number of bytes to reserve for the stack. Only the memory specified by the <b>SizeOfStackCommit</b> member is
    ///committed at load time; the rest is made available one page at a time until this reserve size is reached.
    uint   SizeOfStackReserve;
    ///The number of bytes to commit for the stack.
    uint   SizeOfStackCommit;
    ///The number of bytes to reserve for the local heap. Only the memory specified by the <b>SizeOfHeapCommit</b>
    ///member is committed at load time; the rest is made available one page at a time until this reserve size is
    ///reached.
    uint   SizeOfHeapReserve;
    ///The number of bytes to commit for the local heap.
    uint   SizeOfHeapCommit;
    ///This member is obsolete.
    uint   LoaderFlags;
    ///The number of directory entries in the remainder of the optional header. Each entry describes a location and
    ///size.
    uint   NumberOfRvaAndSizes;
    ///A pointer to the first IMAGE_DATA_DIRECTORY structure in the data directory. The index number of the desired
    ///directory entry. This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_ARCHITECTURE"></a><a
    ///id="image_directory_entry_architecture"></a><dl> <dt><b>IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</b></dt> <dt>7</dt>
    ///</dl> </td> <td width="60%"> Architecture-specific data </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_DIRECTORY_ENTRY_BASERELOC"></a><a id="image_directory_entry_basereloc"></a><dl>
    ///<dt><b>IMAGE_DIRECTORY_ENTRY_BASERELOC</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Base relocation table
    ///</td> </tr> <tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT"></a><a
    ///id="image_directory_entry_bound_import"></a><dl> <dt><b>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</b></dt> <dt>11</dt>
    ///</dl> </td> <td width="60%"> Bound import directory </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR"></a><a id="image_directory_entry_com_descriptor"></a><dl>
    ///<dt><b>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</b></dt> <dt>14</dt> </dl> </td> <td width="60%"> COM descriptor
    ///table </td> </tr> <tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_DEBUG"></a><a
    ///id="image_directory_entry_debug"></a><dl> <dt><b>IMAGE_DIRECTORY_ENTRY_DEBUG</b></dt> <dt>6</dt> </dl> </td> <td
    ///width="60%"> Debug directory </td> </tr> <tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT"></a><a
    ///id="image_directory_entry_delay_import"></a><dl> <dt><b>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</b></dt> <dt>13</dt>
    ///</dl> </td> <td width="60%"> Delay import table </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_DIRECTORY_ENTRY_EXCEPTION"></a><a id="image_directory_entry_exception"></a><dl>
    ///<dt><b>IMAGE_DIRECTORY_ENTRY_EXCEPTION</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Exception directory </td>
    ///</tr> <tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_EXPORT"></a><a id="image_directory_entry_export"></a><dl>
    ///<dt><b>IMAGE_DIRECTORY_ENTRY_EXPORT</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Export directory </td> </tr>
    ///<tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_GLOBALPTR"></a><a id="image_directory_entry_globalptr"></a><dl>
    ///<dt><b>IMAGE_DIRECTORY_ENTRY_GLOBALPTR</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> The relative virtual
    ///address of global pointer </td> </tr> <tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_IAT"></a><a
    ///id="image_directory_entry_iat"></a><dl> <dt><b>IMAGE_DIRECTORY_ENTRY_IAT</b></dt> <dt>12</dt> </dl> </td> <td
    ///width="60%"> Import address table </td> </tr> <tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_IMPORT"></a><a
    ///id="image_directory_entry_import"></a><dl> <dt><b>IMAGE_DIRECTORY_ENTRY_IMPORT</b></dt> <dt>1</dt> </dl> </td>
    ///<td width="60%"> Import directory </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG"></a><a id="image_directory_entry_load_config"></a><dl>
    ///<dt><b>IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</b></dt> <dt>10</dt> </dl> </td> <td width="60%"> Load configuration
    ///directory </td> </tr> <tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_RESOURCE"></a><a
    ///id="image_directory_entry_resource"></a><dl> <dt><b>IMAGE_DIRECTORY_ENTRY_RESOURCE</b></dt> <dt>2</dt> </dl>
    ///</td> <td width="60%"> Resource directory </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_DIRECTORY_ENTRY_SECURITY"></a><a id="image_directory_entry_security"></a><dl>
    ///<dt><b>IMAGE_DIRECTORY_ENTRY_SECURITY</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Security directory </td>
    ///</tr> <tr> <td width="40%"><a id="IMAGE_DIRECTORY_ENTRY_TLS"></a><a id="image_directory_entry_tls"></a><dl>
    ///<dt><b>IMAGE_DIRECTORY_ENTRY_TLS</b></dt> <dt>9</dt> </dl> </td> <td width="60%"> Thread local storage directory
    ///</td> </tr> </table>
    IMAGE_DATA_DIRECTORY[16] DataDirectory;
}

struct IMAGE_ROM_OPTIONAL_HEADER
{
    ushort  Magic;
    ubyte   MajorLinkerVersion;
    ubyte   MinorLinkerVersion;
    uint    SizeOfCode;
    uint    SizeOfInitializedData;
    uint    SizeOfUninitializedData;
    uint    AddressOfEntryPoint;
    uint    BaseOfCode;
    uint    BaseOfData;
    uint    BaseOfBss;
    uint    GprMask;
    uint[4] CprMask;
    uint    GpValue;
}

///Represents the PE header format.
struct IMAGE_NT_HEADERS
{
    ///A 4-byte signature identifying the file as a PE image. The bytes are "PE\0\0".
    uint              Signature;
    ///An IMAGE_FILE_HEADER structure that specifies the file header.
    IMAGE_FILE_HEADER FileHeader;
    ///An IMAGE_OPTIONAL_HEADER structure that specifies the optional file header.
    IMAGE_OPTIONAL_HEADER OptionalHeader;
}

struct IMAGE_ROM_HEADERS
{
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
}

struct ANON_OBJECT_HEADER
{
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint   TimeDateStamp;
    GUID   ClassID;
    uint   SizeOfData;
}

struct ANON_OBJECT_HEADER_V2
{
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint   TimeDateStamp;
    GUID   ClassID;
    uint   SizeOfData;
    uint   Flags;
    uint   MetaDataSize;
    uint   MetaDataOffset;
}

struct ANON_OBJECT_HEADER_BIGOBJ
{
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint   TimeDateStamp;
    GUID   ClassID;
    uint   SizeOfData;
    uint   Flags;
    uint   MetaDataSize;
    uint   MetaDataOffset;
    uint   NumberOfSections;
    uint   PointerToSymbolTable;
    uint   NumberOfSymbols;
}

struct IMAGE_SYMBOL
{
align (2):
union N
    {
    align (2):
        ubyte[8] ShortName;
struct Name
        {
        align (2):
            uint Short;
            uint Long;
        }
        uint[2]  LongName;
    }
    uint   Value;
    short  SectionNumber;
    ushort Type;
    ubyte  StorageClass;
    ubyte  NumberOfAuxSymbols;
}

struct IMAGE_SYMBOL_EX
{
align (2):
union N
    {
    align (2):
        ubyte[8] ShortName;
struct Name
        {
        align (2):
            uint Short;
            uint Long;
        }
        uint[2]  LongName;
    }
    uint   Value;
    int    SectionNumber;
    ushort Type;
    ubyte  StorageClass;
    ubyte  NumberOfAuxSymbols;
}

struct IMAGE_AUX_SYMBOL_TOKEN_DEF
{
align (2):
    ubyte     bAuxType;
    ubyte     bReserved;
    uint      SymbolTableIndex;
    ubyte[12] rgbReserved;
}

union IMAGE_AUX_SYMBOL
{
struct Sym
    {
    align (2):
        uint   TagIndex;
union Misc
        {
        align (2):
struct LnSz
            {
                ushort Linenumber;
                ushort Size;
            }
            uint TotalSize;
        }
union FcnAry
        {
struct Function
            {
            align (2):
                uint PointerToLinenumber;
                uint PointerToNextFunction;
            }
struct Array
            {
                ushort[4] Dimension;
            }
        }
        ushort TvIndex;
    }
struct File
    {
        ubyte[18] Name;
    }
struct Section
    {
    align (2):
        uint   Length;
        ushort NumberOfRelocations;
        ushort NumberOfLinenumbers;
        uint   CheckSum;
        short  Number;
        ubyte  Selection;
        ubyte  bReserved;
        short  HighNumber;
    }
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
struct CRC
    {
    align (2):
        uint      crc;
        ubyte[14] rgbReserved;
    }
}

union IMAGE_AUX_SYMBOL_EX
{
struct Sym
    {
    align (2):
        uint      WeakDefaultSymIndex;
        uint      WeakSearchType;
        ubyte[12] rgbReserved;
    }
struct File
    {
        ubyte[20] Name;
    }
struct Section
    {
    align (2):
        uint     Length;
        ushort   NumberOfRelocations;
        ushort   NumberOfLinenumbers;
        uint     CheckSum;
        short    Number;
        ubyte    Selection;
        ubyte    bReserved;
        short    HighNumber;
        ubyte[2] rgbReserved;
    }
struct
    {
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
        ubyte[2] rgbReserved;
    }
struct CRC
    {
    align (2):
        uint      crc;
        ubyte[16] rgbReserved;
    }
}

struct IMAGE_RELOCATION
{
align (2):
union
    {
    align (2):
        uint VirtualAddress;
        uint RelocCount;
    }
    uint   SymbolTableIndex;
    ushort Type;
}

struct IMAGE_LINENUMBER
{
union Type
    {
    align (2):
        uint SymbolTableIndex;
        uint VirtualAddress;
    }
    ushort Linenumber;
}

struct IMAGE_BASE_RELOCATION
{
    uint VirtualAddress;
    uint SizeOfBlock;
}

struct IMAGE_ARCHIVE_MEMBER_HEADER
{
    ubyte[16] Name;
    ubyte[12] Date;
    ubyte[6]  UserID;
    ubyte[6]  GroupID;
    ubyte[8]  Mode;
    ubyte[10] Size;
    ubyte[2]  EndHeader;
}

struct IMAGE_EXPORT_DIRECTORY
{
    uint   Characteristics;
    uint   TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    uint   Name;
    uint   Base;
    uint   NumberOfFunctions;
    uint   NumberOfNames;
    uint   AddressOfFunctions;
    uint   AddressOfNames;
    uint   AddressOfNameOrdinals;
}

struct IMAGE_IMPORT_BY_NAME
{
    ushort  Hint;
    byte[1] Name;
}

struct IMAGE_THUNK_DATA64
{
union u1
    {
        ulong ForwarderString;
        ulong Function;
        ulong Ordinal;
        ulong AddressOfData;
    }
}

struct IMAGE_THUNK_DATA32
{
union u1
    {
        uint ForwarderString;
        uint Function;
        uint Ordinal;
        uint AddressOfData;
    }
}

struct IMAGE_TLS_DIRECTORY64
{
align (4):
    ulong StartAddressOfRawData;
    ulong EndAddressOfRawData;
    ulong AddressOfIndex;
    ulong AddressOfCallBacks;
    uint  SizeOfZeroFill;
union
    {
        uint Characteristics;
struct
        {
            uint _bitfield154;
        }
    }
}

struct IMAGE_TLS_DIRECTORY32
{
    uint StartAddressOfRawData;
    uint EndAddressOfRawData;
    uint AddressOfIndex;
    uint AddressOfCallBacks;
    uint SizeOfZeroFill;
union
    {
        uint Characteristics;
struct
        {
            uint _bitfield155;
        }
    }
}

struct IMAGE_IMPORT_DESCRIPTOR
{
union
    {
        uint Characteristics;
        uint OriginalFirstThunk;
    }
    uint TimeDateStamp;
    uint ForwarderChain;
    uint Name;
    uint FirstThunk;
}

struct IMAGE_BOUND_IMPORT_DESCRIPTOR
{
    uint   TimeDateStamp;
    ushort OffsetModuleName;
    ushort NumberOfModuleForwarderRefs;
}

struct IMAGE_BOUND_FORWARDER_REF
{
    uint   TimeDateStamp;
    ushort OffsetModuleName;
    ushort Reserved;
}

struct IMAGE_DELAYLOAD_DESCRIPTOR
{
union Attributes
    {
        uint AllAttributes;
struct
        {
            uint _bitfield156;
        }
    }
    uint DllNameRVA;
    uint ModuleHandleRVA;
    uint ImportAddressTableRVA;
    uint ImportNameTableRVA;
    uint BoundImportAddressTableRVA;
    uint UnloadInformationTableRVA;
    uint TimeDateStamp;
}

struct IMAGE_RESOURCE_DIRECTORY
{
    uint   Characteristics;
    uint   TimeDateStamp;
    ushort MajorVersion;
    ushort MinorVersion;
    ushort NumberOfNamedEntries;
    ushort NumberOfIdEntries;
}

struct IMAGE_RESOURCE_DIRECTORY_ENTRY
{
union
    {
struct
        {
            uint _bitfield157;
        }
        uint   Name;
        ushort Id;
    }
union
    {
        uint OffsetToData;
struct
        {
            uint _bitfield158;
        }
    }
}

struct IMAGE_RESOURCE_DIRECTORY_STRING
{
    ushort  Length;
    byte[1] NameString;
}

struct IMAGE_RESOURCE_DIR_STRING_U
{
    ushort    Length;
    ushort[1] NameString;
}

struct IMAGE_RESOURCE_DATA_ENTRY
{
    uint OffsetToData;
    uint Size;
    uint CodePage;
    uint Reserved;
}

struct IMAGE_LOAD_CONFIG_CODE_INTEGRITY
{
    ushort Flags;
    ushort Catalog;
    uint   CatalogOffset;
    uint   Reserved;
}

struct IMAGE_DYNAMIC_RELOCATION_TABLE
{
    uint Version;
    uint Size;
}

struct IMAGE_DYNAMIC_RELOCATION32
{
align (1):
    uint Symbol;
    uint BaseRelocSize;
}

struct IMAGE_DYNAMIC_RELOCATION64
{
align (1):
    ulong Symbol;
    uint  BaseRelocSize;
}

struct IMAGE_DYNAMIC_RELOCATION32_V2
{
align (1):
    uint HeaderSize;
    uint FixupInfoSize;
    uint Symbol;
    uint SymbolGroup;
    uint Flags;
}

struct IMAGE_DYNAMIC_RELOCATION64_V2
{
align (1):
    uint  HeaderSize;
    uint  FixupInfoSize;
    ulong Symbol;
    uint  SymbolGroup;
    uint  Flags;
}

struct IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER
{
    ubyte PrologueByteCount;
}

struct IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER
{
align (1):
    uint   EpilogueCount;
    ubyte  EpilogueByteCount;
    ubyte  BranchDescriptorElementSize;
    ushort BranchDescriptorCount;
}

struct IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION
{
align (1):
    uint _bitfield159;
}

struct IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION
{
align (1):
    ushort _bitfield160;
}

struct IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION
{
align (1):
    ushort _bitfield161;
}

struct IMAGE_HOT_PATCH_INFO
{
    uint Version;
    uint Size;
    uint SequenceNumber;
    uint BaseImageList;
    uint BaseImageCount;
    uint BufferOffset;
    uint ExtraPatchSize;
}

struct IMAGE_HOT_PATCH_BASE
{
    uint SequenceNumber;
    uint Flags;
    uint OriginalTimeDateStamp;
    uint OriginalCheckSum;
    uint CodeIntegrityInfo;
    uint CodeIntegritySize;
    uint PatchTable;
    uint BufferOffset;
}

struct IMAGE_HOT_PATCH_HASHES
{
    ubyte[32] SHA256;
    ubyte[20] SHA1;
}

struct IMAGE_CE_RUNTIME_FUNCTION_ENTRY
{
    uint FuncStart;
    uint _bitfield162;
}

struct IMAGE_ARM_RUNTIME_FUNCTION_ENTRY
{
    uint BeginAddress;
union
    {
        uint UnwindData;
struct
        {
            uint _bitfield163;
        }
    }
}

struct IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
{
    uint BeginAddress;
union
    {
        uint UnwindData;
struct
        {
            uint _bitfield164;
        }
    }
}

union IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA
{
    uint HeaderData;
struct
    {
        uint _bitfield165;
    }
}

struct IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
{
align (4):
    ulong BeginAddress;
    ulong EndAddress;
    ulong ExceptionHandler;
    ulong HandlerData;
    ulong PrologEndAddress;
}

struct IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
{
    uint BeginAddress;
    uint EndAddress;
    uint ExceptionHandler;
    uint HandlerData;
    uint PrologEndAddress;
}

///Represents an entry in the function table on 64-bit Windows.
struct IMAGE_RUNTIME_FUNCTION_ENTRY
{
    ///The address of the start of the function.
    uint BeginAddress;
    ///The address of the end of the function.
    uint EndAddress;
union
    {
        uint UnwindInfoAddress;
        uint UnwindData;
    }
}

///Defines the format of the enclave configuration for systems running 32-bit Windows.
struct IMAGE_ENCLAVE_CONFIG32
{
    ///The size of the <b>IMAGE_ENCLAVE_CONFIG32</b> structure, in bytes.
    uint      Size;
    ///The minimum size of the <b>IMAGE_ENCLAVE_CONFIG32</b> structure that the image loader must be able to process in
    ///order for the enclave to be usable. This member allows an enclave to inform an earlier version of the image
    ///loader that the image loader can safely load the enclave and ignore optional members added to
    ///<b>IMAGE_ENCLAVE_CONFIG32</b> for later versions of the enclave. If the size of <b>IMAGE_ENCLAVE_CONFIG32</b>
    ///that the image loader can process is less than <b>MinimumRequiredConfigSize</b>, the enclave cannot be run
    ///securely. If <b>MinimumRequiredConfigSize</b> is zero, the minimum size of the <b>IMAGE_ENCLAVE_CONFIG32</b>
    ///structure that the image loader must be able to process in order for the enclave to be usable is assumed to be
    ///the size of the structure through and including the <b>MinimumRequiredConfigSize</b> member.
    uint      MinimumRequiredConfigSize;
    ///A flag that indicates whether the enclave permits debugging. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="IMAGE_ENCLAVE_POLICY_DEBUGGABLE"></a><a id="image_enclave_policy_debuggable"></a><dl>
    ///<dt><b>IMAGE_ENCLAVE_POLICY_DEBUGGABLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The enclave
    ///permits debugging. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000000</dt> </dl> </td> <td width="60%"> The
    ///enclave does not permit debugging. </td> </tr> </table>
    uint      PolicyFlags;
    ///The number of images in the array of images that the <b>ImportList</b> member points to.
    uint      NumberOfImports;
    ///The relative virtual address of the array of images that the enclave image may import, with identity information
    ///for each image.
    uint      ImportList;
    ///The size of each image in the array of images that the <b>ImportList</b> member points to.
    uint      ImportEntrySize;
    ///The family identifier that the author of the enclave assigned to the enclave.
    ubyte[16] FamilyID;
    ///The image identifier that the author of the enclave assigned to the enclave.
    ubyte[16] ImageID;
    ///The version number that the author of the enclave assigned to the enclave.
    uint      ImageVersion;
    ///The security version number that the author of the enclave assigned to the enclave.
    uint      SecurityVersion;
    ///The expected virtual size of the private address range for the enclave, in bytes.
    uint      EnclaveSize;
    ///The maximum number of threads that can be created within the enclave.
    uint      NumberOfThreads;
    ///A flag that indicates whether the image is suitable for use as the primary image in the enclave. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE"></a><a
    ///id="image_enclave_flag_primary_image"></a><dl> <dt><b>IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> The image is suitable for use as the primary image in the
    ///enclave. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000000</dt> </dl> </td> <td width="60%"> The image is not
    ///suitable for use as the primary image in the enclave. </td> </tr> </table>
    uint      EnclaveFlags;
}

///Defines the format of the enclave configuration for systems running 32-bit Windows.
struct IMAGE_ENCLAVE_CONFIG64
{
align (4):
    ///The size of the <b>IMAGE_ENCLAVE_CONFIG32</b> structure, in bytes.
    uint      Size;
    ///The minimum size of the <b>IMAGE_ENCLAVE_CONFIG32</b> structure that the image loader must be able to process in
    ///order for the enclave to be usable. This member allows an enclave to inform an earlier version of the image
    ///loader that the image loader can safely load the enclave and ignore optional members added to
    ///<b>IMAGE_ENCLAVE_CONFIG32</b> for later versions of the enclave. If the size of <b>IMAGE_ENCLAVE_CONFIG32</b>
    ///that the image loader can process is less than <b>MinimumRequiredConfigSize</b>, the enclave cannot be run
    ///securely. If <b>MinimumRequiredConfigSize</b> is zero, the minimum size of the <b>IMAGE_ENCLAVE_CONFIG32</b>
    ///structure that the image loader must be able to process in order for the enclave to be usable is assumed to be
    ///the size of the structure through and including the <b>MinimumRequiredConfigSize</b> member.
    uint      MinimumRequiredConfigSize;
    ///A flag that indicates whether the enclave permits debugging. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="IMAGE_ENCLAVE_POLICY_DEBUGGABLE"></a><a id="image_enclave_policy_debuggable"></a><dl>
    ///<dt><b>IMAGE_ENCLAVE_POLICY_DEBUGGABLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The enclave
    ///permits debugging. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000000</dt> </dl> </td> <td width="60%"> The
    ///enclave does not permit debugging. </td> </tr> </table>
    uint      PolicyFlags;
    ///The number of images in the array of images that the <b>ImportList</b> member points to.
    uint      NumberOfImports;
    ///The relative virtual address of the array of images that the enclave image may import, with identity information
    ///for each image.
    uint      ImportList;
    ///The size of each image in the array of images that the <b>ImportList</b> member points to.
    uint      ImportEntrySize;
    ///The family identifier that the author of the enclave assigned to the enclave.
    ubyte[16] FamilyID;
    ///The image identifier that the author of the enclave assigned to the enclave.
    ubyte[16] ImageID;
    ///The version number that the author of the enclave assigned to the enclave.
    uint      ImageVersion;
    ///The security version number that the author of the enclave assigned to the enclave.
    uint      SecurityVersion;
    ///The expected virtual size of the private address range for the enclave, in bytes.
    ulong     EnclaveSize;
    ///The maximum number of threads that can be created within the enclave.
    uint      NumberOfThreads;
    ///A flag that indicates whether the image is suitable for use as the primary image in the enclave. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE"></a><a
    ///id="image_enclave_flag_primary_image"></a><dl> <dt><b>IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> The image is suitable for use as the primary image in the
    ///enclave. </td> </tr> <tr> <td width="40%"> <dl> <dt>0x00000000</dt> </dl> </td> <td width="60%"> The image is not
    ///suitable for use as the primary image in the enclave. </td> </tr> </table>
    uint      EnclaveFlags;
}

///Defines a entry in the array of images that an enclave can import.
struct IMAGE_ENCLAVE_IMPORT
{
    ///The type of identifier of the image that must match the value in the import record. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IMAGE_ENCLAVE_IMPORT_MATCH_NONE"></a><a
    ///id="image_enclave_import_match_none"></a><dl> <dt><b>IMAGE_ENCLAVE_IMPORT_MATCH_NONE</b></dt> <dt>0x00000000</dt>
    ///</dl> </td> <td width="60%"> None of the identifiers of the image need to match the value in the import record.
    ///</td> </tr> <tr> <td width="40%"><a id="IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID"></a><a
    ///id="image_enclave_import_match_unique_id"></a><dl> <dt><b>IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> The value of the enclave unique identifier of the image must
    ///match the value in the import record. Otherwise, loading of the image fails. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_ENCLAVE_IMPORT_MATCH_AUTHOR_ID"></a><a id="image_enclave_import_match_author_id"></a><dl>
    ///<dt><b>IMAGE_ENCLAVE_IMPORT_MATCH_AUTHOR_ID</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The value
    ///of the enclave author identifier of the image must match the value in the import record. Otherwise, loading of
    ///the image fails. If this flag is set and the import record indicates an author identifier of all zeros, the
    ///imported image must be part of the Windows installation. </td> </tr> <tr> <td width="40%"><a
    ///id="IMAGE_ENCLAVE_IMPORT_MATCH_FAMILY_ID"></a><a id="image_enclave_import_match_family_id"></a><dl>
    ///<dt><b>IMAGE_ENCLAVE_IMPORT_MATCH_FAMILY_ID</b></dt> <dt>0x00000003</dt> </dl> </td> <td width="60%"> The value
    ///of the enclave family identifier of the image must match the value in the import record. Otherwise, loading of
    ///the image fails. </td> </tr> <tr> <td width="40%"><a id="IMAGE_ENCLAVE_IMPORT_MATCH_IMAGE_ID"></a><a
    ///id="image_enclave_import_match_image_id"></a><dl> <dt><b>IMAGE_ENCLAVE_IMPORT_MATCH_IMAGE_ID</b></dt>
    ///<dt>0x00000004</dt> </dl> </td> <td width="60%"> The value of the enclave image identifier must match the value
    ///in the import record. Otherwise, loading of the image fails. </td> </tr> </table>
    uint      MatchType;
    ///The minimum enclave security version that each image must have for the image to be imported successfully. The
    ///image is rejected unless its enclave security version is equal to or greater than the minimum value in the import
    ///record. Set the value in the import record to zero to turn off the security version check.
    uint      MinimumSecurityVersion;
    ///The unique identifier of the primary module for the enclave, if the <b>MatchType</b> member is
    ///<b>IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID</b>. Otherwise, the author identifier of the primary module for the
    ///enclave..
    ubyte[32] UniqueOrAuthorID;
    ///The family identifier of the primary module for the enclave.
    ubyte[16] FamilyID;
    ///The image identifier of the primary module for the enclave.
    ubyte[16] ImageID;
    ///The relative virtual address of a NULL-terminated string that contains the same value found in the import
    ///directory for the image.
    uint      ImportName;
    uint      Reserved;
}

struct IMAGE_DEBUG_MISC
{
    uint     DataType;
    uint     Length;
    ubyte    Unicode;
    ubyte[3] Reserved;
    ubyte[1] Data;
}

struct IMAGE_SEPARATE_DEBUG_HEADER
{
    ushort  Signature;
    ushort  Flags;
    ushort  Machine;
    ushort  Characteristics;
    uint    TimeDateStamp;
    uint    CheckSum;
    uint    ImageBase;
    uint    SizeOfImage;
    uint    NumberOfSections;
    uint    ExportedNamesSize;
    uint    DebugDirectorySize;
    uint    SectionAlignment;
    uint[2] Reserved;
}

struct NON_PAGED_DEBUG_INFO
{
align (4):
    ushort Signature;
    ushort Flags;
    uint   Size;
    ushort Machine;
    ushort Characteristics;
    uint   TimeDateStamp;
    uint   CheckSum;
    uint   SizeOfImage;
    ulong  ImageBase;
}

struct IMAGE_ARCHITECTURE_HEADER
{
    uint _bitfield166;
    uint FirstEntryRVA;
}

struct IMAGE_ARCHITECTURE_ENTRY
{
    uint FixupInstRVA;
    uint NewInst;
}

struct IMPORT_OBJECT_HEADER
{
    ushort Sig1;
    ushort Sig2;
    ushort Version;
    ushort Machine;
    uint   TimeDateStamp;
    uint   SizeOfData;
union
    {
        ushort Ordinal;
        ushort Hint;
    }
    ushort _bitfield167;
}

struct IMAGE_COR20_HEADER
{
    uint                 cb;
    ushort               MajorRuntimeVersion;
    ushort               MinorRuntimeVersion;
    IMAGE_DATA_DIRECTORY MetaData;
    uint                 Flags;
union
    {
        uint EntryPointToken;
        uint EntryPointRVA;
    }
    IMAGE_DATA_DIRECTORY Resources;
    IMAGE_DATA_DIRECTORY StrongNameSignature;
    IMAGE_DATA_DIRECTORY CodeManagerTable;
    IMAGE_DATA_DIRECTORY VTableFixups;
    IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
    IMAGE_DATA_DIRECTORY ManagedNativeHeader;
}

union SLIST_HEADER
{
    ulong Alignment;
struct
    {
        SINGLE_LIST_ENTRY Next;
        ushort            Depth;
        ushort            CpuId;
    }
}

union RTL_RUN_ONCE
{
    void* Ptr;
}

struct RTL_BARRIER
{
    uint      Reserved1;
    uint      Reserved2;
    size_t[2] Reserved3;
    uint      Reserved4;
    uint      Reserved5;
}

struct NV_MEMORY_RANGE
{
    void*  BaseAddress;
    size_t Length;
}

struct CORRELATION_VECTOR
{
    byte      Version;
    byte[129] Vector;
}

struct CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG
{
    uint         Size;
    const(PWSTR) TriggerId;
}

struct IMAGE_POLICY_ENTRY
{
    IMAGE_POLICY_ENTRY_TYPE Type;
    IMAGE_POLICY_ID PolicyId;
union u
    {
        const(void)* None;
        ubyte        BoolValue;
        byte         Int8Value;
        ubyte        UInt8Value;
        short        Int16Value;
        ushort       UInt16Value;
        int          Int32Value;
        uint         UInt32Value;
        long         Int64Value;
        ulong        UInt64Value;
        const(PSTR)  AnsiStringValue;
        const(PWSTR) UnicodeStringValue;
    }
}

struct IMAGE_POLICY_METADATA
{
    ubyte              Version;
    ubyte[7]           Reserved0;
    ulong              ApplicationId;
    IMAGE_POLICY_ENTRY Policies;
}

struct RTL_CRITICAL_SECTION_DEBUG
{
    ushort     Type;
    ushort     CreatorBackTraceIndex;
    RTL_CRITICAL_SECTION* CriticalSection;
    LIST_ENTRY ProcessLocksList;
    uint       EntryCount;
    uint       ContentionCount;
    uint       Flags;
    ushort     CreatorBackTraceIndexHigh;
    ushort     SpareWORD;
}

struct RTL_CRITICAL_SECTION
{
    RTL_CRITICAL_SECTION_DEBUG* DebugInfo;
    int    LockCount;
    int    RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    size_t SpinCount;
}

struct RTL_SRWLOCK
{
    void* Ptr;
}

struct RTL_CONDITION_VARIABLE
{
    void* Ptr;
}

///Specifies flags for a HeapOptimizeResources operation initiated with HeapSetInformation.
struct HEAP_OPTIMIZE_RESOURCES_INFORMATION
{
    uint Version;
    uint Flags;
}

struct SUPPORTED_OS_INFO
{
    ushort MajorVersion;
    ushort MinorVersion;
}

struct MAXVERSIONTESTED_INFO
{
    ulong MaxVersionTested;
}

///Contains information about an event record returned by the ReadEventLog function.
struct EVENTLOGRECORD
{
    ///The size of this event record, in bytes. Note that this value is stored at both ends of the entry to ease moving
    ///forward or backward through the log. The length includes any pad bytes inserted at the end of the record for
    ///<b>DWORD</b> alignment.
    uint   Length;
    ///A DWORD value that is always set to <b>ELF_LOG_SIGNATURE</b> (the value is 0x654c664c), which is ASCII for eLfL.
    uint   Reserved;
    ///The number of the record. This value can be used with the EVENTLOG_SEEK_READ flag in the ReadEventLog function to
    ///begin reading at a specified record. For more information, see Event Log Records.
    uint   RecordNumber;
    ///The time at which this entry was submitted. This time is measured in the number of seconds elapsed since 00:00:00
    ///January 1, 1970, Universal Coordinated Time.
    uint   TimeGenerated;
    ///The time at which this entry was received by the service to be written to the log. This time is measured in the
    ///number of seconds elapsed since 00:00:00 January 1, 1970, Universal Coordinated Time.
    uint   TimeWritten;
    ///The event identifier. The value is specific to the event source for the event, and is used with source name to
    ///locate a description string in the message file for the event source. For more information, see Event
    ///Identifiers.
    uint   EventID;
    ///The type of event. This member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="EVENTLOG_ERROR_TYPE"></a><a id="eventlog_error_type"></a><dl>
    ///<dt><b>EVENTLOG_ERROR_TYPE</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Error event </td> </tr> <tr> <td
    ///width="40%"><a id="EVENTLOG_AUDIT_FAILURE"></a><a id="eventlog_audit_failure"></a><dl>
    ///<dt><b>EVENTLOG_AUDIT_FAILURE</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> Failure Audit event </td>
    ///</tr> <tr> <td width="40%"><a id="EVENTLOG_AUDIT_SUCCESS"></a><a id="eventlog_audit_success"></a><dl>
    ///<dt><b>EVENTLOG_AUDIT_SUCCESS</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> Success Audit event </td>
    ///</tr> <tr> <td width="40%"><a id="EVENTLOG_INFORMATION_TYPE"></a><a id="eventlog_information_type"></a><dl>
    ///<dt><b>EVENTLOG_INFORMATION_TYPE</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Information event </td>
    ///</tr> <tr> <td width="40%"><a id="EVENTLOG_WARNING_TYPE"></a><a id="eventlog_warning_type"></a><dl>
    ///<dt><b>EVENTLOG_WARNING_TYPE</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Warning event </td> </tr>
    ///</table> For more information, see Event Types.
    ushort EventType;
    ///The number of strings present in the log (at the position indicated by <b>StringOffset</b>). These strings are
    ///merged into the message before it is displayed to the user.
    ushort NumStrings;
    ///The category for this event. The meaning of this value depends on the event source. For more information, see
    ///Event Categories.
    ushort EventCategory;
    ///Reserved.
    ushort ReservedFlags;
    ///Reserved.
    uint   ClosingRecordNumber;
    ///The offset of the description strings within this event log record.
    uint   StringOffset;
    ///The size of the <b>UserSid</b> member, in bytes. This value can be zero if no security identifier was provided.
    uint   UserSidLength;
    ///The offset of the security identifier (SID) within this event log record. To obtain the user name for this SID,
    ///use the LookupAccountSid function.
    uint   UserSidOffset;
    ///The size of the event-specific data (at the position indicated by <b>DataOffset</b>), in bytes.
    uint   DataLength;
    ///The offset of the event-specific information within this event log record, in bytes. This information could be
    ///something specific (a disk driver might log the number of retries, for example), followed by binary information
    ///specific to the event being logged and to the source that generated the entry.
    uint   DataOffset;
}

struct EVENTSFORLOGFILE
{
    uint           ulSize;
    ushort[256]    szLogicalLogFile;
    uint           ulNumRecords;
    EVENTLOGRECORD pEventLogRecords;
}

struct PACKEDEVENTINFO
{
    uint ulSize;
    uint ulNumEventsForLogFile;
    uint ulOffsets;
}

///The <b>TAPE_ERASE</b> structure describes the partition to be erased.
struct TAPE_ERASE
{
    ///Tape erasure type. This member must have one of the following values: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_ERASE_LONG"></a><a id="tape_erase_long"></a><dl>
    ///<dt><b>TAPE_ERASE_LONG</b></dt> <dt>1L</dt> </dl> </td> <td width="60%"> Erases the entire partition. </td> </tr>
    ///<tr> <td width="40%"><a id="TAPE_ERASE_SHORT"></a><a id="tape_erase_short"></a><dl>
    ///<dt><b>TAPE_ERASE_SHORT</b></dt> <dt>0L</dt> </dl> </td> <td width="60%"> Erases only the partition's header
    ///block. </td> </tr> </table>
    uint  Type;
    ubyte Immediate;
}

///The <b>TAPE_PREPARE</b> structure describes how to prepare the tape.
struct TAPE_PREPARE
{
    ///Tape preparation option. This member must be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_LOCK"></a><a id="tape_lock"></a><dl>
    ///<dt><b>TAPE_LOCK</b></dt> <dt>3L</dt> </dl> </td> <td width="60%"> Locks the tape ejection mechanism so that the
    ///tape is not ejected accidentally during a tape operation. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_TENSION"></a><a id="tape_tension"></a><dl> <dt><b>TAPE_TENSION</b></dt> <dt>2L</dt> </dl> </td> <td
    ///width="60%"> Moves to the end of the tape and rewinds to the beginning of the tape. This value is ignored if the
    ///tape device does not support tensioning. </td> </tr> <tr> <td width="40%"><a id="TAPE_UNLOAD"></a><a
    ///id="tape_unload"></a><dl> <dt><b>TAPE_UNLOAD</b></dt> <dt>1L</dt> </dl> </td> <td width="60%"> Rewinds and
    ///unloads the tape. </td> </tr> <tr> <td width="40%"><a id="TAPE_UNLOCK"></a><a id="tape_unlock"></a><dl>
    ///<dt><b>TAPE_UNLOCK</b></dt> <dt>4L</dt> </dl> </td> <td width="60%"> Unlocks the tape ejection mechanism. </td>
    ///</tr> </table>
    uint  Operation;
    ubyte Immediate;
}

///The <b>TAPE_WRITE_MARKS</b> structure describes the type and number of tapemarks to write.
struct TAPE_WRITE_MARKS
{
    ///Type of tapemark to write. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_FILEMARKS"></a><a id="tape_filemarks"></a><dl>
    ///<dt><b>TAPE_FILEMARKS</b></dt> <dt></dt> </dl> </td> <td width="60%"> Writes filemarks. </td> </tr> <tr> <td
    ///width="40%"><a id="TAPE_LONG_FILEMARKS"></a><a id="tape_long_filemarks"></a><dl>
    ///<dt><b>TAPE_LONG_FILEMARKS</b></dt> <dt>3L</dt> </dl> </td> <td width="60%"> Writes long filemarks. </td> </tr>
    ///<tr> <td width="40%"><a id="TAPE_SETMARKS"></a><a id="tape_setmarks"></a><dl> <dt><b>TAPE_SETMARKS</b></dt>
    ///<dt>0L</dt> </dl> </td> <td width="60%"> Writes setmarks. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_SHORT_FILEMARKS"></a><a id="tape_short_filemarks"></a><dl> <dt><b>TAPE_SHORT_FILEMARKS</b></dt>
    ///<dt>2L</dt> </dl> </td> <td width="60%"> Writes short filemarks. </td> </tr> </table>
    uint  Type;
    ///Number of tapemarks to write.
    uint  Count;
    ubyte Immediate;
}

///The <b>TAPE_GET_POSITION</b> structure describes the position of the tape.
struct TAPE_GET_POSITION
{
    ///Type of position. This member must be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="TAPE_ABSOLUTE_POSITION"></a><a id="tape_absolute_position"></a><dl>
    ///<dt><b>TAPE_ABSOLUTE_POSITION</b></dt> <dt>0L</dt> </dl> </td> <td width="60%"> The position specified by the
    ///<b>Offset</b> member is an absolute number of blocks from the beginning of the partition specified by the
    ///<b>Partition</b> member. </td> </tr> <tr> <td width="40%"><a id="TAPE_LOGICAL_POSITION"></a><a
    ///id="tape_logical_position"></a><dl> <dt><b>TAPE_LOGICAL_POSITION</b></dt> <dt>1L</dt> </dl> </td> <td
    ///width="60%"> The position specified by the <b>Offset</b> member is relative to the current position in the
    ///partition specified by <b>Partition</b>. </td> </tr> </table>
    uint          Type;
    ///Partition to position within. If this member is zero, the current partition is assumed.
    uint          Partition;
    LARGE_INTEGER Offset;
}

///The <b>TAPE_SET_POSITION</b> structure describes how and where to position the tape.
struct TAPE_SET_POSITION
{
    ///Type of positioning. This member must be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_ABSOLUTE_BLOCK"></a><a id="tape_absolute_block"></a><dl>
    ///<dt><b>TAPE_ABSOLUTE_BLOCK</b></dt> <dt>1L</dt> </dl> </td> <td width="60%"> Moves the tape to the
    ///device-specific block address specified by the <b>Offset</b> member. The <b>Partition</b> member is ignored.
    ///</td> </tr> <tr> <td width="40%"><a id="TAPE_LOGICAL_BLOCK"></a><a id="tape_logical_block"></a><dl>
    ///<dt><b>TAPE_LOGICAL_BLOCK</b></dt> <dt>2L</dt> </dl> </td> <td width="60%"> Moves the tape to the block address
    ///specified by <b>Offset</b> in the partition specified by <b>Partition</b>. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_REWIND"></a><a id="tape_rewind"></a><dl> <dt><b>TAPE_REWIND</b></dt> <dt>0L</dt> </dl> </td> <td
    ///width="60%"> Moves the tape to the beginning of the current partition. The <b>Partition</b> and <b>Offset</b>
    ///members are ignored. </td> </tr> <tr> <td width="40%"><a id="TAPE_SPACE_END_OF_DATA"></a><a
    ///id="tape_space_end_of_data"></a><dl> <dt><b>TAPE_SPACE_END_OF_DATA</b></dt> <dt>4L</dt> </dl> </td> <td
    ///width="60%"> Moves the tape to the end of the data on the partition specified by <b>Partition</b>. </td> </tr>
    ///<tr> <td width="40%"><a id="TAPE_SPACE_FILEMARKS"></a><a id="tape_space_filemarks"></a><dl>
    ///<dt><b>TAPE_SPACE_FILEMARKS</b></dt> <dt>6L</dt> </dl> </td> <td width="60%"> Moves the tape forward (or
    ///backward) the number of filemarks specified by <b>Offset</b> in the current partition. The <b>Partition</b>
    ///member is ignored. </td> </tr> <tr> <td width="40%"><a id="TAPE_SPACE_RELATIVE_BLOCKS"></a><a
    ///id="tape_space_relative_blocks"></a><dl> <dt><b>TAPE_SPACE_RELATIVE_BLOCKS</b></dt> <dt>5L</dt> </dl> </td> <td
    ///width="60%"> Moves the tape forward (or backward) the number of blocks specified by <b>Offset</b> in the current
    ///partition. The <b>Partition</b> member is ignored. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_SPACE_SEQUENTIAL_FMKS"></a><a id="tape_space_sequential_fmks"></a><dl>
    ///<dt><b>TAPE_SPACE_SEQUENTIAL_FMKS</b></dt> <dt>7L</dt> </dl> </td> <td width="60%"> Moves the tape forward (or
    ///backward) to the first occurrence of n filemarks in the current partition, where n is the number specified by
    ///<b>Offset</b>. The <b>Partition</b> parameter is ignored. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_SPACE_SEQUENTIAL_SMKS"></a><a id="tape_space_sequential_smks"></a><dl>
    ///<dt><b>TAPE_SPACE_SEQUENTIAL_SMKS</b></dt> <dt>9L</dt> </dl> </td> <td width="60%"> Moves the tape forward (or
    ///backward) to the first occurrence of n setmarks in the current partition, where n is the number specified by
    ///<b>Offset</b>. The <b>Partition</b> member is ignored. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_SPACE_SETMARKS"></a><a id="tape_space_setmarks"></a><dl> <dt><b>TAPE_SPACE_SETMARKS</b></dt> <dt>8L</dt>
    ///</dl> </td> <td width="60%"> Moves the tape forward (or backward) the number of setmarks specified by
    ///<b>Offset</b> in the current partition. The <b>Partition</b> member is ignored. </td> </tr> </table>
    uint          Method;
    ///Partition to position within. If this member is zero, the current partition is assumed.
    uint          Partition;
    ///Block address or count for the position operation specified by the <b>Method</b> member.
    LARGE_INTEGER Offset;
    ///If this member is <b>TRUE</b>, return as soon as the operation begins. Otherwise, return after the operation has
    ///completed.
    ubyte         Immediate;
}

///The <b>TAPE_GET_DRIVE_PARAMETERS</b> structure describes the tape drive. It is used by the GetTapeParameters
///function.
struct TAPE_GET_DRIVE_PARAMETERS
{
    ///If this member is <b>TRUE</b>, the device supports hardware error correction. Otherwise, it does not.
    ubyte ECC;
    ///If this member is <b>TRUE</b>, hardware data compression is enabled. Otherwise, it is disabled.
    ubyte Compression;
    ///If this member is <b>TRUE</b>, data padding is enabled. Otherwise, it is disabled. Data padding keeps the tape
    ///streaming at a constant speed.
    ubyte DataPadding;
    ///If this member is <b>TRUE</b>, setmark reporting is enabled. Otherwise, it is disabled.
    ubyte ReportSetmarks;
    ///Device's default fixed block size, in bytes.
    uint  DefaultBlockSize;
    ///Device's maximum block size, in bytes.
    uint  MaximumBlockSize;
    ///Device's minimum block size, in bytes.
    uint  MinimumBlockSize;
    ///Maximum number of partitions that can be created on the device.
    uint  MaximumPartitionCount;
    ///Low-order bits of the device features flag. This member can be one or more of following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_COMPRESSION"></a><a
    ///id="tape_drive_compression"></a><dl> <dt><b>TAPE_DRIVE_COMPRESSION</b></dt> <dt>0x00020000</dt> </dl> </td> <td
    ///width="60%"> The device supports hardware data compression. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_CLEAN_REQUESTS"></a><a id="tape_drive_clean_requests"></a><dl>
    ///<dt><b>TAPE_DRIVE_CLEAN_REQUESTS</b></dt> <dt>0x02000000</dt> </dl> </td> <td width="60%"> The device can report
    ///if cleaning is required. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_ECC"></a><a
    ///id="tape_drive_ecc"></a><dl> <dt><b>TAPE_DRIVE_ECC</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> The
    ///device supports hardware error correction. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_EJECT_MEDIA"></a><a
    ///id="tape_drive_eject_media"></a><dl> <dt><b>TAPE_DRIVE_EJECT_MEDIA</b></dt> <dt>0x01000000</dt> </dl> </td> <td
    ///width="60%"> The device physically ejects the tape on a software eject. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_ERASE_BOP_ONLY"></a><a id="tape_drive_erase_bop_only"></a><dl>
    ///<dt><b>TAPE_DRIVE_ERASE_BOP_ONLY</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The device performs
    ///the erase operation from the beginning-of-partition marker only. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_ERASE_LONG"></a><a id="tape_drive_erase_long"></a><dl> <dt><b>TAPE_DRIVE_ERASE_LONG</b></dt>
    ///<dt>0x00000020</dt> </dl> </td> <td width="60%"> The device performs a long erase operation. </td> </tr> <tr> <td
    ///width="40%"><a id="TAPE_DRIVE_ERASE_IMMEDIATE"></a><a id="tape_drive_erase_immediate"></a><dl>
    ///<dt><b>TAPE_DRIVE_ERASE_IMMEDIATE</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> The device performs
    ///an immediate erase operation — that is, it returns when the erase operation begins. </td> </tr> <tr> <td
    ///width="40%"><a id="TAPE_DRIVE_ERASE_SHORT"></a><a id="tape_drive_erase_short"></a><dl>
    ///<dt><b>TAPE_DRIVE_ERASE_SHORT</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> The device performs a
    ///short erase operation. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_FIXED"></a><a
    ///id="tape_drive_fixed"></a><dl> <dt><b>TAPE_DRIVE_FIXED</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%">
    ///The device creates fixed data partitions. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_FIXED_BLOCK"></a><a
    ///id="tape_drive_fixed_block"></a><dl> <dt><b>TAPE_DRIVE_FIXED_BLOCK</b></dt> <dt>0x00000400</dt> </dl> </td> <td
    ///width="60%"> The device supports fixed-length block mode. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_GET_ABSOLUTE_BLK"></a><a id="tape_drive_get_absolute_blk"></a><dl>
    ///<dt><b>TAPE_DRIVE_GET_ABSOLUTE_BLK</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The device provides
    ///the current device-specific block address. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_GET_LOGICAL_BLK"></a><a id="tape_drive_get_logical_blk"></a><dl>
    ///<dt><b>TAPE_DRIVE_GET_LOGICAL_BLK</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> The device provides
    ///the current logical block address (and logical tape partition). </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_INITIATOR"></a><a id="tape_drive_initiator"></a><dl> <dt><b>TAPE_DRIVE_INITIATOR</b></dt>
    ///<dt>0x00000004</dt> </dl> </td> <td width="60%"> The device creates initiator-defined partitions. </td> </tr>
    ///<tr> <td width="40%"><a id="TAPE_DRIVE_PADDING"></a><a id="tape_drive_padding"></a><dl>
    ///<dt><b>TAPE_DRIVE_PADDING</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The device supports data
    ///padding. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_REPORT_SMKS"></a><a
    ///id="tape_drive_report_smks"></a><dl> <dt><b>TAPE_DRIVE_REPORT_SMKS</b></dt> <dt>0x00080000</dt> </dl> </td> <td
    ///width="60%"> The device supports setmark reporting. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_SELECT"></a><a id="tape_drive_select"></a><dl> <dt><b>TAPE_DRIVE_SELECT</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> The device creates select data partitions. </td> </tr> <tr> <td
    ///width="40%"><a id="TAPE_DRIVE_SET_CMP_BOP_ONLY"></a><a id="tape_drive_set_cmp_bop_only"></a><dl>
    ///<dt><b>TAPE_DRIVE_SET_CMP_BOP_ONLY</b></dt> <dt>0x04000000</dt> </dl> </td> <td width="60%"> The device must be
    ///at the beginning of a partition before it can set compression on. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_SET_EOT_WZ_SIZE"></a><a id="tape_drive_set_eot_wz_size"></a><dl>
    ///<dt><b>TAPE_DRIVE_SET_EOT_WZ_SIZE</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> The device supports
    ///setting the end-of-medium warning size. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_TAPE_CAPACITY"></a><a
    ///id="tape_drive_tape_capacity"></a><dl> <dt><b>TAPE_DRIVE_TAPE_CAPACITY</b></dt> <dt>0x00000100</dt> </dl> </td>
    ///<td width="60%"> The device returns the maximum capacity of the tape. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_TAPE_REMAINING"></a><a id="tape_drive_tape_remaining"></a><dl>
    ///<dt><b>TAPE_DRIVE_TAPE_REMAINING</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> The device returns the
    ///remaining capacity of the tape. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_VARIABLE_BLOCK"></a><a
    ///id="tape_drive_variable_block"></a><dl> <dt><b>TAPE_DRIVE_VARIABLE_BLOCK</b></dt> <dt>0x00000800</dt> </dl> </td>
    ///<td width="60%"> The device supports variable-length block mode. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_WRITE_PROTECT"></a><a id="tape_drive_write_protect"></a><dl>
    ///<dt><b>TAPE_DRIVE_WRITE_PROTECT</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> The device returns an
    ///error if the tape is write-enabled or write-protected. </td> </tr> </table>
    uint  FeaturesLow;
    ///High-order bits of the device features flag. This member can be one or more of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_ABS_BLK_IMMED"></a><a
    ///id="tape_drive_abs_blk_immed"></a><dl> <dt><b>TAPE_DRIVE_ABS_BLK_IMMED</b></dt> <dt>0x80002000</dt> </dl> </td>
    ///<td width="60%"> The device moves the tape to a device-specific block address and returns as soon as the move
    ///begins. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_ABSOLUTE_BLK"></a><a
    ///id="tape_drive_absolute_blk"></a><dl> <dt><b>TAPE_DRIVE_ABSOLUTE_BLK</b></dt> <dt>0x80001000</dt> </dl> </td> <td
    ///width="60%"> The device moves the tape to a device specific block address. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_END_OF_DATA"></a><a id="tape_drive_end_of_data"></a><dl> <dt><b>TAPE_DRIVE_END_OF_DATA</b></dt>
    ///<dt>0x80010000</dt> </dl> </td> <td width="60%"> The device moves the tape to the end-of-data marker in a
    ///partition. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_FILEMARKS"></a><a
    ///id="tape_drive_filemarks"></a><dl> <dt><b>TAPE_DRIVE_FILEMARKS</b></dt> <dt>0x80040000</dt> </dl> </td> <td
    ///width="60%"> The device moves the tape forward (or backward) a specified number of filemarks. </td> </tr> <tr>
    ///<td width="40%"><a id="TAPE_DRIVE_LOAD_UNLOAD"></a><a id="tape_drive_load_unload"></a><dl>
    ///<dt><b>TAPE_DRIVE_LOAD_UNLOAD</b></dt> <dt>0x80000001</dt> </dl> </td> <td width="60%"> The device enables and
    ///disables the device for further operations. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_LOAD_UNLD_IMMED"></a><a id="tape_drive_load_unld_immed"></a><dl>
    ///<dt><b>TAPE_DRIVE_LOAD_UNLD_IMMED</b></dt> <dt>0x80000020</dt> </dl> </td> <td width="60%"> The device supports
    ///immediate load and unload operations. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_LOCK_UNLOCK"></a><a
    ///id="tape_drive_lock_unlock"></a><dl> <dt><b>TAPE_DRIVE_LOCK_UNLOCK</b></dt> <dt>0x80000004</dt> </dl> </td> <td
    ///width="60%"> The device enables and disables the tape ejection mechanism. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_LOCK_UNLK_IMMED"></a><a id="tape_drive_lock_unlk_immed"></a><dl>
    ///<dt><b>TAPE_DRIVE_LOCK_UNLK_IMMED</b></dt> <dt>0x80000080</dt> </dl> </td> <td width="60%"> The device supports
    ///immediate lock and unlock operations. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_LOG_BLK_IMMED"></a><a
    ///id="tape_drive_log_blk_immed"></a><dl> <dt><b>TAPE_DRIVE_LOG_BLK_IMMED</b></dt> <dt>0x80008000</dt> </dl> </td>
    ///<td width="60%"> The device moves the tape to a logical block address in a partition and returns as soon as the
    ///move begins. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_LOGICAL_BLK"></a><a
    ///id="tape_drive_logical_blk"></a><dl> <dt><b>TAPE_DRIVE_LOGICAL_BLK</b></dt> <dt>0x80004000</dt> </dl> </td> <td
    ///width="60%"> The device moves the tape to a logical block address in a partition. </td> </tr> <tr> <td
    ///width="40%"><a id="TAPE_DRIVE_RELATIVE_BLKS"></a><a id="tape_drive_relative_blks"></a><dl>
    ///<dt><b>TAPE_DRIVE_RELATIVE_BLKS</b></dt> <dt>0x80020000</dt> </dl> </td> <td width="60%"> The device moves the
    ///tape forward (or backward) a specified number of blocks. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_REVERSE_POSITION"></a><a id="tape_drive_reverse_position"></a><dl>
    ///<dt><b>TAPE_DRIVE_REVERSE_POSITION</b></dt> <dt>0x80400000</dt> </dl> </td> <td width="60%"> The device moves the
    ///tape backward over blocks, filemarks, or setmarks. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_REWIND_IMMEDIATE"></a><a id="tape_drive_rewind_immediate"></a><dl>
    ///<dt><b>TAPE_DRIVE_REWIND_IMMEDIATE</b></dt> <dt>0x80000008</dt> </dl> </td> <td width="60%"> The device supports
    ///immediate rewind operation. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_SEQUENTIAL_FMKS"></a><a
    ///id="tape_drive_sequential_fmks"></a><dl> <dt><b>TAPE_DRIVE_SEQUENTIAL_FMKS</b></dt> <dt>0x80080000</dt> </dl>
    ///</td> <td width="60%"> The device moves the tape forward (or backward) to the first occurrence of a specified
    ///number of consecutive filemarks. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_SEQUENTIAL_SMKS"></a><a
    ///id="tape_drive_sequential_smks"></a><dl> <dt><b>TAPE_DRIVE_SEQUENTIAL_SMKS</b></dt> <dt>0x80200000</dt> </dl>
    ///</td> <td width="60%"> The device moves the tape forward (or backward) to the first occurrence of a specified
    ///number of consecutive setmarks. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_SET_BLOCK_SIZE"></a><a
    ///id="tape_drive_set_block_size"></a><dl> <dt><b>TAPE_DRIVE_SET_BLOCK_SIZE</b></dt> <dt>0x80000010</dt> </dl> </td>
    ///<td width="60%"> The device supports setting the size of a fixed-length logical block or setting the
    ///variable-length block mode. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_SET_COMPRESSION"></a><a
    ///id="tape_drive_set_compression"></a><dl> <dt><b>TAPE_DRIVE_SET_COMPRESSION</b></dt> <dt>0x80000200</dt> </dl>
    ///</td> <td width="60%"> The device enables and disables hardware data compression. </td> </tr> <tr> <td
    ///width="40%"><a id="TAPE_DRIVE_SET_ECC"></a><a id="tape_drive_set_ecc"></a><dl> <dt><b>TAPE_DRIVE_SET_ECC</b></dt>
    ///<dt>0x80000100</dt> </dl> </td> <td width="60%"> The device enables and disables hardware error correction. </td>
    ///</tr> <tr> <td width="40%"><a id="TAPE_DRIVE_SET_PADDING"></a><a id="tape_drive_set_padding"></a><dl>
    ///<dt><b>TAPE_DRIVE_SET_PADDING</b></dt> <dt>0x80000400</dt> </dl> </td> <td width="60%"> The device enables and
    ///disables data padding. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_SET_REPORT_SMKS"></a><a
    ///id="tape_drive_set_report_smks"></a><dl> <dt><b>TAPE_DRIVE_SET_REPORT_SMKS</b></dt> <dt>0x80000800</dt> </dl>
    ///</td> <td width="60%"> The device enables and disables the reporting of setmarks. </td> </tr> <tr> <td
    ///width="40%"><a id="TAPE_DRIVE_SETMARKS"></a><a id="tape_drive_setmarks"></a><dl>
    ///<dt><b>TAPE_DRIVE_SETMARKS</b></dt> <dt>0x80100000</dt> </dl> </td> <td width="60%"> The device moves the tape
    ///forward (or reverse) a specified number of setmarks. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_SPACE_IMMEDIATE"></a><a id="tape_drive_space_immediate"></a><dl>
    ///<dt><b>TAPE_DRIVE_SPACE_IMMEDIATE</b></dt> <dt>0x80800000</dt> </dl> </td> <td width="60%"> The device supports
    ///immediate spacing. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_TENSION"></a><a
    ///id="tape_drive_tension"></a><dl> <dt><b>TAPE_DRIVE_TENSION</b></dt> <dt>0x80000002</dt> </dl> </td> <td
    ///width="60%"> The device supports tape tensioning. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_TENSION_IMMED"></a><a id="tape_drive_tension_immed"></a><dl>
    ///<dt><b>TAPE_DRIVE_TENSION_IMMED</b></dt> <dt>0x80000040</dt> </dl> </td> <td width="60%"> The device supports
    ///immediate tape tensioning. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_WRITE_FILEMARKS"></a><a
    ///id="tape_drive_write_filemarks"></a><dl> <dt><b>TAPE_DRIVE_WRITE_FILEMARKS</b></dt> <dt>0x82000000</dt> </dl>
    ///</td> <td width="60%"> The device writes filemarks. </td> </tr> <tr> <td width="40%"><a
    ///id="TAPE_DRIVE_WRITE_LONG_FMKS"></a><a id="tape_drive_write_long_fmks"></a><dl>
    ///<dt><b>TAPE_DRIVE_WRITE_LONG_FMKS</b></dt> <dt>0x88000000</dt> </dl> </td> <td width="60%"> The device writes
    ///long filemarks. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_WRITE_MARK_IMMED"></a><a
    ///id="tape_drive_write_mark_immed"></a><dl> <dt><b>TAPE_DRIVE_WRITE_MARK_IMMED</b></dt> <dt>0x90000000</dt> </dl>
    ///</td> <td width="60%"> The device supports immediate writing of short and long filemarks. </td> </tr> <tr> <td
    ///width="40%"><a id="TAPE_DRIVE_WRITE_SETMARKS"></a><a id="tape_drive_write_setmarks"></a><dl>
    ///<dt><b>TAPE_DRIVE_WRITE_SETMARKS</b></dt> <dt>0x81000000</dt> </dl> </td> <td width="60%"> The device writes
    ///setmarks. </td> </tr> <tr> <td width="40%"><a id="TAPE_DRIVE_WRITE_SHORT_FMKS"></a><a
    ///id="tape_drive_write_short_fmks"></a><dl> <dt><b>TAPE_DRIVE_WRITE_SHORT_FMKS</b></dt> <dt>0x84000000</dt> </dl>
    ///</td> <td width="60%"> The device writes short filemarks. </td> </tr> </table>
    uint  FeaturesHigh;
    ///Indicates the number of bytes between the end-of-tape warning and the physical end of the tape.
    uint  EOTWarningZoneSize;
}

///The <b>TAPE_SET_DRIVE_PARAMETERS</b> structure describes the tape drive. It is used by the SetTapeParametersfunction.
struct TAPE_SET_DRIVE_PARAMETERS
{
    ///If this member is <b>TRUE</b>, hardware error correction is supported. Otherwise, it is not.
    ubyte ECC;
    ///If this member is <b>TRUE</b>, hardware data compression is enabled. Otherwise, it is disabled.
    ubyte Compression;
    ///If this member is <b>TRUE</b>, data padding is enabled. Otherwise, it is disabled. Data padding keeps the tape
    ///streaming at a constant speed.
    ubyte DataPadding;
    ///If this member is <b>TRUE</b>, setmark reporting is enabled. Otherwise, it is disabled.
    ubyte ReportSetmarks;
    ///Number of bytes between the end-of-tape warning and the physical end of the tape.
    uint  EOTWarningZoneSize;
}

///The <b>TAPE_GET_MEDIA_PARAMETERS</b> structure describes the tape in the tape drive. It is used by the
///GetTapeParametersfunction.
struct TAPE_GET_MEDIA_PARAMETERS
{
    ///Total number of bytes on the current tape partition.
    LARGE_INTEGER Capacity;
    ///Number of bytes between the current position and the end of the current tape partition.
    LARGE_INTEGER Remaining;
    ///Number of bytes per block.
    uint          BlockSize;
    ///Number of partitions on the tape.
    uint          PartitionCount;
    ///If this member is <b>TRUE</b>, the tape is write-protected. Otherwise, it is not.
    ubyte         WriteProtected;
}

///The <b>TAPE_SET_MEDIA_PARAMETERS</b> structure describes the tape in the tape drive. It is used by the
///SetTapeParametersfunction.
struct TAPE_SET_MEDIA_PARAMETERS
{
    ///Number of bytes per block. Maximum and minimum block sizes can be obtained by calling the GetTapeParameters
    ///function.
    uint BlockSize;
}

struct TAPE_CREATE_PARTITION
{
    uint Method;
    uint Count;
    uint Size;
}

struct TAPE_WMI_OPERATIONS
{
    uint  Method;
    uint  DataBufferSize;
    void* DataBuffer;
}

struct TRANSACTION_BASIC_INFORMATION
{
    GUID TransactionId;
    uint State;
    uint Outcome;
}

struct TRANSACTIONMANAGER_BASIC_INFORMATION
{
    GUID          TmIdentity;
    LARGE_INTEGER VirtualClock;
}

struct TRANSACTIONMANAGER_LOG_INFORMATION
{
    GUID LogIdentity;
}

struct TRANSACTIONMANAGER_LOGPATH_INFORMATION
{
    uint      LogPathLength;
    ushort[1] LogPath;
}

struct TRANSACTIONMANAGER_RECOVERY_INFORMATION
{
    ulong LastRecoveredLsn;
}

struct TRANSACTIONMANAGER_OLDEST_INFORMATION
{
    GUID OldestTransactionGuid;
}

struct TRANSACTION_PROPERTIES_INFORMATION
{
    uint          IsolationLevel;
    uint          IsolationFlags;
    LARGE_INTEGER Timeout;
    uint          Outcome;
    uint          DescriptionLength;
    ushort[1]     Description;
}

struct TRANSACTION_BIND_INFORMATION
{
    HANDLE TmHandle;
}

struct TRANSACTION_ENLISTMENT_PAIR
{
    GUID EnlistmentId;
    GUID ResourceManagerId;
}

struct TRANSACTION_ENLISTMENTS_INFORMATION
{
    uint NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR[1] EnlistmentPair;
}

struct TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION
{
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
}

struct RESOURCEMANAGER_BASIC_INFORMATION
{
    GUID      ResourceManagerId;
    uint      DescriptionLength;
    ushort[1] Description;
}

struct RESOURCEMANAGER_COMPLETION_INFORMATION
{
    HANDLE IoCompletionPortHandle;
    size_t CompletionKey;
}

struct ENLISTMENT_BASIC_INFORMATION
{
    GUID EnlistmentId;
    GUID TransactionId;
    GUID ResourceManagerId;
}

struct ENLISTMENT_CRM_INFORMATION
{
    GUID CrmTransactionManagerId;
    GUID CrmResourceManagerId;
    GUID CrmEnlistmentId;
}

struct TRANSACTION_LIST_ENTRY
{
    GUID UOW;
}

struct TRANSACTION_LIST_INFORMATION
{
    uint NumberOfTransactions;
    TRANSACTION_LIST_ENTRY[1] TransactionInformation;
}

struct KTMOBJECT_CURSOR
{
    GUID    LastQuery;
    uint    ObjectIdCount;
    GUID[1] ObjectIds;
}

struct TP_CALLBACK_INSTANCE
{
}

struct TP_POOL
{
}

struct TP_POOL_STACK_INFORMATION
{
    size_t StackReserve;
    size_t StackCommit;
}

struct TP_CLEANUP_GROUP
{
}

struct TP_CALLBACK_ENVIRON_V3
{
    uint                 Version;
    PTP_POOL             Pool;
    ptrdiff_t            CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
    void*                RaceDll;
    ptrdiff_t            ActivationContext;
    PTP_SIMPLE_CALLBACK  FinalizationCallback;
union u
    {
        uint Flags;
struct s
        {
            uint _bitfield168;
        }
    }
    TP_CALLBACK_PRIORITY CallbackPriority;
    uint                 Size;
}

struct TP_WORK
{
}

struct TP_TIMER
{
}

struct TP_WAIT
{
}

struct TP_IO
{
}

///<p class="CCE_Message">[This structure may be altered in future versions of Windows. Applications should use the
///alternate functions listed in this topic.] The Thread Environment Block (TEB structure) describes the state of a
///thread.
struct TEB
{
}

struct APP_LOCAL_DEVICE_ID
{
    ubyte[32] value;
}

struct DPI_AWARENESS_CONTEXT__
{
    int unused;
}

///Contains information used to control the I/O rate for a job. This structure is used by the
///SetIoRateControlInformationJobObject and QueryIoRateControlInformationJobObject functions.
struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION
{
    ///The maximum limit for the I/O rate in I/O operations per second (IOPS). Set to 0 if to specify no limit. When you
    ///set both <b>MaxIops</b> and <b>MaxBandwith</b>, the operating system enforces the first limit that the I/O rate
    ///reaches.
    long         MaxIops;
    ///The maximum limit for the I/O rate in bytes per second. Set to 0 to specify no limit. When you set both
    ///<b>MaxBandwith</b> and <b>MaxIops</b>, the operating system enforces the first limit that the I/O rate reaches.
    long         MaxBandwidth;
    ///Sets a minimum I/O rate which the operating system reserves for the job. To make no reservation for the job, set
    ///this value to 0. The operating system allows the job to perform I/O operations at this rate, if possible. If the
    ///sum of the minimum rates for all jobs exceeds the capacity of the operating system, the rate at which the
    ///operating system allows each job to perform I/O operations is proportional to the reservation for the job.
    long         ReservationIops;
    ///The NT device name for the volume to which you want to apply the policy for the I/O rate. For information about
    ///NT device names, see NT Device Names. If this member is <b>NULL</b>, the policy for the I/O rate applies to all
    ///of the volumes for the operating system. For example, if this member is <b>NULL</b> and the <b>MaxIops</b> member
    ///is 100, the maximum limit for the I/O rate for each volume is set to 100 IOPS, instead of setting an aggregate
    ///limit for the I/O rate across all volumes of 100 IOPS.
    const(PWSTR) VolumeName;
    ///The base size of the normalized I/O unit, in bytes. For example, if the <b>BaseIoSize</b> member is 8,000, every
    ///8,000 bytes counts as one I/O unit. 4,000 bytes is also one I/O unit in this example, while 8,001 bytes is two
    ///I/O units. You can set the value of this base I/O size by using the <b>StorageBaseIOSize</b> value of the
    ///<b>HKEY_LOCAL_MACHINE</b>&
    uint         BaseIoSize;
    ///The policy for control of the I/O rate. This member can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="JOB_OBJECT_IO_RATE_CONTROL_ENABLE"></a><a
    ///id="job_object_io_rate_control_enable"></a><dl> <dt><b>JOB_OBJECT_IO_RATE_CONTROL_ENABLE</b></dt> <dt>0x1</dt>
    ///</dl> </td> <td width="60%"> Turns on control of the I/O rate for the job when this structure is passed to the
    ///SetIoRateControlInformationJobObject function. Indicates that control of the I/O rate for the job is turned on
    ///when this structure is used with the QueryIoRateControlInformationJobObject function. </td> </tr> </table>
    uint         ControlFlags;
}

///Contains information about a newly created process and its primary thread. It is used with the CreateProcess,
///CreateProcessAsUser, CreateProcessWithLogonW, or CreateProcessWithTokenW function.
struct PROCESS_INFORMATION
{
    ///A handle to the newly created process. The handle is used to specify the process in all functions that perform
    ///operations on the process object.
    HANDLE hProcess;
    ///A handle to the primary thread of the newly created process. The handle is used to specify the thread in all
    ///functions that perform operations on the thread object.
    HANDLE hThread;
    ///A value that can be used to identify a process. The value is valid from the time the process is created until all
    ///handles to the process are closed and the process object is freed; at this point, the identifier may be reused.
    uint   dwProcessId;
    ///A value that can be used to identify a thread. The value is valid from the time the thread is created until all
    ///handles to the thread are closed and the thread object is freed; at this point, the identifier may be reused.
    uint   dwThreadId;
}

///Specifies the window station, desktop, standard handles, and appearance of the main window for a process at creation
///time.
struct STARTUPINFOA
{
    ///The size of the structure, in bytes.
    uint   cb;
    ///Reserved; must be NULL.
    PSTR   lpReserved;
    ///The name of the desktop, or the name of both the desktop and window station for this process. A backslash in the
    ///string indicates that the string includes both the desktop and window station names. For more information, see
    ///Thread Connection to a Desktop.
    PSTR   lpDesktop;
    ///For console processes, this is the title displayed in the title bar if a new console window is created. If NULL,
    ///the name of the executable file is used as the window title instead. This parameter must be NULL for GUI or
    ///console processes that do not create a new console window.
    PSTR   lpTitle;
    ///If <b>dwFlags</b> specifies STARTF_USEPOSITION, this member is the x offset of the upper left corner of a window
    ///if a new window is created, in pixels. Otherwise, this member is ignored. The offset is from the upper left
    ///corner of the screen. For GUI processes, the specified position is used the first time the new process calls
    ///CreateWindow to create an overlapped window if the <i>x</i> parameter of <b>CreateWindow</b> is CW_USEDEFAULT.
    uint   dwX;
    ///If <b>dwFlags</b> specifies STARTF_USEPOSITION, this member is the y offset of the upper left corner of a window
    ///if a new window is created, in pixels. Otherwise, this member is ignored. The offset is from the upper left
    ///corner of the screen. For GUI processes, the specified position is used the first time the new process calls
    ///CreateWindow to create an overlapped window if the <i>y</i> parameter of <b>CreateWindow</b> is CW_USEDEFAULT.
    uint   dwY;
    ///If <b>dwFlags</b> specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in
    ///pixels. Otherwise, this member is ignored. For GUI processes, this is used only the first time the new process
    ///calls CreateWindow to create an overlapped window if the <i>nWidth</i> parameter of <b>CreateWindow</b> is
    ///CW_USEDEFAULT.
    uint   dwXSize;
    ///If <b>dwFlags</b> specifies STARTF_USESIZE, this member is the height of the window if a new window is created,
    ///in pixels. Otherwise, this member is ignored. For GUI processes, this is used only the first time the new process
    ///calls CreateWindow to create an overlapped window if the <i>nHeight</i> parameter of <b>CreateWindow</b> is
    ///CW_USEDEFAULT.
    uint   dwYSize;
    ///If <b>dwFlags</b> specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this
    ///member specifies the screen buffer width, in character columns. Otherwise, this member is ignored.
    uint   dwXCountChars;
    ///If <b>dwFlags</b> specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this
    ///member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.
    uint   dwYCountChars;
    ///If <b>dwFlags</b> specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a
    ///new console window is created in a console application. Otherwise, this member is ignored. This value can be any
    ///combination of the following values: FOREGROUND_BLUE, FOREGROUND_GREEN, FOREGROUND_RED, FOREGROUND_INTENSITY,
    ///BACKGROUND_BLUE, BACKGROUND_GREEN, BACKGROUND_RED, and BACKGROUND_INTENSITY. For example, the following
    ///combination of values produces red text on a white background: <code>FOREGROUND_RED| BACKGROUND_RED|
    ///BACKGROUND_GREEN| BACKGROUND_BLUE</code>
    uint   dwFillAttribute;
    ///A bitfield that determines whether certain <b>STARTUPINFO</b> members are used when the process creates a window.
    ///This member can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="STARTF_FORCEONFEEDBACK"></a><a id="startf_forceonfeedback"></a><dl>
    ///<dt><b>STARTF_FORCEONFEEDBACK</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> Indicates that the cursor
    ///is in feedback mode for two seconds after CreateProcess is called. The Working in Background cursor is displayed
    ///(see the Pointers tab in the Mouse control panel utility). If during those two seconds the process makes the
    ///first GUI call, the system gives five more seconds to the process. If during those five seconds the process shows
    ///a window, the system gives five more seconds to the process to finish drawing the window. The system turns the
    ///feedback cursor off after the first call to GetMessage, regardless of whether the process is drawing. </td> </tr>
    ///<tr> <td width="40%"><a id="STARTF_FORCEOFFFEEDBACK"></a><a id="startf_forceofffeedback"></a><dl>
    ///<dt><b>STARTF_FORCEOFFFEEDBACK</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> Indicates that the
    ///feedback cursor is forced off while the process is starting. The Normal Select cursor is displayed. </td> </tr>
    ///<tr> <td width="40%"><a id="STARTF_PREVENTPINNING"></a><a id="startf_preventpinning"></a><dl>
    ///<dt><b>STARTF_PREVENTPINNING</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Indicates that any windows
    ///created by the process cannot be pinned on the taskbar. This flag must be combined with STARTF_TITLEISAPPID.
    ///</td> </tr> <tr> <td width="40%"><a id="STARTF_RUNFULLSCREEN"></a><a id="startf_runfullscreen"></a><dl>
    ///<dt><b>STARTF_RUNFULLSCREEN</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Indicates that the process
    ///should be run in full-screen mode, rather than in windowed mode. This flag is only valid for console applications
    ///running on an x86 computer. </td> </tr> <tr> <td width="40%"><a id="STARTF_TITLEISAPPID"></a><a
    ///id="startf_titleisappid"></a><dl> <dt><b>STARTF_TITLEISAPPID</b></dt> <dt>0x00001000</dt> </dl> </td> <td
    ///width="60%"> The <b>lpTitle</b> member contains an AppUserModelID. This identifier controls how the taskbar and
    ///<b>Start</b> menu present the application, and enables it to be associated with the correct shortcuts and Jump
    ///Lists. Generally, applications will use the SetCurrentProcessExplicitAppUserModelID and
    ///<b>GetCurrentProcessExplicitAppUserModelID</b> functions instead of setting this flag. For more information, see
    ///Application User Model IDs. If STARTF_PREVENTPINNING is used, application windows cannot be pinned on the
    ///taskbar. The use of any AppUserModelID-related window properties by the application overrides this setting for
    ///that window only. This flag cannot be used with STARTF_TITLEISLINKNAME. </td> </tr> <tr> <td width="40%"><a
    ///id="STARTF_TITLEISLINKNAME"></a><a id="startf_titleislinkname"></a><dl> <dt><b>STARTF_TITLEISLINKNAME</b></dt>
    ///<dt>0x00000800</dt> </dl> </td> <td width="60%"> The <b>lpTitle</b> member contains the path of the shortcut file
    ///(.lnk) that the user invoked to start this process. This is typically set by the shell when a .lnk file pointing
    ///to the launched application is invoked. Most applications will not need to set this value. This flag cannot be
    ///used with STARTF_TITLEISAPPID. </td> </tr> <tr> <td width="40%"><a id="STARTF_UNTRUSTEDSOURCE"></a><a
    ///id="startf_untrustedsource"></a><dl> <dt><b>STARTF_UNTRUSTEDSOURCE</b></dt> <dt>0x00008000</dt> </dl> </td> <td
    ///width="60%"> The command line came from an untrusted source. For more information, see Remarks. </td> </tr> <tr>
    ///<td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt></dt> </dl> </td> <td width="60%"></td> </tr> <tr> <td
    ///width="40%"><a id="STARTF_USECOUNTCHARS"></a><a id="startf_usecountchars"></a><dl>
    ///<dt><b>STARTF_USECOUNTCHARS</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The <b>dwXCountChars</b>
    ///and <b>dwYCountChars</b> members contain additional information. </td> </tr> <tr> <td width="40%"><a
    ///id="STARTF_USEFILLATTRIBUTE"></a><a id="startf_usefillattribute"></a><dl> <dt><b>STARTF_USEFILLATTRIBUTE</b></dt>
    ///<dt>0x00000010</dt> </dl> </td> <td width="60%"> The <b>dwFillAttribute</b> member contains additional
    ///information. </td> </tr> <tr> <td width="40%"><a id="STARTF_USEHOTKEY"></a><a id="startf_usehotkey"></a><dl>
    ///<dt><b>STARTF_USEHOTKEY</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> The <b>hStdInput</b> member
    ///contains additional information. This flag cannot be used with <b>STARTF_USESTDHANDLES</b>. </td> </tr> <tr> <td
    ///width="40%"><a id="STARTF_USEPOSITION"></a><a id="startf_useposition"></a><dl> <dt><b>STARTF_USEPOSITION</b></dt>
    ///<dt>0x00000004</dt> </dl> </td> <td width="60%"> The <b>dwX</b> and <b>dwY</b> members contain additional
    ///information. </td> </tr> <tr> <td width="40%"><a id="STARTF_USESHOWWINDOW"></a><a
    ///id="startf_useshowwindow"></a><dl> <dt><b>STARTF_USESHOWWINDOW</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> The <b>wShowWindow</b> member contains additional information. </td> </tr> <tr> <td width="40%"><a
    ///id="STARTF_USESIZE"></a><a id="startf_usesize"></a><dl> <dt><b>STARTF_USESIZE</b></dt> <dt>0x00000002</dt> </dl>
    ///</td> <td width="60%"> The <b>dwXSize</b> and <b>dwYSize</b> members contain additional information. </td> </tr>
    ///<tr> <td width="40%"><a id="STARTF_USESTDHANDLES"></a><a id="startf_usestdhandles"></a><dl>
    ///<dt><b>STARTF_USESTDHANDLES</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> The <b>hStdInput</b>,
    ///<b>hStdOutput</b>, and <b>hStdError</b> members contain additional information. If this flag is specified when
    ///calling one of the process creation functions, the handles must be inheritable and the function's
    ///<i>bInheritHandles</i> parameter must be set to TRUE. For more information, see Handle Inheritance. If this flag
    ///is specified when calling the [GetStartupInfo](./nf-processthreadsapi-getstartupinfow.md) function, these members
    ///are either the handle value specified during process creation or INVALID_HANDLE_VALUE. Handles must be closed
    ///with CloseHandle when they are no longer needed. This flag cannot be used with <b>STARTF_USEHOTKEY</b>. </td>
    ///</tr> </table>
    uint   dwFlags;
    ///If <b>dwFlags</b> specifies STARTF_USESHOWWINDOW, this member can be any of the values that can be specified in
    ///the <i>nCmdShow</i> parameter for the ShowWindow function, except for SW_SHOWDEFAULT. Otherwise, this member is
    ///ignored. For GUI processes, the first time ShowWindow is called, its <i>nCmdShow</i> parameter is ignored
    ///<b>wShowWindow</b> specifies the default value. In subsequent calls to ShowWindow, the <b>wShowWindow</b> member
    ///is used if the <i>nCmdShow</i> parameter of <b>ShowWindow</b> is set to SW_SHOWDEFAULT.
    ushort wShowWindow;
    ///Reserved for use by the C Run-time; must be zero.
    ushort cbReserved2;
    ///Reserved for use by the C Run-time; must be NULL.
    ubyte* lpReserved2;
    ///If <b>dwFlags</b> specifies STARTF_USESTDHANDLES, this member is the standard input handle for the process. If
    ///STARTF_USESTDHANDLES is not specified, the default for standard input is the keyboard buffer. If <b>dwFlags</b>
    ///specifies STARTF_USEHOTKEY, this member specifies a hotkey value that is sent as the <i>wParam</i> parameter of a
    ///WM_SETHOTKEY message to the first eligible top-level window created by the application that owns the process. If
    ///the window is created with the WS_POPUP window style, it is not eligible unless the WS_EX_APPWINDOW extended
    ///window style is also set. For more information, see CreateWindowEx. Otherwise, this member is ignored.
    HANDLE hStdInput;
    ///If <b>dwFlags</b> specifies STARTF_USESTDHANDLES, this member is the standard output handle for the process.
    ///Otherwise, this member is ignored and the default for standard output is the console window's buffer. If a
    ///process is launched from the taskbar or jump list, the system sets <b>hStdOutput</b> to a handle to the monitor
    ///that contains the taskbar or jump list used to launch the process. For more information, see Remarks.<b>Windows
    ///7, Windows Server 2008 R2, Windows Vista, Windows Server 2008, Windows XP and Windows Server 2003: </b>This
    ///behavior was introduced in Windows 8 and Windows Server 2012.
    HANDLE hStdOutput;
    ///If <b>dwFlags</b> specifies STARTF_USESTDHANDLES, this member is the standard error handle for the process.
    ///Otherwise, this member is ignored and the default for standard error is the console window's buffer.
    HANDLE hStdError;
}

///Specifies the window station, desktop, standard handles, and appearance of the main window for a process at creation
///time.
struct STARTUPINFOW
{
    ///The size of the structure, in bytes.
    uint   cb;
    ///Reserved; must be NULL.
    PWSTR  lpReserved;
    ///The name of the desktop, or the name of both the desktop and window station for this process. A backslash in the
    ///string indicates that the string includes both the desktop and window station names. For more information, see
    ///[Thread Connection to a Desktop](/windows/desktop/winstation/thread-connection-to-a-desktop).
    PWSTR  lpDesktop;
    ///For console processes, this is the title displayed in the title bar if a new console window is created. If NULL,
    ///the name of the executable file is used as the window title instead. This parameter must be NULL for GUI or
    ///console processes that do not create a new console window.
    PWSTR  lpTitle;
    ///If <b>dwFlags</b> specifies STARTF_USEPOSITION, this member is the x offset of the upper left corner of a window
    ///if a new window is created, in pixels. Otherwise, this member is ignored. The offset is from the upper left
    ///corner of the screen. For GUI processes, the specified position is used the first time the new process calls
    ///CreateWindow to create an overlapped window if the <i>x</i> parameter of <b>CreateWindow</b> is CW_USEDEFAULT.
    uint   dwX;
    ///If <b>dwFlags</b> specifies STARTF_USEPOSITION, this member is the y offset of the upper left corner of a window
    ///if a new window is created, in pixels. Otherwise, this member is ignored. The offset is from the upper left
    ///corner of the screen. For GUI processes, the specified position is used the first time the new process calls
    ///CreateWindow to create an overlapped window if the <i>y</i> parameter of <b>CreateWindow</b> is CW_USEDEFAULT.
    uint   dwY;
    ///If <b>dwFlags</b> specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in
    ///pixels. Otherwise, this member is ignored. For GUI processes, this is used only the first time the new process
    ///calls CreateWindow to create an overlapped window if the <i>nWidth</i> parameter of <b>CreateWindow</b> is
    ///CW_USEDEFAULT.
    uint   dwXSize;
    ///If <b>dwFlags</b> specifies STARTF_USESIZE, this member is the height of the window if a new window is created,
    ///in pixels. Otherwise, this member is ignored. For GUI processes, this is used only the first time the new process
    ///calls CreateWindow to create an overlapped window if the <i>nHeight</i> parameter of <b>CreateWindow</b> is
    ///CW_USEDEFAULT.
    uint   dwYSize;
    ///If <b>dwFlags</b> specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this
    ///member specifies the screen buffer width, in character columns. Otherwise, this member is ignored.
    uint   dwXCountChars;
    ///If <b>dwFlags</b> specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this
    ///member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.
    uint   dwYCountChars;
    ///If <b>dwFlags</b> specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a
    ///new console window is created in a console application. Otherwise, this member is ignored. This value can be any
    ///combination of the following values: FOREGROUND_BLUE, FOREGROUND_GREEN, FOREGROUND_RED, FOREGROUND_INTENSITY,
    ///BACKGROUND_BLUE, BACKGROUND_GREEN, BACKGROUND_RED, and BACKGROUND_INTENSITY. For example, the following
    ///combination of values produces red text on a white background: <code>FOREGROUND_RED| BACKGROUND_RED|
    ///BACKGROUND_GREEN| BACKGROUND_BLUE</code>
    uint   dwFillAttribute;
    ///A bitfield that determines whether certain <b>STARTUPINFO</b> members are used when the process creates a window.
    ///This member can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="STARTF_FORCEONFEEDBACK"></a><a id="startf_forceonfeedback"></a><dl>
    ///<dt><b>STARTF_FORCEONFEEDBACK</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> Indicates that the cursor
    ///is in feedback mode for two seconds after CreateProcess is called. The Working in Background cursor is displayed
    ///(see the Pointers tab in the Mouse control panel utility). If during those two seconds the process makes the
    ///first GUI call, the system gives five more seconds to the process. If during those five seconds the process shows
    ///a window, the system gives five more seconds to the process to finish drawing the window. The system turns the
    ///feedback cursor off after the first call to GetMessage, regardless of whether the process is drawing. </td> </tr>
    ///<tr> <td width="40%"><a id="STARTF_FORCEOFFFEEDBACK"></a><a id="startf_forceofffeedback"></a><dl>
    ///<dt><b>STARTF_FORCEOFFFEEDBACK</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> Indicates that the
    ///feedback cursor is forced off while the process is starting. The Normal Select cursor is displayed. </td> </tr>
    ///<tr> <td width="40%"><a id="STARTF_PREVENTPINNING"></a><a id="startf_preventpinning"></a><dl>
    ///<dt><b>STARTF_PREVENTPINNING</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Indicates that any windows
    ///created by the process cannot be pinned on the taskbar. This flag must be combined with STARTF_TITLEISAPPID.
    ///</td> </tr> <tr> <td width="40%"><a id="STARTF_RUNFULLSCREEN"></a><a id="startf_runfullscreen"></a><dl>
    ///<dt><b>STARTF_RUNFULLSCREEN</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Indicates that the process
    ///should be run in full-screen mode, rather than in windowed mode. This flag is only valid for console applications
    ///running on an x86 computer. </td> </tr> <tr> <td width="40%"><a id="STARTF_TITLEISAPPID"></a><a
    ///id="startf_titleisappid"></a><dl> <dt><b>STARTF_TITLEISAPPID</b></dt> <dt>0x00001000</dt> </dl> </td> <td
    ///width="60%"> The <b>lpTitle</b> member contains an AppUserModelID. This identifier controls how the taskbar and
    ///<b>Start</b> menu present the application, and enables it to be associated with the correct shortcuts and Jump
    ///Lists. Generally, applications will use the SetCurrentProcessExplicitAppUserModelID and
    ///<b>GetCurrentProcessExplicitAppUserModelID</b> functions instead of setting this flag. For more information, see
    ///Application User Model IDs. If STARTF_PREVENTPINNING is used, application windows cannot be pinned on the
    ///taskbar. The use of any AppUserModelID-related window properties by the application overrides this setting for
    ///that window only. This flag cannot be used with STARTF_TITLEISLINKNAME. </td> </tr> <tr> <td width="40%"><a
    ///id="STARTF_TITLEISLINKNAME"></a><a id="startf_titleislinkname"></a><dl> <dt><b>STARTF_TITLEISLINKNAME</b></dt>
    ///<dt>0x00000800</dt> </dl> </td> <td width="60%"> The <b>lpTitle</b> member contains the path of the shortcut file
    ///(.lnk) that the user invoked to start this process. This is typically set by the shell when a .lnk file pointing
    ///to the launched application is invoked. Most applications will not need to set this value. This flag cannot be
    ///used with STARTF_TITLEISAPPID. </td> </tr> <tr> <td width="40%"><a id="STARTF_UNTRUSTEDSOURCE"></a><a
    ///id="startf_untrustedsource"></a><dl> <dt><b>STARTF_UNTRUSTEDSOURCE</b></dt> <dt>0x00008000</dt> </dl> </td> <td
    ///width="60%"> The command line came from an untrusted source. For more information, see Remarks. </td> </tr> <tr>
    ///<td width="40%"><a id=""></a><dl> <dt><b></b></dt> <dt></dt> </dl> </td> <td width="60%"></td> </tr> <tr> <td
    ///width="40%"><a id="STARTF_USECOUNTCHARS"></a><a id="startf_usecountchars"></a><dl>
    ///<dt><b>STARTF_USECOUNTCHARS</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The <b>dwXCountChars</b>
    ///and <b>dwYCountChars</b> members contain additional information. </td> </tr> <tr> <td width="40%"><a
    ///id="STARTF_USEFILLATTRIBUTE"></a><a id="startf_usefillattribute"></a><dl> <dt><b>STARTF_USEFILLATTRIBUTE</b></dt>
    ///<dt>0x00000010</dt> </dl> </td> <td width="60%"> The <b>dwFillAttribute</b> member contains additional
    ///information. </td> </tr> <tr> <td width="40%"><a id="STARTF_USEHOTKEY"></a><a id="startf_usehotkey"></a><dl>
    ///<dt><b>STARTF_USEHOTKEY</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> The <b>hStdInput</b> member
    ///contains additional information. This flag cannot be used with <b>STARTF_USESTDHANDLES</b>. </td> </tr> <tr> <td
    ///width="40%"><a id="STARTF_USEPOSITION"></a><a id="startf_useposition"></a><dl> <dt><b>STARTF_USEPOSITION</b></dt>
    ///<dt>0x00000004</dt> </dl> </td> <td width="60%"> The <b>dwX</b> and <b>dwY</b> members contain additional
    ///information. </td> </tr> <tr> <td width="40%"><a id="STARTF_USESHOWWINDOW"></a><a
    ///id="startf_useshowwindow"></a><dl> <dt><b>STARTF_USESHOWWINDOW</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> The <b>wShowWindow</b> member contains additional information. </td> </tr> <tr> <td width="40%"><a
    ///id="STARTF_USESIZE"></a><a id="startf_usesize"></a><dl> <dt><b>STARTF_USESIZE</b></dt> <dt>0x00000002</dt> </dl>
    ///</td> <td width="60%"> The <b>dwXSize</b> and <b>dwYSize</b> members contain additional information. </td> </tr>
    ///<tr> <td width="40%"><a id="STARTF_USESTDHANDLES"></a><a id="startf_usestdhandles"></a><dl>
    ///<dt><b>STARTF_USESTDHANDLES</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> The <b>hStdInput</b>,
    ///<b>hStdOutput</b>, and <b>hStdError</b> members contain additional information. If this flag is specified when
    ///calling one of the process creation functions, the handles must be inheritable and the function's
    ///<i>bInheritHandles</i> parameter must be set to TRUE. For more information, see Handle Inheritance. If this flag
    ///is specified when calling the [GetStartupInfo](./nf-processthreadsapi-getstartupinfow.md) function, these members
    ///are either the handle value specified during process creation or INVALID_HANDLE_VALUE. Handles must be closed
    ///with CloseHandle when they are no longer needed. This flag cannot be used with <b>STARTF_USEHOTKEY</b>. </td>
    ///</tr> </table>
    uint   dwFlags;
    ///If <b>dwFlags</b> specifies STARTF_USESHOWWINDOW, this member can be any of the values that can be specified in
    ///the <i>nCmdShow</i> parameter for the ShowWindow function, except for SW_SHOWDEFAULT. Otherwise, this member is
    ///ignored. For GUI processes, the first time ShowWindow is called, its <i>nCmdShow</i> parameter is ignored
    ///<b>wShowWindow</b> specifies the default value. In subsequent calls to ShowWindow, the <b>wShowWindow</b> member
    ///is used if the <i>nCmdShow</i> parameter of <b>ShowWindow</b> is set to SW_SHOWDEFAULT.
    ushort wShowWindow;
    ///Reserved for use by the C Run-time; must be zero.
    ushort cbReserved2;
    ///Reserved for use by the C Run-time; must be NULL.
    ubyte* lpReserved2;
    ///If <b>dwFlags</b> specifies STARTF_USESTDHANDLES, this member is the standard input handle for the process. If
    ///STARTF_USESTDHANDLES is not specified, the default for standard input is the keyboard buffer. If <b>dwFlags</b>
    ///specifies STARTF_USEHOTKEY, this member specifies a hotkey value that is sent as the <i>wParam</i> parameter of a
    ///WM_SETHOTKEY message to the first eligible top-level window created by the application that owns the process. If
    ///the window is created with the WS_POPUP window style, it is not eligible unless the WS_EX_APPWINDOW extended
    ///window style is also set. For more information, see CreateWindowEx. Otherwise, this member is ignored.
    HANDLE hStdInput;
    ///If <b>dwFlags</b> specifies STARTF_USESTDHANDLES, this member is the standard output handle for the process.
    ///Otherwise, this member is ignored and the default for standard output is the console window's buffer. If a
    ///process is launched from the taskbar or jump list, the system sets <b>hStdOutput</b> to a handle to the monitor
    ///that contains the taskbar or jump list used to launch the process. For more information, see Remarks.<b>Windows
    ///7, Windows Server 2008 R2, Windows Vista, Windows Server 2008, Windows XP and Windows Server 2003: </b>This
    ///behavior was introduced in Windows 8 and Windows Server 2012.
    HANDLE hStdOutput;
    ///If <b>dwFlags</b> specifies STARTF_USESTDHANDLES, this member is the standard error handle for the process.
    ///Otherwise, this member is ignored and the default for standard error is the console window's buffer.
    HANDLE hStdError;
}

///Specifies the memory priority for a thread or process. This structure is used by the GetProcessInformation,
///SetProcessInformation, GetThreadInformation, and SetThreadInformation functions.
struct MEMORY_PRIORITY_INFORMATION
{
    ///The memory priority for the thread or process. This member can be one of the following values. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEMORY_PRIORITY_VERY_LOW"></a><a
    ///id="memory_priority_very_low"></a><dl> <dt><b>MEMORY_PRIORITY_VERY_LOW</b></dt> <dt>1</dt> </dl> </td> <td
    ///width="60%"> Very low memory priority. </td> </tr> <tr> <td width="40%"><a id="MEMORY_PRIORITY_LOW"></a><a
    ///id="memory_priority_low"></a><dl> <dt><b>MEMORY_PRIORITY_LOW</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Low
    ///memory priority. </td> </tr> <tr> <td width="40%"><a id="MEMORY_PRIORITY_MEDIUM"></a><a
    ///id="memory_priority_medium"></a><dl> <dt><b>MEMORY_PRIORITY_MEDIUM</b></dt> <dt>3</dt> </dl> </td> <td
    ///width="60%"> Medium memory priority. </td> </tr> <tr> <td width="40%"><a id="MEMORY_PRIORITY_BELOW_NORMAL"></a><a
    ///id="memory_priority_below_normal"></a><dl> <dt><b>MEMORY_PRIORITY_BELOW_NORMAL</b></dt> <dt>4</dt> </dl> </td>
    ///<td width="60%"> Below normal memory priority. </td> </tr> <tr> <td width="40%"><a
    ///id="MEMORY_PRIORITY_NORMAL"></a><a id="memory_priority_normal"></a><dl> <dt><b>MEMORY_PRIORITY_NORMAL</b></dt>
    ///<dt>5</dt> </dl> </td> <td width="60%"> Normal memory priority. This is the default priority for all threads and
    ///processes on the system. </td> </tr> </table>
    uint MemoryPriority;
}

///Specifies the throttling policies and how to apply them to a target thread when that thread is subject to power
///management. This structure is used by the [SetThreadInformation
///function](./nf-processthreadsapi-setthreadinformation.md).
struct THREAD_POWER_THROTTLING_STATE
{
    ///The version of the <b>THREAD_POWER_THROTTLING_STATE</b> structure. | Value | Meaning | | --- | --- | |
    ///THREAD_POWER_THROTTLING_CURRENT_VERSION | The current version. |
    uint Version;
    ///This field enables the caller to take control of the power throttling mechanism. | Value | Meaning | | --- | ---
    ///| | THREAD_POWER_THROTTLING_EXECUTION_SPEED | Manages the execution speed of the thread. |
    uint ControlMask;
    uint StateMask;
}

///Represents app memory usage at a single point in time. This structure is used by the PROCESS_INFORMATION_CLASS class.
struct APP_MEMORY_INFORMATION
{
    ///Total commit available to the app.
    ulong AvailableCommit;
    ///The app's usage of private commit.
    ulong PrivateCommitUsage;
    ///The app's peak usage of private commit.
    ulong PeakPrivateCommitUsage;
    ///The app's total usage of private plus shared commit.
    ulong TotalCommitUsage;
}

///Allows applications to configure a process to terminate if an allocation fails to commit memory. This structure is
///used by the PROCESS_INFORMATION_CLASS class.
struct PROCESS_MEMORY_EXHAUSTION_INFO
{
    ///Version should be set to <b>PME_CURRENT_VERSION</b>.
    ushort Version;
    ///Reserved.
    ushort Reserved;
    ///Type of failure. Type should be set to <b>PMETypeFailFastOnCommitFailure</b> (this is the only type available).
    PROCESS_MEMORY_EXHAUSTION_TYPE Type;
    ///Used to turn the feature on or off. <table> <tr> <td>Function</td> <td> Setting</td> </tr> <tr> <td>Enable</td>
    ///<td>PME_FAILFAST_ON_COMMIT_FAIL_ENABLE </td> </tr> <tr> <td>Disable</td> <td>PME_FAILFAST_ON_COMMIT_FAIL_DISABLE
    ///</td> </tr> </table>
    size_t Value;
}

///Specifies the throttling policies and how to apply them to a target process when that process is subject to power
///management. This structure is used by the SetProcessInformation function.
struct PROCESS_POWER_THROTTLING_STATE
{
    ///The version of the <b>PROCESS_POWER_THROTTLING_STATE</b> structure. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="PROCESS_POWER_THROTTLING_CURRENT_VERSION"></a><a
    ///id="process_power_throttling_current_version"></a><dl> <dt><b>PROCESS_POWER_THROTTLING_CURRENT_VERSION</b></dt>
    ///<dt></dt> </dl> </td> <td width="60%"> The current version. </td> </tr> </table>
    uint Version;
    ///This field enables the caller to take control of the power throttling mechanism. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="PROCESS_POWER_THROTTLING_EXECUTION_SPEED"></a><a
    ///id="process_power_throttling_execution_speed"></a><dl> <dt><b>PROCESS_POWER_THROTTLING_EXECUTION_SPEED</b></dt>
    ///<dt></dt> </dl> </td> <td width="60%"> Manages the execution speed of the process. </td> </tr> </table>
    uint ControlMask;
    uint StateMask;
}

///Specifies whether Protected Process Light (PPL) is enabled.
struct PROCESS_PROTECTION_LEVEL_INFORMATION
{
    uint ProtectionLevel;
}

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] Specifies how the system handles positive leap seconds.
struct PROCESS_LEAP_SECOND_INFO
{
    ///Currently, the only valid flag is <b>PROCESS_LEAP_SECOND_INFO_FLAG_ENABLE_SIXTY_SECOND</b>. That flag is
    ///described below. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="PROCESS_LEAP_SECOND_INFO_FLAG_ENABLE_SIXTY_SECOND"></a><a
    ///id="process_leap_second_info_flag_enable_sixty_second"></a><dl>
    ///<dt><b>PROCESS_LEAP_SECOND_INFO_FLAG_ENABLE_SIXTY_SECOND</b></dt> <dt></dt> </dl> </td> <td width="60%"> This
    ///value changes the way positive leap seconds are handled by system. Specifically, it changes how the seconds field
    ///during a positive leap second is handled by the system. If this value is used, then the positive leap second will
    ///be shown (For example: 23:59:59 -&gt; 23:59:60 -&gt; 00:00:00. If this value is not used, then "sixty seconds" is
    ///disabled, and the 59th second preceding a positive leap second will be shown for 2 seconds with the milliseconds
    ///value ticking twice as slow. So 23:59:59 -&gt; 23:59:59.500 -&gt; 00:00:00, which takes 2 seconds in wall clock
    ///time. Disabling "sixty second" can help with legacy apps that do not support seeing the seconds value as 60
    ///during the positive leap second. Such apps may crash or misbehave. Therefore, in these cases, we display the 59th
    ///second for twice as long during the positive leap second. Note that this setting is per-process, and does not
    ///persist if the process is restarted. Developers should test their app for compatibility with seeing the system
    ///return "60", and add a call to their app startup routines to either enable or disable "sixty seconds". "Sixty
    ///seconds" is disabled by default for each process. Obviously, this setting has no effect if leap seconds are
    ///disabled system-wide, because then the system will never even encounter a leap second. </td> </tr> </table>
    uint Flags;
    uint Reserved;
}

///Contains information about the current state of both physical and virtual memory, including extended memory. The
///GlobalMemoryStatusEx function stores information in this structure.
struct MEMORYSTATUSEX
{
    ///The size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
    uint  dwLength;
    ///A number between 0 and 100 that specifies the approximate percentage of physical memory that is in use (0
    ///indicates no memory use and 100 indicates full memory use).
    uint  dwMemoryLoad;
    ///The amount of actual physical memory, in bytes.
    ulong ullTotalPhys;
    ///The amount of physical memory currently available, in bytes. This is the amount of physical memory that can be
    ///immediately reused without having to write its contents to disk first. It is the sum of the size of the standby,
    ///free, and zero lists.
    ulong ullAvailPhys;
    ///The current committed memory limit for the system or the current process, whichever is smaller, in bytes. To get
    ///the system-wide committed memory limit, call GetPerformanceInfo.
    ulong ullTotalPageFile;
    ///The maximum amount of memory the current process can commit, in bytes. This value is equal to or smaller than the
    ///system-wide available commit value. To calculate the system-wide available commit value, call GetPerformanceInfo
    ///and subtract the value of <b>CommitTotal</b> from the value of <b>CommitLimit</b>.
    ulong ullAvailPageFile;
    ///The size of the user-mode portion of the virtual address space of the calling process, in bytes. This value
    ///depends on the type of process, the type of processor, and the configuration of the operating system. For
    ///example, this value is approximately 2 GB for most 32-bit processes on an x86 processor and approximately 3 GB
    ///for 32-bit processes that are large address aware running on a system with 4-gigabyte tuning enabled.
    ulong ullTotalVirtual;
    ///The amount of unreserved and uncommitted memory currently in the user-mode portion of the virtual address space
    ///of the calling process, in bytes.
    ulong ullAvailVirtual;
    ///Reserved. This value is always 0.
    ulong ullAvailExtendedVirtual;
}

///Contains information about a communications driver.
struct COMMPROP
{
    ///The size of the entire data packet, regardless of the amount of data requested, in bytes.
    ushort    wPacketLength;
    ///The version of the structure.
    ushort    wPacketVersion;
    ///A bitmask indicating which services are implemented by this provider. The <b>SP_SERIALCOMM</b> value is always
    ///specified for communications providers, including modem providers.
    uint      dwServiceMask;
    ///Reserved; do not use.
    uint      dwReserved1;
    ///The maximum size of the driver's internal output buffer, in bytes. A value of zero indicates that no maximum
    ///value is imposed by the serial provider.
    uint      dwMaxTxQueue;
    ///The maximum size of the driver's internal input buffer, in bytes. A value of zero indicates that no maximum value
    ///is imposed by the serial provider.
    uint      dwMaxRxQueue;
    ///The maximum allowable baud rate, in bits per second (bps). This member can be one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="BAUD_075"></a><a
    ///id="baud_075"></a><dl> <dt><b>BAUD_075</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> 75 bps </td>
    ///</tr> <tr> <td width="40%"><a id="BAUD_110"></a><a id="baud_110"></a><dl> <dt><b>BAUD_110</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> 110 bps </td> </tr> <tr> <td width="40%"><a
    ///id="BAUD_134_5"></a><a id="baud_134_5"></a><dl> <dt><b>BAUD_134_5</b></dt> <dt>0x00000004</dt> </dl> </td> <td
    ///width="60%"> 134.5 bps </td> </tr> <tr> <td width="40%"><a id="BAUD_150"></a><a id="baud_150"></a><dl>
    ///<dt><b>BAUD_150</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> 150 bps </td> </tr> <tr> <td
    ///width="40%"><a id="BAUD_300"></a><a id="baud_300"></a><dl> <dt><b>BAUD_300</b></dt> <dt>0x00000010</dt> </dl>
    ///</td> <td width="60%"> 300 bps </td> </tr> <tr> <td width="40%"><a id="BAUD_600"></a><a id="baud_600"></a><dl>
    ///<dt><b>BAUD_600</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> 600 bps </td> </tr> <tr> <td
    ///width="40%"><a id="BAUD_1200"></a><a id="baud_1200"></a><dl> <dt><b>BAUD_1200</b></dt> <dt>0x00000040</dt> </dl>
    ///</td> <td width="60%"> 1200 bps </td> </tr> <tr> <td width="40%"><a id="BAUD_1800"></a><a id="baud_1800"></a><dl>
    ///<dt><b>BAUD_1800</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> 1800 bps </td> </tr> <tr> <td
    ///width="40%"><a id="BAUD_2400"></a><a id="baud_2400"></a><dl> <dt><b>BAUD_2400</b></dt> <dt>0x00000100</dt> </dl>
    ///</td> <td width="60%"> 2400 bps </td> </tr> <tr> <td width="40%"><a id="BAUD_4800"></a><a id="baud_4800"></a><dl>
    ///<dt><b>BAUD_4800</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> 4800 bps </td> </tr> <tr> <td
    ///width="40%"><a id="BAUD_7200"></a><a id="baud_7200"></a><dl> <dt><b>BAUD_7200</b></dt> <dt>0x00000400</dt> </dl>
    ///</td> <td width="60%"> 7200 bps </td> </tr> <tr> <td width="40%"><a id="BAUD_9600"></a><a id="baud_9600"></a><dl>
    ///<dt><b>BAUD_9600</b></dt> <dt>0x00000800</dt> </dl> </td> <td width="60%"> 9600 bps </td> </tr> <tr> <td
    ///width="40%"><a id="BAUD_14400"></a><a id="baud_14400"></a><dl> <dt><b>BAUD_14400</b></dt> <dt>0x00001000</dt>
    ///</dl> </td> <td width="60%"> 14400 bps </td> </tr> <tr> <td width="40%"><a id="BAUD_19200"></a><a
    ///id="baud_19200"></a><dl> <dt><b>BAUD_19200</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> 19200 bps
    ///</td> </tr> <tr> <td width="40%"><a id="BAUD_38400"></a><a id="baud_38400"></a><dl> <dt><b>BAUD_38400</b></dt>
    ///<dt>0x00004000</dt> </dl> </td> <td width="60%"> 38400 bps </td> </tr> <tr> <td width="40%"><a
    ///id="BAUD_56K"></a><a id="baud_56k"></a><dl> <dt><b>BAUD_56K</b></dt> <dt>0x00008000</dt> </dl> </td> <td
    ///width="60%"> 56K bps </td> </tr> <tr> <td width="40%"><a id="BAUD_57600"></a><a id="baud_57600"></a><dl>
    ///<dt><b>BAUD_57600</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> 57600 bps </td> </tr> <tr> <td
    ///width="40%"><a id="BAUD_115200"></a><a id="baud_115200"></a><dl> <dt><b>BAUD_115200</b></dt> <dt>0x00020000</dt>
    ///</dl> </td> <td width="60%"> 115200 bps </td> </tr> <tr> <td width="40%"><a id="BAUD_128K"></a><a
    ///id="baud_128k"></a><dl> <dt><b>BAUD_128K</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> 128K bps </td>
    ///</tr> <tr> <td width="40%"><a id="BAUD_USER"></a><a id="baud_user"></a><dl> <dt><b>BAUD_USER</b></dt>
    ///<dt>0x10000000</dt> </dl> </td> <td width="60%"> Programmable baud rate. </td> </tr> </table>
    uint      dwMaxBaud;
    ///The communications-provider type. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="PST_FAX"></a><a id="pst_fax"></a><dl> <dt><b>PST_FAX</b></dt> <dt>0x00000021</dt> </dl> </td> <td
    ///width="60%"> FAX device </td> </tr> <tr> <td width="40%"><a id="PST_LAT"></a><a id="pst_lat"></a><dl>
    ///<dt><b>PST_LAT</b></dt> <dt>0x00000101</dt> </dl> </td> <td width="60%"> LAT protocol </td> </tr> <tr> <td
    ///width="40%"><a id="PST_MODEM"></a><a id="pst_modem"></a><dl> <dt><b>PST_MODEM</b></dt> <dt>0x00000006</dt> </dl>
    ///</td> <td width="60%"> Modem device </td> </tr> <tr> <td width="40%"><a id="PST_NETWORK_BRIDGE"></a><a
    ///id="pst_network_bridge"></a><dl> <dt><b>PST_NETWORK_BRIDGE</b></dt> <dt>0x00000100</dt> </dl> </td> <td
    ///width="60%"> Unspecified network bridge </td> </tr> <tr> <td width="40%"><a id="PST_PARALLELPORT"></a><a
    ///id="pst_parallelport"></a><dl> <dt><b>PST_PARALLELPORT</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%">
    ///Parallel port </td> </tr> <tr> <td width="40%"><a id="PST_RS232"></a><a id="pst_rs232"></a><dl>
    ///<dt><b>PST_RS232</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> RS-232 serial port </td> </tr> <tr>
    ///<td width="40%"><a id="PST_RS422"></a><a id="pst_rs422"></a><dl> <dt><b>PST_RS422</b></dt> <dt>0x00000003</dt>
    ///</dl> </td> <td width="60%"> RS-422 port </td> </tr> <tr> <td width="40%"><a id="PST_RS423"></a><a
    ///id="pst_rs423"></a><dl> <dt><b>PST_RS423</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> RS-423 port
    ///</td> </tr> <tr> <td width="40%"><a id="PST_RS449"></a><a id="pst_rs449"></a><dl> <dt><b>PST_RS449</b></dt>
    ///<dt>0x00000005</dt> </dl> </td> <td width="60%"> RS-449 port </td> </tr> <tr> <td width="40%"><a
    ///id="PST_SCANNER"></a><a id="pst_scanner"></a><dl> <dt><b>PST_SCANNER</b></dt> <dt>0x00000022</dt> </dl> </td> <td
    ///width="60%"> Scanner device </td> </tr> <tr> <td width="40%"><a id="PST_TCPIP_TELNET"></a><a
    ///id="pst_tcpip_telnet"></a><dl> <dt><b>PST_TCPIP_TELNET</b></dt> <dt>0x00000102</dt> </dl> </td> <td width="60%">
    ///TCP/IP Telnet protocol </td> </tr> <tr> <td width="40%"><a id="PST_UNSPECIFIED"></a><a
    ///id="pst_unspecified"></a><dl> <dt><b>PST_UNSPECIFIED</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%">
    ///Unspecified </td> </tr> <tr> <td width="40%"><a id="PST_X25"></a><a id="pst_x25"></a><dl> <dt><b>PST_X25</b></dt>
    ///<dt>0x00000103</dt> </dl> </td> <td width="60%"> X.25 standards </td> </tr> </table>
    uint      dwProvSubType;
    ///A bitmask indicating the capabilities offered by the provider. This member can be a combination of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PCF_16BITMODE"></a><a
    ///id="pcf_16bitmode"></a><dl> <dt><b>PCF_16BITMODE</b></dt> <dt>0x0200</dt> </dl> </td> <td width="60%"> Special
    ///16-bit mode supported </td> </tr> <tr> <td width="40%"><a id="PCF_DTRDSR"></a><a id="pcf_dtrdsr"></a><dl>
    ///<dt><b>PCF_DTRDSR</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> DTR (data-terminal-ready)/DSR
    ///(data-set-ready) supported </td> </tr> <tr> <td width="40%"><a id="PCF_INTTIMEOUTS"></a><a
    ///id="pcf_inttimeouts"></a><dl> <dt><b>PCF_INTTIMEOUTS</b></dt> <dt>0x0080</dt> </dl> </td> <td width="60%">
    ///Interval time-outs supported </td> </tr> <tr> <td width="40%"><a id="PCF_PARITY_CHECK"></a><a
    ///id="pcf_parity_check"></a><dl> <dt><b>PCF_PARITY_CHECK</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%">
    ///Parity checking supported </td> </tr> <tr> <td width="40%"><a id="PCF_RLSD"></a><a id="pcf_rlsd"></a><dl>
    ///<dt><b>PCF_RLSD</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> RLSD (receive-line-signal-detect) supported
    ///</td> </tr> <tr> <td width="40%"><a id="PCF_RTSCTS"></a><a id="pcf_rtscts"></a><dl> <dt><b>PCF_RTSCTS</b></dt>
    ///<dt>0x0002</dt> </dl> </td> <td width="60%"> RTS (request-to-send)/CTS (clear-to-send) supported </td> </tr> <tr>
    ///<td width="40%"><a id="PCF_SETXCHAR"></a><a id="pcf_setxchar"></a><dl> <dt><b>PCF_SETXCHAR</b></dt>
    ///<dt>0x0020</dt> </dl> </td> <td width="60%"> Settable XON/XOFF supported </td> </tr> <tr> <td width="40%"><a
    ///id="PCF_SPECIALCHARS"></a><a id="pcf_specialchars"></a><dl> <dt><b>PCF_SPECIALCHARS</b></dt> <dt>0x0100</dt>
    ///</dl> </td> <td width="60%"> Special character support provided </td> </tr> <tr> <td width="40%"><a
    ///id="PCF_TOTALTIMEOUTS"></a><a id="pcf_totaltimeouts"></a><dl> <dt><b>PCF_TOTALTIMEOUTS</b></dt> <dt>0x0040</dt>
    ///</dl> </td> <td width="60%"> The total (elapsed) time-outs supported </td> </tr> <tr> <td width="40%"><a
    ///id="PCF_XONXOFF"></a><a id="pcf_xonxoff"></a><dl> <dt><b>PCF_XONXOFF</b></dt> <dt>0x0010</dt> </dl> </td> <td
    ///width="60%"> XON/XOFF flow control supported </td> </tr> </table>
    uint      dwProvCapabilities;
    ///A bitmask indicating the communications parameters that can be changed. This member can be a combination of the
    ///following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SP_BAUD"></a><a
    ///id="sp_baud"></a><dl> <dt><b>SP_BAUD</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Baud rate </td> </tr>
    ///<tr> <td width="40%"><a id="SP_DATABITS"></a><a id="sp_databits"></a><dl> <dt><b>SP_DATABITS</b></dt>
    ///<dt>0x0004</dt> </dl> </td> <td width="60%"> Data bits </td> </tr> <tr> <td width="40%"><a
    ///id="SP_HANDSHAKING"></a><a id="sp_handshaking"></a><dl> <dt><b>SP_HANDSHAKING</b></dt> <dt>0x0010</dt> </dl>
    ///</td> <td width="60%"> Handshaking (flow control) </td> </tr> <tr> <td width="40%"><a id="SP_PARITY"></a><a
    ///id="sp_parity"></a><dl> <dt><b>SP_PARITY</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Parity </td> </tr>
    ///<tr> <td width="40%"><a id="SP_PARITY_CHECK"></a><a id="sp_parity_check"></a><dl> <dt><b>SP_PARITY_CHECK</b></dt>
    ///<dt>0x0020</dt> </dl> </td> <td width="60%"> Parity checking </td> </tr> <tr> <td width="40%"><a
    ///id="SP_RLSD"></a><a id="sp_rlsd"></a><dl> <dt><b>SP_RLSD</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%">
    ///RLSD (receive-line-signal-detect) </td> </tr> <tr> <td width="40%"><a id="SP_STOPBITS"></a><a
    ///id="sp_stopbits"></a><dl> <dt><b>SP_STOPBITS</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> Stop bits
    ///</td> </tr> </table>
    uint      dwSettableParams;
    ///The baud rates that can be used. For values, see the <b>dwMaxBaud</b> member.
    uint      dwSettableBaud;
    ///A bitmask indicating the number of data bits that can be set. This member can be a combination of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DATABITS_5"></a><a
    ///id="databits_5"></a><dl> <dt><b>DATABITS_5</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> 5 data bits
    ///</td> </tr> <tr> <td width="40%"><a id="DATABITS_6"></a><a id="databits_6"></a><dl> <dt><b>DATABITS_6</b></dt>
    ///<dt>0x0002</dt> </dl> </td> <td width="60%"> 6 data bits </td> </tr> <tr> <td width="40%"><a
    ///id="DATABITS_7"></a><a id="databits_7"></a><dl> <dt><b>DATABITS_7</b></dt> <dt>0x0004</dt> </dl> </td> <td
    ///width="60%"> 7 data bits </td> </tr> <tr> <td width="40%"><a id="DATABITS_8"></a><a id="databits_8"></a><dl>
    ///<dt><b>DATABITS_8</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> 8 data bits </td> </tr> <tr> <td
    ///width="40%"><a id="DATABITS_16"></a><a id="databits_16"></a><dl> <dt><b>DATABITS_16</b></dt> <dt>0x0010</dt>
    ///</dl> </td> <td width="60%"> 16 data bits </td> </tr> <tr> <td width="40%"><a id="DATABITS_16X"></a><a
    ///id="databits_16x"></a><dl> <dt><b>DATABITS_16X</b></dt> <dt>0x0020</dt> </dl> </td> <td width="60%"> Special wide
    ///path through serial hardware lines </td> </tr> </table>
    ushort    wSettableData;
    ///A bitmask indicating the stop bit and parity settings that can be selected. This member can be a combination of
    ///the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STOPBITS_10"></a><a id="stopbits_10"></a><dl> <dt><b>STOPBITS_10</b></dt> <dt>0x0001</dt> </dl> </td> <td
    ///width="60%"> 1 stop bit </td> </tr> <tr> <td width="40%"><a id="STOPBITS_15"></a><a id="stopbits_15"></a><dl>
    ///<dt><b>STOPBITS_15</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> 1.5 stop bits </td> </tr> <tr> <td
    ///width="40%"><a id="STOPBITS_20"></a><a id="stopbits_20"></a><dl> <dt><b>STOPBITS_20</b></dt> <dt>0x0004</dt>
    ///</dl> </td> <td width="60%"> 2 stop bits </td> </tr> <tr> <td width="40%"><a id="PARITY_NONE"></a><a
    ///id="parity_none"></a><dl> <dt><b>PARITY_NONE</b></dt> <dt>0x0100</dt> </dl> </td> <td width="60%"> No parity
    ///</td> </tr> <tr> <td width="40%"><a id="PARITY_ODD"></a><a id="parity_odd"></a><dl> <dt><b>PARITY_ODD</b></dt>
    ///<dt>0x0200</dt> </dl> </td> <td width="60%"> Odd parity </td> </tr> <tr> <td width="40%"><a
    ///id="PARITY_EVEN"></a><a id="parity_even"></a><dl> <dt><b>PARITY_EVEN</b></dt> <dt>0x0400</dt> </dl> </td> <td
    ///width="60%"> Even parity </td> </tr> <tr> <td width="40%"><a id="PARITY_MARK"></a><a id="parity_mark"></a><dl>
    ///<dt><b>PARITY_MARK</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> Mark parity </td> </tr> <tr> <td
    ///width="40%"><a id="PARITY_SPACE"></a><a id="parity_space"></a><dl> <dt><b>PARITY_SPACE</b></dt> <dt>0x1000</dt>
    ///</dl> </td> <td width="60%"> Space parity </td> </tr> </table>
    ushort    wSettableStopParity;
    ///The size of the driver's internal output buffer, in bytes. A value of zero indicates that the value is
    ///unavailable.
    uint      dwCurrentTxQueue;
    ///The size of the driver's internal input buffer, in bytes. A value of zero indicates that the value is
    ///unavailable.
    uint      dwCurrentRxQueue;
    ///Any provider-specific data. Applications should ignore this member unless they have detailed information about
    ///the format of the data required by the provider. Set this member to <b>COMMPROP_INITIALIZED</b> before calling
    ///the GetCommProperties function to indicate that the <b>wPacketLength</b> member is already valid.
    uint      dwProvSpec1;
    ///Any provider-specific data. Applications should ignore this member unless they have detailed information about
    ///the format of the data required by the provider.
    uint      dwProvSpec2;
    ///Any provider-specific data. Applications should ignore this member unless they have detailed information about
    ///the format of the data required by the provider.
    ushort[1] wcProvChar;
}

///Contains information about a communications device. This structure is filled by the ClearCommError function.
struct COMSTAT
{
    uint _bitfield169;
    ///The number of bytes received by the serial provider but not yet read by a ReadFile operation.
    uint cbInQue;
    ///The number of bytes of user data remaining to be transmitted for all write operations. This value will be zero
    ///for a nonoverlapped write.
    uint cbOutQue;
}

///Defines the control setting for a serial communications device.
struct DCB
{
    ///The length of the structure, in bytes. The caller must set this member to <code>sizeof(DCB)</code>.
    uint   DCBlength;
    ///The baud rate at which the communications device operates. This member can be an actual baud rate value, or one
    ///of the following indexes. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="CBR_110"></a><a id="cbr_110"></a><dl> <dt><b>CBR_110</b></dt> <dt>110</dt> </dl> </td> <td width="60%"> 110
    ///bps </td> </tr> <tr> <td width="40%"><a id="CBR_300"></a><a id="cbr_300"></a><dl> <dt><b>CBR_300</b></dt>
    ///<dt>300</dt> </dl> </td> <td width="60%"> 300 bps </td> </tr> <tr> <td width="40%"><a id="CBR_600"></a><a
    ///id="cbr_600"></a><dl> <dt><b>CBR_600</b></dt> <dt>600</dt> </dl> </td> <td width="60%"> 600 bps </td> </tr> <tr>
    ///<td width="40%"><a id="CBR_1200"></a><a id="cbr_1200"></a><dl> <dt><b>CBR_1200</b></dt> <dt>1200</dt> </dl> </td>
    ///<td width="60%"> 1200 bps </td> </tr> <tr> <td width="40%"><a id="CBR_2400"></a><a id="cbr_2400"></a><dl>
    ///<dt><b>CBR_2400</b></dt> <dt>2400</dt> </dl> </td> <td width="60%"> 2400 bps </td> </tr> <tr> <td width="40%"><a
    ///id="CBR_4800"></a><a id="cbr_4800"></a><dl> <dt><b>CBR_4800</b></dt> <dt>4800</dt> </dl> </td> <td width="60%">
    ///4800 bps </td> </tr> <tr> <td width="40%"><a id="CBR_9600"></a><a id="cbr_9600"></a><dl> <dt><b>CBR_9600</b></dt>
    ///<dt>9600</dt> </dl> </td> <td width="60%"> 9600 bps </td> </tr> <tr> <td width="40%"><a id="CBR_14400"></a><a
    ///id="cbr_14400"></a><dl> <dt><b>CBR_14400</b></dt> <dt>14400</dt> </dl> </td> <td width="60%"> 14400 bps </td>
    ///</tr> <tr> <td width="40%"><a id="CBR_19200"></a><a id="cbr_19200"></a><dl> <dt><b>CBR_19200</b></dt>
    ///<dt>19200</dt> </dl> </td> <td width="60%"> 19200 bps </td> </tr> <tr> <td width="40%"><a id="CBR_38400"></a><a
    ///id="cbr_38400"></a><dl> <dt><b>CBR_38400</b></dt> <dt>38400</dt> </dl> </td> <td width="60%"> 38400 bps </td>
    ///</tr> <tr> <td width="40%"><a id="CBR_57600"></a><a id="cbr_57600"></a><dl> <dt><b>CBR_57600</b></dt>
    ///<dt>57600</dt> </dl> </td> <td width="60%"> 57600 bps </td> </tr> <tr> <td width="40%"><a id="CBR_115200"></a><a
    ///id="cbr_115200"></a><dl> <dt><b>CBR_115200</b></dt> <dt>115200</dt> </dl> </td> <td width="60%"> 115200 bps </td>
    ///</tr> <tr> <td width="40%"><a id="CBR_128000"></a><a id="cbr_128000"></a><dl> <dt><b>CBR_128000</b></dt>
    ///<dt>128000</dt> </dl> </td> <td width="60%"> 128000 bps </td> </tr> <tr> <td width="40%"><a
    ///id="CBR_256000"></a><a id="cbr_256000"></a><dl> <dt><b>CBR_256000</b></dt> <dt>256000</dt> </dl> </td> <td
    ///width="60%"> 256000 bps </td> </tr> </table>
    uint   BaudRate;
    uint   _bitfield170;
    ///Reserved; must be zero.
    ushort wReserved;
    ///The minimum number of bytes in use allowed in the input buffer before flow control is activated to allow
    ///transmission by the sender. This assumes that either XON/XOFF, RTS, or DTR input flow control is specified in the
    ///<b>fInX</b>, <b>fRtsControl</b>, or <b>fDtrControl</b> members.
    ushort XonLim;
    ///The minimum number of free bytes allowed in the input buffer before flow control is activated to inhibit the
    ///sender. Note that the sender may transmit characters after the flow control signal has been activated, so this
    ///value should never be zero. This assumes that either XON/XOFF, RTS, or DTR input flow control is specified in the
    ///<b>fInX</b>, <b>fRtsControl</b>, or <b>fDtrControl</b> members. The maximum number of bytes in use allowed is
    ///calculated by subtracting this value from the size, in bytes, of the input buffer.
    ushort XoffLim;
    ///The number of bits in the bytes transmitted and received.
    ubyte  ByteSize;
    ///The parity scheme to be used. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="EVENPARITY"></a><a id="evenparity"></a><dl>
    ///<dt><b>EVENPARITY</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Even parity. </td> </tr> <tr> <td
    ///width="40%"><a id="MARKPARITY"></a><a id="markparity"></a><dl> <dt><b>MARKPARITY</b></dt> <dt>3</dt> </dl> </td>
    ///<td width="60%"> Mark parity. </td> </tr> <tr> <td width="40%"><a id="NOPARITY"></a><a id="noparity"></a><dl>
    ///<dt><b>NOPARITY</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> No parity. </td> </tr> <tr> <td width="40%"><a
    ///id="ODDPARITY"></a><a id="oddparity"></a><dl> <dt><b>ODDPARITY</b></dt> <dt>1</dt> </dl> </td> <td width="60%">
    ///Odd parity. </td> </tr> <tr> <td width="40%"><a id="SPACEPARITY"></a><a id="spaceparity"></a><dl>
    ///<dt><b>SPACEPARITY</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Space parity. </td> </tr> </table>
    ubyte  Parity;
    ///The number of stop bits to be used. This member can be one of the following values. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="ONESTOPBIT"></a><a id="onestopbit"></a><dl>
    ///<dt><b>ONESTOPBIT</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> 1 stop bit. </td> </tr> <tr> <td
    ///width="40%"><a id="ONE5STOPBITS"></a><a id="one5stopbits"></a><dl> <dt><b>ONE5STOPBITS</b></dt> <dt>1</dt> </dl>
    ///</td> <td width="60%"> 1.5 stop bits. </td> </tr> <tr> <td width="40%"><a id="TWOSTOPBITS"></a><a
    ///id="twostopbits"></a><dl> <dt><b>TWOSTOPBITS</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> 2 stop bits. </td>
    ///</tr> </table>
    ubyte  StopBits;
    ///The value of the XON character for both transmission and reception.
    byte   XonChar;
    ///The value of the XOFF character for both transmission and reception.
    byte   XoffChar;
    ///The value of the character used to replace bytes received with a parity error.
    byte   ErrorChar;
    ///The value of the character used to signal the end of data.
    byte   EofChar;
    ///The value of the character used to signal an event.
    byte   EvtChar;
    ///Reserved; do not use.
    ushort wReserved1;
}

///Contains the time-out parameters for a communications device. The parameters determine the behavior of ReadFile,
///WriteFile, ReadFileEx, and WriteFileEx operations on the device.
struct COMMTIMEOUTS
{
    ///The maximum time allowed to elapse before the arrival of the next byte on the communications line, in
    ///milliseconds. If the interval between the arrival of any two bytes exceeds this amount, the ReadFile operation is
    ///completed and any buffered data is returned. A value of zero indicates that interval time-outs are not used. A
    ///value of <b>MAXDWORD</b>, combined with zero values for both the <b>ReadTotalTimeoutConstant</b> and
    ///<b>ReadTotalTimeoutMultiplier</b> members, specifies that the read operation is to return immediately with the
    ///bytes that have already been received, even if no bytes have been received.
    uint ReadIntervalTimeout;
    ///The multiplier used to calculate the total time-out period for read operations, in milliseconds. For each read
    ///operation, this value is multiplied by the requested number of bytes to be read.
    uint ReadTotalTimeoutMultiplier;
    ///A constant used to calculate the total time-out period for read operations, in milliseconds. For each read
    ///operation, this value is added to the product of the <b>ReadTotalTimeoutMultiplier</b> member and the requested
    ///number of bytes. A value of zero for both the <b>ReadTotalTimeoutMultiplier</b> and
    ///<b>ReadTotalTimeoutConstant</b> members indicates that total time-outs are not used for read operations.
    uint ReadTotalTimeoutConstant;
    ///The multiplier used to calculate the total time-out period for write operations, in milliseconds. For each write
    ///operation, this value is multiplied by the number of bytes to be written.
    uint WriteTotalTimeoutMultiplier;
    ///A constant used to calculate the total time-out period for write operations, in milliseconds. For each write
    ///operation, this value is added to the product of the <b>WriteTotalTimeoutMultiplier</b> member and the number of
    ///bytes to be written. A value of zero for both the <b>WriteTotalTimeoutMultiplier</b> and
    ///<b>WriteTotalTimeoutConstant</b> members indicates that total time-outs are not used for write operations.
    uint WriteTotalTimeoutConstant;
}

///Contains information about the configuration state of a communications device.
struct COMMCONFIG
{
    ///The size of the structure, in bytes. The caller must set this member to <code>sizeof(COMMCONFIG)</code>.
    uint      dwSize;
    ///The version number of the structure. This parameter can be 1. The version of the provider-specific structure
    ///should be included in the <b>wcProviderData</b> member.
    ushort    wVersion;
    ///Reserved; do not use.
    ushort    wReserved;
    ///The device-control block (DCB) structure for RS-232 serial devices. A <b>DCB</b> structure is always present
    ///regardless of the port driver subtype specified in the device's COMMPROP structure.
    DCB       dcb;
    ///The type of communications provider, and thus the format of the provider-specific data. For a list of
    ///communications provider types, see the description of the COMMPROP structure.
    uint      dwProviderSubType;
    ///The offset of the provider-specific data relative to the beginning of the structure, in bytes. This member is
    ///zero if there is no provider-specific data.
    uint      dwProviderOffset;
    ///The size of the provider-specific data, in bytes.
    uint      dwProviderSize;
    ///Optional provider-specific data. This member can be of any size or can be omitted. Because the <b>COMMCONFIG</b>
    ///structure may be expanded in the future, applications should use the <b>dwProviderOffset</b> member to determine
    ///the location of this member.
    ushort[1] wcProviderData;
}

///Contains information about the current state of both physical and virtual memory. The GlobalMemoryStatus function
///stores information in a <b>MEMORYSTATUS</b> structure.
struct MEMORYSTATUS
{
    ///The size of the <b>MEMORYSTATUS</b> data structure, in bytes. You do not need to set this member before calling
    ///the GlobalMemoryStatus function; the function sets it.
    uint   dwLength;
    ///A number between 0 and 100 that specifies the approximate percentage of physical memory that is in use (0
    ///indicates no memory use and 100 indicates full memory use).
    uint   dwMemoryLoad;
    ///The amount of actual physical memory, in bytes.
    size_t dwTotalPhys;
    ///The amount of physical memory currently available, in bytes. This is the amount of physical memory that can be
    ///immediately reused without having to write its contents to disk first. It is the sum of the size of the standby,
    ///free, and zero lists.
    size_t dwAvailPhys;
    ///The current size of the committed memory limit, in bytes. This is physical memory plus the size of the page file,
    ///minus a small overhead.
    size_t dwTotalPageFile;
    ///The maximum amount of memory the current process can commit, in bytes. This value should be smaller than the
    ///system-wide available commit. To calculate this value, call GetPerformanceInfo and subtract the value of
    ///<b>CommitTotal</b> from <b>CommitLimit</b>.
    size_t dwAvailPageFile;
    ///The size of the user-mode portion of the virtual address space of the calling process, in bytes. This value
    ///depends on the type of process, the type of processor, and the configuration of the operating system. For
    ///example, this value is approximately 2 GB for most 32-bit processes on an x86 processor and approximately 3 GB
    ///for 32-bit processes that are large address aware running on a system with 4 GT RAM Tuning enabled.
    size_t dwTotalVirtual;
    ///The amount of unreserved and uncommitted memory currently in the user-mode portion of the virtual address space
    ///of the calling process, in bytes.
    size_t dwAvailVirtual;
}

///Specifies attributes for a user-mode scheduling (UMS) scheduler thread. The EnterUmsSchedulingMode function uses this
///structure.
struct UMS_SCHEDULER_STARTUP_INFO
{
    ///The UMS version for which the application was built. This parameter must be <b>UMS_VERSION</b>.
    uint  UmsVersion;
    ///A pointer to a UMS completion list to associate with the calling thread.
    void* CompletionList;
    ///A pointer to an application-defined UmsSchedulerProc entry point function. The system calls this function when
    ///the calling thread has been converted to UMS and is ready to run UMS worker threads. Subsequently, it calls this
    ///function when a UMS worker thread running on the calling thread yields or blocks.
    PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;
    void* SchedulerParam;
}

///Specifies a UMS scheduler thread, UMS worker thread, or non-UMS thread. The GetUmsSystemThreadInformation function
///uses this structure.
struct UMS_SYSTEM_THREAD_INFORMATION
{
    ///The UMS version. This member must be UMS_VERSION.
    uint UmsVersion;
union
    {
struct
        {
            uint _bitfield171;
        }
        uint ThreadUmsFlags;
    }
}

///The <b>WIN32_STREAM_ID</b> structure contains stream data.
struct WIN32_STREAM_ID
{
    ///Type of data. This member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="BACKUP_ALTERNATE_DATA"></a><a id="backup_alternate_data"></a><dl>
    ///<dt><b>BACKUP_ALTERNATE_DATA</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Alternative data streams.
    ///This corresponds to the NTFS $DATA stream type on a named data stream. </td> </tr> <tr> <td width="40%"><a
    ///id="BACKUP_DATA"></a><a id="backup_data"></a><dl> <dt><b>BACKUP_DATA</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> Standard data. This corresponds to the NTFS $DATA stream type on the default (unnamed) data stream.
    ///</td> </tr> <tr> <td width="40%"><a id="BACKUP_EA_DATA"></a><a id="backup_ea_data"></a><dl>
    ///<dt><b>BACKUP_EA_DATA</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Extended attribute data. This
    ///corresponds to the NTFS $EA stream type. </td> </tr> <tr> <td width="40%"><a id="BACKUP_LINK"></a><a
    ///id="backup_link"></a><dl> <dt><b>BACKUP_LINK</b></dt> <dt>0x00000005</dt> </dl> </td> <td width="60%"> Hard link
    ///information. This corresponds to the NTFS $FILE_NAME stream type. </td> </tr> <tr> <td width="40%"><a
    ///id="BACKUP_OBJECT_ID"></a><a id="backup_object_id"></a><dl> <dt><b>BACKUP_OBJECT_ID</b></dt> <dt>0x00000007</dt>
    ///</dl> </td> <td width="60%"> Objects identifiers. This corresponds to the NTFS $OBJECT_ID stream type. </td>
    ///</tr> <tr> <td width="40%"><a id="BACKUP_PROPERTY_DATA"></a><a id="backup_property_data"></a><dl>
    ///<dt><b>BACKUP_PROPERTY_DATA</b></dt> <dt>0x00000006</dt> </dl> </td> <td width="60%"> Property data. </td> </tr>
    ///<tr> <td width="40%"><a id="BACKUP_REPARSE_DATA"></a><a id="backup_reparse_data"></a><dl>
    ///<dt><b>BACKUP_REPARSE_DATA</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Reparse points. This
    ///corresponds to the NTFS $REPARSE_POINT stream type. </td> </tr> <tr> <td width="40%"><a
    ///id="BACKUP_SECURITY_DATA"></a><a id="backup_security_data"></a><dl> <dt><b>BACKUP_SECURITY_DATA</b></dt>
    ///<dt>0x00000003</dt> </dl> </td> <td width="60%"> Security descriptor data. </td> </tr> <tr> <td width="40%"><a
    ///id="BACKUP_SPARSE_BLOCK"></a><a id="backup_sparse_block"></a><dl> <dt><b>BACKUP_SPARSE_BLOCK</b></dt>
    ///<dt>0x00000009</dt> </dl> </td> <td width="60%"> Sparse file. This corresponds to the NTFS $DATA stream type for
    ///a sparse file. </td> </tr> <tr> <td width="40%"><a id="BACKUP_TXFS_DATA"></a><a id="backup_txfs_data"></a><dl>
    ///<dt><b>BACKUP_TXFS_DATA</b></dt> <dt>0x0000000A</dt> </dl> </td> <td width="60%"> Transactional NTFS (TxF) data
    ///stream. This corresponds to the NTFS $TXF_DATA stream type. <b>Windows Server 2003 and Windows XP: </b>This value
    ///is not supported. </td> </tr> </table>
    uint          dwStreamId;
    ///Attributes of data to facilitate cross-operating system transfer. This member can be one or more of the following
    ///values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="STREAM_MODIFIED_WHEN_READ"></a><a id="stream_modified_when_read"></a><dl>
    ///<dt><b>STREAM_MODIFIED_WHEN_READ</b></dt> </dl> </td> <td width="60%"> Attribute set if the stream contains data
    ///that is modified when read. Allows the backup application to know that verification of data will fail. </td>
    ///</tr> <tr> <td width="40%"><a id="STREAM_CONTAINS_SECURITY"></a><a id="stream_contains_security"></a><dl>
    ///<dt><b>STREAM_CONTAINS_SECURITY</b></dt> </dl> </td> <td width="60%"> Stream contains security data (general
    ///attributes). Allows the stream to be ignored on cross-operations restore. </td> </tr> </table>
    uint          dwStreamAttributes;
    ///Size of data, in bytes.
    LARGE_INTEGER Size;
    ///Length of the name of the alternative data stream, in bytes.
    uint          dwStreamNameSize;
    ///Unicode string that specifies the name of the alternative data stream.
    ushort[1]     cStreamName;
}

///Specifies the window station, desktop, standard handles, and attributes for a new process. It is used with the
///CreateProcess and CreateProcessAsUser functions.
struct STARTUPINFOEXA
{
    ///A STARTUPINFO structure.
    STARTUPINFOA StartupInfo;
    ///An attribute list. This list is created by the InitializeProcThreadAttributeList function.
    ptrdiff_t    lpAttributeList;
}

///Specifies the window station, desktop, standard handles, and attributes for a new process. It is used with the
///CreateProcess and CreateProcessAsUser functions.
struct STARTUPINFOEXW
{
    ///A STARTUPINFO structure.
    STARTUPINFOW StartupInfo;
    ///An attribute list. This list is created by the InitializeProcThreadAttributeList function.
    ptrdiff_t    lpAttributeList;
}

///Indicates whether the event log is full.
struct EVENTLOG_FULL_INFORMATION
{
    ///Indicates whether the event log is full. If the log is full, this member is <b>TRUE</b>. Otherwise, it is
    ///<b>FALSE</b>.
    uint dwFull;
}

///Contains information about the power status of the system.
struct SYSTEM_POWER_STATUS
{
    ///The AC power status. This member can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Offline </td> </tr> <tr> <td
    ///width="40%"> <dl> <dt>1</dt> </dl> </td> <td width="60%"> Online </td> </tr> <tr> <td width="40%"> <dl>
    ///<dt>255</dt> </dl> </td> <td width="60%"> Unknown status </td> </tr> </table>
    ubyte ACLineStatus;
    ///The battery charge status. This member can contain one or more of the following flags. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>1</dt> </dl> </td> <td width="60%">
    ///High—the battery capacity is at more than 66 percent </td> </tr> <tr> <td width="40%"> <dl> <dt>2</dt> </dl>
    ///</td> <td width="60%"> Low—the battery capacity is at less than 33 percent </td> </tr> <tr> <td width="40%">
    ///<dl> <dt>4</dt> </dl> </td> <td width="60%"> Critical—the battery capacity is at less than five percent </td>
    ///</tr> <tr> <td width="40%"> <dl> <dt>8</dt> </dl> </td> <td width="60%"> Charging </td> </tr> <tr> <td
    ///width="40%"> <dl> <dt>128</dt> </dl> </td> <td width="60%"> No system battery </td> </tr> <tr> <td width="40%">
    ///<dl> <dt>255</dt> </dl> </td> <td width="60%"> Unknown status—unable to read the battery flag information </td>
    ///</tr> </table> The value is zero if the battery is not being charged and the battery capacity is between low and
    ///high.
    ubyte BatteryFlag;
    ///The percentage of full battery charge remaining. This member can be a value in the range 0 to 100, or 255 if
    ///status is unknown.
    ubyte BatteryLifePercent;
    ///The status of battery saver. To participate in energy conservation, avoid resource intensive tasks when battery
    ///saver is on. To be notified when this value changes, call the RegisterPowerSettingNotification function with the
    ///power setting GUID, <b>GUID_POWER_SAVING_STATUS</b>. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Battery saver is off. </td> </tr> <tr> <td width="40%">
    ///<dl> <dt>1</dt> </dl> </td> <td width="60%"> Battery saver on. Save energy where possible. </td> </tr> </table>
    ///<div class="alert"><b>Note</b> This flag and the <b>GUID_POWER_SAVING_STATUS</b> GUID were introduced in Windows
    ///10. This flag was previously reserved, named <b>Reserved1</b>, and had a value of 0.</div> <div> </div> For
    ///general information about battery saver, see battery saver (in the hardware component guidelines).
    ubyte SystemStatusFlag;
    ///The number of seconds of battery life remaining, or –1 if remaining seconds are unknown or if the device is
    ///connected to AC power.
    uint  BatteryLifeTime;
    ///The number of seconds of battery life when at full charge, or –1 if full battery lifetime is unknown or if the
    ///device is connected to AC power.
    uint  BatteryFullLifeTime;
}

///<p class="CCE_Message">[This structure may be altered in future versions of Windows.] Contains information about the
///loaded modules for the process.
struct PEB_LDR_DATA
{
    ///Reserved for internal use by the operating system.
    ubyte[8]   Reserved1;
    ///Reserved for internal use by the operating system.
    void[3]*   Reserved2;
    ///The head of a doubly-linked list that contains the loaded modules for the process. Each item in the list is a
    ///pointer to an <b>LDR_DATA_TABLE_ENTRY</b> structure. For more information, see Remarks.
    LIST_ENTRY InMemoryOrderModuleList;
}

///<p class="CCE_Message">[This structure may be altered in future versions of Windows.] Contains process parameter
///information.
struct RTL_USER_PROCESS_PARAMETERS
{
    ///Reserved for internal use by the operating system.
    ubyte[16]      Reserved1;
    ///Reserved for internal use by the operating system.
    void[10]*      Reserved2;
    ///The path of the image file for the process.
    UNICODE_STRING ImagePathName;
    ///The command-line string passed to the process.
    UNICODE_STRING CommandLine;
}

///<p class="CCE_Message">[This structure may be altered in future versions of Windows.] Contains process information.
struct PEB
{
    ///Reserved for internal use by the operating system.
    ubyte[2]      Reserved1;
    ///Indicates whether the specified process is currently being debugged. The <b>PEB</b> structure, however, is an
    ///internal operating-system structure whose layout may change in the future. It is best to use the
    ///CheckRemoteDebuggerPresent function instead.
    ubyte         BeingDebugged;
    ///Reserved for internal use by the operating system.
    ubyte[1]      Reserved2;
    ///Reserved for internal use by the operating system.
    void[2]*      Reserved3;
    ///A pointer to a PEB_LDR_DATA structure that contains information about the loaded modules for the process.
    PEB_LDR_DATA* Ldr;
    ///A pointer to an RTL_USER_PROCESS_PARAMETERS structure that contains process parameter information such as the
    ///command line.
    RTL_USER_PROCESS_PARAMETERS* ProcessParameters;
    ///Reserved for internal use by the operating system.
    void[3]*      Reserved4;
    void*         AtlThunkSListPtr;
    ///Reserved for internal use by the operating system.
    void*         Reserved5;
    ///Reserved for internal use by the operating system.
    uint          Reserved6;
    ///Reserved for internal use by the operating system.
    void*         Reserved7;
    uint          Reserved8;
    uint          AtlThunkSListPtr32;
    void[45]*     Reserved9;
    ubyte[96]     Reserved10;
    ///Not supported.
    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
    ubyte[128]    Reserved11;
    void[1]*      Reserved12;
    ///The Terminal Services session identifier associated with the current process.
    uint          SessionId;
}

// Functions

///Creates an anonymous pipe, and returns handles to the read and write ends of the pipe.
///Params:
///    hReadPipe = A pointer to a variable that receives the read handle for the pipe.
///    hWritePipe = A pointer to a variable that receives the write handle for the pipe.
///    lpPipeAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by
///                       child processes. If <i>lpPipeAttributes</i> is <b>NULL</b>, the handle cannot be inherited. The
///                       <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new pipe. If
///                       <i>lpPipeAttributes</i> is <b>NULL</b>, the pipe gets a default security descriptor. The ACLs in the default
///                       security descriptor for a pipe come from the primary or impersonation token of the creator.
///    nSize = The size of the buffer for the pipe, in bytes. The size is only a suggestion; the system uses the value to
///            calculate an appropriate buffering mechanism. If this parameter is zero, the system uses the default buffer size.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL CreatePipe(HANDLE* hReadPipe, HANDLE* hWritePipe, SECURITY_ATTRIBUTES* lpPipeAttributes, uint nSize);

///Enables a named pipe server process to wait for a client process to connect to an instance of a named pipe. A client
///process connects by calling either the CreateFile or CallNamedPipe function.
///Params:
///    hNamedPipe = A handle to the server end of a named pipe instance. This handle is returned by the CreateNamedPipe function.
///    lpOverlapped = A pointer to an OVERLAPPED structure. If <i>hNamedPipe</i> was opened with FILE_FLAG_OVERLAPPED, the
///                   <i>lpOverlapped</i> parameter must not be <b>NULL</b>. It must point to a valid OVERLAPPED structure. If
///                   <i>hNamedPipe</i> was opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is <b>NULL</b>, the function can
///                   incorrectly report that the connect operation is complete. If <i>hNamedPipe</i> was created with
///                   FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is not <b>NULL</b>, the OVERLAPPED structure should contain a handle
///                   to a manual-reset event object (which the server can create by using the CreateEvent function). If
///                   <i>hNamedPipe</i> was not opened with FILE_FLAG_OVERLAPPED, the function does not return until a client is
///                   connected or an error occurs. Successful synchronous operations result in the function returning a nonzero value
///                   if a client connects after the function is called.
///Returns:
///    If the operation is synchronous, <b>ConnectNamedPipe</b> does not return until the operation has completed. If
///    the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the operation is asynchronous, <b>ConnectNamedPipe</b> returns
///    immediately. If the operation is still pending, the return value is zero and GetLastError returns
///    ERROR_IO_PENDING. (You can use the HasOverlappedIoCompleted macro to determine when the operation has finished.)
///    If the function fails, the return value is zero and <b>GetLastError</b> returns a value other than
///    ERROR_IO_PENDING or ERROR_PIPE_CONNECTED. If a client connects before the function is called, the function
///    returns zero and GetLastError returns ERROR_PIPE_CONNECTED. This can happen if a client connects in the interval
///    between the call to CreateNamedPipe and the call to <b>ConnectNamedPipe</b>. In this situation, there is a good
///    connection between client and server, even though the function returns zero.
///    
@DllImport("KERNEL32")
BOOL ConnectNamedPipe(HANDLE hNamedPipe, OVERLAPPED* lpOverlapped);

///Disconnects the server end of a named pipe instance from a client process.
///Params:
///    hNamedPipe = A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DisconnectNamedPipe(HANDLE hNamedPipe);

///Sets the read mode and the blocking mode of the specified named pipe. If the specified handle is to the client end of
///a named pipe and if the named pipe server process is on a remote computer, the function can also be used to control
///local buffering.
///Params:
///    hNamedPipe = A handle to the named pipe instance. This parameter can be a handle to the server end of the pipe, as returned by
///                 the CreateNamedPipe function, or to the client end of the pipe, as returned by the CreateFile function. The
///                 handle must have GENERIC_WRITE access to the named pipe for a write-only or read/write pipe, or it must have
///                 GENERIC_READ and FILE_WRITE_ATTRIBUTES access for a read-only pipe. This parameter can also be a handle to an
///                 anonymous pipe, as returned by the CreatePipe function.
///    lpMode = The new pipe mode. The mode is a combination of a read-mode flag and a wait-mode flag. This parameter can be
///             <b>NULL</b> if the mode is not being set. Specify one of the following modes. <table> <tr> <th>Mode</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PIPE_READMODE_BYTE"></a><a id="pipe_readmode_byte"></a><dl>
///             <dt><b>PIPE_READMODE_BYTE</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> Data is read from the pipe as
///             a stream of bytes. This mode is the default if no read-mode flag is specified. </td> </tr> <tr> <td
///             width="40%"><a id="PIPE_READMODE_MESSAGE"></a><a id="pipe_readmode_message"></a><dl>
///             <dt><b>PIPE_READMODE_MESSAGE</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Data is read from the pipe
///             as a stream of messages. The function fails if this flag is specified for a byte-type pipe. </td> </tr> </table>
///             One of the following wait modes can be specified. <table> <tr> <th>Mode</th> <th>Meaning</th> </tr> <tr> <td
///             width="40%"><a id="PIPE_WAIT"></a><a id="pipe_wait"></a><dl> <dt><b>PIPE_WAIT</b></dt> <dt>0x00000000</dt> </dl>
///             </td> <td width="60%"> Blocking mode is enabled. This mode is the default if no wait-mode flag is specified. When
///             a blocking mode pipe handle is specified in the ReadFile, WriteFile, or ConnectNamedPipe function, operations are
///             not finished until there is data to read, all data is written, or a client is connected. Use of this mode can
///             mean waiting indefinitely in some situations for a client process to perform an action. </td> </tr> <tr> <td
///             width="40%"><a id="PIPE_NOWAIT"></a><a id="pipe_nowait"></a><dl> <dt><b>PIPE_NOWAIT</b></dt> <dt>0x00000001</dt>
///             </dl> </td> <td width="60%"> Nonblocking mode is enabled. In this mode, ReadFile, WriteFile, and ConnectNamedPipe
///             always return immediately. Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager
///             version 2.0 and should not be used to achieve asynchronous input and output (I/O) with named pipes. </td> </tr>
///             </table>
///    lpMaxCollectionCount = The maximum number of bytes collected on the client computer before transmission to the server. This parameter
///                           must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or if client and server
///                           processes are on the same machine. This parameter is ignored if the client process specifies the
///                           FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created. This parameter can be
///                           <b>NULL</b> if the collection count is not being set.
///    lpCollectDataTimeout = The maximum time, in milliseconds, that can pass before a remote named pipe transfers information over the
///                           network. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end of a named pipe or
///                           if client and server processes are on the same computer. This parameter is ignored if the client process
///                           specified the FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created. This parameter
///                           can be <b>NULL</b> if the collection count is not being set.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, uint* lpMode, uint* lpMaxCollectionCount, 
                             uint* lpCollectDataTimeout);

///Copies data from a named or anonymous pipe into a buffer without removing it from the pipe. It also returns
///information about data in the pipe.
///Params:
///    hNamedPipe = A handle to the pipe. This parameter can be a handle to a named pipe instance, as returned by the CreateNamedPipe
///                 or CreateFile function, or it can be a handle to the read end of an anonymous pipe, as returned by the CreatePipe
///                 function. The handle must have GENERIC_READ access to the pipe.
///    lpBuffer = A pointer to a buffer that receives data read from the pipe. This parameter can be <b>NULL</b> if no data is to
///               be read.
///    nBufferSize = The size of the buffer specified by the <i>lpBuffer</i> parameter, in bytes. This parameter is ignored if
///                  <i>lpBuffer</i> is <b>NULL</b>.
///    lpBytesRead = A pointer to a variable that receives the number of bytes read from the pipe. This parameter can be <b>NULL</b>
///                  if no data is to be read.
///    lpTotalBytesAvail = A pointer to a variable that receives the total number of bytes available to be read from the pipe. This
///                        parameter can be <b>NULL</b> if no data is to be read.
///    lpBytesLeftThisMessage = A pointer to a variable that receives the number of bytes remaining in this message. This parameter will be zero
///                             for byte-type named pipes or for anonymous pipes. This parameter can be <b>NULL</b> if no data is to be read.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL PeekNamedPipe(HANDLE hNamedPipe, void* lpBuffer, uint nBufferSize, uint* lpBytesRead, uint* lpTotalBytesAvail, 
                   uint* lpBytesLeftThisMessage);

///Combines the functions that write a message to and read a message from the specified named pipe into a single network
///operation.
///Params:
///    hNamedPipe = A handle to the named pipe returned by the CreateNamedPipe or CreateFile function. This parameter can also be a
///                 handle to an anonymous pipe, as returned by the CreatePipe function.
///    lpInBuffer = A pointer to the buffer containing the data to be written to the pipe.
///    nInBufferSize = The size of the input buffer, in bytes.
///    lpOutBuffer = A pointer to the buffer that receives the data read from the pipe.
///    nOutBufferSize = The size of the output buffer, in bytes.
///    lpBytesRead = A pointer to the variable that receives the number of bytes read from the pipe. If <i>lpOverlapped</i> is
///                  <b>NULL</b>, <i>lpBytesRead</i> cannot be <b>NULL</b>. If <i>lpOverlapped</i> is not <b>NULL</b>,
///                  <i>lpBytesRead</i> can be <b>NULL</b>. If this is an overlapped read operation, you can get the number of bytes
///                  read by calling GetOverlappedResult. If <i>hNamedPipe</i> is associated with an I/O completion port, you can get
///                  the number of bytes read by calling GetQueuedCompletionStatus.
///    lpOverlapped = A pointer to an OVERLAPPED structure. This structure is required if <i>hNamedPipe</i> was opened with
///                   FILE_FLAG_OVERLAPPED. If <i>hNamedPipe</i> was opened with FILE_FLAG_OVERLAPPED, the <i>lpOverlapped</i>
///                   parameter must not be <b>NULL</b>. It must point to a valid OVERLAPPED structure. If <i>hNamedPipe</i> was
///                   created with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is <b>NULL</b>, the function can incorrectly report
///                   that the operation is complete. If <i>hNamedPipe</i> was opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i>
///                   is not <b>NULL</b>, <b>TransactNamedPipe</b> is executed as an overlapped operation. The OVERLAPPED structure
///                   should contain a manual-reset event object (which can be created by using the CreateEvent function). If the
///                   operation cannot be completed immediately, <b>TransactNamedPipe</b> returns <b>FALSE</b> and GetLastError returns
///                   ERROR_IO_PENDING. In this situation, the event object is set to the nonsignaled state before
///                   <b>TransactNamedPipe</b> returns, and it is set to the signaled state when the transaction has finished. Also,
///                   you can be notified when an overlapped operation completes by using the GetQueuedCompletionStatus or
///                   GetQueuedCompletionStatusEx functions. In this case, you do not need to assign the manual-reset event in the
///                   <b>OVERLAPPED</b> structure, and the completion happens against <i>hNamedPipe</i> in the same way as an
///                   asynchronous read or write operation. For more information about overlapped operations, see Pipes. If
///                   <i>hNamedPipe</i> was not opened with FILE_FLAG_OVERLAPPED, <b>TransactNamedPipe</b> does not return until the
///                   operation is complete.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the message to be read is longer than the buffer specified by
///    the <i>nOutBufferSize</i> parameter, <b>TransactNamedPipe</b> returns <b>FALSE</b> and the GetLastError function
///    returns ERROR_MORE_DATA. The remainder of the message can be read by a subsequent call to ReadFile, ReadFileEx,
///    or PeekNamedPipe.
///    
@DllImport("KERNEL32")
BOOL TransactNamedPipe(HANDLE hNamedPipe, void* lpInBuffer, uint nInBufferSize, void* lpOutBuffer, 
                       uint nOutBufferSize, uint* lpBytesRead, OVERLAPPED* lpOverlapped);

@DllImport("KERNEL32")
HANDLE CreateNamedPipeW(const(PWSTR) lpName, uint dwOpenMode, uint dwPipeMode, uint nMaxInstances, 
                        uint nOutBufferSize, uint nInBufferSize, uint nDefaultTimeOut, 
                        SECURITY_ATTRIBUTES* lpSecurityAttributes);

@DllImport("KERNEL32")
BOOL WaitNamedPipeW(const(PWSTR) lpNamedPipeName, uint nTimeOut);

@DllImport("KERNEL32")
BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, PWSTR ClientComputerName, uint ClientComputerNameLength);

///Retrieves information about the specified named pipe.
///Params:
///    hNamedPipe = A handle to the named pipe instance. The handle must have GENERIC_READ access to the named pipe for a read-only
///                 or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only pipe. This
///                 parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.
///    lpFlags = A pointer to a variable that receives the type of the named pipe. This parameter can be <b>NULL</b> if this
///              information is not required. Otherwise, this parameter can be one or more of the following values. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PIPE_CLIENT_END"></a><a
///              id="pipe_client_end"></a><dl> <dt><b>PIPE_CLIENT_END</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%">
///              The handle refers to the client end of a named pipe instance. This is the default. </td> </tr> <tr> <td
///              width="40%"><a id="PIPE_SERVER_END"></a><a id="pipe_server_end"></a><dl> <dt><b>PIPE_SERVER_END</b></dt>
///              <dt>0x00000001</dt> </dl> </td> <td width="60%"> The handle refers to the server end of a named pipe instance. If
///              this value is not specified, the handle refers to the client end of a named pipe instance. </td> </tr> <tr> <td
///              width="40%"><a id="PIPE_TYPE_BYTE"></a><a id="pipe_type_byte"></a><dl> <dt><b>PIPE_TYPE_BYTE</b></dt>
///              <dt>0x00000000</dt> </dl> </td> <td width="60%"> The named pipe is a byte pipe. This is the default. </td> </tr>
///              <tr> <td width="40%"><a id="PIPE_TYPE_MESSAGE"></a><a id="pipe_type_message"></a><dl>
///              <dt><b>PIPE_TYPE_MESSAGE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The named pipe is a message
///              pipe. If this value is not specified, the pipe is a byte pipe. </td> </tr> </table>
///    lpOutBufferSize = A pointer to a variable that receives the size of the buffer for outgoing data, in bytes. If the buffer size is
///                      zero, the buffer is allocated as needed. This parameter can be <b>NULL</b> if this information is not required.
///    lpInBufferSize = A pointer to a variable that receives the size of the buffer for incoming data, in bytes. If the buffer size is
///                     zero, the buffer is allocated as needed. This parameter can be <b>NULL</b> if this information is not required.
///    lpMaxInstances = A pointer to a variable that receives the maximum number of pipe instances that can be created. If the variable
///                     is set to PIPE_UNLIMITED_INSTANCES (255), the number of pipe instances that can be created is limited only by the
///                     availability of system resources. This parameter can be <b>NULL</b> if this information is not required.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNamedPipeInfo(HANDLE hNamedPipe, uint* lpFlags, uint* lpOutBufferSize, uint* lpInBufferSize, 
                      uint* lpMaxInstances);

@DllImport("KERNEL32")
BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, uint* lpState, uint* lpCurInstances, uint* lpMaxCollectionCount, 
                              uint* lpCollectDataTimeout, PWSTR lpUserName, uint nMaxUserNameSize);

@DllImport("KERNEL32")
BOOL CallNamedPipeW(const(PWSTR) lpNamedPipeName, void* lpInBuffer, uint nInBufferSize, void* lpOutBuffer, 
                    uint nOutBufferSize, uint* lpBytesRead, uint nTimeOut);

///Creates a private heap object that can be used by the calling process. The function reserves space in the virtual
///address space of the process and allocates physical storage for a specified initial portion of this block.
///Params:
///    flOptions = The heap allocation options. These options affect subsequent access to the new heap through calls to the heap
///                functions. This parameter can be 0 or one or more of the following values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HEAP_CREATE_ENABLE_EXECUTE"></a><a
///                id="heap_create_enable_execute"></a><dl> <dt><b>HEAP_CREATE_ENABLE_EXECUTE</b></dt> <dt>0x00040000</dt> </dl>
///                </td> <td width="60%"> All memory blocks that are allocated from this heap allow code execution, if the hardware
///                enforces data execution prevention. Use this flag heap in applications that run code from the heap. If
///                <b>HEAP_CREATE_ENABLE_EXECUTE</b> is not specified and an application attempts to run code from a protected page,
///                the application receives an exception with the status code <b>STATUS_ACCESS_VIOLATION</b>. </td> </tr> <tr> <td
///                width="40%"><a id="HEAP_GENERATE_EXCEPTIONS"></a><a id="heap_generate_exceptions"></a><dl>
///                <dt><b>HEAP_GENERATE_EXCEPTIONS</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The system raises an
///                exception to indicate failure (for example, an out-of-memory condition) for calls to HeapAlloc and HeapReAlloc
///                instead of returning <b>NULL</b>. </td> </tr> <tr> <td width="40%"><a id="HEAP_NO_SERIALIZE"></a><a
///                id="heap_no_serialize"></a><dl> <dt><b>HEAP_NO_SERIALIZE</b></dt> <dt>0x00000001</dt> </dl> </td> <td
///                width="60%"> Serialized access is not used when the heap functions access this heap. This option applies to all
///                subsequent heap function calls. Alternatively, you can specify this option on individual heap function calls. The
///                low-fragmentation heap (LFH) cannot be enabled for a heap created with this option. A heap created with this
///                option cannot be locked. For more information about serialized access, see the Remarks section of this topic.
///                </td> </tr> </table>
///    dwInitialSize = The initial size of the heap, in bytes. This value determines the initial amount of memory that is committed for
///                    the heap. The value is rounded up to a multiple of the system page size. The value must be smaller than
///                    <i>dwMaximumSize</i>. If this parameter is 0, the function commits one page. To determine the size of a page on
///                    the host computer, use the GetSystemInfo function.
///    dwMaximumSize = The maximum size of the heap, in bytes. The <b>HeapCreate</b> function rounds <i>dwMaximumSize</i> up to a
///                    multiple of the system page size and then reserves a block of that size in the process's virtual address space
///                    for the heap. If allocation requests made by the HeapAlloc or HeapReAlloc functions exceed the size specified by
///                    <i>dwInitialSize</i>, the system commits additional pages of memory for the heap, up to the heap's maximum size.
///                    If <i>dwMaximumSize</i> is not zero, the heap size is fixed and cannot grow beyond the maximum size. Also, the
///                    largest memory block that can be allocated from the heap is slightly less than 512 KB for a 32-bit process and
///                    slightly less than 1,024 KB for a 64-bit process. Requests to allocate larger blocks fail, even if the maximum
///                    size of the heap is large enough to contain the block. If <i>dwMaximumSize</i> is 0, the heap can grow in size.
///                    The heap's size is limited only by the available memory. Requests to allocate memory blocks larger than the limit
///                    for a fixed-size heap do not automatically fail; instead, the system calls the VirtualAlloc function to obtain
///                    the memory that is needed for large blocks. Applications that need to allocate large memory blocks should set
///                    <i>dwMaximumSize</i> to 0.
///Returns:
///    If the function succeeds, the return value is a handle to the newly created heap. If the function fails, the
///    return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HeapHandle HeapCreate(uint flOptions, size_t dwInitialSize, size_t dwMaximumSize);

///Destroys the specified heap object. It decommits and releases all the pages of a private heap object, and it
///invalidates the handle to the heap.
///Params:
///    hHeap = A handle to the heap to be destroyed. This handle is returned by the HeapCreate function. Do not use the handle
///            to the process heap returned by the GetProcessHeap function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL HeapDestroy(HeapHandle hHeap);

///Allocates a block of memory from a heap. The allocated memory is not movable.
///Params:
///    hHeap = A handle to the heap from which the memory will be allocated. This handle is returned by the HeapCreate or
///            GetProcessHeap function.
///    dwFlags = The heap allocation options. Specifying any of these values will override the corresponding value specified when
///              the heap was created with HeapCreate. This parameter can be one or more of the following values. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HEAP_GENERATE_EXCEPTIONS"></a><a
///              id="heap_generate_exceptions"></a><dl> <dt><b>HEAP_GENERATE_EXCEPTIONS</b></dt> <dt>0x00000004</dt> </dl> </td>
///              <td width="60%"> The system will raise an exception to indicate a function failure, such as an out-of-memory
///              condition, instead of returning <b>NULL</b>. To ensure that exceptions are generated for all calls to this
///              function, specify <b>HEAP_GENERATE_EXCEPTIONS</b> in the call to HeapCreate. In this case, it is not necessary to
///              additionally specify <b>HEAP_GENERATE_EXCEPTIONS</b> in this function call. </td> </tr> <tr> <td width="40%"><a
///              id="HEAP_NO_SERIALIZE"></a><a id="heap_no_serialize"></a><dl> <dt><b>HEAP_NO_SERIALIZE</b></dt>
///              <dt>0x00000001</dt> </dl> </td> <td width="60%"> Serialized access will not be used for this allocation. For more
///              information, see Remarks. To ensure that serialized access is disabled for all calls to this function, specify
///              <b>HEAP_NO_SERIALIZE</b> in the call to HeapCreate. In this case, it is not necessary to additionally specify
///              <b>HEAP_NO_SERIALIZE</b> in this function call. This value should not be specified when accessing the process's
///              default heap. The system may create additional threads within the application's process, such as a CTRL+C
///              handler, that simultaneously access the process's default heap. </td> </tr> <tr> <td width="40%"><a
///              id="HEAP_ZERO_MEMORY"></a><a id="heap_zero_memory"></a><dl> <dt><b>HEAP_ZERO_MEMORY</b></dt> <dt>0x00000008</dt>
///              </dl> </td> <td width="60%"> The allocated memory will be initialized to zero. Otherwise, the memory is not
///              initialized to zero. </td> </tr> </table>
///    dwBytes = The number of bytes to be allocated. If the heap specified by the <i>hHeap</i> parameter is a "non-growable"
///              heap, <i>dwBytes</i> must be less than 0x7FFF8. You create a non-growable heap by calling the HeapCreate function
///              with a nonzero value.
///Returns:
///    If the function succeeds, the return value is a pointer to the allocated memory block. If the function fails and
///    you have not specified <b>HEAP_GENERATE_EXCEPTIONS</b>, the return value is <b>NULL</b>. If the function fails
///    and you have specified <b>HEAP_GENERATE_EXCEPTIONS</b>, the function may generate either of the exceptions listed
///    in the following table. The particular exception depends upon the nature of the heap corruption. For more
///    information, see GetExceptionCode. <table> <tr> <th>Exception code</th> <th>Description</th> </tr> <tr>
///    <td><b>STATUS_NO_MEMORY</b></td> <td>The allocation attempt failed because of a lack of available memory or heap
///    corruption.</td> </tr> <tr> <td><b>STATUS_ACCESS_VIOLATION</b></td> <td>The allocation attempt failed because of
///    heap corruption or improper function parameters.</td> </tr> </table> If the function fails, it does not call
///    SetLastError. An application cannot call GetLastError for extended error information.
///    
@DllImport("KERNEL32")
void* HeapAlloc(HeapHandle hHeap, uint dwFlags, size_t dwBytes);

///Reallocates a block of memory from a heap. This function enables you to resize a memory block and change other memory
///block properties. The allocated memory is not movable.
///Params:
///    hHeap = A handle to the heap from which the memory is to be reallocated. This handle is a returned by either the
///            HeapCreate or GetProcessHeap function.
///    dwFlags = The heap reallocation options. Specifying a value overrides the corresponding value specified in the
///              <i>flOptions</i> parameter when the heap was created by using the HeapCreate function. This parameter can be one
///              or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="HEAP_GENERATE_EXCEPTIONS"></a><a id="heap_generate_exceptions"></a><dl>
///              <dt><b>HEAP_GENERATE_EXCEPTIONS</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The operating-system
///              raises an exception to indicate a function failure, such as an out-of-memory condition, instead of returning
///              <b>NULL</b>. To ensure that exceptions are generated for all calls to this function, specify
///              <b>HEAP_GENERATE_EXCEPTIONS</b> in the call to HeapCreate. In this case, it is not necessary to additionally
///              specify <b>HEAP_GENERATE_EXCEPTIONS</b> in this function call. </td> </tr> <tr> <td width="40%"><a
///              id="HEAP_NO_SERIALIZE"></a><a id="heap_no_serialize"></a><dl> <dt><b>HEAP_NO_SERIALIZE</b></dt>
///              <dt>0x00000001</dt> </dl> </td> <td width="60%"> Serialized access will not be used. For more information, see
///              Remarks. To ensure that serialized access is disabled for all calls to this function, specify
///              <b>HEAP_NO_SERIALIZE</b> in the call to HeapCreate. In this case, it is not necessary to additionally specify
///              <b>HEAP_NO_SERIALIZE</b> in this function call. This value should not be specified when accessing the process
///              heap. The system may create additional threads within the application's process, such as a CTRL+C handler, that
///              simultaneously access the process heap. </td> </tr> <tr> <td width="40%"><a
///              id="HEAP_REALLOC_IN_PLACE_ONLY"></a><a id="heap_realloc_in_place_only"></a><dl>
///              <dt><b>HEAP_REALLOC_IN_PLACE_ONLY</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> There can be no
///              movement when reallocating a memory block. If this value is not specified, the function may move the block to a
///              new location. If this value is specified and the block cannot be resized without moving, the function fails,
///              leaving the original memory block unchanged. </td> </tr> <tr> <td width="40%"><a id="HEAP_ZERO_MEMORY"></a><a
///              id="heap_zero_memory"></a><dl> <dt><b>HEAP_ZERO_MEMORY</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%">
///              If the reallocation request is for a larger size, the additional region of memory beyond the original size be
///              initialized to zero. The contents of the memory block up to its original size are unaffected. </td> </tr>
///              </table>
///    lpMem = A pointer to the block of memory that the function reallocates. This pointer is returned by an earlier call to
///            the HeapAlloc or <b>HeapReAlloc</b> function.
///    dwBytes = The new size of the memory block, in bytes. A memory block's size can be increased or decreased by using this
///              function. If the heap specified by the <i>hHeap</i> parameter is a "non-growable" heap, <i>dwBytes</i> must be
///              less than 0x7FFF8. You create a non-growable heap by calling the HeapCreate function with a nonzero value.
///Returns:
///    If the function succeeds, the return value is a pointer to the reallocated memory block. If the function fails
///    and you have not specified <b>HEAP_GENERATE_EXCEPTIONS</b>, the return value is <b>NULL</b>. If the function
///    fails and you have specified <b>HEAP_GENERATE_EXCEPTIONS</b>, the function may generate either of the exceptions
///    listed in the following table. For more information, see GetExceptionCode. <table> <tr> <th>Exception code</th>
///    <th>Description</th> </tr> <tr> <td><b>STATUS_NO_MEMORY</b></td> <td>The allocation attempt failed because of a
///    lack of available memory or heap corruption.</td> </tr> <tr> <td><b>STATUS_ACCESS_VIOLATION</b></td> <td>The
///    allocation attempt failed because of heap corruption or improper function parameters.</td> </tr> </table> If the
///    function fails, it does not call SetLastError. An application cannot call GetLastError for extended error
///    information.
///    
@DllImport("KERNEL32")
void* HeapReAlloc(HeapHandle hHeap, uint dwFlags, void* lpMem, size_t dwBytes);

///Frees a memory block allocated from a heap by the HeapAlloc or HeapReAlloc function.
///Params:
///    hHeap = A handle to the heap whose memory block is to be freed. This handle is returned by either the HeapCreate or
///            GetProcessHeap function.
///    dwFlags = The heap free options. Specifying the following value overrides the corresponding value specified in the
///              <i>flOptions</i> parameter when the heap was created by using the HeapCreate function. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HEAP_NO_SERIALIZE"></a><a
///              id="heap_no_serialize"></a><dl> <dt><b>HEAP_NO_SERIALIZE</b></dt> <dt>0x00000001</dt> </dl> </td> <td
///              width="60%"> Serialized access will not be used. For more information, see Remarks. To ensure that serialized
///              access is disabled for all calls to this function, specify <b>HEAP_NO_SERIALIZE</b> in the call to HeapCreate. In
///              this case, it is not necessary to additionally specify <b>HEAP_NO_SERIALIZE</b> in this function call. Do not
///              specify this value when accessing the process heap. The system may create additional threads within the
///              application's process, such as a CTRL+C handler, that simultaneously access the process heap. </td> </tr>
///              </table>
///    lpMem = A pointer to the memory block to be freed. This pointer is returned by the HeapAlloc or HeapReAlloc function.
///            This pointer can be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. An
///    application can call GetLastError for extended error information.
///    
@DllImport("KERNEL32")
BOOL HeapFree(HANDLE hHeap, uint dwFlags, void* lpMem);

///Retrieves the size of a memory block allocated from a heap by the HeapAlloc or HeapReAlloc function.
///Params:
///    hHeap = A handle to the heap in which the memory block resides. This handle is returned by either the HeapCreate or
///            GetProcessHeap function.
///    dwFlags = The heap size options. Specifying the following value overrides the corresponding value specified in the
///              <i>flOptions</i> parameter when the heap was created by using the HeapCreate function. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="HEAP_NO_SERIALIZE"></a><a
///              id="heap_no_serialize"></a><dl> <dt><b>HEAP_NO_SERIALIZE</b></dt> <dt>0x00000001</dt> </dl> </td> <td
///              width="60%"> Serialized access will not be used. For more information, see Remarks. To ensure that serialized
///              access is disabled for all calls to this function, specify <b>HEAP_NO_SERIALIZE</b> in the call to HeapCreate. In
///              this case, it is not necessary to additionally specify <b>HEAP_NO_SERIALIZE</b> in this function call. This value
///              should not be specified when accessing the process heap. The system may create additional threads within the
///              application's process, such as a CTRL+C handler, that simultaneously access the process heap. </td> </tr>
///              </table>
///    lpMem = A pointer to the memory block whose size the function will obtain. This is a pointer returned by the HeapAlloc or
///            HeapReAlloc function. The memory block must be from the heap specified by the <i>hHeap</i> parameter.
///Returns:
///    If the function succeeds, the return value is the requested size of the allocated memory block, in bytes. If the
///    function fails, the return value is <code>(SIZE_T)-1</code>. The function does not call SetLastError. An
///    application cannot call GetLastError for extended error information. If the <i>lpMem</i> parameter refers to a
///    heap allocation that is not in the heap specified by the <i>hHeap</i> parameter, the behavior of the
///    <b>HeapSize</b> function is undefined.
///    
@DllImport("KERNEL32")
size_t HeapSize(HeapHandle hHeap, uint dwFlags, const(void)* lpMem);

///Retrieves a handle to the default heap of the calling process. This handle can then be used in subsequent calls to
///the heap functions.
///Returns:
///    If the function succeeds, the return value is a handle to the calling process's heap. If the function fails, the
///    return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE GetProcessHeap();

///Returns the size of the largest committed free block in the specified heap. If the Disable heap coalesce on free
///global flag is set, this function also coalesces adjacent free blocks of memory in the heap.
///Params:
///    hHeap = A handle to the heap. This handle is returned by either the HeapCreate or GetProcessHeap function.
///    dwFlags = The heap access options. This parameter can be the following value. <table> <tr> <th>Value</th> <th>Meaning</th>
///              </tr> <tr> <td width="40%"><a id="HEAP_NO_SERIALIZE"></a><a id="heap_no_serialize"></a><dl>
///              <dt><b>HEAP_NO_SERIALIZE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Serialized access will not be
///              used. For more information, see Remarks. To ensure that serialized access is disabled for all calls to this
///              function, specify <b>HEAP_NO_SERIALIZE</b> in the call to HeapCreate. In this case, it is not necessary to
///              additionally specify <b>HEAP_NO_SERIALIZE</b> in this function call. Do not specify this value when accessing the
///              process heap. The system may create additional threads within the application's process, such as a CTRL+C
///              handler, that simultaneously access the process heap. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is the size of the largest committed free block in the heap, in bytes.
///    If the function fails, the return value is zero. To get extended error information, call GetLastError. In the
///    unlikely case that there is absolutely no space available in the heap, the function return value is zero, and
///    GetLastError returns the value NO_ERROR.
///    
@DllImport("KERNEL32")
size_t HeapCompact(HeapHandle hHeap, uint dwFlags);

///Enables features for a specified heap.
///Params:
///    HeapHandle = A handle to the heap where information is to be set. This handle is returned by either the HeapCreate or
///                 GetProcessHeap function.
///    HeapInformationClass = The class of information to be set. This parameter can be one of the following values from the
///                           <b>HEAP_INFORMATION_CLASS</b> enumeration type. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                           width="40%"><a id="HeapCompatibilityInformation"></a><a id="heapcompatibilityinformation"></a><a
///                           id="HEAPCOMPATIBILITYINFORMATION"></a><dl> <dt><b>HeapCompatibilityInformation</b></dt> <dt>0</dt> </dl> </td>
///                           <td width="60%"> Enables heap features. Only the low-fragmentation heap (LFH) is supported. However, it is not
///                           necessary for applications to enable the LFH because the system uses the LFH as needed to service memory
///                           allocation requests. <b>Windows XP and Windows Server 2003: </b>The LFH is not enabled by default. To enable the
///                           LFH for the specified heap, set the variable pointed to by the <i>HeapInformation</i> parameter to 2. After the
///                           LFH is enabled for a heap, it cannot be disabled. The LFH cannot be enabled for heaps created with
///                           <b>HEAP_NO_SERIALIZE</b> or for heaps created with a fixed size. The LFH also cannot be enabled if you are using
///                           the heap debugging tools in Debugging Tools for Windows or Microsoft Application Verifier. When a process is run
///                           under any debugger, certain heap debug options are automatically enabled for all heaps in the process. These heap
///                           debug options prevent the use of the LFH. To enable the low-fragmentation heap when running under a debugger, set
///                           the _NO_DEBUG_HEAP environment variable to 1. </td> </tr> <tr> <td width="40%"><a
///                           id="HeapEnableTerminationOnCorruption"></a><a id="heapenableterminationoncorruption"></a><a
///                           id="HEAPENABLETERMINATIONONCORRUPTION"></a><dl> <dt><b>HeapEnableTerminationOnCorruption</b></dt> <dt>1</dt>
///                           </dl> </td> <td width="60%"> Enables the terminate-on-corruption feature. If the heap manager detects an error in
///                           any heap used by the process, it calls the Windows Error Reporting service and terminates the process. After a
///                           process enables this feature, it cannot be disabled. <b>Windows Server 2003 and Windows XP: </b>This value is not
///                           supported until Windows Vista and Windows XP with SP3. The function succeeds but the
///                           <b>HeapEnableTerminationOnCorruption</b> value is ignored. </td> </tr> <tr> <td width="40%"><a
///                           id="HeapOptimizeResources"></a><a id="heapoptimizeresources"></a><a id="HEAPOPTIMIZERESOURCES"></a><dl>
///                           <dt><b>HeapOptimizeResources</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> If HeapSetInformation is called
///                           with <i>HeapHandle</i> set to NULL, then all heaps in the process with a low-fragmentation heap (LFH) will have
///                           their caches optimized, and the memory will be decommitted if possible. If a heap pointer is supplied in
///                           <i>HeapHandle</i>, then only that heap will be optimized. Note that the HEAP_OPTIMIZE_RESOURCES_INFORMATION
///                           structure passed in <i>HeapInformation</i> must be properly initialized. <b>Note</b> This value was added in
///                           Windows 8.1. </td> </tr> </table>
///    HeapInformation = The heap information buffer. The format of this data depends on the value of the <i>HeapInformationClass</i>
///                      parameter. If the <i>HeapInformationClass</i> parameter is <b>HeapCompatibilityInformation</b>, the
///                      <i>HeapInformation</i> parameter is a pointer to a <b>ULONG</b> variable. If the <i>HeapInformationClass</i>
///                      parameter is <b>HeapEnableTerminationOnCorruption</b>, the <i>HeapInformation</i> parameter should be <b>NULL</b>
///                      and <i>HeapInformationLength</i> should be 0
///    HeapInformationLength = The size of the <i>HeapInformation</i> buffer, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, void* HeapInformation, 
                        size_t HeapInformationLength);

///Validates the specified heap. The function scans all the memory blocks in the heap and verifies that the heap control
///structures maintained by the heap manager are in a consistent state. You can also use the <b>HeapValidate</b>
///function to validate a single memory block within a specified heap without checking the validity of the entire heap.
///Params:
///    hHeap = A handle to the heap to be validated. This handle is returned by either the HeapCreate or GetProcessHeap
///            function.
///    dwFlags = The heap access options. This parameter can be the following value. <table> <tr> <th>Value</th> <th>Meaning</th>
///              </tr> <tr> <td width="40%"><a id="HEAP_NO_SERIALIZE"></a><a id="heap_no_serialize"></a><dl>
///              <dt><b>HEAP_NO_SERIALIZE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Serialized access will not be
///              used. For more information, see Remarks. To ensure that serialized access is disabled for all calls to this
///              function, specify <b>HEAP_NO_SERIALIZE</b> in the call to HeapCreate. In this case, it is not necessary to
///              additionally specify <b>HEAP_NO_SERIALIZE</b> in this function call. This value should not be specified when
///              accessing the process default heap. The system may create additional threads within the application's process,
///              such as a CTRL+C handler, that simultaneously access the process default heap. </td> </tr> </table>
///    lpMem = A pointer to a memory block within the specified heap. This parameter may be <b>NULL</b>. If this parameter is
///            <b>NULL</b>, the function attempts to validate the entire heap specified by <i>hHeap</i>. If this parameter is
///            not <b>NULL</b>, the function attempts to validate the memory block pointed to by <i>lpMem</i>. It does not
///            attempt to validate the rest of the heap.
///Returns:
///    If the specified heap or memory block is valid, the return value is nonzero. If the specified heap or memory
///    block is invalid, the return value is zero. On a system set up for debugging, the <b>HeapValidate</b> function
///    then displays debugging messages that describe the part of the heap or memory block that is invalid, and stops at
///    a hard-coded breakpoint so that you can examine the system to determine the source of the invalidity. The
///    <b>HeapValidate</b> function does not set the thread's last error value. There is no extended error information
///    for this function; do not call GetLastError.
///    
@DllImport("KERNEL32")
BOOL HeapValidate(HANDLE hHeap, uint dwFlags, const(void)* lpMem);

///Summarizes the specified heap.
///Params:
///    hHeap = A handle to the heap to be summarized. This handle is returned by either the HeapCreate or GetProcessHeap
///            function.
///    dwFlags = The heap summary options.
///    lpSummary = Receives a pointer to a [Heap_Summary](ns-heapapi-heap_summary.md) structure representing the heap summary.
///Returns:
///    Returns S_OK on success.
///    
@DllImport("KERNEL32")
BOOL HeapSummary(HANDLE hHeap, uint dwFlags, HEAP_SUMMARY* lpSummary);

///Returns the number of active heaps and retrieves handles to all of the active heaps for the calling process.
///Params:
///    NumberOfHeaps = The maximum number of heap handles that can be stored into the buffer pointed to by <i>ProcessHeaps</i>.
///    ProcessHeaps = A pointer to a buffer that receives an array of heap handles.
///Returns:
///    The return value is the number of handles to heaps that are active for the calling process. If the return value
///    is less than or equal to <i>NumberOfHeaps</i>, the function has stored that number of heap handles in the buffer
///    pointed to by <i>ProcessHeaps</i>. If the return value is greater than <i>NumberOfHeaps</i>, the buffer pointed
///    to by <i>ProcessHeaps</i> is too small to hold all the heap handles for the calling process, and the function
///    stores <i>NumberOfHeaps</i> handles in the buffer. Use the return value to allocate a buffer that is large enough
///    to receive all of the handles, and call the function again. If the return value is zero, the function has failed
///    because every process has at least one active heap, the default heap for the process. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetProcessHeaps(uint NumberOfHeaps, HANDLE* ProcessHeaps);

///Attempts to acquire the critical section object, or lock, that is associated with a specified heap.
///Params:
///    hHeap = A handle to the heap to be locked. This handle is returned by either the HeapCreate or GetProcessHeap function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL HeapLock(HeapHandle hHeap);

///Releases ownership of the critical section object, or lock, that is associated with a specified heap. It reverses the
///action of the HeapLock function.
///Params:
///    hHeap = A handle to the heap to be unlocked. This handle is returned by either the HeapCreate or GetProcessHeap function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL HeapUnlock(HANDLE hHeap);

///Enumerates the memory blocks in the specified heap.
///Params:
///    hHeap = A handle to the heap. This handle is returned by either the HeapCreate or GetProcessHeap function.
///    lpEntry = A pointer to a PROCESS_HEAP_ENTRY structure that maintains state information for a particular heap enumeration.
///              If the <b>HeapWalk</b> function succeeds, returning the value <b>TRUE</b>, this structure's members contain
///              information about the next memory block in the heap. To initiate a heap enumeration, set the <b>lpData</b> field
///              of the PROCESS_HEAP_ENTRY structure to <b>NULL</b>. To continue a particular heap enumeration, call the
///              <b>HeapWalk</b> function repeatedly, with no changes to <i>hHeap</i>, <i>lpEntry</i>, or any of the members of
///              the <b>PROCESS_HEAP_ENTRY</b> structure.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the heap enumeration terminates successfully by reaching the
///    end of the heap, the function returns <b>FALSE</b>, and GetLastError returns the error code
///    <b>ERROR_NO_MORE_ITEMS</b>.
///    
@DllImport("KERNEL32")
BOOL HeapWalk(HANDLE hHeap, PROCESS_HEAP_ENTRY* lpEntry);

///Retrieves information about the specified heap.
///Params:
///    HeapHandle = A handle to the heap whose information is to be retrieved. This handle is returned by either the HeapCreate or
///                 GetProcessHeap function.
///    HeapInformationClass = The class of information to be retrieved. This parameter can be the following value from the
///                           <b>HEAP_INFORMATION_CLASS</b> enumeration type. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                           width="40%"><a id="HeapCompatibilityInformation"></a><a id="heapcompatibilityinformation"></a><a
///                           id="HEAPCOMPATIBILITYINFORMATION"></a><dl> <dt><b>HeapCompatibilityInformation</b></dt> <dt>0</dt> </dl> </td>
///                           <td width="60%"> Indicates the heap features that are enabled. The <i>HeapInformation</i> parameter is a pointer
///                           to a <b>ULONG</b> variable. If <i>HeapInformation</i> is 0, the heap is a standard heap that does not support
///                           look-aside lists. If <i>HeapInformation</i> is 1, the heap supports look-aside lists. For more information, see
///                           Remarks. If <i>HeapInformation</i> is 2, the low-fragmentation heap (LFH) has been enabled for the heap. Enabling
///                           the LFH disables look-aside lists. </td> </tr> </table>
///    HeapInformation = A pointer to a buffer that receives the heap information. The format of this data depends on the value of the
///                      <i>HeapInformationClass</i> parameter.
///    HeapInformationLength = The size of the heap information being queried, in bytes.
///    ReturnLength = A pointer to a variable that receives the length of data written to the <i>HeapInformation</i> buffer. If the
///                   buffer is too small, the function fails and <i>ReturnLength</i> specifies the minimum size required for the
///                   buffer. If you do not want to receive this information, specify <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, void* HeapInformation, 
                          size_t HeapInformationLength, size_t* ReturnLength);

///Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process.
///Memory allocated by this function is automatically initialized to zero. To allocate memory in the address space of
///another process, use the VirtualAllocEx function.
///Params:
///    lpAddress = The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded
///                down to the nearest multiple of the allocation granularity. If the memory is already reserved and is being
///                committed, the address is rounded down to the next page boundary. To determine the size of a page and the
///                allocation granularity on the host computer, use the GetSystemInfo function. If this parameter is <b>NULL</b>,
///                the system determines where to allocate the region. If this address is within an enclave that you have not
///                initialized by calling InitializeEnclave, <b>VirtualAlloc</b> allocates a page of zeros for the enclave at that
///                address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the
///                Intel Software Guard Extensions programming model. If the address in within an enclave that you initialized, then
///                the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error.
///    dwSize = The size of the region, in bytes. If the <i>lpAddress</i> parameter is <b>NULL</b>, this value is rounded up to
///             the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the
///             range from <i>lpAddress</i> to <i>lpAddress</i>+<i>dwSize</i>. This means that a 2-byte range straddling a page
///             boundary causes both pages to be included in the allocated region.
///    flAllocationType = The type of memory allocation. This parameter must contain one of the following values. <table> <tr>
///                       <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_COMMIT"></a><a id="mem_commit"></a><dl>
///                       <dt><b>MEM_COMMIT</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> Allocates memory charges (from the
///                       overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also
///                       guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical
///                       pages are not allocated unless/until the virtual addresses are actually accessed. To reserve and commit pages in
///                       one step, call <b>VirtualAlloc</b> with <code>MEM_COMMIT | MEM_RESERVE</code>. Attempting to commit a specific
///                       address range by specifying <b>MEM_COMMIT</b> without <b>MEM_RESERVE</b> and a non-<b>NULL</b> <i>lpAddress</i>
///                       fails unless the entire range has already been reserved. The resulting error code is
///                       <b>ERROR_INVALID_ADDRESS</b>. An attempt to commit a page that is already committed does not cause the function
///                       to fail. This means that you can commit pages without first determining the current commitment state of each
///                       page. If <i>lpAddress</i> specifies an address within an enclave, <i>flAllocationType</i> must be
///                       <b>MEM_COMMIT</b>. </td> </tr> <tr> <td width="40%"><a id="MEM_RESERVE"></a><a id="mem_reserve"></a><dl>
///                       <dt><b>MEM_RESERVE</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Reserves a range of the process's
///                       virtual address space without allocating any actual physical storage in memory or in the paging file on disk. You
///                       can commit reserved pages in subsequent calls to the <b>VirtualAlloc</b> function. To reserve and commit pages in
///                       one step, call <b>VirtualAlloc</b> with <b>MEM_COMMIT</b> | <b>MEM_RESERVE</b>. Other memory allocation
///                       functions, such as <b>malloc</b> and LocalAlloc, cannot use a reserved range of memory until it is released.
///                       </td> </tr> <tr> <td width="40%"><a id="MEM_RESET"></a><a id="mem_reset"></a><dl> <dt><b>MEM_RESET</b></dt>
///                       <dt>0x00080000</dt> </dl> </td> <td width="60%"> Indicates that data in the memory range specified by
///                       <i>lpAddress</i> and <i>dwSize</i> is no longer of interest. The pages should not be read from or written to the
///                       paging file. However, the memory block will be used again later, so it should not be decommitted. This value
///                       cannot be used with any other value. Using this value does not guarantee that the range operated on with
///                       <b>MEM_RESET</b> will contain zeros. If you want the range to contain zeros, decommit the memory and then
///                       recommit it. When you specify <b>MEM_RESET</b>, the <b>VirtualAlloc</b> function ignores the value of
///                       <i>flProtect</i>. However, you must still set <i>flProtect</i> to a valid protection value, such as
///                       <b>PAGE_NOACCESS</b>. <b>VirtualAlloc</b> returns an error if you use <b>MEM_RESET</b> and the range of memory is
///                       mapped to a file. A shared view is only acceptable if it is mapped to a paging file. </td> </tr> <tr> <td
///                       width="40%"><a id="MEM_RESET_UNDO"></a><a id="mem_reset_undo"></a><dl> <dt><b>MEM_RESET_UNDO</b></dt>
///                       <dt>0x1000000</dt> </dl> </td> <td width="60%"> <b>MEM_RESET_UNDO</b> should only be called on an address range
///                       to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory
///                       range specified by <i>lpAddress</i> and <i>dwSize</i> is of interest to the caller and attempts to reverse the
///                       effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is
///                       intact. If the function fails, at least some of the data in the address range has been replaced with zeroes. This
///                       value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not
///                       <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the <b>VirtualAlloc</b>
///                       function ignores the value of <i>flProtect</i>. However, you must still set <i>flProtect</i> to a valid
///                       protection value, such as <b>PAGE_NOACCESS</b>. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008,
///                       Windows Vista, Windows Server 2003 and Windows XP: </b>The <b>MEM_RESET_UNDO</b> flag is not supported until
///                       Windows 8 and Windows Server 2012. </td> </tr> </table> This parameter can also specify the following values as
///                       indicated. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_LARGE_PAGES"></a><a
///                       id="mem_large_pages"></a><dl> <dt><b>MEM_LARGE_PAGES</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%">
///                       Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum.
///                       To obtain this value, use the GetLargePageMinimum function. If you specify this value, you must also specify
///                       <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>. </td> </tr> <tr> <td width="40%"><a id="MEM_PHYSICAL"></a><a
///                       id="mem_physical"></a><dl> <dt><b>MEM_PHYSICAL</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> Reserves
///                       an address range that can be used to map Address Windowing Extensions (AWE) pages. This value must be used with
///                       <b>MEM_RESERVE</b> and no other values. </td> </tr> <tr> <td width="40%"><a id="MEM_TOP_DOWN"></a><a
///                       id="mem_top_down"></a><dl> <dt><b>MEM_TOP_DOWN</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%">
///                       Allocates memory at the highest possible address. This can be slower than regular allocations, especially when
///                       there are many allocations. </td> </tr> <tr> <td width="40%"><a id="MEM_WRITE_WATCH"></a><a
///                       id="mem_write_watch"></a><dl> <dt><b>MEM_WRITE_WATCH</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%">
///                       Causes the system to track pages that are written to in the allocated region. If you specify this value, you must
///                       also specify <b>MEM_RESERVE</b>. To retrieve the addresses of the pages that have been written to since the
///                       region was allocated or the write-tracking state was reset, call the GetWriteWatch function. To reset the
///                       write-tracking state, call <b>GetWriteWatch</b> or ResetWriteWatch. The write-tracking feature remains enabled
///                       for the memory region until the region is freed. </td> </tr> </table>
///    flProtect = The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify
///                any one of the memory protection constants. If <i>lpAddress</i> specifies an address within an enclave,
///                <i>flProtect</i> cannot be any of the following values: <ul> <li>PAGE_NOACCESS</li> <li>PAGE_GUARD</li>
///                <li>PAGE_NOCACHE</li> <li>PAGE_WRITECOMBINE</li> </ul>
///Returns:
///    If the function succeeds, the return value is the base address of the allocated region of pages. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* VirtualAlloc(void* lpAddress, size_t dwSize, uint flAllocationType, PAGE_TYPE flProtect);

///Changes the protection on a region of committed pages in the virtual address space of the calling process. To change
///the access protection of any process, use the VirtualProtectEx function.
///Params:
///    lpAddress = The address of the starting page of the region of pages whose access protection attributes are to be changed. All
///                pages in the specified region must be within the same reserved region allocated when calling the VirtualAlloc or
///                VirtualAllocEx function using <b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were
///                allocated by separate calls to <b>VirtualAlloc</b> or <b>VirtualAllocEx</b> using <b>MEM_RESERVE</b>.
///    dwSize = The size of the region whose access protection attributes are to be changed, in bytes. The region of affected
///             pages includes all pages containing one or more bytes in the range from the <i>lpAddress</i> parameter to
///             <code>(lpAddress+dwSize)</code>. This means that a 2-byte range straddling a page boundary causes the protection
///             attributes of both pages to be changed.
///    flNewProtect = The memory protection option. This parameter can be one of the memory protection constants. For mapped views,
///                   this value must be compatible with the access protection specified when the view was mapped (see MapViewOfFile,
///                   MapViewOfFileEx, and MapViewOfFileExNuma).
///    lpflOldProtect = A pointer to a variable that receives the previous access protection value of the first page in the specified
///                     region of pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the function fails.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL VirtualProtect(void* lpAddress, size_t dwSize, PAGE_TYPE flNewProtect, PAGE_TYPE* lpflOldProtect);

///Releases, decommits, or releases and decommits a region of pages within the virtual address space of the calling
///process. To free memory allocated in another process by the VirtualAllocEx function, use the VirtualFreeEx function.
///Params:
///    lpAddress = A pointer to the base address of the region of pages to be freed. If the <i>dwFreeType</i> parameter is
///                <b>MEM_RELEASE</b>, this parameter must be the base address returned by the VirtualAlloc function when the region
///                of pages is reserved.
///    dwSize = The size of the region of memory to be freed, in bytes. If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>,
///             this parameter must be 0 (zero). The function frees the entire region that is reserved in the initial allocation
///             call to VirtualAlloc. If the <i>dwFreeType</i> parameter is <b>MEM_DECOMMIT</b>, the function decommits all
///             memory pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to
///             <code>(lpAddress+dwSize)</code>. This means, for example, that a 2-byte region of memory that straddles a page
///             boundary causes both pages to be decommitted. If <i>lpAddress</i> is the base address returned by VirtualAlloc
///             and <i>dwSize</i> is 0 (zero), the function decommits the entire region that is allocated by <b>VirtualAlloc</b>.
///             After that, the entire region is in the reserved state.
///    dwFreeType = The type of free operation. This parameter must be one of the following values. <table> <tr> <th>Value</th>
///                 <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_DECOMMIT"></a><a id="mem_decommit"></a><dl>
///                 <dt><b>MEM_DECOMMIT</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> Decommits the specified region of
///                 committed pages. After the operation, the pages are in the reserved state. The function does not fail if you
///                 attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first
///                 determining the current commitment state. The <b>MEM_DECOMMIT</b> value is not supported when the
///                 <i>lpAddress</i> parameter provides the base address for an enclave. </td> </tr> <tr> <td width="40%"><a
///                 id="MEM_RELEASE"></a><a id="mem_release"></a><dl> <dt><b>MEM_RELEASE</b></dt> <dt>0x00008000</dt> </dl> </td> <td
///                 width="60%"> Releases the specified region of pages, or placeholder (for a placeholder, the address space is
///                 released and available for other allocations). After this operation, the pages are in the free state. If you
///                 specify this value, <i>dwSize</i> must be 0 (zero), and <i>lpAddress</i> must point to the base address returned
///                 by the VirtualAlloc function when the region is reserved. The function fails if either of these conditions is not
///                 met. If any pages in the region are committed currently, the function first decommits, and then releases them.
///                 The function does not fail if you attempt to release pages that are in different states, some reserved and some
///                 committed. This means that you can release a range of pages without first determining the current commitment
///                 state. </td> </tr> </table> When using <b>MEM_RELEASE</b>, this parameter can additionally specify one of the
///                 following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="MEM_COALESCE_PLACEHOLDERS"></a><a id="mem_coalesce_placeholders"></a><dl>
///                 <dt><b>MEM_COALESCE_PLACEHOLDERS</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> To coalesce two
///                 adjacent placeholders, specify <code>MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS</code>. When you coalesce
///                 placeholders, <i>lpAddress</i> and <i>dwSize</i> must exactly match those of the placeholder. </td> </tr> <tr>
///                 <td width="40%"><a id="MEM_PRESERVE_PLACEHOLDER"></a><a id="mem_preserve_placeholder"></a><dl>
///                 <dt><b>MEM_PRESERVE_PLACEHOLDER</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Frees an allocation
///                 back to a placeholder (after you've replaced a placeholder with a private allocation using VirtualAlloc2 or
///                 Virtual2AllocFromApp). To split a placeholder into two placeholders, specify <code>MEM_RELEASE |
///                 MEM_PRESERVE_PLACEHOLDER</code>. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL VirtualFree(void* lpAddress, size_t dwSize, uint dwFreeType);

///Retrieves information about a range of pages in the virtual address space of the calling process. To retrieve
///information about a range of pages in the address space of another process, use the VirtualQueryEx function.
///Params:
///    lpAddress = A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page
///                boundary. To determine the size of a page on the host computer, use the GetSystemInfo function. If
///                <i>lpAddress</i> specifies an address above the highest memory address accessible to the process, the function
///                fails with <b>ERROR_INVALID_PARAMETER</b>.
///    lpBuffer = A pointer to a MEMORY_BASIC_INFORMATION structure in which information about the specified page range is
///               returned.
///    dwLength = The size of the buffer pointed to by the <i>lpBuffer</i> parameter, in bytes.
///Returns:
///    The return value is the actual number of bytes returned in the information buffer. If the function fails, the
///    return value is zero. To get extended error information, call GetLastError. Possible error values include
///    <b>ERROR_INVALID_PARAMETER</b>.
///    
@DllImport("KERNEL32")
size_t VirtualQuery(const(void)* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, size_t dwLength);

///Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified
///process. The function initializes the memory it allocates to zero. To specify the NUMA node for the physical memory,
///see VirtualAllocExNuma.
///Params:
///    hProcess = The handle to a process. The function allocates memory within the virtual address space of this process. The
///               handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see Process Security and
///               Access Rights.
///    lpAddress = The pointer that specifies a desired starting address for the region of pages that you want to allocate. If you
///                are reserving memory, the function rounds this address down to the nearest multiple of the allocation
///                granularity. If you are committing memory that is already reserved, the function rounds this address down to the
///                nearest page boundary. To determine the size of a page and the allocation granularity on the host computer, use
///                the GetSystemInfo function. If <i>lpAddress</i> is <b>NULL</b>, the function determines where to allocate the
///                region. If this address is within an enclave that you have not initialized by calling InitializeEnclave,
///                <b>VirtualAllocEx</b> allocates a page of zeros for the enclave at that address. The page must be previously
///                uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions
///                programming model. If the address in within an enclave that you initialized, then the allocation operation fails
///                with the <b>ERROR_INVALID_ADDRESS</b> error.
///    dwSize = The size of the region of memory to allocate, in bytes. If <i>lpAddress</i> is <b>NULL</b>, the function rounds
///             <i>dwSize</i> up to the next page boundary. If <i>lpAddress</i> is not <b>NULL</b>, the function allocates all
///             pages that contain one or more bytes in the range from <i>lpAddress</i> to <i>lpAddress</i>+<i>dwSize</i>. This
///             means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both
///             pages.
///    flAllocationType = The type of memory allocation. This parameter must contain one of the following values. <table> <tr>
///                       <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_COMMIT"></a><a id="mem_commit"></a><dl>
///                       <dt><b>MEM_COMMIT</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> Allocates memory charges (from the
///                       overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also
///                       guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical
///                       pages are not allocated unless/until the virtual addresses are actually accessed. To reserve and commit pages in
///                       one step, call <b>VirtualAllocEx</b> with <code>MEM_COMMIT | MEM_RESERVE</code>. Attempting to commit a specific
///                       address range by specifying <b>MEM_COMMIT</b> without <b>MEM_RESERVE</b> and a non-<b>NULL</b> <i>lpAddress</i>
///                       fails unless the entire range has already been reserved. The resulting error code is
///                       <b>ERROR_INVALID_ADDRESS</b>. An attempt to commit a page that is already committed does not cause the function
///                       to fail. This means that you can commit pages without first determining the current commitment state of each
///                       page. If <i>lpAddress</i> specifies an address within an enclave, <i>flAllocationType</i> must be
///                       <b>MEM_COMMIT</b>. </td> </tr> <tr> <td width="40%"><a id="MEM_RESERVE"></a><a id="mem_reserve"></a><dl>
///                       <dt><b>MEM_RESERVE</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Reserves a range of the process's
///                       virtual address space without allocating any actual physical storage in memory or in the paging file on disk. You
///                       commit reserved pages by calling <b>VirtualAllocEx</b> again with <b>MEM_COMMIT</b>. To reserve and commit pages
///                       in one step, call <b>VirtualAllocEx</b> with <code>MEM_COMMIT | MEM_RESERVE</code>. Other memory allocation
///                       functions, such as <b>malloc</b> and LocalAlloc, cannot use reserved memory until it has been released. </td>
///                       </tr> <tr> <td width="40%"><a id="MEM_RESET"></a><a id="mem_reset"></a><dl> <dt><b>MEM_RESET</b></dt>
///                       <dt>0x00080000</dt> </dl> </td> <td width="60%"> Indicates that data in the memory range specified by
///                       <i>lpAddress</i> and <i>dwSize</i> is no longer of interest. The pages should not be read from or written to the
///                       paging file. However, the memory block will be used again later, so it should not be decommitted. This value
///                       cannot be used with any other value. Using this value does not guarantee that the range operated on with
///                       <b>MEM_RESET</b> will contain zeros. If you want the range to contain zeros, decommit the memory and then
///                       recommit it. When you use <b>MEM_RESET</b>, the <b>VirtualAllocEx</b> function ignores the value of
///                       <i>fProtect</i>. However, you must still set <i>fProtect</i> to a valid protection value, such as
///                       <b>PAGE_NOACCESS</b>. <b>VirtualAllocEx</b> returns an error if you use <b>MEM_RESET</b> and the range of memory
///                       is mapped to a file. A shared view is only acceptable if it is mapped to a paging file. </td> </tr> <tr> <td
///                       width="40%"><a id="MEM_RESET_UNDO"></a><a id="mem_reset_undo"></a><dl> <dt><b>MEM_RESET_UNDO</b></dt>
///                       <dt>0x1000000</dt> </dl> </td> <td width="60%"> <b>MEM_RESET_UNDO</b> should only be called on an address range
///                       to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory
///                       range specified by <i>lpAddress</i> and <i>dwSize</i> is of interest to the caller and attempts to reverse the
///                       effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is
///                       intact. If the function fails, at least some of the data in the address range has been replaced with zeroes. This
///                       value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not
///                       <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the <b>VirtualAllocEx</b>
///                       function ignores the value of <i>flProtect</i>. However, you must still set <i>flProtect</i> to a valid
///                       protection value, such as <b>PAGE_NOACCESS</b>. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008,
///                       Windows Vista, Windows Server 2003 and Windows XP: </b>The <b>MEM_RESET_UNDO</b> flag is not supported until
///                       Windows 8 and Windows Server 2012. </td> </tr> </table> This parameter can also specify the following values as
///                       indicated. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_LARGE_PAGES"></a><a
///                       id="mem_large_pages"></a><dl> <dt><b>MEM_LARGE_PAGES</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%">
///                       Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum.
///                       To obtain this value, use the GetLargePageMinimum function. If you specify this value, you must also specify
///                       <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>. </td> </tr> <tr> <td width="40%"><a id="MEM_PHYSICAL"></a><a
///                       id="mem_physical"></a><dl> <dt><b>MEM_PHYSICAL</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> Reserves
///                       an address range that can be used to map Address Windowing Extensions (AWE) pages. This value must be used with
///                       <b>MEM_RESERVE</b> and no other values. </td> </tr> <tr> <td width="40%"><a id="MEM_TOP_DOWN"></a><a
///                       id="mem_top_down"></a><dl> <dt><b>MEM_TOP_DOWN</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%">
///                       Allocates memory at the highest possible address. This can be slower than regular allocations, especially when
///                       there are many allocations. </td> </tr> </table>
///    flProtect = The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify
///                any one of the memory protection constants. If <i>lpAddress</i> specifies an address within an enclave,
///                <i>flProtect</i> cannot be any of the following values: <ul> <li>PAGE_NOACCESS</li> <li>PAGE_GUARD</li>
///                <li>PAGE_NOCACHE</li> <li>PAGE_WRITECOMBINE</li> </ul>
///Returns:
///    If the function succeeds, the return value is the base address of the allocated region of pages. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* VirtualAllocEx(HANDLE hProcess, void* lpAddress, size_t dwSize, uint flAllocationType, PAGE_TYPE flProtect);

///Changes the protection on a region of committed pages in the virtual address space of a specified process.
///Params:
///    hProcess = A handle to the process whose memory protection is to be changed. The handle must have the
///               <b>PROCESS_VM_OPERATION</b> access right. For more information, see Process Security and Access Rights.
///    lpAddress = A pointer to the base address of the region of pages whose access protection attributes are to be changed. All
///                pages in the specified region must be within the same reserved region allocated when calling the VirtualAlloc or
///                VirtualAllocEx function using <b>MEM_RESERVE</b>. The pages cannot span adjacent reserved regions that were
///                allocated by separate calls to <b>VirtualAlloc</b> or <b>VirtualAllocEx</b> using <b>MEM_RESERVE</b>.
///    dwSize = The size of the region whose access protection attributes are changed, in bytes. The region of affected pages
///             includes all pages containing one or more bytes in the range from the <i>lpAddress</i> parameter to
///             <code>(lpAddress+dwSize)</code>. This means that a 2-byte range straddling a page boundary causes the protection
///             attributes of both pages to be changed.
///    flNewProtect = The memory protection option. This parameter can be one of the memory protection constants. For mapped views,
///                   this value must be compatible with the access protection specified when the view was mapped (see MapViewOfFile,
///                   MapViewOfFileEx, and MapViewOfFileExNuma).
///    lpflOldProtect = A pointer to a variable that receives the previous access protection of the first page in the specified region of
///                     pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the function fails.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL VirtualProtectEx(HANDLE hProcess, void* lpAddress, size_t dwSize, PAGE_TYPE flNewProtect, 
                      PAGE_TYPE* lpflOldProtect);

///Retrieves information about a range of pages within the virtual address space of a specified process.
///Params:
///    hProcess = A handle to the process whose memory information is queried. The handle must have been opened with the
///               <b>PROCESS_QUERY_INFORMATION</b> access right, which enables using the handle to read information from the
///               process object. For more information, see Process Security and Access Rights.
///    lpAddress = A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page
///                boundary. To determine the size of a page on the host computer, use the GetSystemInfo function. If
///                <i>lpAddress</i> specifies an address above the highest memory address accessible to the process, the function
///                fails with <b>ERROR_INVALID_PARAMETER</b>.
///    lpBuffer = A pointer to a MEMORY_BASIC_INFORMATION structure in which information about the specified page range is
///               returned.
///    dwLength = The size of the buffer pointed to by the <i>lpBuffer</i> parameter, in bytes.
///Returns:
///    The return value is the actual number of bytes returned in the information buffer. If the function fails, the
///    return value is zero. To get extended error information, call GetLastError. Possible error values include
///    <b>ERROR_INVALID_PARAMETER</b>.
///    
@DllImport("KERNEL32")
size_t VirtualQueryEx(HANDLE hProcess, const(void)* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, size_t dwLength);

///Creates or opens a named or unnamed file mapping object for a specified file. To specify the NUMA node for the
///physical memory, see CreateFileMappingNuma.
///Params:
///    hFile = A handle to the file from which to create a file mapping object. The file must be opened with access rights that
///            are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but
///            it is recommended that files you intend to map be opened for exclusive access. For more information, see File
///            Security and Access Rights. If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify
///            a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In
///            this scenario, <b>CreateFileMapping</b> creates a file mapping object of a specified size that is backed by the
///            system paging file instead of by a file in the file system.
///    lpFileMappingAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether a returned handle can be inherited by child
///                              processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a
///                              security descriptor for a new file mapping object. If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be
///                              inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the
///                              default security descriptor for a file mapping object come from the primary or impersonation token of the
///                              creator. For more information, see File Mapping Security and Access Rights.
///    flProtect = Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with
///                this protection. This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="PAGE_EXECUTE_READ"></a><a id="page_execute_read"></a><dl>
///                <dt><b>PAGE_EXECUTE_READ</b></dt> <dt>0x20</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, or execute access. The file handle specified by the <i>hFile</i> parameter must be
///                created with the <b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights. <b>Windows Server 2003 and Windows
///                XP: </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1. </td> </tr> <tr>
///                <td width="40%"><a id="PAGE_EXECUTE_READWRITE"></a><a id="page_execute_readwrite"></a><dl>
///                <dt><b>PAGE_EXECUTE_READWRITE</b></dt> <dt>0x40</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, read/write, or execute access. The file handle that the <i>hFile</i> parameter
///                specifies must be created with the <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and <b>GENERIC_EXECUTE</b> access
///                rights. <b>Windows Server 2003 and Windows XP: </b>This value is not available until Windows XP with SP2 and
///                Windows Server 2003 with SP1. </td> </tr> <tr> <td width="40%"><a id="PAGE_EXECUTE_WRITECOPY"></a><a
///                id="page_execute_writecopy"></a><dl> <dt><b>PAGE_EXECUTE_WRITECOPY</b></dt> <dt>0x80</dt> </dl> </td> <td
///                width="60%"> Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent
///                to <b>PAGE_EXECUTE_READ</b>. The file handle that the <i>hFile</i> parameter specifies must be created with the
///                <b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights. <b>Windows Vista: </b>This value is not available
///                until Windows Vista with SP1. <b>Windows Server 2003 and Windows XP: </b>This value is not supported. </td> </tr>
///                <tr> <td width="40%"><a id="PAGE_READONLY"></a><a id="page_readonly"></a><dl> <dt><b>PAGE_READONLY</b></dt>
///                <dt>0x02</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only or copy-on-write access. An
///                attempt to write to a specific region results in an access violation. The file handle that the <i>hFile</i>
///                parameter specifies must be created with the <b>GENERIC_READ</b> access right. </td> </tr> <tr> <td
///                width="40%"><a id="PAGE_READWRITE"></a><a id="page_readwrite"></a><dl> <dt><b>PAGE_READWRITE</b></dt>
///                <dt>0x04</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only, copy-on-write, or read/write
///                access. The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b>
///                and <b>GENERIC_WRITE</b> access rights. </td> </tr> <tr> <td width="40%"><a id="PAGE_WRITECOPY"></a><a
///                id="page_writecopy"></a><dl> <dt><b>PAGE_WRITECOPY</b></dt> <dt>0x08</dt> </dl> </td> <td width="60%"> Allows
///                views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>. The
///                file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.
///                </td> </tr> </table> An application can specify one or more of the following attributes for the file mapping
///                object by combining them with one of the preceding page protection values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SEC_COMMIT"></a><a id="sec_commit"></a><dl>
///                <dt><b>SEC_COMMIT</b></dt> <dt>0x8000000</dt> </dl> </td> <td width="60%"> If the file mapping object is backed
///                by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
///                when a view of the file is mapped into a process address space, the entire range of pages is committed rather
///                than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
///                <b>CreateFileMapping</b> fails. This attribute has no effect for file mapping objects that are backed by
///                executable image files or data files (the <i>hfile</i> parameter is a handle to a file). <b>SEC_COMMIT</b> cannot
///                be combined with <b>SEC_RESERVE</b>. If no attribute is specified, <b>SEC_COMMIT</b> is assumed. </td> </tr> <tr>
///                <td width="40%"><a id="SEC_IMAGE"></a><a id="sec_image"></a><dl> <dt><b>SEC_IMAGE</b></dt> <dt>0x1000000</dt>
///                </dl> </td> <td width="60%"> Specifies that the file that the <i>hFile</i> parameter specifies is an executable
///                image file. The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
///                <b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file.
///                Page protection for views of an executable image file is determined by the executable file itself. No other
///                attributes are valid with <b>SEC_IMAGE</b>. </td> </tr> <tr> <td width="40%"><a id="SEC_IMAGE_NO_EXECUTE"></a><a
///                id="sec_image_no_execute"></a><dl> <dt><b>SEC_IMAGE_NO_EXECUTE</b></dt> <dt>0x11000000</dt> </dl> </td> <td
///                width="60%"> Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that
///                will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a
///                view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver
///                callbacks registered using the PsSetLoadImageNotifyRoutine kernel API. The <b>SEC_IMAGE_NO_EXECUTE</b> attribute
///                must be combined with the <b>PAGE_READONLY</b> page protection value. No other attributes are valid with
///                <b>SEC_IMAGE_NO_EXECUTE</b>. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows
///                Server 2003 and Windows XP: </b>This value is not supported before Windows Server 2012 and Windows 8. </td> </tr>
///                <tr> <td width="40%"><a id="SEC_LARGE_PAGES"></a><a id="sec_large_pages"></a><dl> <dt><b>SEC_LARGE_PAGES</b></dt>
///                <dt>0x80000000</dt> </dl> </td> <td width="60%"> Enables large pages to be used for file mapping objects that are
///                backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
///                attribute is not supported for file mapping objects that are backed by executable image files or data files (the
///                <i>hFile</i> parameter is a handle to an executable image or data file). The maximum size of the file mapping
///                object must be a multiple of the minimum size of a large page returned by the GetLargePageMinimum function. If it
///                is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with
///                <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.
///                <b>SEC_LARGE_PAGES</b> requires the SeLockMemoryPrivilege privilege to be enabled in the caller's token. If
///                <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified. <b>Windows Server 2003: </b>This
///                value is not supported until Windows Server 2003 with SP1. <b>Windows XP: </b>This value is not supported. </td>
///                </tr> <tr> <td width="40%"><a id="SEC_NOCACHE"></a><a id="sec_nocache"></a><dl> <dt><b>SEC_NOCACHE</b></dt>
///                <dt>0x10000000</dt> </dl> </td> <td width="60%"> Sets all pages to be non-cachable. Applications should not use
///                this attribute except when explicitly required for a device. Using the interlocked functions with memory that is
///                mapped with <b>SEC_NOCACHE</b> can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.
///                <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or <b>SEC_COMMIT</b> attribute to be set. </td> </tr>
///                <tr> <td width="40%"><a id="SEC_RESERVE"></a><a id="sec_reserve"></a><dl> <dt><b>SEC_RESERVE</b></dt>
///                <dt>0x4000000</dt> </dl> </td> <td width="60%"> If the file mapping object is backed by the operating system
///                paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file
///                is mapped into a process address space, the entire range of pages is reserved for later use by the process rather
///                than committed. Reserved pages can be committed in subsequent calls to the VirtualAlloc function. After the pages
///                are committed, they cannot be freed or decommitted with the VirtualFree function. This attribute has no effect
///                for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a
///                handle to a file). <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>. </td> </tr> <tr> <td
///                width="40%"><a id="SEC_WRITECOMBINE"></a><a id="sec_writecombine"></a><dl> <dt><b>SEC_WRITECOMBINE</b></dt>
///                <dt>0x40000000</dt> </dl> </td> <td width="60%"> Sets all pages to be write-combined. Applications should not use
///                this attribute except when explicitly required for a device. Using the interlocked functions with memory that is
///                mapped with <b>SEC_WRITECOMBINE</b> can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.
///                <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or <b>SEC_COMMIT</b> attribute to be set.
///                <b>Windows Server 2003 and Windows XP: </b>This flag is not supported until Windows Vista. </td> </tr> </table>
///    dwMaximumSizeHigh = The high-order <b>DWORD</b> of the maximum size of the file mapping object.
///    dwMaximumSizeLow = The low-order <b>DWORD</b> of the maximum size of the file mapping object. If this parameter and
///                       <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file mapping object is equal to the current size
///                       of the file that <i>hFile</i> identifies. An attempt to map a file with a length of 0 (zero) fails with an error
///                       code of <b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those
///                       files.
///    lpName = The name of the file mapping object. If this parameter matches the name of an existing mapping object, the
///             function requests access to the object with the protection that <i>flProtect</i> specifies. If this parameter is
///             <b>NULL</b>, the file mapping object is created without a name. If <i>lpName</i> matches the name of an existing
///             event, semaphore, mutex, waitable timer, or job object, the function fails, and the GetLastError function returns
///             <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a
///             "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). Creating a file mapping object in the
///             global namespace from a session other than session zero requires the SeCreateGlobalPrivilege privilege. For more
///             information, see Kernel Object Namespaces. Fast user switching is implemented by using Terminal Services
///             sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so
///             on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications
///             can support multiple users.
///Returns:
///    If the function succeeds, the return value is a handle to the newly created file mapping object. If the object
///    exists before the function call, the function returns a handle to the existing object (with its current size, not
///    the specified size), and GetLastErrorreturns <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateFileMappingW(HANDLE hFile, SECURITY_ATTRIBUTES* lpFileMappingAttributes, PAGE_TYPE flProtect, 
                          uint dwMaximumSizeHigh, uint dwMaximumSizeLow, const(PWSTR) lpName);

///Opens a named file mapping object.
///Params:
///    dwDesiredAccess = The access to the file mapping object. This access is checked against any security descriptor on the target file
///                      mapping object. For a list of values, see File Mapping Security and Access Rights.
///    bInheritHandle = If this parameter is <b>TRUE</b>, a process created by the CreateProcess function can inherit the handle;
///                     otherwise, the handle cannot be inherited.
///    lpName = The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this
///             name and the security descriptor on the mapping object does not conflict with the <i>dwDesiredAccess</i>
///             parameter, the open operation succeeds. The name can have a "Global\" or "Local\" prefix to explicitly open an
///             object in the global or session namespace. The remainder of the name can contain any character except the
///             backslash character (\\). For more information, see Kernel Object Namespaces. Fast user switching is implemented
///             using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session
///             1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications
///             can support multiple users.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified file mapping object. If the
///    function fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenFileMappingW(uint dwDesiredAccess, BOOL bInheritHandle, const(PWSTR) lpName);

///Maps a view of a file mapping into the address space of a calling process. To specify a suggested base address for
///the view, use the MapViewOfFileEx function. However, this practice is not recommended.
///Params:
///    hFileMappingObject = A handle to a file mapping object. The CreateFileMapping and OpenFileMapping functions return this handle.
///    dwDesiredAccess = The type of access to a file mapping object, which determines the page protection of the pages. This parameter
///                      can be one of the following values, or a bitwise OR combination of multiple values where appropriate. <table>
///                      <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_MAP_ALL_ACCESS"></a><a
///                      id="file_map_all_access"></a><dl> <dt><b>FILE_MAP_ALL_ACCESS</b></dt> </dl> </td> <td width="60%"> A read/write
///                      view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or
///                      <b>PAGE_EXECUTE_READWRITE</b> protection. When used with the <b>MapViewOfFile</b> function,
///                      <b>FILE_MAP_ALL_ACCESS</b> is equivalent to <b>FILE_MAP_WRITE</b>. </td> </tr> <tr> <td width="40%"><a
///                      id="FILE_MAP_READ"></a><a id="file_map_read"></a><dl> <dt><b>FILE_MAP_READ</b></dt> </dl> </td> <td width="60%">
///                      A read-only view of the file is mapped. An attempt to write to the file view results in an access violation. The
///                      file mapping object must have been created with <b>PAGE_READONLY</b>, <b>PAGE_READWRITE</b>,
///                      <b>PAGE_EXECUTE_READ</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection. </td> </tr> <tr> <td width="40%"><a
///                      id="FILE_MAP_WRITE"></a><a id="file_map_write"></a><dl> <dt><b>FILE_MAP_WRITE</b></dt> </dl> </td> <td
///                      width="60%"> A read/write view of the file is mapped. The file mapping object must have been created with
///                      <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection. When used with <b>MapViewOfFile</b>,
///                      (<b>FILE_MAP_WRITE</b> | <b>FILE_MAP_READ</b>) and <b>FILE_MAP_ALL_ACCESS</b> are equivalent to
///                      <b>FILE_MAP_WRITE</b>. </td> </tr> </table> Using bitwise OR, you can combine the values above with these values.
///                      <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_MAP_COPY"></a><a
///                      id="file_map_copy"></a><dl> <dt><b>FILE_MAP_COPY</b></dt> </dl> </td> <td width="60%"> A copy-on-write view of
///                      the file is mapped. The file mapping object must have been created with <b>PAGE_READONLY</b>,
///                      <b>PAGE_READ_EXECUTE</b>, <b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, <b>PAGE_READWRITE</b>, or
///                      <b>PAGE_EXECUTE_READWRITE</b> protection. When a process writes to a copy-on-write page, the system copies the
///                      original page to a new page that is private to the process. The new page is backed by the paging file. The
///                      protection of the new page changes from copy-on-write to read/write. When copy-on-write access is specified, the
///                      system and process commit charge taken is for the entire view because the calling process can potentially write
///                      to every page in the view, making all pages private. The contents of the new page are never written back to the
///                      original file and are lost when the view is unmapped. </td> </tr> <tr> <td width="40%"><a
///                      id="FILE_MAP_EXECUTE"></a><a id="file_map_execute"></a><dl> <dt><b>FILE_MAP_EXECUTE</b></dt> </dl> </td> <td
///                      width="60%"> An executable view of the file is mapped (mapped memory can be run as code). The file mapping object
///                      must have been created with <b>PAGE_EXECUTE_READ</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, or
///                      <b>PAGE_EXECUTE_READWRITE</b> protection. <b>Windows Server 2003 and Windows XP: </b>This value is available
///                      starting with Windows XP with SP2 and Windows Server 2003 with SP1. </td> </tr> <tr> <td width="40%"><a
///                      id="FILE_MAP_LARGE_PAGES"></a><a id="file_map_large_pages"></a><dl> <dt><b>FILE_MAP_LARGE_PAGES</b></dt> </dl>
///                      </td> <td width="60%"> Starting with Windows 10, version 1703, this flag specifies that the view should be mapped
///                      using large page support. The size of the view must be a multiple of the size of a large page reported by the
///                      GetLargePageMinimum function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b>
///                      option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of
///                      <b>GetLargePageMinimum</b>.<br/><br/><b>Note: </b>On OS versions before Windows 10, version 1703, the
///                      <b>FILE_MAP_LARGE_PAGES</b> flag has no effect. On these releases, the view is automatically mapped using large
///                      pages if the section was created with the <b>SEC_LARGE_PAGES</b> flag set. </td> </tr> <tr> <td width="40%"><a
///                      id="FILE_MAP_TARGETS_INVALID"></a><a id="file_map_targets_invalid"></a><dl>
///                      <dt><b>FILE_MAP_TARGETS_INVALID</b></dt> </dl> </td> <td width="60%"> Sets all the locations in the mapped file
///                      as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this
///                      flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in
///                      those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages
///                      allocated is to be marked valid call targets for CFG. </td> </tr> </table> For file mapping objects created with
///                      the <b>SEC_IMAGE</b> attribute, the <i>dwDesiredAccess</i> parameter has no effect, and should be set to any
///                      valid value such as <b>FILE_MAP_READ</b>. For more information about access to file mapping objects, see File
///                      Mapping Security and Access Rights.
///    dwFileOffsetHigh = A high-order <b>DWORD</b> of the file offset where the view begins.
///    dwFileOffsetLow = A low-order <b>DWORD</b> of the file offset where the view is to begin. The combination of the high and low
///                      offsets must specify an offset within the file mapping. They must also match the memory allocation granularity of
///                      the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation
///                      granularity of the system, use the GetSystemInfo function, which fills in the members of a SYSTEM_INFO structure.
///    dwNumberOfBytesToMap = The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified by
///                           CreateFileMapping. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the
///                           file mapping.
///Returns:
///    If the function succeeds, the return value is the starting address of the mapped view. If the function fails, the
///    return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* MapViewOfFile(HANDLE hFileMappingObject, uint dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, 
                    size_t dwNumberOfBytesToMap);

///Maps a view of a file mapping into the address space of a calling process. A caller can optionally specify a
///suggested base memory address for the view. To specify the NUMA node for the physical memory, see
///MapViewOfFileExNuma.
///Params:
///    hFileMappingObject = A handle to a file mapping object. The CreateFileMapping and OpenFileMapping functions return this handle.
///    dwDesiredAccess = The type of access to a file mapping object, which determines the page protection of the pages. This parameter
///                      can be one of the following values, or a bitwise OR combination of multiple values where appropriate. <table>
///                      <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_MAP_ALL_ACCESS"></a><a
///                      id="file_map_all_access"></a><dl> <dt><b>FILE_MAP_ALL_ACCESS</b></dt> </dl> </td> <td width="60%"> A read/write
///                      view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or
///                      <b>PAGE_EXECUTE_READWRITE</b> protection. When used with the <b>MapViewOfFileEx</b> function,
///                      <b>FILE_MAP_ALL_ACCESS</b> is equivalent to <b>FILE_MAP_WRITE</b>. </td> </tr> <tr> <td width="40%"><a
///                      id="FILE_MAP_READ"></a><a id="file_map_read"></a><dl> <dt><b>FILE_MAP_READ</b></dt> </dl> </td> <td width="60%">
///                      A read-only view of the file is mapped. An attempt to write to the file view results in an access violation. The
///                      file mapping object must have been created with <b>PAGE_READONLY</b>, <b>PAGE_READWRITE</b>,
///                      <b>PAGE_EXECUTE_READ</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection. </td> </tr> <tr> <td width="40%"><a
///                      id="FILE_MAP_WRITE"></a><a id="file_map_write"></a><dl> <dt><b>FILE_MAP_WRITE</b></dt> </dl> </td> <td
///                      width="60%"> A read/write view of the file is mapped. The file mapping object must have been created with
///                      <b>PAGE_READWRITE</b> or <b>PAGE_EXECUTE_READWRITE</b> protection. When used with <b>MapViewOfFileEx</b>,
///                      (<b>FILE_MAP_WRITE</b> | <b>FILE_MAP_READ</b>) and <b>FILE_MAP_ALL_ACCESS</b> are equivalent to
///                      <b>FILE_MAP_WRITE</b>. </td> </tr> </table> Using bitwise OR, you can combine the values above with these values.
///                      <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_MAP_COPY"></a><a
///                      id="file_map_copy"></a><dl> <dt><b>FILE_MAP_COPY</b></dt> </dl> </td> <td width="60%"> A copy-on-write view of
///                      the file is mapped. The file mapping object must have been created with <b>PAGE_READONLY</b>,
///                      <b>PAGE_READ_EXECUTE</b>, <b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, <b>PAGE_READWRITE</b>, or
///                      <b>PAGE_EXECUTE_READWRITE</b> protection. When a process writes to a copy-on-write page, the system copies the
///                      original page to a new page that is private to the process. The new page is backed by the paging file. The
///                      protection of the new page changes from copy-on-write to read/write. When copy-on-write access is specified, the
///                      system and process commit charge taken is for the entire view because the calling process can potentially write
///                      to every page in the view, making all pages private. The contents of the new page are never written back to the
///                      original file and are lost when the view is unmapped. </td> </tr> <tr> <td width="40%"><a
///                      id="FILE_MAP_LARGE_PAGES"></a><a id="file_map_large_pages"></a><dl> <dt><b>FILE_MAP_LARGE_PAGES</b></dt> </dl>
///                      </td> <td width="60%"> Starting with Windows 10, version 1703, this flag specifies that the view should be mapped
///                      using large page support. The size of the view must be a multiple of the size of a large page reported by the
///                      GetLargePageMinimum function, and the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b>
///                      option. If you provide a non-null value for <i>lpBaseAddress</i>, then the value must be a multiple of
///                      <b>GetLargePageMinimum</b>. </td> </tr> <tr> <td width="40%"><a id="FILE_MAP_EXECUTE"></a><a
///                      id="file_map_execute"></a><dl> <dt><b>FILE_MAP_EXECUTE</b></dt> </dl> </td> <td width="60%"> An executable view
///                      of the file is mapped (mapped memory can be run as code). The file mapping object must have been created with
///                      <b>PAGE_EXECUTE_READ</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection. <b>Windows
///                      Server 2003 and Windows XP: </b>This value is available starting with Windows XP with SP2 and Windows Server 2003
///                      with SP1. </td> </tr> <tr> <td width="40%"><a id="FILE_MAP_TARGETS_INVALID"></a><a
///                      id="file_map_targets_invalid"></a><dl> <dt><b>FILE_MAP_TARGETS_INVALID</b></dt> </dl> </td> <td width="60%"> Sets
///                      all the locations in the mapped file as invalid targets for Control Flow Guard (CFG). This flag is similar to
///                      <b>PAGE_TARGETS_INVALID</b>. Use this flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>.
///                      Any indirect call to locations in those pages will fail CFG checks, and the process will be terminated. The
///                      default behavior for executable pages allocated is to be marked valid call targets for CFG. </td> </tr> </table>
///                      For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the <i>dwDesiredAccess</i> parameter has no
///                      effect, and should be set to any valid value such as <b>FILE_MAP_READ</b>. For more information about access to
///                      file mapping objects, see File Mapping Security and Access Rights.
///    dwFileOffsetHigh = The high-order <b>DWORD</b> of the file offset where the view is to begin.
///    dwFileOffsetLow = The low-order <b>DWORD</b> of the file offset where the view is to begin. The combination of the high and low
///                      offsets must specify an offset within the file mapping. They must also match the memory allocation granularity of
///                      the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation
///                      granularity of the system, use the GetSystemInfo function, which fills in the members of a SYSTEM_INFO structure.
///    dwNumberOfBytesToMap = The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified by
///                           CreateFileMapping. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the
///                           file mapping.
///    lpBaseAddress = A pointer to the memory address in the calling process address space where mapping begins. This must be a
///                    multiple of the system's memory allocation granularity, or the function fails. To determine the memory allocation
///                    granularity of the system, use the GetSystemInfo function. If there is not enough address space at the specified
///                    address, the function fails. If <i>lpBaseAddress</i> is <b>NULL</b>, the operating system chooses the mapping
///                    address. In this scenario, the function is equivalent to the MapViewOfFile function. While it is possible to
///                    specify an address that is safe now (not used by the operating system), there is no guarantee that the address
///                    will remain safe over time. Therefore, it is better to let the operating system choose the address. In this case,
///                    you would not store pointers in the memory mapped file, you would store offsets from the base of the file mapping
///                    so that the mapping can be used at any address.
///Returns:
///    If the function succeeds, the return value is the starting address of the mapped view. If the function fails, the
///    return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* MapViewOfFileEx(HANDLE hFileMappingObject, uint dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, 
                      size_t dwNumberOfBytesToMap, void* lpBaseAddress);

///Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified
///process.
///Params:
///    hProcess = A handle to a process. The function frees memory within the virtual address space of the process. The handle must
///               have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see Process Security and Access Rights.
///    lpAddress = A pointer to the starting address of the region of memory to be freed. If the <i>dwFreeType</i> parameter is
///                <b>MEM_RELEASE</b>, <i>lpAddress</i> must be the base address returned by the VirtualAllocEx function when the
///                region is reserved.
///    dwSize = The size of the region of memory to free, in bytes. If the <i>dwFreeType</i> parameter is <b>MEM_RELEASE</b>,
///             <i>dwSize</i> must be 0 (zero). The function frees the entire region that is reserved in the initial allocation
///             call to VirtualAllocEx. If <i>dwFreeType</i> is <b>MEM_DECOMMIT</b>, the function decommits all memory pages that
///             contain one or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>.
///             This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be
///             decommitted. If <i>lpAddress</i> is the base address returned by VirtualAllocEx and <i>dwSize</i> is 0 (zero),
///             the function decommits the entire region that is allocated by <b>VirtualAllocEx</b>. After that, the entire
///             region is in the reserved state.
///    dwFreeType = The type of free operation. This parameter must be one of the following values. <table> <tr> <th>Value</th>
///                 <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_DECOMMIT"></a><a id="mem_decommit"></a><dl>
///                 <dt><b>MEM_DECOMMIT</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> Decommits the specified region of
///                 committed pages. After the operation, the pages are in the reserved state. The function does not fail if you
///                 attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first
///                 determining the current commitment state. The <b>MEM_DECOMMIT</b> value is not supported when the
///                 <i>lpAddress</i> parameter provides the base address for an enclave. </td> </tr> <tr> <td width="40%"><a
///                 id="MEM_RELEASE"></a><a id="mem_release"></a><dl> <dt><b>MEM_RELEASE</b></dt> <dt>0x00008000</dt> </dl> </td> <td
///                 width="60%"> Releases the specified region of pages, or placeholder (for a placeholder, the address space is
///                 released and available for other allocations). After this operation, the pages are in the free state. If you
///                 specify this value, <i>dwSize</i> must be 0 (zero), and <i>lpAddress</i> must point to the base address returned
///                 by the VirtualAlloc function when the region is reserved. The function fails if either of these conditions is not
///                 met. If any pages in the region are committed currently, the function first decommits, and then releases them.
///                 The function does not fail if you attempt to release pages that are in different states, some reserved and some
///                 committed. This means that you can release a range of pages without first determining the current commitment
///                 state. </td> </tr> </table> When using <b>MEM_RELEASE</b>, this parameter can additionally specify one of the
///                 following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="MEM_COALESCE_PLACEHOLDERS"></a><a id="mem_coalesce_placeholders"></a><dl>
///                 <dt><b>MEM_COALESCE_PLACEHOLDERS</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> To coalesce two
///                 adjacent placeholders, specify <code>MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS</code>. When you coalesce
///                 placeholders, <i>lpAddress</i> and <i>dwSize</i> must exactly match those of the placeholder. </td> </tr> <tr>
///                 <td width="40%"><a id="MEM_PRESERVE_PLACEHOLDER"></a><a id="mem_preserve_placeholder"></a><dl>
///                 <dt><b>MEM_PRESERVE_PLACEHOLDER</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Frees an allocation
///                 back to a placeholder (after you've replaced a placeholder with a private allocation using VirtualAlloc2 or
///                 Virtual2AllocFromApp). To split a placeholder into two placeholders, specify <code>MEM_RELEASE |
///                 MEM_PRESERVE_PLACEHOLDER</code>. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL VirtualFreeEx(HANDLE hProcess, void* lpAddress, size_t dwSize, uint dwFreeType);

///Writes to the disk a byte range within a mapped view of a file.
///Params:
///    lpBaseAddress = A pointer to the base address of the byte range to be flushed to the disk representation of the mapped file.
///    dwNumberOfBytesToFlush = The number of bytes to be flushed. If <i>dwNumberOfBytesToFlush</i> is zero, the file is flushed from the base
///                             address to the end of the mapping.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FlushViewOfFile(const(void)* lpBaseAddress, size_t dwNumberOfBytesToFlush);

///Unmaps a mapped view of a file from the calling process's address space.
///Params:
///    lpBaseAddress = A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical
///                    to the value returned by a previous call to the MapViewOfFile or MapViewOfFileEx function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL UnmapViewOfFile(const(void)* lpBaseAddress);

///Retrieves the minimum size of a large page.
///Returns:
///    If the processor supports large pages, the return value is the minimum size of a large page. If the processor
///    does not support large pages, the return value is zero.
///    
@DllImport("KERNEL32")
size_t GetLargePageMinimum();

///Retrieves the minimum and maximum working set sizes of the specified process.
///Params:
///    hProcess = A handle to the process whose working set sizes will be obtained. The handle must have the
///               <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information,
///               see Process Security and Access Rights. <b>Windows Server 2003: </b>The handle must have the
///               <b>PROCESS_QUERY_INFORMATION</b> access right.
///    lpMinimumWorkingSetSize = A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The
///                              virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is
///                              active.
///    lpMaximumWorkingSetSize = A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The
///                              virtual memory manager attempts to keep no more than this much memory resident in the process whenever the
///                              process is active when memory is in short supply.
///    Flags = The flags that control the enforcement of the minimum and maximum working set sizes. <table> <tr> <th>Value</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="QUOTA_LIMITS_HARDWS_MIN_DISABLE"></a><a
///            id="quota_limits_hardws_min_disable"></a><dl> <dt><b>QUOTA_LIMITS_HARDWS_MIN_DISABLE</b></dt> <dt>0x00000002</dt>
///            </dl> </td> <td width="60%"> The working set may fall below the minimum working set limit if memory demands are
///            high. </td> </tr> <tr> <td width="40%"><a id="QUOTA_LIMITS_HARDWS_MIN_ENABLE"></a><a
///            id="quota_limits_hardws_min_enable"></a><dl> <dt><b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b></dt> <dt>0x00000001</dt>
///            </dl> </td> <td width="60%"> The working set will not fall below the minimum working set limit. </td> </tr> <tr>
///            <td width="40%"><a id="QUOTA_LIMITS_HARDWS_MAX_DISABLE"></a><a id="quota_limits_hardws_max_disable"></a><dl>
///            <dt><b>QUOTA_LIMITS_HARDWS_MAX_DISABLE</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> The working set
///            may exceed the maximum working set limit if there is abundant memory. </td> </tr> <tr> <td width="40%"><a
///            id="QUOTA_LIMITS_HARDWS_MAX_ENABLE"></a><a id="quota_limits_hardws_max_enable"></a><dl>
///            <dt><b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The working set
///            will not exceed the maximum working set limit. </td> </tr> </table>
@DllImport("KERNEL32")
BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, size_t* lpMinimumWorkingSetSize, size_t* lpMaximumWorkingSetSize, 
                                uint* Flags);

///Sets the minimum and maximum working set sizes for the specified process.
///Params:
///    hProcess = A handle to the process whose working set sizes is to be set. The handle must have <b>PROCESS_SET_QUOTA</b>
///               access rights. For more information, see Process Security and Access Rights.
///    dwMinimumWorkingSetSize = The minimum working set size for the process, in bytes. The virtual memory manager attempts to keep at least this
///                              much memory resident in the process whenever the process is active. This parameter must be greater than zero but
///                              less than or equal to the maximum working set size. The default size is 50 pages (for example, this is 204,800
///                              bytes on systems with a 4K page size). If the value is greater than zero but less than 20 pages, the minimum
///                              value is set to 20 pages. If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the
///                              value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified
///                              process.
///    dwMaximumWorkingSetSize = The maximum working set size for the process, in bytes. The virtual memory manager attempts to keep no more than
///                              this much memory resident in the process whenever the process is active and available memory is low. This
///                              parameter must be greater than or equal to 13 pages (for example, 53,248 on systems with a 4K page size), and
///                              less than the system-wide maximum (number of available pages minus 512 pages). The default size is 345 pages (for
///                              example, this is 1,413,120 bytes on systems with a 4K page size). If both <i>dwMinimumWorkingSetSize</i> and
///                              <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible
///                              from the working set of the specified process. For details, see Remarks.
///    Flags = The flags that control the enforcement of the minimum and maximum working set sizes. <table> <tr> <th>Value</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="QUOTA_LIMITS_HARDWS_MIN_DISABLE"></a><a
///            id="quota_limits_hardws_min_disable"></a><dl> <dt><b>QUOTA_LIMITS_HARDWS_MIN_DISABLE</b></dt> <dt>0x00000002</dt>
///            </dl> </td> <td width="60%"> The working set may fall below the minimum working set limit if memory demands are
///            high. This flag cannot be used with <b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b>. </td> </tr> <tr> <td width="40%"><a
///            id="QUOTA_LIMITS_HARDWS_MIN_ENABLE"></a><a id="quota_limits_hardws_min_enable"></a><dl>
///            <dt><b>QUOTA_LIMITS_HARDWS_MIN_ENABLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The working set
///            will not fall below the minimum working set limit. This flag cannot be used with
///            <b>QUOTA_LIMITS_HARDWS_MIN_DISABLE</b>. </td> </tr> <tr> <td width="40%"><a
///            id="QUOTA_LIMITS_HARDWS_MAX_DISABLE"></a><a id="quota_limits_hardws_max_disable"></a><dl>
///            <dt><b>QUOTA_LIMITS_HARDWS_MAX_DISABLE</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> <i>The working
///            set may exceed the maximum working set limit if there is abundant memory.</i> This flag cannot be used with
///            <b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b>. </td> </tr> <tr> <td width="40%"><a
///            id="QUOTA_LIMITS_HARDWS_MAX_ENABLE"></a><a id="quota_limits_hardws_max_enable"></a><dl>
///            <dt><b>QUOTA_LIMITS_HARDWS_MAX_ENABLE</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The working set
///            will not exceed the maximum working set limit. This flag cannot be used with
///            <b>QUOTA_LIMITS_HARDWS_MAX_DISABLE</b>. </td> </tr> </table>
///Returns:
///    If the function is succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the function fails, the return value is zero. To get extended
///    error information, call <b>GetLastError</b>.
///    
@DllImport("KERNEL32")
BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, size_t dwMinimumWorkingSetSize, size_t dwMaximumWorkingSetSize, 
                                uint Flags);

///Locks the specified region of the process's virtual address space into physical memory, ensuring that subsequent
///access to the region will not incur a page fault.
///Params:
///    lpAddress = A pointer to the base address of the region of pages to be locked.
///    dwSize = The size of the region to be locked, in bytes. The region of affected pages includes all pages that contain one
///             or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means
///             that a 2-byte range straddling a page boundary causes both pages to be locked.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL VirtualLock(void* lpAddress, size_t dwSize);

///Unlocks a specified range of pages in the virtual address space of a process, enabling the system to swap the pages
///out to the paging file if necessary.
///Params:
///    lpAddress = A pointer to the base address of the region of pages to be unlocked.
///    dwSize = The size of the region being unlocked, in bytes. The region of affected pages includes all pages containing one
///             or more bytes in the range from the <i>lpAddress</i> parameter to <code>(lpAddress+dwSize)</code>. This means
///             that a 2-byte range straddling a page boundary causes both pages to be unlocked.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL VirtualUnlock(void* lpAddress, size_t dwSize);

///Retrieves the addresses of the pages that are written to in a region of virtual memory. <b>64-bit Windows on
///Itanium-based systems: </b>Due to the difference in page sizes, <b>GetWriteWatch</b> is not supported for 32-bit
///applications.
///Params:
///    dwFlags = Indicates whether the function resets the write-tracking state. To reset the write-tracking state, set this
///              parameter to <b>WRITE_WATCH_FLAG_RESET</b>. If this parameter is 0 (zero), <b>GetWriteWatch</b> does not reset
///              the write-tracking state. For more information, see the Remarks section of this topic.
///    lpBaseAddress = The base address of the memory region for which to retrieve write-tracking information. This address must be in a
///                    memory region that is allocated by the VirtualAlloc function using <b>MEM_WRITE_WATCH</b>.
///    dwRegionSize = The size of the memory region for which to retrieve write-tracking information, in bytes.
///    lpAddresses = A pointer to a buffer that receives an array of page addresses in the memory region. The addresses indicate the
///                  pages that have been written to since the region has been allocated or the write-tracking state has been reset.
///    lpdwCount = On input, this variable indicates the size of the <i>lpAddresses</i> array, in array elements. On output, the
///                variable receives the number of page addresses that are returned in the array.
///    lpdwGranularity = A pointer to a variable that receives the page size, in bytes.
///Returns:
///    If the function succeeds, the return value is 0 (zero). If the function fails, the return value is a nonzero
///    value.
///    
@DllImport("KERNEL32")
uint GetWriteWatch(uint dwFlags, void* lpBaseAddress, size_t dwRegionSize, void** lpAddresses, size_t* lpdwCount, 
                   uint* lpdwGranularity);

///Resets the write-tracking state for a region of virtual memory. Subsequent calls to the GetWriteWatch function only
///report pages that are written to since the reset operation. <b>64-bit Windows on Itanium-based systems: </b>Due to
///the difference in page sizes, <b>ResetWriteWatch</b> is not supported for 32-bit applications.
///Params:
///    lpBaseAddress = A pointer to the base address of the memory region for which to reset the write-tracking state. This address must
///                    be in a memory region that is allocated by the VirtualAlloc function with <b>MEM_WRITE_WATCH</b>.
///    dwRegionSize = The size of the memory region for which to reset the write-tracking information, in bytes.
///Returns:
///    If the function succeeds, the return value is 0 (zero). If the function fails, the return value is a nonzero
///    value.
///    
@DllImport("KERNEL32")
uint ResetWriteWatch(void* lpBaseAddress, size_t dwRegionSize);

///Creates a memory resource notification object.
///Params:
///    NotificationType = The memory condition under which the object is to be signaled. This parameter can be one of the following values
///                       from the <b>MEMORY_RESOURCE_NOTIFICATION_TYPE</b> enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                       <tr> <td width="40%"><a id="LowMemoryResourceNotification"></a><a id="lowmemoryresourcenotification"></a><a
///                       id="LOWMEMORYRESOURCENOTIFICATION"></a><dl> <dt><b>LowMemoryResourceNotification</b></dt> <dt>0</dt> </dl> </td>
///                       <td width="60%"> Available physical memory is running low. </td> </tr> <tr> <td width="40%"><a
///                       id="HighMemoryResourceNotification"></a><a id="highmemoryresourcenotification"></a><a
///                       id="HIGHMEMORYRESOURCENOTIFICATION"></a><dl> <dt><b>HighMemoryResourceNotification</b></dt> <dt>1</dt> </dl>
///                       </td> <td width="60%"> Available physical memory is high. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to a memory resource notification object. If the function
///    fails, the return value is <b>NULL</b>. To get extended information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType);

///Retrieves the state of the specified memory resource object.
///Params:
///    ResourceNotificationHandle = A handle to a memory resource notification object. The CreateMemoryResourceNotification function returns this
///                                 handle.
///    ResourceState = The memory pointed to by this parameter receives the state of the memory resource notification object. The value
///                    of this parameter is set to <b>TRUE</b> if the specified memory condition exists, and <b>FALSE</b> if the
///                    specified memory condition does not exist.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. For more
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, BOOL* ResourceState);

///Retrieves the current size limits for the working set of the system cache.
///Params:
///    lpMinimumFileCacheSize = A pointer to a variable that receives the minimum size of the file cache, in bytes. The virtual memory manager
///                             attempts to keep at least this much memory resident in the system file cache, if there is a previous call to the
///                             SetSystemFileCacheSize function with the <b>FILE_CACHE_MIN_HARD_ENABLE</b> flag.
///    lpMaximumFileCacheSize = A pointer to a variable that receives the maximum size of the file cache, in bytes. The virtual memory manager
///                             enforces this limit only if there is a previous call to SetSystemFileCacheSize with the
///                             <b>FILE_CACHE_MAX_HARD_ENABLE</b> flag.
///    lpFlags = The flags that indicate which of the file cache limits are enabled. <table> <tr> <th>Value</th> <th>Meaning</th>
///              </tr> <tr> <td width="40%"><a id="FILE_CACHE_MAX_HARD_ENABLE"></a><a id="file_cache_max_hard_enable"></a><dl>
///              <dt><b>FILE_CACHE_MAX_HARD_ENABLE</b></dt> <dt>0x1</dt> </dl> </td> <td width="60%"> The maximum size limit is
///              enabled. If this flag is not present, this limit is disabled. </td> </tr> <tr> <td width="40%"><a
///              id="FILE_CACHE_MIN_HARD_ENABLE"></a><a id="file_cache_min_hard_enable"></a><dl>
///              <dt><b>FILE_CACHE_MIN_HARD_ENABLE</b></dt> <dt>0x4</dt> </dl> </td> <td width="60%"> The minimum size limit is
///              enabled. If this flag is not present, this limit is disabled. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetSystemFileCacheSize(size_t* lpMinimumFileCacheSize, size_t* lpMaximumFileCacheSize, uint* lpFlags);

///Limits the size of the working set for the file system cache.
///Params:
///    MinimumFileCacheSize = The minimum size of the file cache, in bytes. The virtual memory manager attempts to keep at least this much
///                           memory resident in the system file cache. To flush the cache, specify <code>(SIZE_T) -1</code>.
///    MaximumFileCacheSize = The maximum size of the file cache, in bytes. The virtual memory manager enforces this limit only if this call or
///                           a previous call to <b>SetSystemFileCacheSize</b> specifies <b>FILE_CACHE_MAX_HARD_ENABLE</b>. To flush the cache,
///                           specify <code>(SIZE_T) -1</code>.
///    Flags = The flags that enable or disable the file cache limits. If this parameter is 0 (zero), the size limits retain the
///            current setting, which is either disabled or enabled. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///            width="40%"><a id="FILE_CACHE_MAX_HARD_DISABLE"></a><a id="file_cache_max_hard_disable"></a><dl>
///            <dt><b>FILE_CACHE_MAX_HARD_DISABLE</b></dt> <dt>0x2</dt> </dl> </td> <td width="60%"> Disable the maximum size
///            limit. The <b>FILE_CACHE_MAX_HARD_DISABLE</b> and <b>FILE_CACHE_MAX_HARD_ENABLE</b> flags are mutually exclusive.
///            </td> </tr> <tr> <td width="40%"><a id="FILE_CACHE_MAX_HARD_ENABLE"></a><a
///            id="file_cache_max_hard_enable"></a><dl> <dt><b>FILE_CACHE_MAX_HARD_ENABLE</b></dt> <dt>0x1</dt> </dl> </td> <td
///            width="60%"> Enable the maximum size limit. The <b>FILE_CACHE_MAX_HARD_DISABLE</b> and
///            <b>FILE_CACHE_MAX_HARD_ENABLE</b> flags are mutually exclusive. </td> </tr> <tr> <td width="40%"><a
///            id="FILE_CACHE_MIN_HARD_DISABLE"></a><a id="file_cache_min_hard_disable"></a><dl>
///            <dt><b>FILE_CACHE_MIN_HARD_DISABLE</b></dt> <dt>0x8</dt> </dl> </td> <td width="60%"> Disable the minimum size
///            limit. The <b>FILE_CACHE_MIN_HARD_DISABLE</b> and <b>FILE_CACHE_MIN_HARD_ENABLE</b> flags are mutually exclusive.
///            </td> </tr> <tr> <td width="40%"><a id="FILE_CACHE_MIN_HARD_ENABLE"></a><a
///            id="file_cache_min_hard_enable"></a><dl> <dt><b>FILE_CACHE_MIN_HARD_ENABLE</b></dt> <dt>0x4</dt> </dl> </td> <td
///            width="60%"> Enable the minimum size limit. The <b>FILE_CACHE_MIN_HARD_DISABLE</b> and
///            <b>FILE_CACHE_MIN_HARD_ENABLE</b> flags are mutually exclusive. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetSystemFileCacheSize(size_t MinimumFileCacheSize, size_t MaximumFileCacheSize, uint Flags);

///Creates or opens a named or unnamed file mapping object for a specified file and specifies the NUMA node for the
///physical memory.
///Params:
///    hFile = A handle to the file from which to create a file mapping object. The file must be opened with access rights that
///            are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but
///            it is recommended that files you intend to map be opened for exclusive access. For more information, see File
///            Security and Access Rights. If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify
///            a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In
///            this scenario, <b>CreateFileMappingNuma</b> creates a file mapping object of a specified size that is backed by
///            the system paging file instead of by a file in the file system.
///    lpFileMappingAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether a returned handle can be inherited by child
///                              processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a
///                              security descriptor for a new file mapping object. If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle
///                              cannot be inherited and the file mapping object gets a default security descriptor. The access control lists
///                              (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token
///                              of the creator. For more information, see File Mapping Security and Access Rights.
///    flProtect = Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with
///                this protection. This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="PAGE_EXECUTE_READ"></a><a id="page_execute_read"></a><dl>
///                <dt><b>PAGE_EXECUTE_READ</b></dt> <dt>0x20</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, or execute access. The file handle that the <i>hFile</i> parameter specifies must be
///                created with the <b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights. </td> </tr> <tr> <td
///                width="40%"><a id="PAGE_EXECUTE_READWRITE"></a><a id="page_execute_readwrite"></a><dl>
///                <dt><b>PAGE_EXECUTE_READWRITE</b></dt> <dt>0x40</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, read/write or execute access. The file handle that the <i>hFile</i> parameter specifies
///                must be created with the <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and <b>GENERIC_EXECUTE</b> access rights.
///                </td> </tr> <tr> <td width="40%"><a id="PAGE_EXECUTE_WRITECOPY"></a><a id="page_execute_writecopy"></a><dl>
///                <dt><b>PAGE_EXECUTE_WRITECOPY</b></dt> <dt>0x80</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>. The file
///                handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> and
///                <b>GENERIC_EXECUTE</b> access rights. <b>Windows Vista: </b>This value is not available until Windows Vista with
///                SP1. </td> </tr> <tr> <td width="40%"><a id="PAGE_READONLY"></a><a id="page_readonly"></a><dl>
///                <dt><b>PAGE_READONLY</b></dt> <dt>0x02</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only
///                or copy-on-write access. An attempt to write to a specific region results in an access violation. The file handle
///                that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right. </td> </tr>
///                <tr> <td width="40%"><a id="PAGE_READWRITE"></a><a id="page_readwrite"></a><dl> <dt><b>PAGE_READWRITE</b></dt>
///                <dt>0x04</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only, copy-on-write, or read/write
///                access. The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b>
///                and <b>GENERIC_WRITE</b> access rights. </td> </tr> <tr> <td width="40%"><a id="PAGE_WRITECOPY"></a><a
///                id="page_writecopy"></a><dl> <dt><b>PAGE_WRITECOPY</b></dt> <dt>0x08</dt> </dl> </td> <td width="60%"> Allows
///                views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>. The
///                file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.
///                </td> </tr> </table> An application can specify one or more of the following attributes for the file mapping
///                object by combining them with one of the preceding page protection values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SEC_COMMIT"></a><a id="sec_commit"></a><dl>
///                <dt><b>SEC_COMMIT</b></dt> <dt>0x8000000</dt> </dl> </td> <td width="60%"> Allocates physical storage in memory
///                or the paging file for all pages. This is the default setting. </td> </tr> <tr> <td width="40%"><a
///                id="SEC_IMAGE"></a><a id="sec_image"></a><dl> <dt><b>SEC_IMAGE</b></dt> <dt>0x1000000</dt> </dl> </td> <td
///                width="60%"> Sets the file that is specified to be an executable image file. The <b>SEC_IMAGE</b> attribute must
///                be combined with a page protection value such as <b>PAGE_READONLY</b>. However, this page protection value has no
///                effect on views of the executable image file. Page protection for views of an executable image file is determined
///                by the executable file itself. No other attributes are valid with <b>SEC_IMAGE</b>. </td> </tr> <tr> <td
///                width="40%"><a id="SEC_IMAGE_NO_EXECUTE"></a><a id="sec_image_no_execute"></a><dl>
///                <dt><b>SEC_IMAGE_NO_EXECUTE</b></dt> <dt>0x11000000</dt> </dl> </td> <td width="60%"> Specifies that the file
///                that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded
///                image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object
///                created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the
///                PsSetLoadImageNotifyRoutine kernel API. The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
///                <b>PAGE_READONLY</b> page protection value. No other attributes are valid with <b>SEC_IMAGE_NO_EXECUTE</b>.
///                <b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista: </b>This value is not supported
///                before Windows Server 2012 and Windows 8. </td> </tr> <tr> <td width="40%"><a id="SEC_LARGE_PAGES"></a><a
///                id="sec_large_pages"></a><dl> <dt><b>SEC_LARGE_PAGES</b></dt> <dt>0x80000000</dt> </dl> </td> <td width="60%">
///                Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data for
///                regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a large page
///                reported by the GetLargePageMinimum function and to enable the SeLockMemoryPrivilege privilege. </td> </tr> <tr>
///                <td width="40%"><a id="SEC_NOCACHE"></a><a id="sec_nocache"></a><dl> <dt><b>SEC_NOCACHE</b></dt>
///                <dt>0x10000000</dt> </dl> </td> <td width="60%"> Sets all pages to noncachable. Applications should not use this
///                flag except when explicitly required for a device. Using the interlocked functions with memory mapped with
///                <b>SEC_NOCACHE</b> can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception. <b>SEC_NOCACHE</b> requires
///                either <b>SEC_RESERVE</b> or <b>SEC_COMMIT</b> to be set. </td> </tr> <tr> <td width="40%"><a
///                id="SEC_RESERVE"></a><a id="sec_reserve"></a><dl> <dt><b>SEC_RESERVE</b></dt> <dt>0x4000000</dt> </dl> </td> <td
///                width="60%"> Reserves all pages without allocating physical storage. The reserved range of pages cannot be used
///                by any other allocation operations until the range of pages is released. Reserved pages can be identified in
///                subsequent calls to the VirtualAllocExNuma function. This attribute is valid only if the <i>hFile</i> parameter
///                is <b>INVALID_HANDLE_VALUE</b> (that is, a file mapping object that is backed by the system paging file). </td>
///                </tr> <tr> <td width="40%"><a id="SEC_WRITECOMBINE"></a><a id="sec_writecombine"></a><dl>
///                <dt><b>SEC_WRITECOMBINE</b></dt> <dt>0x40000000</dt> </dl> </td> <td width="60%"> Sets all pages to be
///                write-combined. Applications should not use this attribute except when explicitly required for a device. Using
///                the interlocked functions with memory that is mapped with <b>SEC_WRITECOMBINE</b> can result in an
///                <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception. <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
///                <b>SEC_COMMIT</b> attribute to be set. </td> </tr> </table>
///    dwMaximumSizeHigh = The high-order <b>DWORD</b> of the maximum size of the file mapping object.
///    dwMaximumSizeLow = The low-order <b>DWORD</b> of the maximum size of the file mapping object. If this parameter and the
///                       <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum size of the file mapping object is equal to the
///                       current size of the file that the <i>hFile</i> parameter identifies. An attempt to map a file with a length of 0
///                       (zero) fails with an error code of <b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of
///                       0 (zero) and reject those files.
///    lpName = The name of the file mapping object. If this parameter matches the name of an existing file mapping object, the
///             function requests access to the object with the protection that the <i>flProtect</i> parameter specifies. If this
///             parameter is <b>NULL</b>, the file mapping object is created without a name. If the <i>lpName</i> parameter
///             matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails and
///             the GetLastError function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same
///             namespace. The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or
///             session namespace. The remainder of the name can contain any character except the backslash character (\\).
///             Creating a file mapping object in the global namespace requires the SeCreateGlobalPrivilege privilege. For more
///             information, see Kernel Object Namespaces. Fast user switching is implemented by using Terminal Services
///             sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so
///             on. Kernel object names must follow the guidelines so that applications can support multiple users.
///    nndPreferred = The NUMA node where the physical memory should reside. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                   <td width="40%"><a id="NUMA_NO_PREFERRED_NODE"></a><a id="numa_no_preferred_node"></a><dl>
///                   <dt><b>NUMA_NO_PREFERRED_NODE</b></dt> <dt>0xffffffff</dt> </dl> </td> <td width="60%"> No NUMA node is
///                   preferred. This is the same as calling the CreateFileMapping function. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to the file mapping object. If the object exists before
///    the function call, the function returns a handle to the existing object (with its current size, not the specified
///    size) and the GetLastErrorfunction returns <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
HANDLE CreateFileMappingNumaW(HANDLE hFile, SECURITY_ATTRIBUTES* lpFileMappingAttributes, uint flProtect, 
                              uint dwMaximumSizeHigh, uint dwMaximumSizeLow, const(PWSTR) lpName, uint nndPreferred);

///Provides an efficient mechanism to bring into memory potentially discontiguous virtual address ranges in a process
///address space.
///Params:
///    hProcess = Handle to the process whose virtual address ranges are to be prefetched. Use the GetCurrentProcess function to
///               use the current process.
///    NumberOfEntries = Number of entries in the array pointed to by the <i>VirtualAddresses</i> parameter.
///    VirtualAddresses = Pointer to an array of WIN32_MEMORY_RANGE_ENTRY structures which each specify a virtual address range to be
///                       prefetched. The virtual address ranges may cover any part of the process address space accessible by the target
///                       process.
///    Flags = Reserved. Must be 0.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is 0
///    (zero). To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL PrefetchVirtualMemory(HANDLE hProcess, size_t NumberOfEntries, WIN32_MEMORY_RANGE_ENTRY* VirtualAddresses, 
                           uint Flags);

///Creates or opens a named or unnamed file mapping object for a specified file from a Windows Store app.
///Params:
///    hFile = A handle to the file from which to create a file mapping object. The file must be opened with access rights that
///            are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but
///            it is recommended that files you intend to map be opened for exclusive access. For more information, see File
///            Security and Access Rights. If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify
///            a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In
///            this scenario, <b>CreateFileMappingFromApp</b> creates a file mapping object of a specified size that is backed
///            by the system paging file instead of by a file in the file system.
///    SecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether a returned handle can be inherited by child
///                         processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a
///                         security descriptor for a new file mapping object. If <i>SecurityAttributes</i> is <b>NULL</b>, the handle cannot
///                         be inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in
///                         the default security descriptor for a file mapping object come from the primary or impersonation token of the
///                         creator. For more information, see File Mapping Security and Access Rights.
///    PageProtection = Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with
///                     this protection. This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///                     </tr> <tr> <td width="40%"><a id="PAGE_READONLY"></a><a id="page_readonly"></a><dl> <dt><b>PAGE_READONLY</b></dt>
///                     <dt>0x02</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only or copy-on-write access. An
///                     attempt to write to a specific region results in an access violation. The file handle that the <i>hFile</i>
///                     parameter specifies must be created with the <b>GENERIC_READ</b> access right. </td> </tr> <tr> <td
///                     width="40%"><a id="PAGE_READWRITE"></a><a id="page_readwrite"></a><dl> <dt><b>PAGE_READWRITE</b></dt>
///                     <dt>0x04</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only, copy-on-write, or read/write
///                     access. The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b>
///                     and <b>GENERIC_WRITE</b> access rights. </td> </tr> <tr> <td width="40%"><a id="PAGE_WRITECOPY"></a><a
///                     id="page_writecopy"></a><dl> <dt><b>PAGE_WRITECOPY</b></dt> <dt>0x08</dt> </dl> </td> <td width="60%"> Allows
///                     views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>. The
///                     file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.
///                     </td> </tr> </table> An application can specify one or more of the following attributes for the file mapping
///                     object by combining them with one of the preceding page protection values. <table> <tr> <th>Value</th>
///                     <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SEC_COMMIT"></a><a id="sec_commit"></a><dl>
///                     <dt><b>SEC_COMMIT</b></dt> <dt>0x8000000</dt> </dl> </td> <td width="60%"> If the file mapping object is backed
///                     by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
///                     when a view of the file is mapped into a process address space, the entire range of pages is committed rather
///                     than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
///                     <b>CreateFileMappingFromApp</b> fails. This attribute has no effect for file mapping objects that are backed by
///                     executable image files or data files (the <i>hfile</i> parameter is a handle to a file). <b>SEC_COMMIT</b> cannot
///                     be combined with <b>SEC_RESERVE</b>. If no attribute is specified, <b>SEC_COMMIT</b> is assumed. </td> </tr> <tr>
///                     <td width="40%"><a id="SEC_IMAGE_NO_EXECUTE"></a><a id="sec_image_no_execute"></a><dl>
///                     <dt><b>SEC_IMAGE_NO_EXECUTE</b></dt> <dt>0x11000000</dt> </dl> </td> <td width="60%"> Specifies that the file
///                     that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded
///                     image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object
///                     created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the
///                     PsSetLoadImageNotifyRoutine kernel API. The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
///                     <b>PAGE_READONLY</b> page protection value. No other attributes are valid with <b>SEC_IMAGE_NO_EXECUTE</b>. </td>
///                     </tr> <tr> <td width="40%"><a id="SEC_LARGE_PAGES"></a><a id="sec_large_pages"></a><dl>
///                     <dt><b>SEC_LARGE_PAGES</b></dt> <dt>0x80000000</dt> </dl> </td> <td width="60%"> Enables large pages to be used
///                     for file mapping objects that are backed by the operating system paging file (the <i>hfile</i> parameter is
///                     <b>INVALID_HANDLE_VALUE</b>). This attribute is not supported for file mapping objects that are backed by
///                     executable image files or data files (the <i>hFile</i> parameter is a handle to an executable image or data
///                     file). The maximum size of the file mapping object must be a multiple of the minimum size of a large page
///                     returned by the GetLargePageMinimum function. If it is not, <b>CreateFileMappingFromApp</b> fails. When mapping a
///                     view of a file mapping object created with <b>SEC_LARGE_PAGES</b>, the base address and view size must also be
///                     multiples of the minimum large page size. <b>SEC_LARGE_PAGES</b> requires the SeLockMemoryPrivilege privilege to
///                     be enabled in the caller's token. If <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be
///                     specified. </td> </tr> <tr> <td width="40%"><a id="SEC_NOCACHE"></a><a id="sec_nocache"></a><dl>
///                     <dt><b>SEC_NOCACHE</b></dt> <dt>0x10000000</dt> </dl> </td> <td width="60%"> Sets all pages to be non-cachable.
///                     Applications should not use this attribute except when explicitly required for a device. Using the interlocked
///                     functions with memory that is mapped with <b>SEC_NOCACHE</b> can result in an
///                     <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception. <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or
///                     <b>SEC_COMMIT</b> attribute to be set. </td> </tr> <tr> <td width="40%"><a id="SEC_RESERVE"></a><a
///                     id="sec_reserve"></a><dl> <dt><b>SEC_RESERVE</b></dt> <dt>0x4000000</dt> </dl> </td> <td width="60%"> If the file
///                     mapping object is backed by the operating system paging file (the <i>hfile</i> parameter is
///                     <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file is mapped into a process address space, the
///                     entire range of pages is reserved for later use by the process rather than committed. Reserved pages can be
///                     committed in subsequent calls to the VirtualAlloc function. After the pages are committed, they cannot be freed
///                     or decommitted with the VirtualFree function. This attribute has no effect for file mapping objects that are
///                     backed by executable image files or data files (the <i>hfile</i> parameter is a handle to a file).
///                     <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>. </td> </tr> <tr> <td width="40%"><a
///                     id="SEC_WRITECOMBINE"></a><a id="sec_writecombine"></a><dl> <dt><b>SEC_WRITECOMBINE</b></dt> <dt>0x40000000</dt>
///                     </dl> </td> <td width="60%"> Sets all pages to be write-combined. Applications should not use this attribute
///                     except when explicitly required for a device. Using the interlocked functions with memory that is mapped with
///                     <b>SEC_WRITECOMBINE</b> can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception. <b>SEC_WRITECOMBINE</b>
///                     requires either the <b>SEC_RESERVE</b> or <b>SEC_COMMIT</b> attribute to be set. </td> </tr> </table>
///    MaximumSize = The maximum size of the file mapping object. An attempt to map a file with a length of 0 (zero) fails with an
///                  error code of <b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject
///                  those files.
///    Name = The name of the file mapping object. If this parameter matches the name of an existing mapping object, the
///           function requests access to the object with the protection that <i>flProtect</i> specifies. If this parameter is
///           <b>NULL</b>, the file mapping object is created without a name. If <i>lpName</i> matches the name of an existing
///           event, semaphore, mutex, waitable timer, or job object, the function fails, and the GetLastError function returns
///           <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a
///           "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of
///           the name can contain any character except the backslash character (\\). Creating a file mapping object in the
///           global namespace from a session other than session zero requires the SeCreateGlobalPrivilege privilege. For more
///           information, see Kernel Object Namespaces. Fast user switching is implemented by using Terminal Services
///           sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so
///           on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications
///           can support multiple users.
///Returns:
///    If the function succeeds, the return value is a handle to the newly created file mapping object. If the object
///    exists before the function call, the function returns a handle to the existing object (with its current size, not
///    the specified size), and GetLastError returns <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateFileMappingFromApp(HANDLE hFile, SECURITY_ATTRIBUTES* SecurityAttributes, uint PageProtection, 
                                ulong MaximumSize, const(PWSTR) Name);

///Maps a view of a file mapping into the address space of a calling Windows Store app.
///Params:
///    hFileMappingObject = A handle to a file mapping object. The CreateFileMappingFromApp function returns this handle.
///    DesiredAccess = The type of access to a file mapping object, which determines the page protection of the pages. This parameter
///                    can be one of the following values, or a bitwise OR combination of multiple values where appropriate. <table>
///                    <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_MAP_ALL_ACCESS"></a><a
///                    id="file_map_all_access"></a><dl> <dt><b>FILE_MAP_ALL_ACCESS</b></dt> </dl> </td> <td width="60%"> A read/write
///                    view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> protection.
///                    When used with <b>MapViewOfFileFromApp</b>, <b>FILE_MAP_ALL_ACCESS</b> is equivalent to <b>FILE_MAP_WRITE</b>.
///                    </td> </tr> <tr> <td width="40%"><a id="FILE_MAP_READ"></a><a id="file_map_read"></a><dl>
///                    <dt><b>FILE_MAP_READ</b></dt> </dl> </td> <td width="60%"> A read-only view of the file is mapped. An attempt to
///                    write to the file view results in an access violation. The file mapping object must have been created with
///                    <b>PAGE_READONLY</b>, <b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or <b>PAGE_EXECUTE_READWRITE</b>
///                    protection. </td> </tr> <tr> <td width="40%"><a id="FILE_MAP_WRITE"></a><a id="file_map_write"></a><dl>
///                    <dt><b>FILE_MAP_WRITE</b></dt> </dl> </td> <td width="60%"> A read/write view of the file is mapped. The file
///                    mapping object must have been created with <b>PAGE_READWRITE</b> protection. When used with
///                    <b>MapViewOfFileFromApp</b>, <code>(FILE_MAP_WRITE | FILE_MAP_READ)</code> is equivalent to
///                    <b>FILE_MAP_WRITE</b>. </td> </tr> </table> Using bitwise OR, you can combine the values above with these values.
///                    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_MAP_COPY"></a><a
///                    id="file_map_copy"></a><dl> <dt><b>FILE_MAP_COPY</b></dt> </dl> </td> <td width="60%"> A copy-on-write view of
///                    the file is mapped. The file mapping object must have been created with <b>PAGE_READONLY</b>,
///                    <b>PAGE_READ_EXECUTE</b>, <b>PAGE_WRITECOPY</b>, or <b>PAGE_READWRITE</b> protection. When a process writes to a
///                    copy-on-write page, the system copies the original page to a new page that is private to the process. The new
///                    page is backed by the paging file. The protection of the new page changes from copy-on-write to read/write. When
///                    copy-on-write access is specified, the system and process commit charge taken is for the entire view because the
///                    calling process can potentially write to every page in the view, making all pages private. The contents of the
///                    new page are never written back to the original file and are lost when the view is unmapped. </td> </tr> <tr> <td
///                    width="40%"><a id="FILE_MAP_LARGE_PAGES"></a><a id="file_map_large_pages"></a><dl>
///                    <dt><b>FILE_MAP_LARGE_PAGES</b></dt> </dl> </td> <td width="60%"> Starting with Windows 10, version 1703, this
///                    flag specifies that the view should be mapped using large page support. The size of the view must be a multiple
///                    of the size of a large page reported by the GetLargePageMinimum function, and the file-mapping object must have
///                    been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for <i>lpBaseAddress</i>,
///                    then the value must be a multiple of <b>GetLargePageMinimum</b>. </td> </tr> <tr> <td width="40%"><a
///                    id="FILE_MAP_TARGETS_INVALID"></a><a id="file_map_targets_invalid"></a><dl>
///                    <dt><b>FILE_MAP_TARGETS_INVALID</b></dt> </dl> </td> <td width="60%"> Sets all the locations in the mapped file
///                    as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this
///                    flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in
///                    those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages
///                    allocated is to be marked valid call targets for CFG. </td> </tr> </table> For file-mapping objects created with
///                    the <b>SEC_IMAGE</b> attribute, the <i>dwDesiredAccess</i> parameter has no effect, and should be set to any
///                    valid value such as <b>FILE_MAP_READ</b>. For more information about access to file mapping objects, see File
///                    Mapping Security and Access Rights.
///    FileOffset = The file offset where the view is to begin. The offset must specify an offset within the file mapping. They must
///                 also match the memory allocation granularity of the system. That is, the offset must be a multiple of the
///                 allocation granularity. To obtain the memory allocation granularity of the system, use the GetSystemInfo
///                 function, which fills in the members of a SYSTEM_INFO structure.
///    NumberOfBytesToMap = The number of bytes of a file mapping to map to the view. All bytes must be within the maximum size specified by
///                         CreateFileMappingFromApp. If this parameter is 0 (zero), the mapping extends from the specified offset to the end
///                         of the file mapping.
///Returns:
///    If the function succeeds, the return value is the starting address of the mapped view. If the function fails, the
///    return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* MapViewOfFileFromApp(HANDLE hFileMappingObject, uint DesiredAccess, ulong FileOffset, 
                           size_t NumberOfBytesToMap);

///This is an extended version of UnmapViewOfFile that takes an additional flags parameter.
///Params:
///    BaseAddress = A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be identical
///                  to the value returned by a previous call to the MapViewOfFile or MapViewOfFileEx function.
///    UnmapFlags = This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                 width="40%"><a id="MEM_UNMAP_WITH_TRANSIENT_BOOST"></a><a id="mem_unmap_with_transient_boost"></a><dl>
///                 <dt><b>MEM_UNMAP_WITH_TRANSIENT_BOOST</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Specifies that
///                 the priority of the pages being unmapped should be temporarily boosted (with automatic short term decay) because
///                 the caller expects that these pages will be accessed again shortly from another thread. For more information
///                 about memory priorities, see the SetThreadInformation(ThreadMemoryPriority) function. </td> </tr> <tr> <td
///                 width="40%"><a id="MEM_PRESERVE_PLACEHOLDER"></a><a id="mem_preserve_placeholder"></a><dl>
///                 <dt><b>MEM_PRESERVE_PLACEHOLDER</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Unmaps a mapped view
///                 back to a placeholder (after you've replaced a placeholder with a mapped view using MapViewOfFile2 or
///                 <b>MapViewOfFile2FromApp</b>). </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL UnmapViewOfFileEx(void* BaseAddress, uint UnmapFlags);

///Allocates physical memory pages to be mapped and unmapped within any Address Windowing Extensions (AWE) region of a
///specified process. <b>64-bit Windows on Itanium-based systems: </b>Due to the difference in page sizes,
///<b>AllocateUserPhysicalPages</b> is not supported for 32-bit applications.
///Params:
///    hProcess = A handle to a process. The function allocates memory that can later be mapped within the virtual address space of
///               this process. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see
///               Process Security and Access Rights.
///    NumberOfPages = The size of the physical memory to allocate, in pages. To determine the page size of the computer, use the
///                    GetSystemInfo function. On output, this parameter receives the number of pages that are actually allocated, which
///                    might be less than the number requested.
///    PageArray = A pointer to an array to store the page frame numbers of the allocated memory. The size of the array that is
///                allocated should be at least the <i>NumberOfPages</i> times the size of the <b>ULONG_PTR</b> data type. Do not
///                attempt to modify this buffer. It contains operating system data, and corruption could be catastrophic. The
///                information in the buffer is not useful to an application.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>. Fewer pages than requested can be allocated. The
///    caller must check the value of the <i>NumberOfPages</i> parameter on return to see how many pages are allocated.
///    All allocated page frame numbers are sequentially placed in the memory pointed to by the <i>UserPfnArray</i>
///    parameter. If the function fails, the return value is <b>FALSE</b>, and no frames are allocated. To get extended
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL AllocateUserPhysicalPages(HANDLE hProcess, uint* NumberOfPages, uint* PageArray);

///Frees physical memory pages that are allocated previously by using AllocateUserPhysicalPages or
///AllocateUserPhysicalPagesNuma. If any of these pages are currently mapped in the Address Windowing Extensions (AWE)
///region, they are automatically unmapped by this call. This does not affect the virtual address space that is occupied
///by a specified Address Windowing Extensions (AWE) region. <b>64-bit Windows on Itanium-based systems: </b>Due to the
///difference in page sizes, <b>FreeUserPhysicalPages</b> is not supported for 32-bit applications.
///Params:
///    hProcess = The handle to a process. The function frees memory within the virtual address space of this process.
///    NumberOfPages = The size of the physical memory to free, in pages. On return, if the function fails, this parameter indicates the
///                    number of pages that are freed.
///    PageArray = A pointer to an array of page frame numbers of the allocated memory to be freed.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is
///    <b>FALSE</b>. In this case, the <i>NumberOfPages</i> parameter reflect how many pages have actually been
///    released. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FreeUserPhysicalPages(HANDLE hProcess, uint* NumberOfPages, uint* PageArray);

///Maps previously allocated physical memory pages at a specified address in an Address Windowing Extensions (AWE)
///region. To perform batch mapping and unmapping of multiple regions, use the MapUserPhysicalPagesScatter function.
///<b>64-bit Windows on Itanium-based systems: </b>Due to the difference in page sizes, <b>MapUserPhysicalPages</b> is
///not supported for 32-bit applications.
///Params:
///    VirtualAddress = A pointer to the starting address of the region of memory to remap. The value of <i>lpAddress</i> must be within
///                     the address range that the VirtualAlloc function returns when the Address Windowing Extensions (AWE) region is
///                     allocated.
///    NumberOfPages = The size of the physical memory and virtual address space for which to establish translations, in pages. The
///                    virtual address range is contiguous starting at <i>lpAddress</i>. The physical frames are specified by the
///                    <i>UserPfnArray</i>. The total number of pages cannot extend from the starting address beyond the end of the
///                    range that is specified in AllocateUserPhysicalPages.
///    PageArray = A pointer to an array of physical page frame numbers. These frames are mapped by the argument <i>lpAddress</i> on
///                return from this function. The size of the memory that is allocated should be at least the <i>NumberOfPages</i>
///                times the size of the data type <b>ULONG_PTR</b>. Do not attempt to modify this buffer. It contains operating
///                system data, and corruption could be catastrophic. The information in the buffer is not useful to an application.
///                If this parameter is <b>NULL</b>, the specified address range is unmapped. Also, the specified physical pages are
///                not freed, and you must call FreeUserPhysicalPages to free them.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is
///    <b>FALSE</b> and no mapping is done—partial or otherwise. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL MapUserPhysicalPages(void* VirtualAddress, size_t NumberOfPages, uint* PageArray);

///Allocates physical memory pages to be mapped and unmapped within any Address Windowing Extensions (AWE) region of a
///specified process and specifies the NUMA node for the physical memory.
///Params:
///    hProcess = A handle to a process. The function allocates memory that can later be mapped within the virtual address space of
///               this process. The handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see
///               Process Security and Access Rights.
///    NumberOfPages = The size of the physical memory to allocate, in pages. To determine the page size of the computer, use the
///                    GetSystemInfo function. On output, this parameter receives the number of pages that are actually allocated, which
///                    might be less than the number requested.
///    PageArray = A pointer to an array to store the page frame numbers of the allocated memory. The size of the array that is
///                allocated should be at least the <i>NumberOfPages</i> times the size of the <b>ULONG_PTR</b> data type. <div
///                class="alert"><b>Caution</b> Do not attempt to modify this buffer. It contains operating system data, and
///                corruption could be catastrophic. The information in the buffer is not useful to an application.</div> <div>
///                </div>
///    nndPreferred = The NUMA node where the physical memory should reside.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>. Fewer pages than requested can be allocated. The
///    caller must check the value of the <i>NumberOfPages</i> parameter on return to see how many pages are allocated.
///    All allocated page frame numbers are sequentially placed in the memory pointed to by the <i>PageArray</i>
///    parameter. If the function fails, the return value is <b>FALSE</b> and no frames are allocated. To get extended
///    error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, uint* NumberOfPages, uint* PageArray, uint nndPreferred);

///Reserves, commits, or changes the state of a region of memory within the virtual address space of the specified
///process, and specifies the NUMA node for the physical memory.
///Params:
///    hProcess = The handle to a process. The function allocates memory within the virtual address space of this process. The
///               handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see Process Security and
///               Access Rights.
///    lpAddress = The pointer that specifies a desired starting address for the region of pages that you want to allocate. If you
///                are reserving memory, the function rounds this address down to the nearest multiple of the allocation
///                granularity. If you are committing memory that is already reserved, the function rounds this address down to the
///                nearest page boundary. To determine the size of a page and the allocation granularity on the host computer, use
///                the GetSystemInfo function. If <i>lpAddress</i> is <b>NULL</b>, the function determines where to allocate the
///                region.
///    dwSize = The size of the region of memory to be allocated, in bytes. If <i>lpAddress</i> is <b>NULL</b>, the function
///             rounds <i>dwSize</i> up to the next page boundary. If <i>lpAddress</i> is not <b>NULL</b>, the function allocates
///             all pages that contain one or more bytes in the range from <i>lpAddress</i> to <code>(lpAddress+dwSize)</code>.
///             This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both
///             pages.
///    flAllocationType = The type of memory allocation. This parameter must contain one of the following values. <table> <tr>
///                       <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_COMMIT"></a><a id="mem_commit"></a><dl>
///                       <dt><b>MEM_COMMIT</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> Allocates memory charges (from the
///                       overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also
///                       guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical
///                       pages are not allocated unless/until the virtual addresses are actually accessed. To reserve and commit pages in
///                       one step, call the function with <code>MEM_COMMIT | MEM_RESERVE</code>. Attempting to commit a specific address
///                       range by specifying <b>MEM_COMMIT</b> without <b>MEM_RESERVE</b> and a non-<b>NULL</b> <i>lpAddress</i> fails
///                       unless the entire range has already been reserved. The resulting error code is <b>ERROR_INVALID_ADDRESS</b>. An
///                       attempt to commit a page that is already committed does not cause the function to fail. This means that you can
///                       commit pages without first determining the current commitment state of each page. </td> </tr> <tr> <td
///                       width="40%"><a id="MEM_RESERVE"></a><a id="mem_reserve"></a><dl> <dt><b>MEM_RESERVE</b></dt> <dt>0x00002000</dt>
///                       </dl> </td> <td width="60%"> Reserves a range of the process's virtual address space without allocating any
///                       actual physical storage in memory or in the paging file on disk. You commit reserved pages by calling the
///                       function again with <b>MEM_COMMIT</b>. To reserve and commit pages in one step, call the function with
///                       <code>MEM_COMMIT | MEM_RESERVE</code>. Other memory allocation functions, such as <b>malloc</b> and LocalAlloc,
///                       cannot use reserved memory until it has been released. </td> </tr> <tr> <td width="40%"><a id="MEM_RESET"></a><a
///                       id="mem_reset"></a><dl> <dt><b>MEM_RESET</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> Indicates that
///                       data in the memory range specified by <i>lpAddress</i> and <i>dwSize</i> is no longer of interest. The pages
///                       should not be read from or written to the paging file. However, the memory block will be used again later, so it
///                       should not be decommitted. This value cannot be used with any other value. Using this value does not guarantee
///                       that the range operated on with <b>MEM_RESET</b> will contain zeros. If you want the range to contain zeros,
///                       decommit the memory and then recommit it. When you use <b>MEM_RESET</b>, the function ignores the value of
///                       <i>fProtect</i>. However, you must still set <i>fProtect</i> to a valid protection value, such as
///                       <b>PAGE_NOACCESS</b>. The function returns an error if you use <b>MEM_RESET</b> and the range of memory is mapped
///                       to a file. A shared view is only acceptable if it is mapped to a paging file. </td> </tr> <tr> <td width="40%"><a
///                       id="MEM_RESET_UNDO"></a><a id="mem_reset_undo"></a><dl> <dt><b>MEM_RESET_UNDO</b></dt> <dt>0x1000000</dt> </dl>
///                       </td> <td width="60%"> <b>MEM_RESET_UNDO</b> should only be called on an address range to which <b>MEM_RESET</b>
///                       was successfully applied earlier. It indicates that the data in the specified memory range specified by
///                       <i>lpAddress</i> and <i>dwSize</i> is of interest to the caller and attempts to reverse the effects of
///                       <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is intact. If the
///                       function fails, at least some of the data in the address range has been replaced with zeroes. This value cannot
///                       be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not
///                       <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the
///                       <b>VirtualAllocExNuma</b> function ignores the value of <i>flProtect</i>. However, you must still set
///                       <i>flProtect</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>. <b>Windows Server 2008 R2, Windows 7,
///                       Windows Server 2008 and Windows Vista: </b>The <b>MEM_RESET_UNDO</b> flag is not supported until Windows 8 and
///                       Windows Server 2012. </td> </tr> </table> This parameter can also specify the following values as indicated.
///                       <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_LARGE_PAGES"></a><a
///                       id="mem_large_pages"></a><dl> <dt><b>MEM_LARGE_PAGES</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%">
///                       Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum.
///                       To obtain this value, use the GetLargePageMinimum function. If you specify this value, you must also specify
///                       <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>. </td> </tr> <tr> <td width="40%"><a id="MEM_PHYSICAL"></a><a
///                       id="mem_physical"></a><dl> <dt><b>MEM_PHYSICAL</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> Reserves
///                       an address range that can be used to map Address Windowing Extensions (AWE) pages. This value must be used with
///                       <b>MEM_RESERVE</b> and no other values. </td> </tr> <tr> <td width="40%"><a id="MEM_TOP_DOWN"></a><a
///                       id="mem_top_down"></a><dl> <dt><b>MEM_TOP_DOWN</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%">
///                       Allocates memory at the highest possible address. </td> </tr> </table>
///    flProtect = The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify
///                any one of the memory protection constants. Protection attributes specified when protecting a page cannot
///                conflict with those specified when allocating a page.
///    nndPreferred = The NUMA node where the physical memory should reside. Used only when allocating a new VA region (either
///                   committed or reserved). Otherwise this parameter is ignored when the API is used to commit pages in a region that
///                   already exists
///Returns:
///    If the function succeeds, the return value is the base address of the allocated region of pages. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* VirtualAllocExNuma(HANDLE hProcess, void* lpAddress, size_t dwSize, uint flAllocationType, uint flProtect, 
                         uint nndPreferred);

///Gets the memory error handling capabilities of the system.
///Params:
///    Capabilities = A <b>PULONG</b> that receives one or more of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th>
///                   </tr> <tr> <td width="40%"><a id="MEHC_PATROL_SCRUBBER_PRESENT"></a><a id="mehc_patrol_scrubber_present"></a><dl>
///                   <dt><b>MEHC_PATROL_SCRUBBER_PRESENT</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The hardware can detect and
///                   report failed memory. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetMemoryErrorHandlingCapabilities(uint* Capabilities);

///Registers a bad memory notification that is called when one or more bad memory pages are detected and the system
///cannot remove at least one of them (for example if the pages contains modified data that has not yet been written to
///the pagefile.)
///Params:
///    Callback = A pointer to the application-defined BadMemoryCallbackRoutine function to register.
///Returns:
///    Registration handle that represents the callback notification. Can be passed to the
///    UnregisterBadMemoryNotification function when no longer needed.
///    
@DllImport("KERNEL32")
void* RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback);

///Closes the specified bad memory notification handle.
///Params:
///    RegistrationHandle = Registration handle returned from the RegisterBadMemoryNotification function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL UnregisterBadMemoryNotification(void* RegistrationHandle);

///Indicates that the data contained in a range of memory pages is no longer needed by the application and can be
///discarded by the system if necessary. The specified pages will be marked as inaccessible, removed from the process
///working set, and will not be written to the paging file. To later reclaim offered pages, call ReclaimVirtualMemory.
///Params:
///    VirtualAddress = Page-aligned starting address of the memory to offer.
///    Size = Size, in bytes, of the memory region to offer. <i>Size</i> must be an integer multiple of the system page size.
///    Priority = <i>Priority</i> indicates how important the offered memory is to the application. A higher priority increases the
///               probability that the offered memory can be reclaimed intact when calling ReclaimVirtualMemory. The system
///               typically discards lower priority memory before discarding higher priority memory. <i>Priority</i> must be one of
///               the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="VMOfferPriorityVeryLow"></a><a id="vmofferpriorityverylow"></a><a id="VMOFFERPRIORITYVERYLOW"></a><dl>
///               <dt><b>VMOfferPriorityVeryLow</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> The offered memory is
///               very low priority, and should be the first discarded. </td> </tr> <tr> <td width="40%"><a
///               id="VMOfferPriorityLow"></a><a id="vmofferprioritylow"></a><a id="VMOFFERPRIORITYLOW"></a><dl>
///               <dt><b>VMOfferPriorityLow</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> The offered memory is low
///               priority. </td> </tr> <tr> <td width="40%"><a id="VMOfferPriorityBelowNormal"></a><a
///               id="vmofferprioritybelownormal"></a><a id="VMOFFERPRIORITYBELOWNORMAL"></a><dl>
///               <dt><b>VMOfferPriorityBelowNormal</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> The offered memory is
///               below normal priority. </td> </tr> <tr> <td width="40%"><a id="VMOfferPriorityNormal"></a><a
///               id="vmofferprioritynormal"></a><a id="VMOFFERPRIORITYNORMAL"></a><dl> <dt><b>VMOfferPriorityNormal</b></dt>
///               <dt>0x00002000</dt> </dl> </td> <td width="60%"> The offered memory is of normal priority to the application, and
///               should be the last discarded. </td> </tr> </table>
///Returns:
///    ERROR_SUCCESS if successful; a System Error Code otherwise.
///    
@DllImport("KERNEL32")
uint OfferVirtualMemory(void* VirtualAddress, size_t Size, OFFER_PRIORITY Priority);

///Reclaims a range of memory pages that were offered to the system with OfferVirtualMemory. If the offered memory has
///been discarded, the contents of the memory region is undefined and must be rewritten by the application. If the
///offered memory has not been discarded, it is reclaimed intact.
///Params:
///    VirtualAddress = Page-aligned starting address of the memory to reclaim.
///    Size = Size, in bytes, of the memory region to reclaim. <i>Size</i> must be an integer multiple of the system page size.
///Returns:
///    Returns ERROR_SUCCESS if successful and the memory was reclaimed intact. Returns ERROR_BUSY if successful but the
///    memory was discarded and must be rewritten by the application. In this case, the contents of the memory region is
///    undefined. Returns a System Error Code otherwise.
///    
@DllImport("KERNEL32")
uint ReclaimVirtualMemory(const(void)* VirtualAddress, size_t Size);

///Discards the memory contents of a range of memory pages, without decommitting the memory. The contents of discarded
///memory is undefined and must be rewritten by the application.
///Params:
///    VirtualAddress = Page-aligned starting address of the memory to discard.
///    Size = Size, in bytes, of the memory region to discard. <i>Size</i> must be an integer multiple of the system page size.
///Returns:
///    ERROR_SUCCESS if successful; a System Error Code otherwise.
///    
@DllImport("KERNEL32")
uint DiscardVirtualMemory(void* VirtualAddress, size_t Size);

///Provides Control Flow Guard (CFG) with a list of valid indirect call targets and specifies whether they should be
///marked valid or not. The valid call target information is provided as a list of offsets relative to a virtual memory
///range (start and size of the range). The call targets specified should be 16-byte aligned and in ascending order.
///Params:
///    hProcess = The handle to the target process.
///    VirtualAddress = The start of the virtual memory region whose call targets are being marked valid. The memory region must be
///                     allocated using one of the executable [memory protection
///                     constants](/windows/desktop/Memory/memory-protection-constants).
///    RegionSize = The size of the virtual memory region.
///    NumberOfOffsets = The number of offsets relative to the virtual memory ranges.
///    OffsetInformation = A list of offsets and flags relative to the virtual memory ranges.
///Returns:
///    <b>TRUE</b> if the operation was successful; otherwise, <b>FALSE</b>. To retrieve error values for this function,
///    call [GetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).
///    
@DllImport("api-ms-win-core-memory-l1-1-3")
BOOL SetProcessValidCallTargets(HANDLE hProcess, void* VirtualAddress, size_t RegionSize, uint NumberOfOffsets, 
                                CFG_CALL_TARGET_INFO* OffsetInformation);

@DllImport("api-ms-win-core-memory-l1-1-7")
BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, void* VirtualAddress, size_t RegionSize, 
                                             uint NumberOfOffsets, CFG_CALL_TARGET_INFO* OffsetInformation, 
                                             HANDLE Section, ulong ExpectedFileOffset);

///Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process.
///Memory allocated by this function is automatically initialized to zero.
///Params:
///    BaseAddress = The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded
///                  down to the nearest multiple of the allocation granularity. If the memory is already reserved and is being
///                  committed, the address is rounded down to the next page boundary. To determine the size of a page and the
///                  allocation granularity on the host computer, use the GetSystemInfo function. If this parameter is <b>NULL</b>,
///                  the system determines where to allocate the region.
///    Size = The size of the region, in bytes. If the <i>BaseAddress</i> parameter is <b>NULL</b>, this value is rounded up to
///           the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the
///           range from <i>BaseAddress</i> to <i>BaseAddress</i>+<i>Size</i>. This means that a 2-byte range straddling a page
///           boundary causes both pages to be included in the allocated region.
///    AllocationType = The type of memory allocation. This parameter must contain one of the following values. <table> <tr>
///                     <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_COMMIT"></a><a id="mem_commit"></a><dl>
///                     <dt><b>MEM_COMMIT</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> Allocates memory charges (from the
///                     overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also
///                     guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical
///                     pages are not allocated unless/until the virtual addresses are actually accessed. To reserve and commit pages in
///                     one step, call <b>VirtualAllocFromApp</b> with <code>MEM_COMMIT | MEM_RESERVE</code>. Attempting to commit a
///                     specific address range by specifying <b>MEM_COMMIT</b> without <b>MEM_RESERVE</b> and a non-<b>NULL</b>
///                     <i>BaseAddress</i> fails unless the entire range has already been reserved. The resulting error code is
///                     <b>ERROR_INVALID_ADDRESS</b>. An attempt to commit a page that is already committed does not cause the function
///                     to fail. This means that you can commit pages without first determining the current commitment state of each
///                     page. </td> </tr> <tr> <td width="40%"><a id="MEM_RESERVE"></a><a id="mem_reserve"></a><dl>
///                     <dt><b>MEM_RESERVE</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Reserves a range of the process's
///                     virtual address space without allocating any actual physical storage in memory or in the paging file on disk. You
///                     can commit reserved pages in subsequent calls to the <b>VirtualAllocFromApp</b> function. To reserve and commit
///                     pages in one step, call <b>VirtualAllocFromApp</b> with <b>MEM_COMMIT</b> | <b>MEM_RESERVE</b>. Other memory
///                     allocation functions, such as <b>malloc</b> and LocalAlloc, cannot use a reserved range of memory until it is
///                     released. </td> </tr> <tr> <td width="40%"><a id="MEM_RESET"></a><a id="mem_reset"></a><dl>
///                     <dt><b>MEM_RESET</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> Indicates that data in the memory
///                     range specified by <i>BaseAddress</i> and <i>Size</i> is no longer of interest. The pages should not be read from
///                     or written to the paging file. However, the memory block will be used again later, so it should not be
///                     decommitted. This value cannot be used with any other value. Using this value does not guarantee that the range
///                     operated on with <b>MEM_RESET</b> will contain zeros. If you want the range to contain zeros, decommit the memory
///                     and then recommit it. When you specify <b>MEM_RESET</b>, the <b>VirtualAllocFromApp</b> function ignores the
///                     value of <i>Protection</i>. However, you must still set <i>Protection</i> to a valid protection value, such as
///                     <b>PAGE_NOACCESS</b>. <b>VirtualAllocFromApp</b> returns an error if you use <b>MEM_RESET</b> and the range of
///                     memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file. </td> </tr> <tr>
///                     <td width="40%"><a id="MEM_RESET_UNDO"></a><a id="mem_reset_undo"></a><dl> <dt><b>MEM_RESET_UNDO</b></dt>
///                     <dt>0x1000000</dt> </dl> </td> <td width="60%"> <b>MEM_RESET_UNDO</b> should only be called on an address range
///                     to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory
///                     range specified by <i>BaseAddress</i> and <i>Size</i> is of interest to the caller and attempts to reverse the
///                     effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is
///                     intact. If the function fails, at least some of the data in the address range has been replaced with zeroes. This
///                     value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not
///                     <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the
///                     <b>VirtualAllocFromApp</b> function ignores the value of <i>Protection</i>. However, you must still set
///                     <i>Protection</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>. </td> </tr> </table> This parameter
///                     can also specify the following values as indicated. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                     width="40%"><a id="MEM_LARGE_PAGES"></a><a id="mem_large_pages"></a><dl> <dt><b>MEM_LARGE_PAGES</b></dt>
///                     <dt>0x20000000</dt> </dl> </td> <td width="60%"> Allocates memory using large page support. The size and
///                     alignment must be a multiple of the large-page minimum. To obtain this value, use the GetLargePageMinimum
///                     function. If you specify this value, you must also specify <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>. </td> </tr>
///                     <tr> <td width="40%"><a id="MEM_PHYSICAL"></a><a id="mem_physical"></a><dl> <dt><b>MEM_PHYSICAL</b></dt>
///                     <dt>0x00400000</dt> </dl> </td> <td width="60%"> Reserves an address range that can be used to map Address
///                     Windowing Extensions (AWE) pages. This value must be used with <b>MEM_RESERVE</b> and no other values. </td>
///                     </tr> <tr> <td width="40%"><a id="MEM_TOP_DOWN"></a><a id="mem_top_down"></a><dl> <dt><b>MEM_TOP_DOWN</b></dt>
///                     <dt>0x00100000</dt> </dl> </td> <td width="60%"> Allocates memory at the highest possible address. This can be
///                     slower than regular allocations, especially when there are many allocations. </td> </tr> <tr> <td width="40%"><a
///                     id="MEM_WRITE_WATCH"></a><a id="mem_write_watch"></a><dl> <dt><b>MEM_WRITE_WATCH</b></dt> <dt>0x00200000</dt>
///                     </dl> </td> <td width="60%"> Causes the system to track pages that are written to in the allocated region. If you
///                     specify this value, you must also specify <b>MEM_RESERVE</b>. To retrieve the addresses of the pages that have
///                     been written to since the region was allocated or the write-tracking state was reset, call the GetWriteWatch
///                     function. To reset the write-tracking state, call <b>GetWriteWatch</b> or ResetWriteWatch. The write-tracking
///                     feature remains enabled for the memory region until the region is freed. </td> </tr> </table>
///    Protection = The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify
///                 one of the memory protection constants. The following constants generate an error: <ul>
///                 <li><b>PAGE_EXECUTE</b></li> <li><b>PAGE_EXECUTE_READ</b></li> <li><b>PAGE_EXECUTE_READWRITE</b></li>
///                 <li><b>PAGE_EXECUTE_WRITECOPY</b></li> </ul>
///Returns:
///    If the function succeeds, the return value is the base address of the allocated region of pages. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-3")
void* VirtualAllocFromApp(void* BaseAddress, size_t Size, uint AllocationType, uint Protection);

///Changes the protection on a region of committed pages in the virtual address space of the calling process.
///Params:
///    Address = A pointer an address that describes the starting page of the region of pages whose access protection attributes
///              are to be changed. All pages in the specified region must be within the same reserved region allocated when
///              calling the VirtualAlloc, VirtualAllocFromApp, or VirtualAllocEx function using <b>MEM_RESERVE</b>. The pages
///              cannot span adjacent reserved regions that were allocated by separate calls to <b>VirtualAlloc</b>,
///              <b>VirtualAllocFromApp</b>, or <b>VirtualAllocEx</b> using <b>MEM_RESERVE</b>.
///    Size = The size of the region whose access protection attributes are to be changed, in bytes. The region of affected
///           pages includes all pages containing one or more bytes in the range from the <i>Address</i> parameter to
///           <code>(Address+Size)</code>. This means that a 2-byte range straddling a page boundary causes the protection
///           attributes of both pages to be changed.
///    NewProtection = The memory protection option. This parameter can be one of the memory protection constants. For mapped views,
///                    this value must be compatible with the access protection specified when the view was mapped (see MapViewOfFile,
///                    MapViewOfFileEx, and MapViewOfFileExNuma). The following constants generate an error: <ul>
///                    <li><b>PAGE_EXECUTE_READWRITE</b></li> <li><b>PAGE_EXECUTE_WRITECOPY</b></li> </ul> The following constants are
///                    allowed only for apps that have the <b>codeGeneration</b> capability: <ul> <li><b>PAGE_EXECUTE</b></li>
///                    <li><b>PAGE_EXECUTE_READ</b></li> </ul>
///    OldProtection = A pointer to a variable that receives the previous access protection value of the first page in the specified
///                    region of pages. If this parameter is <b>NULL</b> or does not point to a valid variable, the function fails.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-3")
BOOL VirtualProtectFromApp(void* Address, size_t Size, uint NewProtection, uint* OldProtection);

///Opens a named file mapping object.
///Params:
///    DesiredAccess = The access to the file mapping object. This access is checked against any security descriptor on the target file
///                    mapping object. For a list of values, see File Mapping Security and Access Rights. You can only open the file
///                    mapping object for <b>FILE_MAP_EXECUTE</b> access if your app has the <b>codeGeneration</b> capability.
///    InheritHandle = If this parameter is <b>TRUE</b>, a process created by the CreateProcess function can inherit the handle;
///                    otherwise, the handle cannot be inherited.
///    Name = The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this
///           name and the security descriptor on the mapping object does not conflict with the <i>DesiredAccess</i> parameter,
///           the open operation succeeds. The name can have a "Global\" or "Local\" prefix to explicitly open an object in the
///           global or session namespace. The remainder of the name can contain any character except the backslash character
///           (\\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal
///           Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and so on.
///           Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support
///           multiple users.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified file mapping object. If the
///    function fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-3")
HANDLE OpenFileMappingFromApp(uint DesiredAccess, BOOL InheritHandle, const(PWSTR) Name);

///The <b>QueryVirtualMemoryInformation</b> function returns information about a page or a set of pages within the
///virtual address space of the specified process.
///Params:
///    Process = A handle for the process in whose context the pages to be queried reside.
///    VirtualAddress = The address of the region of pages to be queried. This value is rounded down to the next host-page-address
///                     boundary.
///    MemoryInformationClass = The memory information class about which to retrieve information. The only supported value is
///                             <b>MemoryRegionInfo</b>.
///    MemoryInformation = A pointer to a buffer that receives the specified information. If the <i>MemoryInformationClass</i> parameter has
///                        a value of <b>MemoryRegionInfo</b>, this parameter must point to a WIN32_MEMORY_REGION_INFORMATION structure.
///    MemoryInformationSize = Specifies the length in bytes of the memory information buffer.
///    ReturnSize = An optional pointer which, if specified, receives the number of bytes placed in the memory information buffer.
///Returns:
///    Returns <b>TRUE</b> on success. Returns <b>FALSE</b> for failure. To get extended error information, call
///    GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-4")
BOOL QueryVirtualMemoryInformation(HANDLE Process, const(void)* VirtualAddress, 
                                   WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, void* MemoryInformation, 
                                   size_t MemoryInformationSize, size_t* ReturnSize);

///Maps a view of a file or a pagefile-backed section into the address space of the specified process.
///Params:
///    FileMappingHandle = A <b>HANDLE</b> to a section that is to be mapped into the address space of the specified process.
///    ProcessHandle = A <b>HANDLE</b> to a process into which the section will be mapped.
///    Offset = The offset from the beginning of the section. This must be 64k aligned.
///    BaseAddress = The desired base address of the view. The address is rounded down to the nearest 64k boundary. If this parameter
///                  is <b>NULL</b>, the system picks the base address.
///    ViewSize = The number of bytes to map. A value of zero (0) specifies that the entire section is to be mapped.
///    AllocationType = The type of allocation. This parameter can be zero (0) or one of the following constant values: <ul>
///                     <li><b>MEM_RESERVE</b> - Maps a reserved view</li> <li><b>MEM_LARGE_PAGES</b> - Maps a large page view</li> </ul>
///    PageProtection = The desired page protection. For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
///                     <i>PageProtection</i> parameter has no effect, and should be set to any valid value such as <b>PAGE_READONLY</b>.
///    PreferredNode = The preferred NUMA node for this memory.
///Returns:
///    Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error
///    status is available using GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-5")
void* MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ulong Offset, void* BaseAddress, 
                         size_t ViewSize, uint AllocationType, uint PageProtection, uint PreferredNode);

///Unmaps a previously mapped view of a file or a pagefile-backed section.
///Params:
///    Process = A <b>HANDLE</b> to the process from which the section will be unmapped.
///    BaseAddress = The base address of a previously mapped view that is to be unmapped. This value must be identical to the value
///                  returned by a previous call to MapViewOfFile2.
///    UnmapFlags = This parameter can be zero (0) or one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                 <tr> <td width="40%"><a id="MEM_UNMAP_WITH_TRANSIENT_BOOST"></a><a id="mem_unmap_with_transient_boost"></a><dl>
///                 <dt><b>MEM_UNMAP_WITH_TRANSIENT_BOOST</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Specifies that
///                 the priority of the pages being unmapped should be temporarily boosted (with automatic short term decay) because
///                 the caller expects that these pages will be accessed again shortly from another thread. For more information
///                 about memory priorities, see the SetThreadInformation(ThreadMemoryPriority) function. </td> </tr> <tr> <td
///                 width="40%"><a id="MEM_PRESERVE_PLACEHOLDER"></a><a id="mem_preserve_placeholder"></a><dl>
///                 <dt><b>MEM_PRESERVE_PLACEHOLDER</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Unmaps a mapped view
///                 back to a placeholder (after you've replaced a placeholder with a mapped view using MapViewOfFile2 or
///                 <b>MapViewOfFile2FromApp</b>). </td> </tr> </table>
///Returns:
///    Returns <b>TRUE</b> if sucessful. Otherwise, returns <b>FALSE</b> and extended error status is available using
///    GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-5")
BOOL UnmapViewOfFile2(HANDLE Process, void* BaseAddress, uint UnmapFlags);

@DllImport("api-ms-win-core-memory-l1-1-5")
BOOL VirtualUnlockEx(HANDLE Process, void* Address, size_t Size);

///Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified
///process. The function initializes the memory it allocates to zero. Using this function, you can: for new allocations,
///specify a range of virtual address space and a power-of-2 alignment restriction; specify an arbitrary number of
///extended parameters; specify a preferred NUMA node for the physical memory as an extended parameter; and specify a
///placeholder operation (specifically, replacement). To specify the NUMA node, see the <i>ExtendedParameters</i>
///parameter.
///Params:
///    Process = The handle to a process. The function allocates memory within the virtual address space of this process. The
///              handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see Process Security and
///              Access Rights.
///    BaseAddress = The pointer that specifies a desired starting address for the region of pages that you want to allocate. If an
///                  explicit base address is specified, then it must be a multiple of the system allocation granularity. To determine
///                  the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function. If
///                  <i>BaseAddress</i> is <b>NULL</b>, the function determines where to allocate the region. If this address is
///                  within an enclave that you have not initialized by calling InitializeEnclave, <b>VirtualAlloc2</b> allocates a
///                  page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured
///                  with the EEXTEND instruction of the Intel Software Guard Extensions programming model. If the address in within
///                  an enclave that you initialized, then the allocation operation fails with the <b>ERROR_INVALID_ADDRESS</b> error.
///    Size = The size of the region of memory to allocate, in bytes. The size must always be a multiple of the page size. If
///           <i>BaseAddress</i> is not <b>NULL</b>, the function allocates all pages that contain one or more bytes in the
///           range from <i>BaseAddress</i> to <i>BaseAddress</i>+<i>Size</i>. This means, for example, that a 2-byte range
///           that straddles a page boundary causes the function to allocate both pages.
///    AllocationType = The type of memory allocation. This parameter must contain one of the following values. <table> <tr>
///                     <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_COMMIT"></a><a id="mem_commit"></a><dl>
///                     <dt><b>MEM_COMMIT</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> Allocates memory charges (from the
///                     overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also
///                     guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical
///                     pages are not allocated unless/until the virtual addresses are actually accessed. To reserve and commit pages in
///                     one step, call <b>VirtualAlloc2</b> with <code>MEM_COMMIT | MEM_RESERVE</code>. Attempting to commit a specific
///                     address range by specifying <b>MEM_COMMIT</b> without <b>MEM_RESERVE</b> and a non-<b>NULL</b> <i>BaseAddress</i>
///                     fails unless the entire range has already been reserved. The resulting error code is
///                     <b>ERROR_INVALID_ADDRESS</b>. An attempt to commit a page that is already committed does not cause the function
///                     to fail. This means that you can commit pages without first determining the current commitment state of each
///                     page. If <i>BaseAddress</i> specifies an address within an enclave, <i>AllocationType</i> must be
///                     <b>MEM_COMMIT</b>. </td> </tr> <tr> <td width="40%"><a id="MEM_RESERVE"></a><a id="mem_reserve"></a><dl>
///                     <dt><b>MEM_RESERVE</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Reserves a range of the process's
///                     virtual address space without allocating any actual physical storage in memory or in the paging file on disk. You
///                     commit reserved pages by calling <b>VirtualAlloc2</b> again with <b>MEM_COMMIT</b>. To reserve and commit pages
///                     in one step, call <b>VirtualAlloc2</b> with <code>MEM_COMMIT | MEM_RESERVE</code>. Other memory allocation
///                     functions, such as <b>malloc</b> and LocalAlloc, cannot use reserved memory until it has been released. </td>
///                     </tr> <tr> <td width="40%"><a id="MEM_REPLACE_PLACEHOLDER"></a><a id="mem_replace_placeholder"></a><dl>
///                     <dt><b>MEM_REPLACE_PLACEHOLDER</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> Replaces a placeholder
///                     with a normal private allocation. Only data/pf-backed section views are supported (no images, physical memory,
///                     etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>Size</i> must exactly match those of the
///                     placeholder. After you replace a placeholder with a private allocation, to free that allocation back to a
///                     placeholder, see the <i>dwFreeType</i> parameter of VirtualFree and VirtualFreeEx. A placeholder is a type of
///                     reserved memory region. </td> </tr> <tr> <td width="40%"><a id="MEM_RESERVE_PLACEHOLDER"></a><a
///                     id="mem_reserve_placeholder"></a><dl> <dt><b>MEM_RESERVE_PLACEHOLDER</b></dt> <dt>0x00040000</dt> </dl> </td> <td
///                     width="60%"> To create a placeholder, call <b>VirtualAlloc2</b> with <code>MEM_RESERVE |
///                     MEM_RESERVE_PLACEHOLDER</code> and <i>PageProtection</i> set to <b>PAGE_NOACCESS</b>. To free/split/coalesce a
///                     placeholder, see the <i>dwFreeType</i> parameter of VirtualFree and VirtualFreeEx. A placeholder is a type of
///                     reserved memory region. </td> </tr> <tr> <td width="40%"><a id="MEM_RESET"></a><a id="mem_reset"></a><dl>
///                     <dt><b>MEM_RESET</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> Indicates that data in the memory
///                     range specified by <i>BaseAddress</i> and <i>Size</i> is no longer of interest. The pages should not be read from
///                     or written to the paging file. However, the memory block will be used again later, so it should not be
///                     decommitted. This value cannot be used with any other value. Using this value does not guarantee that the range
///                     operated on with <b>MEM_RESET</b> will contain zeros. If you want the range to contain zeros, decommit the memory
///                     and then recommit it. When you use <b>MEM_RESET</b>, the <b>VirtualAlloc2</b> function ignores the value of
///                     <i>fProtect</i>. However, you must still set <i>fProtect</i> to a valid protection value, such as
///                     <b>PAGE_NOACCESS</b>. <b>VirtualAlloc2</b> returns an error if you use <b>MEM_RESET</b> and the range of memory
///                     is mapped to a file. A shared view is only acceptable if it is mapped to a paging file. </td> </tr> <tr> <td
///                     width="40%"><a id="MEM_RESET_UNDO"></a><a id="mem_reset_undo"></a><dl> <dt><b>MEM_RESET_UNDO</b></dt>
///                     <dt>0x1000000</dt> </dl> </td> <td width="60%"> <b>MEM_RESET_UNDO</b> should only be called on an address range
///                     to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the data in the specified memory
///                     range specified by <i>BaseAddress</i> and <i>Size</i> is of interest to the caller and attempts to reverse the
///                     effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the specified address range is
///                     intact. If the function fails, at least some of the data in the address range has been replaced with zeroes. This
///                     value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an address range which was not
///                     <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify <b>MEM_RESET</b>, the <b>VirtualAlloc2</b>
///                     function ignores the value of <i>PageProtection</i>. However, you must still set <i>PageProtection</i> to a valid
///                     protection value, such as <b>PAGE_NOACCESS</b>. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008,
///                     Windows Vista, Windows Server 2003 and Windows XP: </b>The <b>MEM_RESET_UNDO</b> flag is not supported until
///                     Windows 8 and Windows Server 2012. </td> </tr> </table> This parameter can also specify the following values as
///                     indicated. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_LARGE_PAGES"></a><a
///                     id="mem_large_pages"></a><dl> <dt><b>MEM_LARGE_PAGES</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%">
///                     Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum.
///                     To obtain this value, use the GetLargePageMinimum function. If you specify this value, you must also specify
///                     <b>MEM_RESERVE</b> and <b>MEM_COMMIT</b>. </td> </tr> <tr> <td width="40%"><a id="MEM_PHYSICAL"></a><a
///                     id="mem_physical"></a><dl> <dt><b>MEM_PHYSICAL</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> Reserves
///                     an address range that can be used to map Address Windowing Extensions (AWE) pages. This value must be used with
///                     <b>MEM_RESERVE</b> and no other values. </td> </tr> <tr> <td width="40%"><a id="MEM_TOP_DOWN"></a><a
///                     id="mem_top_down"></a><dl> <dt><b>MEM_TOP_DOWN</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%">
///                     Allocates memory at the highest possible address. This can be slower than regular allocations, especially when
///                     there are many allocations. </td> </tr> </table>
///    PageProtection = The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify
///                     any one of the memory protection constants. If <i>BaseAddress</i> specifies an address within an enclave,
///                     <i>PageProtection</i> cannot be any of the following values: <ul> <li>PAGE_NOACCESS</li> <li>PAGE_GUARD</li>
///                     <li>PAGE_NOCACHE</li> <li>PAGE_WRITECOMBINE</li> </ul>
///    ExtendedParameters = An optional pointer to one or more extended parameters of type MEM_EXTENDED_PARAMETER. Each of those extended
///                         parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or
///                         <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided,
///                         then the behavior is the same as for the VirtualAlloc/MapViewOfFile functions (that is, the preferred NUMA node
///                         for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).
///    ParameterCount = The number of extended parameters pointed to by <i>ExtendedParameters</i>.
///Returns:
///    If the function succeeds, the return value is the base address of the allocated region of pages. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-6")
void* VirtualAlloc2(HANDLE Process, void* BaseAddress, size_t Size, uint AllocationType, uint PageProtection, 
                    MEM_EXTENDED_PARAMETER* ExtendedParameters, uint ParameterCount);

///Maps a view of a file or a pagefile-backed section into the address space of the specified process. Using this
///function, you can: for new allocations, specify a range of virtual address space and a power-of-2 alignment
///restriction; specify an arbitrary number of extended parameters; specify a preferred NUMA node for the physical
///memory as an extended parameter; and specify a placeholder operation (specifically, replacement). To specify the NUMA
///node, see the <i>ExtendedParameters</i> parameter.
///Params:
///    FileMapping = A <b>HANDLE</b> to a section that is to be mapped into the address space of the specified process.
///    Process = A <b>HANDLE</b> to a process into which the section will be mapped.
///    BaseAddress = The desired base address of the view. The address is rounded down to the nearest 64k boundary. If this parameter
///                  is <b>NULL</b>, the system picks the base address.
///    Offset = The offset from the beginning of the section. This must be 64k aligned.
///    ViewSize = The number of bytes to map. A value of zero (0) specifies that the entire section is to be mapped. The size must
///               always be a multiple of the page size.
///    AllocationType = The type of memory allocation. This parameter can be zero (0) or one of the following values. <table> <tr>
///                     <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_RESERVE"></a><a id="mem_reserve"></a><dl>
///                     <dt><b>MEM_RESERVE</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Maps a reserved view. </td> </tr>
///                     <tr> <td width="40%"><a id="MEM_REPLACE_PLACEHOLDER"></a><a id="mem_replace_placeholder"></a><dl>
///                     <dt><b>MEM_REPLACE_PLACEHOLDER</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> Replaces a placeholder
///                     with a mapped view. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you
///                     replace a placeholder, <i>BaseAddress</i> and <i>ViewSize</i> must exactly match those of the placeholder. After
///                     you replace a placeholder with a mapped view, to free that mapped view back to a placeholder, see the
///                     <i>UnmapFlags</i> parameter of UnmapViewOfFileEx and UnmapViewOfFile2. A placeholder is a type of reserved memory
///                     region. </td> </tr> <tr> <td width="40%"><a id="MEM_LARGE_PAGES"></a><a id="mem_large_pages"></a><dl>
///                     <dt><b>MEM_LARGE_PAGES</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%"> Maps a large page view. This
///                     flag specifies that the view should be mapped using large page support. The size of the view must be a multiple
///                     of the size of a large page reported by the GetLargePageMinimum function, and the file-mapping object must have
///                     been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null value for the <i>BaseAddress</i>
///                     parameter, then the value must be a multiple of <b>GetLargePageMinimum</b>. </td> </tr> </table>
///    PageProtection = The desired page protection. For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
///                     <i>PageProtection</i> parameter has no effect, and should be set to any valid value such as <b>PAGE_READONLY</b>.
///    ExtendedParameters = An optional pointer to one or more extended parameters of type MEM_EXTENDED_PARAMETER. Each of those extended
///                         parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or
///                         <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided,
///                         then the behavior is the same as for the VirtualAlloc/MapViewOfFile functions (that is, the preferred NUMA node
///                         for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).
///    ParameterCount = The number of extended parameters pointed to by <i>ExtendedParameters</i>.
///Returns:
///    Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error
///    status is available using GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-6")
void* MapViewOfFile3(HANDLE FileMapping, HANDLE Process, void* BaseAddress, ulong Offset, size_t ViewSize, 
                     uint AllocationType, uint PageProtection, MEM_EXTENDED_PARAMETER* ExtendedParameters, 
                     uint ParameterCount);

///Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process.
///Memory allocated by this function is automatically initialized to zero. Using this function, you can: for new
///allocations, specify a range of virtual address space and a power-of-2 alignment restriction; specify an arbitrary
///number of extended parameters; specify a preferred NUMA node for the physical memory as an extended parameter; and
///specify a placeholder operation (specifically, replacement). To specify the NUMA node, see the
///<i>ExtendedParameters</i> parameter.
///Params:
///    Process = The handle to a process. The function allocates memory within the virtual address space of this process. The
///              handle must have the <b>PROCESS_VM_OPERATION</b> access right. For more information, see Process Security and
///              Access Rights.
///    BaseAddress = The pointer that specifies a desired starting address for the region of pages that you want to allocate. If an
///                  explicit base address is specified, then it must be a multiple of the system allocation granularity. To determine
///                  the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function. If
///                  <i>BaseAddress</i> is <b>NULL</b>, the function determines where to allocate the region.
///    Size = The size of the region of memory to allocate, in bytes. The size must always be a multiple of the page size. If
///           <i>BaseAddress</i> is not <b>NULL</b>, the function allocates all pages that contain one or more bytes in the
///           range from <i>BaseAddress</i> to <i>BaseAddress</i>+<i>Size</i>. This means, for example, that a 2-byte range
///           that straddles a page boundary causes the function to allocate both pages.
///    AllocationType = The type of memory allocation. This parameter must contain one of the following values. <table> <tr>
///                     <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_COMMIT"></a><a id="mem_commit"></a><dl>
///                     <dt><b>MEM_COMMIT</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> Allocates memory charges (from the
///                     overall size of memory and the paging files on disk) for the specified reserved memory pages. The function also
///                     guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical
///                     pages are not allocated unless/until the virtual addresses are actually accessed. To reserve and commit pages in
///                     one step, call <b>Virtual2AllocFromApp</b> with <code>MEM_COMMIT | MEM_RESERVE</code>. Attempting to commit a
///                     specific address range by specifying <b>MEM_COMMIT</b> without <b>MEM_RESERVE</b> and a non-<b>NULL</b>
///                     <i>BaseAddress</i> fails unless the entire range has already been reserved. The resulting error code is
///                     <b>ERROR_INVALID_ADDRESS</b>. An attempt to commit a page that is already committed does not cause the function
///                     to fail. This means that you can commit pages without first determining the current commitment state of each
///                     page. </td> </tr> <tr> <td width="40%"><a id="MEM_RESERVE"></a><a id="mem_reserve"></a><dl>
///                     <dt><b>MEM_RESERVE</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Reserves a range of the process's
///                     virtual address space without allocating any actual physical storage in memory or in the paging file on disk. You
///                     can commit reserved pages in subsequent calls to the <b>Virtual2AllocFromApp</b> function. To reserve and commit
///                     pages in one step, call <b>Virtual2AllocFromApp</b> with <b>MEM_COMMIT</b> | <b>MEM_RESERVE</b>. Other memory
///                     allocation functions, such as <b>malloc</b> and LocalAlloc, cannot use a reserved range of memory until it is
///                     released. </td> </tr> <tr> <td width="40%"><a id="MEM_REPLACE_PLACEHOLDER"></a><a
///                     id="mem_replace_placeholder"></a><dl> <dt><b>MEM_REPLACE_PLACEHOLDER</b></dt> <dt>0x00004000</dt> </dl> </td> <td
///                     width="60%"> Replaces a placeholder with a normal private allocation. Only data/pf-backed section views are
///                     supported (no images, physical memory, etc.). When you replace a placeholder, <i>BaseAddress</i> and <i>Size</i>
///                     must exactly match those of the placeholder. After you replace a placeholder with a private allocation, to free
///                     that allocation back to a placeholder, see the <i>dwFreeType</i> parameter of VirtualFree and VirtualFreeEx. A
///                     placeholder is a type of reserved memory region. </td> </tr> <tr> <td width="40%"><a
///                     id="MEM_RESERVE_PLACEHOLDER"></a><a id="mem_reserve_placeholder"></a><dl> <dt><b>MEM_RESERVE_PLACEHOLDER</b></dt>
///                     <dt>0x00040000</dt> </dl> </td> <td width="60%"> To create a placeholder, call VirtualAlloc2 with
///                     <code>MEM_RESERVE | MEM_RESERVE_PLACEHOLDER</code> and <i>PageProtection</i> set to <b>PAGE_NOACCESS</b>. To
///                     free/split/coalesce a placeholder, see the <i>dwFreeType</i> parameter of VirtualFree and VirtualFreeEx. A
///                     placeholder is a type of reserved memory region. </td> </tr> <tr> <td width="40%"><a id="MEM_RESET"></a><a
///                     id="mem_reset"></a><dl> <dt><b>MEM_RESET</b></dt> <dt>0x00080000</dt> </dl> </td> <td width="60%"> Indicates that
///                     data in the memory range specified by <i>BaseAddress</i> and <i>Size</i> is no longer of interest. The pages
///                     should not be read from or written to the paging file. However, the memory block will be used again later, so it
///                     should not be decommitted. This value cannot be used with any other value. Using this value does not guarantee
///                     that the range operated on with <b>MEM_RESET</b> will contain zeros. If you want the range to contain zeros,
///                     decommit the memory and then recommit it. When you specify <b>MEM_RESET</b>, the <b>Virtual2AllocFromApp</b>
///                     function ignores the value of <i>Protection</i>. However, you must still set <i>Protection</i> to a valid
///                     protection value, such as <b>PAGE_NOACCESS</b>. <b>Virtual2AllocFromApp</b> returns an error if you use
///                     <b>MEM_RESET</b> and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to
///                     a paging file. </td> </tr> <tr> <td width="40%"><a id="MEM_RESET_UNDO"></a><a id="mem_reset_undo"></a><dl>
///                     <dt><b>MEM_RESET_UNDO</b></dt> <dt>0x1000000</dt> </dl> </td> <td width="60%"> <b>MEM_RESET_UNDO</b> should only
///                     be called on an address range to which <b>MEM_RESET</b> was successfully applied earlier. It indicates that the
///                     data in the specified memory range specified by <i>BaseAddress</i> and <i>Size</i> is of interest to the caller
///                     and attempts to reverse the effects of <b>MEM_RESET</b>. If the function succeeds, that means all data in the
///                     specified address range is intact. If the function fails, at least some of the data in the address range has been
///                     replaced with zeroes. This value cannot be used with any other value. If <b>MEM_RESET_UNDO</b> is called on an
///                     address range which was not <b>MEM_RESET</b> earlier, the behavior is undefined. When you specify
///                     <b>MEM_RESET</b>, the <b>Virtual2AllocFromApp</b> function ignores the value of <i>Protection</i>. However, you
///                     must still set <i>Protection</i> to a valid protection value, such as <b>PAGE_NOACCESS</b>. </td> </tr> </table>
///                     This parameter can also specify the following values as indicated. <table> <tr> <th>Value</th> <th>Meaning</th>
///                     </tr> <tr> <td width="40%"><a id="MEM_LARGE_PAGES"></a><a id="mem_large_pages"></a><dl>
///                     <dt><b>MEM_LARGE_PAGES</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%"> Allocates memory using large
///                     page support. The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
///                     GetLargePageMinimum function. If you specify this value, you must also specify <b>MEM_RESERVE</b> and
///                     <b>MEM_COMMIT</b>. </td> </tr> <tr> <td width="40%"><a id="MEM_PHYSICAL"></a><a id="mem_physical"></a><dl>
///                     <dt><b>MEM_PHYSICAL</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> Reserves an address range that can
///                     be used to map Address Windowing Extensions (AWE) pages. This value must be used with <b>MEM_RESERVE</b> and no
///                     other values. </td> </tr> <tr> <td width="40%"><a id="MEM_TOP_DOWN"></a><a id="mem_top_down"></a><dl>
///                     <dt><b>MEM_TOP_DOWN</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> Allocates memory at the highest
///                     possible address. This can be slower than regular allocations, especially when there are many allocations. </td>
///                     </tr> <tr> <td width="40%"><a id="MEM_WRITE_WATCH"></a><a id="mem_write_watch"></a><dl>
///                     <dt><b>MEM_WRITE_WATCH</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> Causes the system to track pages
///                     that are written to in the allocated region. If you specify this value, you must also specify <b>MEM_RESERVE</b>.
///                     To retrieve the addresses of the pages that have been written to since the region was allocated or the
///                     write-tracking state was reset, call the GetWriteWatch function. To reset the write-tracking state, call
///                     <b>GetWriteWatch</b> or ResetWriteWatch. The write-tracking feature remains enabled for the memory region until
///                     the region is freed. </td> </tr> </table>
///    PageProtection = The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify
///                     one of the memory protection constants. The following constants generate an error: <ul>
///                     <li><b>PAGE_EXECUTE</b></li> <li><b>PAGE_EXECUTE_READ</b></li> <li><b>PAGE_EXECUTE_READWRITE</b></li>
///                     <li><b>PAGE_EXECUTE_WRITECOPY</b></li> </ul>
///    ExtendedParameters = An optional pointer to one or more extended parameters of type MEM_EXTENDED_PARAMETER. Each of those extended
///                         parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or
///                         <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided,
///                         then the behavior is the same as for the VirtualAlloc/MapViewOfFile functions (that is, the preferred NUMA node
///                         for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).
///    ParameterCount = The number of extended parameters pointed to by <i>ExtendedParameters</i>.
///Returns:
///    If the function succeeds, the return value is the base address of the allocated region of pages. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-6")
void* VirtualAlloc2FromApp(HANDLE Process, void* BaseAddress, size_t Size, uint AllocationType, 
                           uint PageProtection, MEM_EXTENDED_PARAMETER* ExtendedParameters, uint ParameterCount);

///Maps a view of a file mapping into the address space of a calling Windows Store app. Using this function, you can:
///for new allocations, specify a range of virtual address space and a power-of-2 alignment restriction; specify an
///arbitrary number of extended parameters; specify a preferred NUMA node for the physical memory as an extended
///parameter; and specify a placeholder operation (specifically, replacement). To specify the NUMA node, see the
///<i>ExtendedParameters</i> parameter.
///Params:
///    FileMapping = A <b>HANDLE</b> to a section that is to be mapped into the address space of the specified process.
///    Process = A <b>HANDLE</b> to a process into which the section will be mapped.
///    BaseAddress = The desired base address of the view. The address is rounded down to the nearest 64k boundary. If this parameter
///                  is <b>NULL</b>, the system picks the base address.
///    Offset = The offset from the beginning of the section. This must be 64k aligned.
///    ViewSize = The number of bytes to map. A value of zero (0) specifies that the entire section is to be mapped. The size must
///               always be a multiple of the page size.
///    AllocationType = The type of memory allocation. This parameter can be zero (0) or one of the following values. <table> <tr>
///                     <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MEM_RESERVE"></a><a id="mem_reserve"></a><dl>
///                     <dt><b>MEM_RESERVE</b></dt> <dt>0x00002000</dt> </dl> </td> <td width="60%"> Maps a reserved view. </td> </tr>
///                     <tr> <td width="40%"><a id="MEM_REPLACE_PLACEHOLDER"></a><a id="mem_replace_placeholder"></a><dl>
///                     <dt><b>MEM_REPLACE_PLACEHOLDER</b></dt> <dt>0x00004000</dt> </dl> </td> <td width="60%"> Replaces a placeholder
///                     with a mapped view. Only data/pf-backed section views are supported (no images, physical memory, etc.). When you
///                     replace a placeholder, <i>BaseAddress</i> and <i>ViewSize</i> must exactly match those of the placeholder. After
///                     you replace a placeholder with a mapped view, to free that mapped view back to a placeholder, see the
///                     <i>UnmapFlags</i> parameter of UnmapViewOfFileEx and UnmapViewOfFile2. A placeholder is a type of reserved memory
///                     region. </td> </tr> <tr> <td width="40%"><a id="MEM_LARGE_PAGES"></a><a id="mem_large_pages"></a><dl>
///                     <dt><b>MEM_LARGE_PAGES</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%"> Maps a large page view. See
///                     large page support. </td> </tr> </table>
///    PageProtection = The desired page protection. For file-mapping objects created with the <b>SEC_IMAGE</b> attribute, the
///                     <i>PageProtection</i> parameter has no effect, and should be set to any valid value such as <b>PAGE_READONLY</b>.
///    ExtendedParameters = An optional pointer to one or more extended parameters of type MEM_EXTENDED_PARAMETER. Each of those extended
///                         parameter values can itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or
///                         <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided,
///                         then the behavior is the same as for the VirtualAlloc/MapViewOfFile functions (that is, the preferred NUMA node
///                         for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).
///    ParameterCount = The number of extended parameters pointed to by <i>ExtendedParameters</i>.
///Returns:
///    Returns the base address of the mapped view, if successful. Otherwise, returns <b>NULL</b> and extended error
///    status is available using GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-6")
void* MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, void* BaseAddress, ulong Offset, size_t ViewSize, 
                            uint AllocationType, uint PageProtection, MEM_EXTENDED_PARAMETER* ExtendedParameters, 
                            uint ParameterCount);

///Creates or opens a named or unnamed file mapping object for a specified file. You can specify a preferred NUMA node
///for the physical memory as an extended parameter; see the *ExtendedParameters* parameter.
///Params:
///    File = Type: \_In\_ **[HANDLE](/windows/win32/winprog/windows-data-types)** A handle to the file from which to create a
///           file mapping object. The file must be opened with access rights that are compatible with the protection flags
///           that the <i>flProtect</i> parameter specifies. It is not required, but it is recommended that files you intend to
///           map be opened for exclusive access. For more information, see File security and access rights. If <i>hFile</i> is
///           <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify a size for the file mapping object in the
///           <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In this scenario, <b>CreateFileMapping</b>
///           creates a file mapping object of a specified size that is backed by the system paging file instead of by a file
///           in the file system.
///    SecurityAttributes = Type: \_In_opt\_ **[SECURITY_ATTRIBUTES](/previous-versions/windows/desktop/legacy/aa379560(v=vs.85))\*** A
///                         pointer to a SECURITY_ATTRIBUTES structure that determines whether a returned handle can be inherited by child
///                         processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a
///                         security descriptor for a new file mapping object. If <i>lpAttributes</i> is <b>NULL</b>, the handle cannot be
///                         inherited and the file mapping object gets a default security descriptor. The access control lists (ACL) in the
///                         default security descriptor for a file mapping object come from the primary or impersonation token of the
///                         creator. For more information, see File Mapping Security and Access Rights.
///    DesiredAccess = Type: \_In\_ **[ULONG](/windows/win32/winprog/windows-data-types)** The desired access mask for the returned file
///                    mapping handle. For a list of access rights, see [File-mapping security and access
///                    rights](/windows/win32/memory/file-mapping-security-and-access-rights).
///    PageProtection = Type: \_In\_ **[ULONG](/windows/win32/winprog/windows-data-types)** Specifies the page protection of the file
///                     mapping object. All mapped views of the object must be compatible with this protection. This parameter can be one
///                     of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                     id="PAGE_EXECUTE_READ"></a><a id="page_execute_read"></a><dl> <dt><b>PAGE_EXECUTE_READ</b></dt> <dt>0x20</dt>
///                     </dl> </td> <td width="60%"> Allows views to be mapped for read-only, copy-on-write, or execute access. The file
///                     handle specified by the <i>hFile</i> parameter must be created with the <b>GENERIC_READ</b> and
///                     <b>GENERIC_EXECUTE</b> access rights. <b>Windows Server 2003 and Windows XP: </b>This value is not available
///                     until Windows XP with SP2 and Windows Server 2003 with SP1. </td> </tr> <tr> <td width="40%"><a
///                     id="PAGE_EXECUTE_READWRITE"></a><a id="page_execute_readwrite"></a><dl> <dt><b>PAGE_EXECUTE_READWRITE</b></dt>
///                     <dt>0x40</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only, copy-on-write, read/write, or
///                     execute access. The file handle that the <i>hFile</i> parameter specifies must be created with the
///                     <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and <b>GENERIC_EXECUTE</b> access rights. <b>Windows Server 2003 and
///                     Windows XP: </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1. </td>
///                     </tr> <tr> <td width="40%"><a id="PAGE_EXECUTE_WRITECOPY"></a><a id="page_execute_writecopy"></a><dl>
///                     <dt><b>PAGE_EXECUTE_WRITECOPY</b></dt> <dt>0x80</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                     read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>. The file
///                     handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> and
///                     <b>GENERIC_EXECUTE</b> access rights. <b>Windows Vista: </b>This value is not available until Windows Vista with
///                     SP1. <b>Windows Server 2003 and Windows XP: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
///                     id="PAGE_READONLY"></a><a id="page_readonly"></a><dl> <dt><b>PAGE_READONLY</b></dt> <dt>0x02</dt> </dl> </td> <td
///                     width="60%"> Allows views to be mapped for read-only or copy-on-write access. An attempt to write to a specific
///                     region results in an access violation. The file handle that the <i>hFile</i> parameter specifies must be created
///                     with the <b>GENERIC_READ</b> access right. </td> </tr> <tr> <td width="40%"><a id="PAGE_READWRITE"></a><a
///                     id="page_readwrite"></a><dl> <dt><b>PAGE_READWRITE</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> Allows
///                     views to be mapped for read-only, copy-on-write, or read/write access. The file handle that the <i>hFile</i>
///                     parameter specifies must be created with the <b>GENERIC_READ</b> and <b>GENERIC_WRITE</b> access rights. </td>
///                     </tr> <tr> <td width="40%"><a id="PAGE_WRITECOPY"></a><a id="page_writecopy"></a><dl>
///                     <dt><b>PAGE_WRITECOPY</b></dt> <dt>0x08</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only
///                     or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>. The file handle that the <i>hFile</i>
///                     parameter specifies must be created with the <b>GENERIC_READ</b> access right. </td> </tr> </table>
///    AllocationAttributes = Type: \_In\_ **[ULONG](/windows/win32/winprog/windows-data-types)** You can specify one or more of the following
///                           attributes for the file mapping object. Also see the *PageProtection* parameter. <table> <tr> <th>Value</th>
///                           <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SEC_COMMIT"></a><a id="sec_commit"></a><dl>
///                           <dt><b>SEC_COMMIT</b></dt> <dt>0x8000000</dt> </dl> </td> <td width="60%"> If the file mapping object is backed
///                           by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
///                           when a view of the file is mapped into a process address space, the entire range of pages is committed rather
///                           than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
///                           <b>CreateFileMapping</b> fails. This attribute has no effect for file mapping objects that are backed by
///                           executable image files or data files (the <i>hfile</i> parameter is a handle to a file). <b>SEC_COMMIT</b> cannot
///                           be combined with <b>SEC_RESERVE</b>. If no attribute is specified, <b>SEC_COMMIT</b> is assumed. </td> </tr> <tr>
///                           <td width="40%"><a id="SEC_IMAGE"></a><a id="sec_image"></a><dl> <dt><b>SEC_IMAGE</b></dt> <dt>0x1000000</dt>
///                           </dl> </td> <td width="60%"> Specifies that the file that the <i>hFile</i> parameter specifies is an executable
///                           image file. The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
///                           <b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file.
///                           Page protection for views of an executable image file is determined by the executable file itself. No other
///                           attributes are valid with <b>SEC_IMAGE</b>. </td> </tr> <tr> <td width="40%"><a id="SEC_IMAGE_NO_EXECUTE"></a><a
///                           id="sec_image_no_execute"></a><dl> <dt><b>SEC_IMAGE_NO_EXECUTE</b></dt> <dt>0x11000000</dt> </dl> </td> <td
///                           width="60%"> Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that
///                           will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a
///                           view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver
///                           callbacks registered using the PsSetLoadImageNotifyRoutine kernel API. The <b>SEC_IMAGE_NO_EXECUTE</b> attribute
///                           must be combined with the <b>PAGE_READONLY</b> page protection value. No other attributes are valid with
///                           <b>SEC_IMAGE_NO_EXECUTE</b>. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows
///                           Server 2003 and Windows XP: </b>This value is not supported before Windows Server 2012 and Windows 8. </td> </tr>
///                           <tr> <td width="40%"><a id="SEC_LARGE_PAGES"></a><a id="sec_large_pages"></a><dl> <dt><b>SEC_LARGE_PAGES</b></dt>
///                           <dt>0x80000000</dt> </dl> </td> <td width="60%"> Enables large pages to be used for file mapping objects that are
///                           backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
///                           attribute is not supported for file mapping objects that are backed by executable image files or data files (the
///                           <i>hFile</i> parameter is a handle to an executable image or data file). The maximum size of the file mapping
///                           object must be a multiple of the minimum size of a large page returned by the GetLargePageMinimum function. If it
///                           is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with
///                           <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.
///                           <b>SEC_LARGE_PAGES</b> requires the SeLockMemoryPrivilege privilege to be enabled in the caller's token. If
///                           <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified. <b>Windows Server 2003: </b>This
///                           value is not supported until Windows Server 2003 with SP1. <b>Windows XP: </b>This value is not supported. </td>
///                           </tr> <tr> <td width="40%"><a id="SEC_NOCACHE"></a><a id="sec_nocache"></a><dl> <dt><b>SEC_NOCACHE</b></dt>
///                           <dt>0x10000000</dt> </dl> </td> <td width="60%"> Sets all pages to be non-cachable. Applications should not use
///                           this attribute except when explicitly required for a device. Using the interlocked functions with memory that is
///                           mapped with <b>SEC_NOCACHE</b> can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.
///                           <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or <b>SEC_COMMIT</b> attribute to be set. </td> </tr>
///                           <tr> <td width="40%"><a id="SEC_RESERVE"></a><a id="sec_reserve"></a><dl> <dt><b>SEC_RESERVE</b></dt>
///                           <dt>0x4000000</dt> </dl> </td> <td width="60%"> If the file mapping object is backed by the operating system
///                           paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file
///                           is mapped into a process address space, the entire range of pages is reserved for later use by the process rather
///                           than committed. Reserved pages can be committed in subsequent calls to the VirtualAlloc function. After the pages
///                           are committed, they cannot be freed or decommitted with the VirtualFree function. This attribute has no effect
///                           for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a
///                           handle to a file). <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>. </td> </tr> <tr> <td
///                           width="40%"><a id="SEC_WRITECOMBINE"></a><a id="sec_writecombine"></a><dl> <dt><b>SEC_WRITECOMBINE</b></dt>
///                           <dt>0x40000000</dt> </dl> </td> <td width="60%"> Sets all pages to be write-combined. Applications should not use
///                           this attribute except when explicitly required for a device. Using the interlocked functions with memory that is
///                           mapped with <b>SEC_WRITECOMBINE</b> can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.
///                           <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or <b>SEC_COMMIT</b> attribute to be set.
///                           <b>Windows Server 2003 and Windows XP: </b>This flag is not supported until Windows Vista. </td> </tr> </table>
///    MaximumSize = Type: \_In\_ **[ULONG64](/windows/win32/winprog/windows-data-types)** The maximum size of the file mapping
///                  object. If this parameter is 0 (zero), then the maximum size of the file mapping object is equal to the current
///                  size of the file that <i>hFile</i> identifies. An attempt to map a file with a length of 0 (zero) fails with an
///                  error code of <b>ERROR_FILE_INVALID</b>. You should test for files with a length of 0 (zero), and reject those
///                  files.
///    Name = Type: \_In_opt\_ **[PCWSTR](/windows/win32/winprog/windows-data-types)** The name of the file mapping object. If
///           this parameter matches the name of an existing mapping object, then the function requests access to the object
///           with the protection that <i>flProtect</i> specifies. If this parameter is <b>NULL</b>, then the file mapping
///           object is created without a name. If <i>lpName</i> matches the name of an existing event, semaphore, mutex,
///           waitable timer, or job object, the function fails, and the GetLastError function returns
///           <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a
///           "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of
///           the name can contain any character except the backslash character (\\). Creating a file mapping object in the
///           global namespace from a session other than session zero requires the SeCreateGlobalPrivilege privilege. For more
///           information, see Kernel Object Namespaces. Fast user switching is implemented by using Terminal Services
///           sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so
///           on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications
///           can support multiple users.
///    ExtendedParameters = Type: \_Inout\_updates\_opt\_(ParameterCount)
///                         **[MEM_EXTENDED_PARAMETER](/windows/win32/api/winnt/ns-winnt-mem_extended_parameter)\*** An optional pointer to
///                         one or more extended parameters of type MEM_EXTENDED_PARAMETER. Each of those extended parameter values can
///                         itself have a <i>Type</i> field of either <b>MemExtendedParameterAddressRequirements</b> or
///                         <b>MemExtendedParameterNumaNode</b>. If no <b>MemExtendedParameterNumaNode</b> extended parameter is provided,
///                         then the behavior is the same as for the VirtualAlloc/MapViewOfFile functions (that is, the preferred NUMA node
///                         for the physical pages is determined based on the ideal processor of the thread that first accesses the memory).
///    ParameterCount = _In_ ULONG ParameterCount The number of extended parameters pointed to by *ExtendedParameters*.
///Returns:
///    If the function succeeds, the return value is a handle to the newly created file mapping object. If the object
///    exists before the function call, the function returns a handle to the existing object (with its current size, not
///    the specified size), and GetLastErrorreturns <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("api-ms-win-core-memory-l1-1-7")
HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES* SecurityAttributes, uint DesiredAccess, 
                          uint PageProtection, uint AllocationAttributes, ulong MaximumSize, const(PWSTR) Name, 
                          MEM_EXTENDED_PARAMETER* ExtendedParameters, uint ParameterCount);

///Retrieves whether the specified type of enclave is supported.
///Params:
///    flEnclaveType = The type of enclave to check. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                    id="ENCLAVE_TYPE_SGX"></a><a id="enclave_type_sgx"></a><dl> <dt><b><b>ENCLAVE_TYPE_SGX</b></b></dt>
///                    <dt>0x00000001</dt> </dl> </td> <td width="60%"> An enclave for the Intel Software Guard Extensions (SGX)
///                    architecture extension. </td> </tr> <tr> <td width="40%"><a id="ENCLAVE_TYPE_VBS"></a><a
///                    id="enclave_type_vbs"></a><dl> <dt><b>ENCLAVE_TYPE_VBS</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">
///                    A virtualization-based security (VBS) enclave. </td> </tr> </table>
@DllImport("KERNEL32")
BOOL IsEnclaveTypeSupported(uint flEnclaveType);

///Creates a new uninitialized enclave. An enclave is an isolated region of code and data within the address space for
///an application. Only code that runs within the enclave can access data within the same enclave.
///Params:
///    hProcess = A handle to the process for which you want to create an enclave.
///    lpAddress = The preferred base address of the enclave. Specify <b>NULL</b> to have the operating system assign the base
///                address.
///    dwSize = The size of the enclave that you want to create, including the size of the code that you will load into the
///             enclave, in bytes.
///    dwInitialCommitment = The amount of memory to commit for the enclave, in bytes. If the amount of enclave memory available is not
///                          sufficient to commit this number of bytes, enclave creation fails. Any memory that remains unused when you
///                          initialize the enclave by calling InitializeEnclave is returned to the list of free pages. The value of the
///                          <i>dwInitialCommittment</i> parameter must not exceed the value of the <i>dwSize</i> parameter. This parameter is
///                          not used for virtualization-based security (VBS) enclaves.
///    flEnclaveType = The architecture type of the enclave that you want to create. To verify that an enclave type is supported, call
///                    IsEnclaveTypeSupported. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                    id="ENCLAVE_TYPE_SGX"></a><a id="enclave_type_sgx"></a><dl> <dt><b><b>ENCLAVE_TYPE_SGX</b></b></dt>
///                    <dt>0x00000001</dt> </dl> </td> <td width="60%"> An enclave for the Intel Software Guard Extensions (SGX)
///                    architecture extension. </td> </tr> <tr> <td width="40%"><a id="ENCLAVE_TYPE_VBS"></a><a
///                    id="enclave_type_vbs"></a><dl> <dt><b>ENCLAVE_TYPE_VBS</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%">
///                    A VBS enclave. </td> </tr> </table>
///    lpEnclaveInformation = A pointer to the architecture-specific information to use to create the enclave. For the <b>ENCLAVE_TYPE_SGX</b>
///                           enclave type, you must specify a pointer to an ENCLAVE_CREATE_INFO_SGX structure. For the <b>ENCLAVE_TYPE_VBS</b>
///                           enclave type, you must specify a pointer to an ENCLAVE_CREATE_INFO_VBS structure.
///    dwInfoLength = The length of the structure that the <i>lpEnclaveInformation</i> parameter points to, in bytes. For the
///                   <b>ENCLAVE_TYPE_SGX</b> enclave type, this value must be 4096. For the <b>ENCLAVE_TYPE_VBS</b> enclave type, this
///                   value must be <code>sizeof(ENCLAVE_CREATE_INFO_VBS)</code>, which is 36 bytes.
///    lpEnclaveError = An optional pointer to a variable that receives an enclave error code that is architecture-specific. For the
///                     <b>ENCLAVE_TYPE_SGX</b> and <b>ENCLAVE_TYPE_VBS</b> enclave types, the <i>lpEnclaveError</i> parameter is not
///                     used.
///Returns:
///    If the function succeeds, the return value is the base address of the created enclave. If the function fails, the
///    return value is <b>NULL</b>. To get extended error information, call GetLastError. For a list of common error
///    codes, see System Error Codes. The following error codes also apply for this function. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b><b>ERROR_NOT_SUPPORTED</b></b></dt> </dl>
///    </td> <td width="60%"> An unsupported enclave type was specified. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>ERROR_BAD_LENGTH</b></b></dt> </dl> </td> <td width="60%"> The value of the <i>dwInfoLength</i>
///    parameter did not match the value expected based on the value specified for the <i>lpEnclaveInformation</i>
///    parameter. </td> </tr> </table>
///    
@DllImport("KERNEL32")
void* CreateEnclave(HANDLE hProcess, void* lpAddress, size_t dwSize, size_t dwInitialCommitment, 
                    uint flEnclaveType, const(void)* lpEnclaveInformation, uint dwInfoLength, uint* lpEnclaveError);

///Loads data into an uninitialized enclave that you created by calling CreateEnclave.
///Params:
///    hProcess = A handle to the process for which the enclave was created.
///    lpAddress = The address in the enclave where you want to load the data.
///    lpBuffer = A pointer to the data the you want to load into the enclave.
///    nSize = The size of the data that you want to load into the enclave, in bytes. This value must be a whole-number multiple
///            of the page size.
///    flProtect = The memory protection to use for the pages that you want to add to the enclave. For a list of memory protection
///                values, see memory protection constants. This value must not include the following constants: <ul>
///                <li><b>PAGE_GUARD</b></li> <li><b>PAGE_NOCACHE</b></li> <li><b>PAGE_WRITECOMBINE</b></li>
///                <li><b>PAGE_NOACCESS</b></li> </ul> This value can include the enclave specific constants that the following
///                table describes. <table> <tr> <th>Constant</th> <th>Description</th> </tr> <tr>
///                <td><b>PAGE_ENCLAVE_THREAD_CONTROL</b></td> <td>The page contains a thread control structure (TCS).</td> </tr>
///                <tr> <td><b>PAGE_ENCLAVE_UNVALIDATED</b></td> <td>The page contents that you supply are excluded from measurement
///                with the EEXTEND instruction of the Intel Software Guard Extensions programming model.</td> </tr> </table>
///    lpPageInformation = A pointer to information that describes the pages that you want to add to the enclave. The
///                        <i>lpPageInformation</i> parameter is not used.
///    dwInfoLength = The length of the structure that the <i>lpPageInformation</i> parameter points to, in bytes. This value must be
///                   0.
///    lpNumberOfBytesWritten = A pointer to a variable that receives the number of bytes that <b>LoadEnclaveData</b> copied into the enclave.
///    lpEnclaveError = An optional pointer to a variable that receives an enclave error code that is architecture-specific. The
///                     <i>lpEnclaveError</i> parameter is not used.
///Returns:
///    If all of the data is loaded into the enclave successfully, the return value is nonzero. Otherwise, the return
///    value is zero. To get extended error information, call GetLastError. For a list of common error codes, see System
///    Error Codes. The following error codes also apply for this function. <table> <tr> <th>Return code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b><b>ERROR_BAD_LENGTH</b></b></dt> </dl> </td> <td
///    width="60%"> The value of the <i>dwInfoLength</i> parameter did not match the value expected based on the value
///    specified for the <i>lpPageInformation</i> parameter. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL LoadEnclaveData(HANDLE hProcess, void* lpAddress, const(void)* lpBuffer, size_t nSize, uint flProtect, 
                     const(void)* lpPageInformation, uint dwInfoLength, size_t* lpNumberOfBytesWritten, 
                     uint* lpEnclaveError);

///Initializes an enclave that you created and loaded with data.
///Params:
///    hProcess = A handle to the process for which the enclave was created.
///    lpAddress = Any address within the enclave.
///    lpEnclaveInformation = A pointer to architecture-specific information to use to initialize the enclave. For the <b>ENCLAVE_TYPE_SGX</b>
///                           enclave type, specify a pointer to an ENCLAVE_INIT_INFO_SGX structure. For the <b>ENCLAVE_TYPE_VBS</b> enclave
///                           type, specify a pointer to an ENCLAVE_INIT_INFO_VBS structure.
///    dwInfoLength = The length of the structure that the <i>lpEnclaveInformation</i> parameter points to, in bytes. For the
///                   <b>ENCLAVE_TYPE_SGX</b> enclave type, this value must be 4096. For the <b>ENCLAVE_TYPE_VBS</b> enclave type, this
///                   value must be <code>sizeof(ENCLAVE_INIT_INFO_VBS)</code>, which is 8 bytes.
///    lpEnclaveError = An optional pointer to a variable that receives an enclave error code that is architecture-specific. For the
///                     <b>ENCLAVE_TYPE_SGX</b> enclave type, the <i>lpEnclaveError</i> parameter contains the error that the EINIT
///                     instruction generated if the function fails and .GetLastError returns <b>ERROR_ENCLAVE_FAILURE</b>. For the
///                     <b>ENCLAVE_TYPE_VBS</b> enclave type, the <i>lpEnclaveError</i> parameter is not used.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. For a list of common error codes, see System Error Codes. The
///    following error codes also apply for this function. <table> <tr> <th>Return code</th> <th>Description</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b><b>ERROR_ENCLAVE_FAILURE</b></b></dt> </dl> </td> <td width="60%"> An failure
///    specific to the underlying enclave architecture occurred. The value for the <i>lpEnclaveError</i> parameter
///    contains the architecture-specific error. For the <b>ENCLAVE_TYPE_SGX</b> enclave type, the EINIT instruction
///    that the ENCLAVE_INIT_INFO_SGX structure specified generated an error. The value of the <i>lpEnclaveError</i>
///    parameter contains the error that the instruction generated. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>ERROR_BAD_LENGTH</b></b></dt> </dl> </td> <td width="60%"> The value of the <i>dwInfoLength</i>
///    parameter did not match the value expected based on the value specified for the <i>lpEnclaveInformation</i>
///    parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>ERROR_RETRY</b></b></dt> </dl> </td> <td width="60%">
///    The processor was not able to initialize the enclave in a timely fashion. Try to initialize the enclave again.
///    </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL InitializeEnclave(HANDLE hProcess, void* lpAddress, const(void)* lpEnclaveInformation, uint dwInfoLength, 
                       uint* lpEnclaveError);

@DllImport("api-ms-win-core-enclave-l1-1-1")
BOOL LoadEnclaveImageA(void* lpEnclaveAddress, const(PSTR) lpImageName);

///Loads an image and all of its imports into an enclave.
///Params:
///    lpEnclaveAddress = The base address of the image into which to load the image.
///    lpImageName = A NULL-terminated string that contains the name of the image to load.
///Returns:
///    <b>TRUE</b> if the function succeeds; otherwise <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("api-ms-win-core-enclave-l1-1-1")
BOOL LoadEnclaveImageW(void* lpEnclaveAddress, const(PWSTR) lpImageName);

///Calls a function within an enclave. <b>CallEnclave</b> can also be called within an enclave to call a function
///outside of the enclave.
///Params:
///    lpRoutine = The address of the function that you want to call.
///    lpParameter = The parameter than you want to pass to the function.
///    fWaitForThread = <b>TRUE</b> if the call to the specified function should block execution until an idle enclave thread becomes
///                     available when no idle enclave thread is available. <b>FALSE</b> if the call to the specified function should
///                     fail when no idle enclave thread is available. This parameter is ignored when you use <b>CallEnclave</b> within
///                     an enclave to call a function that is not in any enclave.
///    lpReturnValue = The return value of the function, if it is called successfully.
///Returns:
///    <b>TRUE</b> if the specified function was called successfully; otherwise <b>FALSE</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("api-ms-win-core-enclave-l1-1-1")
BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, void* lpParameter, BOOL fWaitForThread, void** lpReturnValue);

///Ends the execution of the threads that are running within an enclave.
///Params:
///    lpAddress = The base address of the enclave in which to end the execution of the threads.
///    fWait = <b>TRUE</b> if <b>TerminateEnclave</b> should not return until all of the threads in the enclave end execution.
///            <b>FALSE</b> if <b>TerminateEnclave</b> should return immediately.
///Returns:
///    <b>TRUE</b> if the function succeeds; otherwise <b>FALSE</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("api-ms-win-core-enclave-l1-1-1")
BOOL TerminateEnclave(void* lpAddress, BOOL fWait);

///Deletes the specified enclave.
///Params:
///    lpAddress = The base address of the enclave that you want to delete.
///Returns:
///    <b>TRUE</b> if the enclave was deleted successfully; otherwise <b>FALSE</b>. To get extended error information,
///    call GetLastError. For a list of common error codes, see System Error Codes. The following error codes also apply
///    for this function. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ENCLAVE_NOT_TERMINATED</b></dt> </dl> </td> <td width="60%"> The execution of threads running with
///    the enclave was not ended, because either TerminateEnclave was not called, or the execution of the threads has
///    not yet ended in response to an earlier call to <b>TerminateEnclave</b>. </td> </tr> </table>
///    
@DllImport("api-ms-win-core-enclave-l1-1-1")
BOOL DeleteEnclave(void* lpAddress);

///Disables the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications for the specified dynamic-link library (DLL). This
///can reduce the size of the working set for some applications.
///Params:
///    hLibModule = A handle to the DLL module for which the DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications are to be
///                 disabled. The LoadLibrary, LoadLibraryEx, or GetModuleHandle function returns this handle. Note that you cannot
///                 call <b>GetModuleHandle</b> with NULL because this returns the base address of the executable image, not the DLL
///                 image.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. The
///    <b>DisableThreadLibraryCalls</b> function fails if the DLL specified by <i>hModule</i> has active static thread
///    local storage, or if <i>hModule</i> is an invalid module handle. To get extended error information, call
///    GetLastError.
///    
@DllImport("KERNEL32")
BOOL DisableThreadLibraryCalls(ptrdiff_t hLibModule);

@DllImport("KERNEL32")
HRSRC FindResourceExW(ptrdiff_t hModule, const(PWSTR) lpType, const(PWSTR) lpName, ushort wLanguage);

///Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count. When the
///reference count reaches zero, the module is unloaded from the address space of the calling process and the handle is
///no longer valid.
///Params:
///    hLibModule = A handle to the loaded library module. The LoadLibrary, LoadLibraryEx, GetModuleHandle, or GetModuleHandleEx
///                 function returns this handle.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL FreeLibrary(ptrdiff_t hLibModule);

///Decrements the reference count of a loaded dynamic-link library (DLL) by one, then calls ExitThread to terminate the
///calling thread. The function does not return.
///Params:
///    hLibModule = A handle to the DLL module whose reference count the function decrements. The LoadLibrary or GetModuleHandleEx
///                 function returns this handle. Do not call this function with a handle returned by either the
///                 <b>GetModuleHandleEx</b> function (with the GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT flag) or the
///                 GetModuleHandle function, as they do not maintain a reference count for the module.
///    dwExitCode = The exit code for the calling thread.
@DllImport("KERNEL32")
void FreeLibraryAndExitThread(ptrdiff_t hLibModule, uint dwExitCode);

///Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded
///by the current process. To locate the file for a module that was loaded by another process, use the
///GetModuleFileNameEx function.
///Params:
///    hModule = A handle to the loaded module whose path is being requested. If this parameter is <b>NULL</b>,
///              <b>GetModuleFileName</b> retrieves the path of the executable file of the current process. The
///              <b>GetModuleFileName</b> function does not retrieve the path for modules that were loaded using the
///              <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see LoadLibraryEx.
///    lpFilename = A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less
///                 than the size that the <i>nSize</i> parameter specifies, the function succeeds and the path is returned as a
///                 null-terminated string. If the length of the path exceeds the size that the <i>nSize</i> parameter specifies, the
///                 function succeeds and the string is truncated to <i>nSize</i> characters including the terminating null
///                 character. <b>Windows XP: </b>The string is truncated to <i>nSize</i> characters and is not null-terminated. The
///                 string returned will use the same format that was specified when the module was loaded. Therefore, the path can
///                 be a long or short file name, and can use the prefix `\\?\`. For more information, see Naming a File.
///    nSize = The size of the <i>lpFilename</i> buffer, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is the length of the string that is copied to the buffer, in
///    characters, not including the terminating null character. If the buffer is too small to hold the module name, the
///    string is truncated to <i>nSize</i> characters including the terminating null character, the function returns
///    <i>nSize</i>, and the function sets the last error to <b>ERROR_INSUFFICIENT_BUFFER</b>. <b>Windows XP: </b>If the
///    buffer is too small to hold the module name, the function returns <i>nSize</i>. The last error code remains
///    <b>ERROR_SUCCESS</b>. If <i>nSize</i> is zero, the return value is zero and the last error code is
///    <b>ERROR_SUCCESS</b>. If the function fails, the return value is 0 (zero). To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
uint GetModuleFileNameA(ptrdiff_t hModule, PSTR lpFilename, uint nSize);

///Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded
///by the current process. To locate the file for a module that was loaded by another process, use the
///GetModuleFileNameEx function.
///Params:
///    hModule = A handle to the loaded module whose path is being requested. If this parameter is <b>NULL</b>,
///              <b>GetModuleFileName</b> retrieves the path of the executable file of the current process. The
///              <b>GetModuleFileName</b> function does not retrieve the path for modules that were loaded using the
///              <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see LoadLibraryEx.
///    lpFilename = A pointer to a buffer that receives the fully qualified path of the module. If the length of the path is less
///                 than the size that the <i>nSize</i> parameter specifies, the function succeeds and the path is returned as a
///                 null-terminated string. If the length of the path exceeds the size that the <i>nSize</i> parameter specifies, the
///                 function succeeds and the string is truncated to <i>nSize</i> characters including the terminating null
///                 character. <b>Windows XP: </b>The string is truncated to <i>nSize</i> characters and is not null-terminated. The
///                 string returned will use the same format that was specified when the module was loaded. Therefore, the path can
///                 be a long or short file name, and can use the prefix "\\?\". For more information, see Naming a File.
///    nSize = The size of the <i>lpFilename</i> buffer, in <b>TCHARs</b>.
///Returns:
///    If the function succeeds, the return value is the length of the string that is copied to the buffer, in
///    characters, not including the terminating null character. If the buffer is too small to hold the module name, the
///    string is truncated to <i>nSize</i> characters including the terminating null character, the function returns
///    <i>nSize</i>, and the function sets the last error to <b>ERROR_INSUFFICIENT_BUFFER</b>. <b>Windows XP: </b>If the
///    buffer is too small to hold the module name, the function returns <i>nSize</i>. The last error code remains
///    <b>ERROR_SUCCESS</b>. If <i>nSize</i> is zero, the return value is zero and the last error code is
///    <b>ERROR_SUCCESS</b>. If the function fails, the return value is 0 (zero). To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
uint GetModuleFileNameW(ptrdiff_t hModule, PWSTR lpFilename, uint nSize);

///Retrieves a module handle for the specified module. The module must have been loaded by the calling process. To avoid
///the race conditions described in the Remarks section, use the GetModuleHandleEx function.
///Params:
///    lpModuleName = The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default
///                   library extension .dll is appended. The file name string can include a trailing point character (.) to indicate
///                   that the module name has no extension. The string does not have to specify a path. When specifying a path, be
///                   sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of
///                   modules currently mapped into the address space of the calling process. If this parameter is NULL,
///                   <b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file). The
///                   <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the
///                   <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see LoadLibraryEx.
///Returns:
///    If the function succeeds, the return value is a handle to the specified module. If the function fails, the return
///    value is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t GetModuleHandleA(const(PSTR) lpModuleName);

///Retrieves a module handle for the specified module. The module must have been loaded by the calling process. To avoid
///the race conditions described in the Remarks section, use the GetModuleHandleEx function.
///Params:
///    lpModuleName = The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default
///                   library extension .dll is appended. The file name string can include a trailing point character (.) to indicate
///                   that the module name has no extension. The string does not have to specify a path. When specifying a path, be
///                   sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of
///                   modules currently mapped into the address space of the calling process. If this parameter is NULL,
///                   <b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file). The
///                   <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the
///                   <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see LoadLibraryEx.
///Returns:
///    If the function succeeds, the return value is a handle to the specified module. If the function fails, the return
///    value is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t GetModuleHandleW(const(PWSTR) lpModuleName);

///Retrieves a module handle for the specified module and increments the module's reference count unless
///GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.
///Params:
///    dwFlags = This parameter can be zero or one or more of the following values. If the module's reference count is
///              incremented, the caller must use the FreeLibrary function to decrement the reference count when the module handle
///              is no longer needed.
///    lpModuleName = The name of the loaded module (either a .dll or .exe file), or an address in the module (if <i>dwFlags</i> is
///                   GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS). For a module name, if the file name extension is omitted, the default
///                   library extension .dll is appended. The file name string can include a trailing point character (.) to indicate
///                   that the module name has no extension. The string does not have to specify a path. When specifying a path, be
///                   sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of
///                   modules currently mapped into the address space of the calling process. If this parameter is NULL, the function
///                   returns a handle to the file used to create the calling process (.exe file).
///    phModule = A handle to the specified module. If the function fails, this parameter is NULL. The <b>GetModuleHandleEx</b>
///               function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag.
///               For more information, see LoadLibraryEx.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, see GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetModuleHandleExA(uint dwFlags, const(PSTR) lpModuleName, ptrdiff_t* phModule);

///Retrieves a module handle for the specified module and increments the module's reference count unless
///GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT is specified. The module must have been loaded by the calling process.
///Params:
///    dwFlags = This parameter can be zero or one or more of the following values. If the module's reference count is
///              incremented, the caller must use the FreeLibrary function to decrement the reference count when the module handle
///              is no longer needed.
///    lpModuleName = The name of the loaded module (either a .dll or .exe file), or an address in the module (if <i>dwFlags</i> is
///                   GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS). For a module name, if the file name extension is omitted, the default
///                   library extension .dll is appended. The file name string can include a trailing point character (.) to indicate
///                   that the module name has no extension. The string does not have to specify a path. When specifying a path, be
///                   sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of
///                   modules currently mapped into the address space of the calling process. If this parameter is NULL, the function
///                   returns a handle to the file used to create the calling process (.exe file).
///    phModule = A handle to the specified module. If the function fails, this parameter is NULL. The <b>GetModuleHandleEx</b>
///               function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag.
///               For more information, see LoadLibraryEx.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, see GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetModuleHandleExW(uint dwFlags, const(PWSTR) lpModuleName, ptrdiff_t* phModule);

///Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).
///Params:
///    hModule = A handle to the DLL module that contains the function or variable. The LoadLibrary, LoadLibraryEx,
///              LoadPackagedLibrary, or GetModuleHandle function returns this handle. The <b>GetProcAddress</b> function does not
///              retrieve addresses from modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more
///              information, see LoadLibraryEx.
///    lpProcName = The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be
///                 in the low-order word; the high-order word must be zero.
///Returns:
///    If the function succeeds, the return value is the address of the exported function or variable. If the function
///    fails, the return value is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
FARPROC GetProcAddress(ptrdiff_t hModule, const(PSTR) lpProcName);

///Loads the specified module into the address space of the calling process. The specified module may cause other
///modules to be loaded.
///Params:
///    lpLibFileName = A string that specifies the file name of the module to load. This name is not related to the name stored in a
///                    library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. The
///                    module can be a library module (a .dll file) or an executable module (an .exe file). If the specified module is
///                    an executable module, static imports are not loaded; instead, the module is loaded as if
///                    <b>DONT_RESOLVE_DLL_REFERENCES</b> was specified. See the <i>dwFlags</i> parameter for more information. If the
///                    string specifies a module name without a path and the file name extension is omitted, the function appends the
///                    default library extension .dll to the module name. To prevent the function from appending .dll to the module
///                    name, include a trailing point character (.) in the module name string. If the string specifies a fully qualified
///                    path, the function searches only that path for the module. When specifying a path, be sure to use backslashes
///                    (\\), not forward slashes (/). For more information about paths, see Naming Files, Paths, and Namespaces. If the
///                    string specifies a module name without a path and more than one loaded module has the same base name and
///                    extension, the function returns a handle to the module that was loaded first. If the string specifies a module
///                    name without a path and a module of the same name is not already loaded, or if the string specifies a module name
///                    with a relative path, the function searches for the specified module. The function also searches for modules if
///                    loading the specified module causes the system to load other associated modules (that is, if the module has
///                    dependencies). The directories that are searched and the order in which they are searched depend on the specified
///                    path and the <i>dwFlags</i> parameter. For more information, see Remarks. If the function cannot find the module
///                    or one of its dependencies, the function fails.
///    hFile = This parameter is reserved for future use. It must be <b>NULL</b>.
///    dwFlags = The action to be taken when loading the module. If no flags are specified, the behavior of this function is
///              identical to that of the LoadLibrary function. This parameter can be one of the following values. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DONT_RESOLVE_DLL_REFERENCES"></a><a
///              id="dont_resolve_dll_references"></a><dl> <dt><b>DONT_RESOLVE_DLL_REFERENCES</b></dt> <dt>0x00000001</dt> </dl>
///              </td> <td width="60%"> If this value is used, and the executable module is a DLL, the system does not call
///              DllMain for process and thread initialization and termination. Also, the system does not load additional
///              executable modules that are referenced by the specified module. <div class="alert"><b>Note</b> Do not use this
///              value; it is provided only for backward compatibility. If you are planning to access only data or resources in
///              the DLL, use <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> or both.
///              Otherwise, load the library as a DLL or executable module using the LoadLibrary function.</div> <div> </div>
///              </td> </tr> <tr> <td width="40%"><a id="LOAD_IGNORE_CODE_AUTHZ_LEVEL"></a><a
///              id="load_ignore_code_authz_level"></a><dl> <dt><b>LOAD_IGNORE_CODE_AUTHZ_LEVEL</b></dt> <dt>0x00000010</dt> </dl>
///              </td> <td width="60%"> If this value is used, the system does not check AppLocker rules or apply Software
///              Restriction Policies for the DLL. This action applies only to the DLL being loaded and not to its dependencies.
///              This value is recommended for use in setup programs that must run extracted DLLs during installation. <b>Windows
///              Server 2008 R2 and Windows 7: </b>On systems with KB2532445 installed, the caller must be running as
///              "LocalSystem" or "TrustedInstaller"; otherwise the system ignores this flag. For more information, see "You can
///              circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server
///              2008 R2" in the Help and Support Knowledge Base at http://support.microsoft.com/kb/2532445. <b>Windows Server
///              2008, Windows Vista, Windows Server 2003 and Windows XP: </b>AppLocker was introduced in Windows 7 and Windows
///              Server 2008 R2. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_AS_DATAFILE"></a><a
///              id="load_library_as_datafile"></a><dl> <dt><b>LOAD_LIBRARY_AS_DATAFILE</b></dt> <dt>0x00000002</dt> </dl> </td>
///              <td width="60%"> If this value is used, the system maps the file into the calling process's virtual address space
///              as if it were a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you
///              cannot call functions like GetModuleFileName, GetModuleHandle or GetProcAddress with this DLL. Using this value
///              causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL only to
///              extract messages or resources from it. This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For
///              more information, see Remarks. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE"></a><a
///              id="load_library_as_datafile_exclusive"></a><dl> <dt><b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b></dt>
///              <dt>0x00000040</dt> </dl> </td> <td width="60%"> Similar to <b>LOAD_LIBRARY_AS_DATAFILE</b>, except that the DLL
///              file is opened with exclusive write access for the calling process. Other processes cannot open the DLL file for
///              write access while it is in use. However, the DLL can still be opened by other processes. This value can be used
///              with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information, see Remarks. <b>Windows Server 2003 and Windows
///              XP: </b>This value is not supported until Windows Vista. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_LIBRARY_AS_IMAGE_RESOURCE"></a><a id="load_library_as_image_resource"></a><dl>
///              <dt><b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> If this value is
///              used, the system maps the file into the process's virtual address space as an image file. However, the loader
///              does not load the static imports or perform the other usual initialization steps. Use this flag when you want to
///              load a DLL only to extract messages or resources from it. Unless the application depends on the file having the
///              in-memory layout of an image, this value should be used with either <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
///              <b>LOAD_LIBRARY_AS_DATAFILE</b>. For more information, see the Remarks section. <b>Windows Server 2003 and
///              Windows XP: </b>This value is not supported until Windows Vista. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_LIBRARY_SEARCH_APPLICATION_DIR"></a><a id="load_library_search_application_dir"></a><dl>
///              <dt><b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> If this
///              value is used, the application's installation directory is searched for the DLL and its dependencies. Directories
///              in the standard search path are not searched. This value cannot be combined with
///              <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server
///              2008: </b>This value requires KB2533623 to be installed. <b>Windows Server 2003 and Windows XP: </b>This value is
///              not supported. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_SEARCH_DEFAULT_DIRS"></a><a
///              id="load_library_search_default_dirs"></a><dl> <dt><b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b></dt>
///              <dt>0x00001000</dt> </dl> </td> <td width="60%"> This value is a combination of
///              <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>, <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
///              <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>. Directories in the standard search path are not searched. This value cannot
///              be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. This value represents the recommended maximum number of
///              directories an application should include in its DLL search path. <b>Windows 7, Windows Server 2008 R2, Windows
///              Vista and Windows Server 2008: </b>This value requires KB2533623 to be installed. <b>Windows Server 2003 and
///              Windows XP: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR"></a><a id="load_library_search_dll_load_dir"></a><dl>
///              <dt><b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> If this value
///              is used, the directory that contains the DLL is temporarily added to the beginning of the list of directories
///              that are searched for the DLL's dependencies. Directories in the standard search path are not searched. The
///              <i>lpFileName</i> parameter must specify a fully qualified path. This value cannot be combined with
///              <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading
///              Lib1.dll with this value causes the system to search for Lib2.dll only in C:\Dir1. To search for Lib2.dll in
///              C:\Dir1 and all of the directories in the DLL search path, combine this value with
///              <b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b>. <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server
///              2008: </b>This value requires KB2533623 to be installed. <b>Windows Server 2003 and Windows XP: </b>This value is
///              not supported. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_SEARCH_SYSTEM32"></a><a
///              id="load_library_search_system32"></a><dl> <dt><b>LOAD_LIBRARY_SEARCH_SYSTEM32</b></dt> <dt>0x00000800</dt> </dl>
///              </td> <td width="60%"> If this value is used, %windows%\system32 is searched for the DLL and its dependencies.
///              Directories in the standard search path are not searched. This value cannot be combined with
///              <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server
///              2008: </b>This value requires KB2533623 to be installed. <b>Windows Server 2003 and Windows XP: </b>This value is
///              not supported. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_SEARCH_USER_DIRS"></a><a
///              id="load_library_search_user_dirs"></a><dl> <dt><b>LOAD_LIBRARY_SEARCH_USER_DIRS</b></dt> <dt>0x00000400</dt>
///              </dl> </td> <td width="60%"> If this value is used, directories added using the AddDllDirectory or the
///              SetDllDirectory function are searched for the DLL and its dependencies. If more than one directory has been
///              added, the order in which the directories are searched is unspecified. Directories in the standard search path
///              are not searched. This value cannot be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. <b>Windows 7, Windows
///              Server 2008 R2, Windows Vista and Windows Server 2008: </b>This value requires KB2533623 to be installed.
///              <b>Windows Server 2003 and Windows XP: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_WITH_ALTERED_SEARCH_PATH"></a><a id="load_with_altered_search_path"></a><dl>
///              <dt><b>LOAD_WITH_ALTERED_SEARCH_PATH</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> If this value is
///              used and <i>lpFileName</i> specifies an absolute path, the system uses the alternate file search strategy
///              discussed in the Remarks section to find associated executable modules that the specified module causes to be
///              loaded. If this value is used and <i>lpFileName</i> specifies a relative path, the behavior is undefined. If this
///              value is not used, or if <i>lpFileName</i> does not specify a path, the system uses the standard search strategy
///              discussed in the Remarks section to find associated executable modules that the specified module causes to be
///              loaded. This value cannot be combined with any <b>LOAD_LIBRARY_SEARCH</b> flag. </td> </tr> <tr> <td
///              width="40%"><a id="LOAD_LIBRARY_REQUIRE_SIGNED_TARGET"></a><dl>
///              <dt><b>LOAD_LIBRARY_REQUIRE_SIGNED_TARGET</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> Specifies
///              that the digital signature of the binary image must be checked at load time. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_LIBRARY_SAFE_CURRENT_DIRS"></a><dl> <dt><b>LOAD_LIBRARY_SAFE_CURRENT_DIRS</b></dt> <dt>0x00002000</dt>
///              </dl> </td> <td width="60%"> If this value is used, loading a DLL for execution from the current directory is
///              only allowed if it is under a directory in the Safe load list. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to the loaded module. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t LoadLibraryExA(const(PSTR) lpLibFileName, HANDLE hFile, uint dwFlags);

///Loads the specified module into the address space of the calling process. The specified module may cause other
///modules to be loaded.
///Params:
///    lpLibFileName = A string that specifies the file name of the module to load. This name is not related to the name stored in a
///                    library module itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. The
///                    module can be a library module (a .dll file) or an executable module (an .exe file). If the specified module is
///                    an executable module, static imports are not loaded; instead, the module is loaded as if
///                    <b>DONT_RESOLVE_DLL_REFERENCES</b> was specified. See the <i>dwFlags</i> parameter for more information. If the
///                    string specifies a module name without a path and the file name extension is omitted, and the module name does
///                    not contain any point character (.), then the function appends the default library extension .dll to the module
///                    name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in
///                    the module name string. If the string specifies a fully qualified path, the function searches only that path for
///                    the module. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). For more
///                    information about paths, see Naming Files, Paths, and Namespaces. If the string specifies a module name without a
///                    path and more than one loaded module has the same base name and extension, the function returns a handle to the
///                    module that was loaded first. If the string specifies a module name without a path and a module of the same name
///                    is not already loaded, or if the string specifies a module name with a relative path, the function searches for
///                    the specified module. The function also searches for modules if loading the specified module causes the system to
///                    load other associated modules (that is, if the module has dependencies). The directories that are searched and
///                    the order in which they are searched depend on the specified path and the <i>dwFlags</i> parameter. For more
///                    information, see Remarks. If the function cannot find the module or one of its dependencies, the function fails.
///    hFile = This parameter is reserved for future use. It must be <b>NULL</b>.
///    dwFlags = The action to be taken when loading the module. If no flags are specified, the behavior of this function is
///              identical to that of the LoadLibrary function. This parameter can be one of the following values. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DONT_RESOLVE_DLL_REFERENCES"></a><a
///              id="dont_resolve_dll_references"></a><dl> <dt><b>DONT_RESOLVE_DLL_REFERENCES</b></dt> <dt>0x00000001</dt> </dl>
///              </td> <td width="60%"> If this value is used, and the executable module is a DLL, the system does not call
///              DllMain for process and thread initialization and termination. Also, the system does not load additional
///              executable modules that are referenced by the specified module. <div class="alert"><b>Note</b> Do not use this
///              value; it is provided only for backward compatibility. If you are planning to access only data or resources in
///              the DLL, use <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b> or both.
///              Otherwise, load the library as a DLL or executable module using the LoadLibrary function.</div> <div> </div>
///              </td> </tr> <tr> <td width="40%"><a id="LOAD_IGNORE_CODE_AUTHZ_LEVEL"></a><a
///              id="load_ignore_code_authz_level"></a><dl> <dt><b>LOAD_IGNORE_CODE_AUTHZ_LEVEL</b></dt> <dt>0x00000010</dt> </dl>
///              </td> <td width="60%"> If this value is used, the system does not check AppLocker rules or apply Software
///              Restriction Policies for the DLL. This action applies only to the DLL being loaded and not to its dependencies.
///              This value is recommended for use in setup programs that must run extracted DLLs during installation. <b>Windows
///              Server 2008 R2 and Windows 7: </b>On systems with KB2532445 installed, the caller must be running as
///              "LocalSystem" or "TrustedInstaller"; otherwise the system ignores this flag. For more information, see "You can
///              circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server
///              2008 R2" in the Help and Support Knowledge Base at http://support.microsoft.com/kb/2532445. <b>Windows Server
///              2008, Windows Vista, Windows Server 2003 and Windows XP: </b>AppLocker was introduced in Windows 7 and Windows
///              Server 2008 R2. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_AS_DATAFILE"></a><a
///              id="load_library_as_datafile"></a><dl> <dt><b>LOAD_LIBRARY_AS_DATAFILE</b></dt> <dt>0x00000002</dt> </dl> </td>
///              <td width="60%"> If this value is used, the system maps the file into the calling process's virtual address space
///              as if it were a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you
///              cannot call functions like GetModuleFileName, GetModuleHandle or GetProcAddress with this DLL. Using this value
///              causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL only to
///              extract messages or resources from it. This value can be used with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For
///              more information, see Remarks. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE"></a><a
///              id="load_library_as_datafile_exclusive"></a><dl> <dt><b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b></dt>
///              <dt>0x00000040</dt> </dl> </td> <td width="60%"> Similar to <b>LOAD_LIBRARY_AS_DATAFILE</b>, except that the DLL
///              file is opened with exclusive write access for the calling process. Other processes cannot open the DLL file for
///              write access while it is in use. However, the DLL can still be opened by other processes. This value can be used
///              with <b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b>. For more information, see Remarks. <b>Windows Server 2003 and Windows
///              XP: </b>This value is not supported until Windows Vista. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_LIBRARY_AS_IMAGE_RESOURCE"></a><a id="load_library_as_image_resource"></a><dl>
///              <dt><b>LOAD_LIBRARY_AS_IMAGE_RESOURCE</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> If this value is
///              used, the system maps the file into the process's virtual address space as an image file. However, the loader
///              does not load the static imports or perform the other usual initialization steps. Use this flag when you want to
///              load a DLL only to extract messages or resources from it. Unless the application depends on the file having the
///              in-memory layout of an image, this value should be used with either <b>LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE</b> or
///              <b>LOAD_LIBRARY_AS_DATAFILE</b>. For more information, see the Remarks section. <b>Windows Server 2003 and
///              Windows XP: </b>This value is not supported until Windows Vista. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_LIBRARY_SEARCH_APPLICATION_DIR"></a><a id="load_library_search_application_dir"></a><dl>
///              <dt><b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> If this
///              value is used, the application's installation directory is searched for the DLL and its dependencies. Directories
///              in the standard search path are not searched. This value cannot be combined with
///              <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server
///              2008: </b>This value requires KB2533623 to be installed. <b>Windows Server 2003 and Windows XP: </b>This value is
///              not supported. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_SEARCH_DEFAULT_DIRS"></a><a
///              id="load_library_search_default_dirs"></a><dl> <dt><b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b></dt>
///              <dt>0x00001000</dt> </dl> </td> <td width="60%"> This value is a combination of
///              <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>, <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
///              <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>. Directories in the standard search path are not searched. This value cannot
///              be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. This value represents the recommended maximum number of
///              directories an application should include in its DLL search path. <b>Windows 7, Windows Server 2008 R2, Windows
///              Vista and Windows Server 2008: </b>This value requires KB2533623 to be installed. <b>Windows Server 2003 and
///              Windows XP: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR"></a><a id="load_library_search_dll_load_dir"></a><dl>
///              <dt><b>LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> If this value
///              is used, the directory that contains the DLL is temporarily added to the beginning of the list of directories
///              that are searched for the DLL's dependencies. Directories in the standard search path are not searched. The
///              <i>lpFileName</i> parameter must specify a fully qualified path. This value cannot be combined with
///              <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading
///              Lib1.dll with this value causes the system to search for Lib2.dll only in C:\Dir1. To search for Lib2.dll in
///              C:\Dir1 and all of the directories in the DLL search path, combine this value with
///              <b>LOAD_LIBRARY_DEFAULT_DIRS</b>. <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server 2008:
///              </b>This value requires KB2533623 to be installed. <b>Windows Server 2003 and Windows XP: </b>This value is not
///              supported. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_SEARCH_SYSTEM32"></a><a
///              id="load_library_search_system32"></a><dl> <dt><b>LOAD_LIBRARY_SEARCH_SYSTEM32</b></dt> <dt>0x00000800</dt> </dl>
///              </td> <td width="60%"> If this value is used, %windows%\system32 is searched for the DLL and its dependencies.
///              Directories in the standard search path are not searched. This value cannot be combined with
///              <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. <b>Windows 7, Windows Server 2008 R2, Windows Vista and Windows Server
///              2008: </b>This value requires KB2533623 to be installed. <b>Windows Server 2003 and Windows XP: </b>This value is
///              not supported. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_SEARCH_USER_DIRS"></a><a
///              id="load_library_search_user_dirs"></a><dl> <dt><b>LOAD_LIBRARY_SEARCH_USER_DIRS</b></dt> <dt>0x00000400</dt>
///              </dl> </td> <td width="60%"> If this value is used, directories added using the AddDllDirectory or the
///              SetDllDirectory function are searched for the DLL and its dependencies. If more than one directory has been
///              added, the order in which the directories are searched is unspecified. Directories in the standard search path
///              are not searched. This value cannot be combined with <b>LOAD_WITH_ALTERED_SEARCH_PATH</b>. <b>Windows 7, Windows
///              Server 2008 R2, Windows Vista and Windows Server 2008: </b>This value requires KB2533623 to be installed.
///              <b>Windows Server 2003 and Windows XP: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_WITH_ALTERED_SEARCH_PATH"></a><a id="load_with_altered_search_path"></a><dl>
///              <dt><b>LOAD_WITH_ALTERED_SEARCH_PATH</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> If this value is
///              used and <i>lpFileName</i> specifies an absolute path, the system uses the alternate file search strategy
///              discussed in the Remarks section to find associated executable modules that the specified module causes to be
///              loaded. If this value is used and <i>lpFileName</i> specifies a relative path, the behavior is undefined. If this
///              value is not used, or if <i>lpFileName</i> does not specify a path, the system uses the standard search strategy
///              discussed in the Remarks section to find associated executable modules that the specified module causes to be
///              loaded. This value cannot be combined with any <b>LOAD_LIBRARY_SEARCH</b> flag. </td> </tr> <tr> <td
///              width="40%"><a id="LOAD_LIBRARY_REQUIRE_SIGNED_TARGET"></a><dl>
///              <dt><b>LOAD_LIBRARY_REQUIRE_SIGNED_TARGET</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> Specifies
///              that the digital signature of the binary image must be checked at load time. </td> </tr> <tr> <td width="40%"><a
///              id="LOAD_LIBRARY_SAFE_CURRENT_DIRS"></a><dl> <dt><b>LOAD_LIBRARY_SAFE_CURRENT_DIRS</b></dt> <dt>0x00002000</dt>
///              </dl> </td> <td width="60%"> If this value is used, loading a DLL for execution from the current directory is
///              only allowed if it is under a directory in the Safe load list. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to the loaded module. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t LoadLibraryExW(const(PWSTR) lpLibFileName, HANDLE hFile, uint dwFlags);

///Adds a directory to the process DLL search path.
///Params:
///    NewDirectory = An absolute path to the directory to add to the search path. For example, to add the directory Dir2 to the
///                   process DLL search path, specify \Dir2. For more information about paths, see Naming Files, Paths, and
///                   Namespaces.
///Returns:
///    If the function succeeds, the return value is an opaque pointer that can be passed to RemoveDllDirectory to
///    remove the DLL from the process DLL search path. If the function fails, the return value is zero. To get extended
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* AddDllDirectory(const(PWSTR) NewDirectory);

///Removes a directory that was added to the process DLL search path by using AddDllDirectory.
///Params:
///    Cookie = The cookie returned by AddDllDirectory when the directory was added to the search path.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL RemoveDllDirectory(void* Cookie);

///Specifies a default set of directories to search when the calling process loads a DLL. This search path is used when
///LoadLibraryEx is called with no <b>LOAD_LIBRARY_SEARCH</b> flags.
///Params:
///    DirectoryFlags = The directories to search. This parameter can be any combination of the following values. <table> <tr>
///                     <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_SEARCH_APPLICATION_DIR"></a><a
///                     id="load_library_search_application_dir"></a><dl> <dt><b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b></dt>
///                     <dt>0x00000200</dt> </dl> </td> <td width="60%"> If this value is used, the application's installation directory
///                     is searched. </td> </tr> <tr> <td width="40%"><a id="LOAD_LIBRARY_SEARCH_DEFAULT_DIRS"></a><a
///                     id="load_library_search_default_dirs"></a><dl> <dt><b>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</b></dt>
///                     <dt>0x00001000</dt> </dl> </td> <td width="60%"> This value is a combination of
///                     <b>LOAD_LIBRARY_SEARCH_APPLICATION_DIR</b>, <b>LOAD_LIBRARY_SEARCH_SYSTEM32</b>, and
///                     <b>LOAD_LIBRARY_SEARCH_USER_DIRS</b>. This value represents the recommended maximum number of directories an
///                     application should include in its DLL search path. </td> </tr> <tr> <td width="40%"><a
///                     id="LOAD_LIBRARY_SEARCH_SYSTEM32"></a><a id="load_library_search_system32"></a><dl>
///                     <dt><b>LOAD_LIBRARY_SEARCH_SYSTEM32</b></dt> <dt>0x00000800</dt> </dl> </td> <td width="60%"> If this value is
///                     used, %windows%\system32 is searched. </td> </tr> <tr> <td width="40%"><a
///                     id="LOAD_LIBRARY_SEARCH_USER_DIRS"></a><a id="load_library_search_user_dirs"></a><dl>
///                     <dt><b>LOAD_LIBRARY_SEARCH_USER_DIRS</b></dt> <dt>0x00000400</dt> </dl> </td> <td width="60%"> If this value is
///                     used, any path explicitly added using the AddDllDirectory or SetDllDirectory function is searched. If more than
///                     one directory has been added, the order in which those directories are searched is unspecified. </td> </tr>
///                     </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetDefaultDllDirectories(uint DirectoryFlags);

@DllImport("KERNEL32")
HRSRC FindResourceW(ptrdiff_t hModule, const(PWSTR) lpName, const(PWSTR) lpType);

///Loads the specified module into the address space of the calling process. The specified module may cause other
///modules to be loaded. For additional load options, use the LoadLibraryEx function.
///Params:
///    lpLibFileName = The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file).
///                    The name specified is the file name of the module and is not related to the name stored in the library module
///                    itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. If the string specifies
///                    a full path, the function searches only that path for the module. If the string specifies a relative path or a
///                    module name without a path, the function uses a standard search strategy to find the module; for more
///                    information, see the Remarks. If the function cannot find the module, the function fails. When specifying a path,
///                    be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see Naming a File or
///                    Directory. If the string specifies a module name without a path and the file name extension is omitted, the
///                    function appends the default library extension .dll to the module name. To prevent the function from appending
///                    .dll to the module name, include a trailing point character (.) in the module name string.
///Returns:
///    If the function succeeds, the return value is a handle to the module. If the function fails, the return value is
///    NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t LoadLibraryA(const(PSTR) lpLibFileName);

///Loads the specified module into the address space of the calling process. The specified module may cause other
///modules to be loaded. For additional load options, use the LoadLibraryEx function.
///Params:
///    lpLibFileName = The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file).
///                    The name specified is the file name of the module and is not related to the name stored in the library module
///                    itself, as specified by the <b>LIBRARY</b> keyword in the module-definition (.def) file. If the string specifies
///                    a full path, the function searches only that path for the module. If the string specifies a relative path or a
///                    module name without a path, the function uses a standard search strategy to find the module; for more
///                    information, see the Remarks. If the function cannot find the module, the function fails. When specifying a path,
///                    be sure to use backslashes (\\), not forward slashes (/). For more information about paths, see Naming a File or
///                    Directory. If the string specifies a module name without a path and the file name extension is omitted, the
///                    function appends the default library extension .dll to the module name. To prevent the function from appending
///                    .dll to the module name, include a trailing point character (.) in the module name string.
///Returns:
///    If the function succeeds, the return value is a handle to the module. If the function fails, the return value is
///    NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t LoadLibraryW(const(PWSTR) lpLibFileName);

@DllImport("KERNEL32")
BOOL EnumResourceNamesW(ptrdiff_t hModule, const(PWSTR) lpType, ENUMRESNAMEPROCW lpEnumFunc, ptrdiff_t lParam);

@DllImport("KERNEL32")
BOOL AllocConsole();

@DllImport("KERNEL32")
BOOL FreeConsole();

@DllImport("KERNEL32")
BOOL AttachConsole(uint dwProcessId);

@DllImport("KERNEL32")
uint GetConsoleCP();

@DllImport("KERNEL32")
uint GetConsoleOutputCP();

@DllImport("KERNEL32")
BOOL GetConsoleMode(HANDLE hConsoleHandle, ConsoleMode* lpMode);

@DllImport("KERNEL32")
BOOL SetConsoleMode(HANDLE hConsoleHandle, ConsoleMode dwMode);

@DllImport("KERNEL32")
BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, uint* lpNumberOfEvents);

@DllImport("KERNEL32")
BOOL ReadConsoleInputA(HANDLE hConsoleInput, INPUT_RECORD* lpBuffer, uint nLength, uint* lpNumberOfEventsRead);

@DllImport("KERNEL32")
BOOL ReadConsoleInputW(HANDLE hConsoleInput, INPUT_RECORD* lpBuffer, uint nLength, uint* lpNumberOfEventsRead);

@DllImport("KERNEL32")
BOOL PeekConsoleInputA(HANDLE hConsoleInput, INPUT_RECORD* lpBuffer, uint nLength, uint* lpNumberOfEventsRead);

@DllImport("KERNEL32")
BOOL PeekConsoleInputW(HANDLE hConsoleInput, INPUT_RECORD* lpBuffer, uint nLength, uint* lpNumberOfEventsRead);

@DllImport("KERNEL32")
BOOL ReadConsoleA(HANDLE hConsoleInput, void* lpBuffer, uint nNumberOfCharsToRead, uint* lpNumberOfCharsRead, 
                  CONSOLE_READCONSOLE_CONTROL* pInputControl);

@DllImport("KERNEL32")
BOOL ReadConsoleW(HANDLE hConsoleInput, void* lpBuffer, uint nNumberOfCharsToRead, uint* lpNumberOfCharsRead, 
                  CONSOLE_READCONSOLE_CONTROL* pInputControl);

@DllImport("KERNEL32")
BOOL WriteConsoleA(HANDLE hConsoleOutput, const(void)* lpBuffer, uint nNumberOfCharsToWrite, 
                   uint* lpNumberOfCharsWritten, void* lpReserved);

@DllImport("KERNEL32")
BOOL WriteConsoleW(HANDLE hConsoleOutput, const(void)* lpBuffer, uint nNumberOfCharsToWrite, 
                   uint* lpNumberOfCharsWritten, void* lpReserved);

@DllImport("KERNEL32")
BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);

@DllImport("KERNEL32")
HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, uint dwFlags, void** phPC);

@DllImport("KERNEL32")
HRESULT ResizePseudoConsole(void* hPC, COORD size);

@DllImport("KERNEL32")
void ClosePseudoConsole(void* hPC);

@DllImport("KERNEL32")
BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, byte cCharacter, uint nLength, COORD dwWriteCoord, 
                                 uint* lpNumberOfCharsWritten);

@DllImport("KERNEL32")
BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, ushort cCharacter, uint nLength, COORD dwWriteCoord, 
                                 uint* lpNumberOfCharsWritten);

@DllImport("KERNEL32")
BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, ushort wAttribute, uint nLength, COORD dwWriteCoord, 
                                uint* lpNumberOfAttrsWritten);

@DllImport("KERNEL32")
BOOL GenerateConsoleCtrlEvent(uint dwCtrlEvent, uint dwProcessGroupId);

@DllImport("KERNEL32")
HANDLE CreateConsoleScreenBuffer(uint dwDesiredAccess, uint dwShareMode, 
                                 const(SECURITY_ATTRIBUTES)* lpSecurityAttributes, uint dwFlags, 
                                 void* lpScreenBufferData);

@DllImport("KERNEL32")
BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput);

@DllImport("KERNEL32")
BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput);

@DllImport("KERNEL32")
BOOL SetConsoleCP(uint wCodePageID);

@DllImport("KERNEL32")
BOOL SetConsoleOutputCP(uint wCodePageID);

@DllImport("KERNEL32")
BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, CONSOLE_CURSOR_INFO* lpConsoleCursorInfo);

@DllImport("KERNEL32")
BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const(CONSOLE_CURSOR_INFO)* lpConsoleCursorInfo);

@DllImport("KERNEL32")
BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO* lpConsoleScreenBufferInfo);

@DllImport("KERNEL32")
BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFOEX* lpConsoleScreenBufferInfoEx);

@DllImport("KERNEL32")
BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFOEX* lpConsoleScreenBufferInfoEx);

@DllImport("KERNEL32")
BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize);

@DllImport("KERNEL32")
BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition);

@DllImport("KERNEL32")
COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput);

@DllImport("KERNEL32")
BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, ushort wAttributes);

@DllImport("KERNEL32")
BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const(SMALL_RECT)* lpConsoleWindow);

@DllImport("KERNEL32")
BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, const(PSTR) lpCharacter, uint nLength, COORD dwWriteCoord, 
                                  uint* lpNumberOfCharsWritten);

@DllImport("KERNEL32")
BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, const(PWSTR) lpCharacter, uint nLength, 
                                  COORD dwWriteCoord, uint* lpNumberOfCharsWritten);

@DllImport("KERNEL32")
BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const(ushort)* lpAttribute, uint nLength, 
                                 COORD dwWriteCoord, uint* lpNumberOfAttrsWritten);

@DllImport("KERNEL32")
BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, PSTR lpCharacter, uint nLength, COORD dwReadCoord, 
                                 uint* lpNumberOfCharsRead);

@DllImport("KERNEL32")
BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, PWSTR lpCharacter, uint nLength, COORD dwReadCoord, 
                                 uint* lpNumberOfCharsRead);

@DllImport("KERNEL32")
BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, ushort* lpAttribute, uint nLength, COORD dwReadCoord, 
                                uint* lpNumberOfAttrsRead);

@DllImport("KERNEL32")
BOOL WriteConsoleInputA(HANDLE hConsoleInput, const(INPUT_RECORD)* lpBuffer, uint nLength, 
                        uint* lpNumberOfEventsWritten);

@DllImport("KERNEL32")
BOOL WriteConsoleInputW(HANDLE hConsoleInput, const(INPUT_RECORD)* lpBuffer, uint nLength, 
                        uint* lpNumberOfEventsWritten);

@DllImport("KERNEL32")
BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const(SMALL_RECT)* lpScrollRectangle, 
                                const(SMALL_RECT)* lpClipRectangle, COORD dwDestinationOrigin, 
                                const(CHAR_INFO)* lpFill);

@DllImport("KERNEL32")
BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const(SMALL_RECT)* lpScrollRectangle, 
                                const(SMALL_RECT)* lpClipRectangle, COORD dwDestinationOrigin, 
                                const(CHAR_INFO)* lpFill);

@DllImport("KERNEL32")
BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const(CHAR_INFO)* lpBuffer, COORD dwBufferSize, 
                         COORD dwBufferCoord, SMALL_RECT* lpWriteRegion);

@DllImport("KERNEL32")
BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const(CHAR_INFO)* lpBuffer, COORD dwBufferSize, 
                         COORD dwBufferCoord, SMALL_RECT* lpWriteRegion);

@DllImport("KERNEL32")
BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, CHAR_INFO* lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, 
                        SMALL_RECT* lpReadRegion);

@DllImport("KERNEL32")
BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, CHAR_INFO* lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, 
                        SMALL_RECT* lpReadRegion);

@DllImport("KERNEL32")
uint GetConsoleTitleA(PSTR lpConsoleTitle, uint nSize);

@DllImport("KERNEL32")
uint GetConsoleTitleW(PWSTR lpConsoleTitle, uint nSize);

@DllImport("KERNEL32")
uint GetConsoleOriginalTitleA(PSTR lpConsoleTitle, uint nSize);

@DllImport("KERNEL32")
uint GetConsoleOriginalTitleW(PWSTR lpConsoleTitle, uint nSize);

@DllImport("KERNEL32")
BOOL SetConsoleTitleA(const(PSTR) lpConsoleTitle);

@DllImport("KERNEL32")
BOOL SetConsoleTitleW(const(PWSTR) lpConsoleTitle);

@DllImport("KERNEL32")
BOOL GetNumberOfConsoleMouseButtons(uint* lpNumberOfMouseButtons);

@DllImport("KERNEL32")
COORD GetConsoleFontSize(HANDLE hConsoleOutput, uint nFont);

@DllImport("KERNEL32")
BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, CONSOLE_FONT_INFO* lpConsoleCurrentFont);

@DllImport("KERNEL32")
BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, 
                             CONSOLE_FONT_INFOEX* lpConsoleCurrentFontEx);

@DllImport("KERNEL32")
BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, 
                             CONSOLE_FONT_INFOEX* lpConsoleCurrentFontEx);

@DllImport("KERNEL32")
BOOL GetConsoleSelectionInfo(CONSOLE_SELECTION_INFO* lpConsoleSelectionInfo);

@DllImport("KERNEL32")
BOOL GetConsoleHistoryInfo(CONSOLE_HISTORY_INFO* lpConsoleHistoryInfo);

@DllImport("KERNEL32")
BOOL SetConsoleHistoryInfo(CONSOLE_HISTORY_INFO* lpConsoleHistoryInfo);

@DllImport("KERNEL32")
BOOL GetConsoleDisplayMode(uint* lpModeFlags);

@DllImport("KERNEL32")
BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, uint dwFlags, COORD* lpNewScreenBufferDimensions);

@DllImport("KERNEL32")
HWND GetConsoleWindow();

@DllImport("KERNEL32")
BOOL AddConsoleAliasA(PSTR Source, PSTR Target, PSTR ExeName);

@DllImport("KERNEL32")
BOOL AddConsoleAliasW(PWSTR Source, PWSTR Target, PWSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleAliasA(PSTR Source, PSTR TargetBuffer, uint TargetBufferLength, PSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleAliasW(PWSTR Source, PWSTR TargetBuffer, uint TargetBufferLength, PWSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleAliasesLengthA(PSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleAliasesLengthW(PWSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleAliasExesLengthA();

@DllImport("KERNEL32")
uint GetConsoleAliasExesLengthW();

@DllImport("KERNEL32")
uint GetConsoleAliasesA(PSTR AliasBuffer, uint AliasBufferLength, PSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleAliasesW(PWSTR AliasBuffer, uint AliasBufferLength, PWSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleAliasExesA(PSTR ExeNameBuffer, uint ExeNameBufferLength);

@DllImport("KERNEL32")
uint GetConsoleAliasExesW(PWSTR ExeNameBuffer, uint ExeNameBufferLength);

@DllImport("KERNEL32")
void ExpungeConsoleCommandHistoryA(PSTR ExeName);

@DllImport("KERNEL32")
void ExpungeConsoleCommandHistoryW(PWSTR ExeName);

@DllImport("KERNEL32")
BOOL SetConsoleNumberOfCommandsA(uint Number, PSTR ExeName);

@DllImport("KERNEL32")
BOOL SetConsoleNumberOfCommandsW(uint Number, PWSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleCommandHistoryLengthA(PSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleCommandHistoryLengthW(PWSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleCommandHistoryA(PSTR Commands, uint CommandBufferLength, PSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleCommandHistoryW(PWSTR Commands, uint CommandBufferLength, PWSTR ExeName);

@DllImport("KERNEL32")
uint GetConsoleProcessList(uint* lpdwProcessList, uint dwProcessCount);

@DllImport("WINMM")
uint timeSetEvent(uint uDelay, uint uResolution, LPTIMECALLBACK fptc, size_t dwUser, uint fuEvent);

@DllImport("WINMM")
uint timeKillEvent(uint uTimerID);

@DllImport("RPCNS4")
int I_RpcNsGetBuffer(RPC_MESSAGE* Message);

@DllImport("RPCNS4")
int I_RpcNsSendReceive(RPC_MESSAGE* Message, void** Handle);

@DllImport("RPCNS4")
void I_RpcNsRaiseException(RPC_MESSAGE* Message, int Status);

@DllImport("RPCNS4")
int I_RpcReBindBuffer(RPC_MESSAGE* Message);

@DllImport("WINSPOOL")
BOOL EnumPrintersA(uint Flags, PSTR Name, uint Level, ubyte* pPrinterEnum, uint cbBuf, uint* pcbNeeded, 
                   uint* pcReturned);

@DllImport("WINSPOOL")
BOOL EnumPrintersW(uint Flags, PWSTR Name, uint Level, ubyte* pPrinterEnum, uint cbBuf, uint* pcbNeeded, 
                   uint* pcReturned);

@DllImport("WINSPOOL")
HANDLE GetSpoolFileHandle(HANDLE hPrinter);

@DllImport("WINSPOOL")
HANDLE CommitSpoolData(HANDLE hPrinter, HANDLE hSpoolFile, uint cbCommit);

@DllImport("WINSPOOL")
BOOL CloseSpoolFileHandle(HANDLE hPrinter, HANDLE hSpoolFile);

@DllImport("WINSPOOL")
BOOL OpenPrinterA(PSTR pPrinterName, HANDLE* phPrinter, PRINTER_DEFAULTSA* pDefault);

@DllImport("WINSPOOL")
BOOL OpenPrinterW(PWSTR pPrinterName, HANDLE* phPrinter, PRINTER_DEFAULTSW* pDefault);

@DllImport("WINSPOOL")
BOOL ResetPrinterA(HANDLE hPrinter, PRINTER_DEFAULTSA* pDefault);

@DllImport("SPOOLSS")
BOOL ResetPrinterW(HANDLE hPrinter, PRINTER_DEFAULTSW* pDefault);

@DllImport("WINSPOOL")
BOOL SetJobA(HANDLE hPrinter, uint JobId, uint Level, ubyte* pJob, uint Command);

@DllImport("WINSPOOL")
BOOL SetJobW(HANDLE hPrinter, uint JobId, uint Level, ubyte* pJob, uint Command);

@DllImport("WINSPOOL")
BOOL GetJobA(HANDLE hPrinter, uint JobId, uint Level, ubyte* pJob, uint cbBuf, uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL GetJobW(HANDLE hPrinter, uint JobId, uint Level, ubyte* pJob, uint cbBuf, uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL EnumJobsA(HANDLE hPrinter, uint FirstJob, uint NoJobs, uint Level, ubyte* pJob, uint cbBuf, uint* pcbNeeded, 
               uint* pcReturned);

@DllImport("WINSPOOL")
BOOL EnumJobsW(HANDLE hPrinter, uint FirstJob, uint NoJobs, uint Level, ubyte* pJob, uint cbBuf, uint* pcbNeeded, 
               uint* pcReturned);

@DllImport("WINSPOOL")
HANDLE AddPrinterA(PSTR pName, uint Level, ubyte* pPrinter);

@DllImport("WINSPOOL")
HANDLE AddPrinterW(PWSTR pName, uint Level, ubyte* pPrinter);

@DllImport("WINSPOOL")
BOOL DeletePrinter(HANDLE hPrinter);

@DllImport("WINSPOOL")
BOOL SetPrinterA(HANDLE hPrinter, uint Level, ubyte* pPrinter, uint Command);

@DllImport("WINSPOOL")
BOOL SetPrinterW(HANDLE hPrinter, uint Level, ubyte* pPrinter, uint Command);

@DllImport("WINSPOOL")
BOOL GetPrinterA(HANDLE hPrinter, uint Level, ubyte* pPrinter, uint cbBuf, uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL GetPrinterW(HANDLE hPrinter, uint Level, ubyte* pPrinter, uint cbBuf, uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL AddPrinterDriverA(PSTR pName, uint Level, ubyte* pDriverInfo);

@DllImport("SPOOLSS")
BOOL AddPrinterDriverW(PWSTR pName, uint Level, ubyte* pDriverInfo);

@DllImport("WINSPOOL")
BOOL AddPrinterDriverExA(PSTR pName, uint Level, ubyte* lpbDriverInfo, uint dwFileCopyFlags);

@DllImport("SPOOLSS")
BOOL AddPrinterDriverExW(PWSTR pName, uint Level, ubyte* lpbDriverInfo, uint dwFileCopyFlags);

@DllImport("WINSPOOL")
BOOL EnumPrinterDriversA(PSTR pName, PSTR pEnvironment, uint Level, ubyte* pDriverInfo, uint cbBuf, 
                         uint* pcbNeeded, uint* pcReturned);

@DllImport("WINSPOOL")
BOOL EnumPrinterDriversW(PWSTR pName, PWSTR pEnvironment, uint Level, ubyte* pDriverInfo, uint cbBuf, 
                         uint* pcbNeeded, uint* pcReturned);

@DllImport("WINSPOOL")
BOOL GetPrinterDriverA(HANDLE hPrinter, PSTR pEnvironment, uint Level, ubyte* pDriverInfo, uint cbBuf, 
                       uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL GetPrinterDriverW(HANDLE hPrinter, PWSTR pEnvironment, uint Level, ubyte* pDriverInfo, uint cbBuf, 
                       uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL GetPrinterDriverDirectoryA(PSTR pName, PSTR pEnvironment, uint Level, ubyte* pDriverDirectory, uint cbBuf, 
                                uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL GetPrinterDriverDirectoryW(PWSTR pName, PWSTR pEnvironment, uint Level, ubyte* pDriverDirectory, uint cbBuf, 
                                uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL DeletePrinterDriverA(PSTR pName, PSTR pEnvironment, PSTR pDriverName);

@DllImport("SPOOLSS")
BOOL DeletePrinterDriverW(PWSTR pName, PWSTR pEnvironment, PWSTR pDriverName);

@DllImport("WINSPOOL")
BOOL DeletePrinterDriverExA(PSTR pName, PSTR pEnvironment, PSTR pDriverName, uint dwDeleteFlag, uint dwVersionFlag);

@DllImport("SPOOLSS")
BOOL DeletePrinterDriverExW(PWSTR pName, PWSTR pEnvironment, PWSTR pDriverName, uint dwDeleteFlag, 
                            uint dwVersionFlag);

@DllImport("WINSPOOL")
BOOL AddPrintProcessorA(PSTR pName, PSTR pEnvironment, PSTR pPathName, PSTR pPrintProcessorName);

@DllImport("SPOOLSS")
BOOL AddPrintProcessorW(PWSTR pName, PWSTR pEnvironment, PWSTR pPathName, PWSTR pPrintProcessorName);

@DllImport("WINSPOOL")
BOOL EnumPrintProcessorsA(PSTR pName, PSTR pEnvironment, uint Level, ubyte* pPrintProcessorInfo, uint cbBuf, 
                          uint* pcbNeeded, uint* pcReturned);

@DllImport("SPOOLSS")
BOOL EnumPrintProcessorsW(PWSTR pName, PWSTR pEnvironment, uint Level, ubyte* pPrintProcessorInfo, uint cbBuf, 
                          uint* pcbNeeded, uint* pcReturned);

@DllImport("WINSPOOL")
BOOL GetPrintProcessorDirectoryA(PSTR pName, PSTR pEnvironment, uint Level, ubyte* pPrintProcessorInfo, uint cbBuf, 
                                 uint* pcbNeeded);

@DllImport("SPOOLSS")
BOOL GetPrintProcessorDirectoryW(PWSTR pName, PWSTR pEnvironment, uint Level, ubyte* pPrintProcessorInfo, 
                                 uint cbBuf, uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL EnumPrintProcessorDatatypesA(PSTR pName, PSTR pPrintProcessorName, uint Level, ubyte* pDatatypes, uint cbBuf, 
                                  uint* pcbNeeded, uint* pcReturned);

@DllImport("SPOOLSS")
BOOL EnumPrintProcessorDatatypesW(PWSTR pName, PWSTR pPrintProcessorName, uint Level, ubyte* pDatatypes, 
                                  uint cbBuf, uint* pcbNeeded, uint* pcReturned);

@DllImport("WINSPOOL")
BOOL DeletePrintProcessorA(PSTR pName, PSTR pEnvironment, PSTR pPrintProcessorName);

@DllImport("SPOOLSS")
BOOL DeletePrintProcessorW(PWSTR pName, PWSTR pEnvironment, PWSTR pPrintProcessorName);

@DllImport("WINSPOOL")
uint StartDocPrinterA(HANDLE hPrinter, uint Level, ubyte* pDocInfo);

@DllImport("WINSPOOL")
uint StartDocPrinterW(HANDLE hPrinter, uint Level, ubyte* pDocInfo);

@DllImport("SPOOLSS")
BOOL StartPagePrinter(HANDLE hPrinter);

@DllImport("WINSPOOL")
BOOL WritePrinter(HANDLE hPrinter, void* pBuf, uint cbBuf, uint* pcWritten);

@DllImport("SPOOLSS")
BOOL FlushPrinter(HANDLE hPrinter, void* pBuf, uint cbBuf, uint* pcWritten, uint cSleep);

@DllImport("SPOOLSS")
BOOL EndPagePrinter(HANDLE hPrinter);

@DllImport("WINSPOOL")
BOOL AbortPrinter(HANDLE hPrinter);

@DllImport("SPOOLSS")
BOOL ReadPrinter(HANDLE hPrinter, void* pBuf, uint cbBuf, uint* pNoBytesRead);

@DllImport("WINSPOOL")
BOOL EndDocPrinter(HANDLE hPrinter);

@DllImport("WINSPOOL")
BOOL AddJobA(HANDLE hPrinter, uint Level, ubyte* pData, uint cbBuf, uint* pcbNeeded);

@DllImport("SPOOLSS")
BOOL AddJobW(HANDLE hPrinter, uint Level, ubyte* pData, uint cbBuf, uint* pcbNeeded);

@DllImport("SPOOLSS")
BOOL ScheduleJob(HANDLE hPrinter, uint JobId);

@DllImport("WINSPOOL")
BOOL PrinterProperties(HWND hWnd, HANDLE hPrinter);

@DllImport("WINSPOOL")
int DocumentPropertiesA(HWND hWnd, HANDLE hPrinter, PSTR pDeviceName, DEVMODEA* pDevModeOutput, 
                        DEVMODEA* pDevModeInput, uint fMode);

@DllImport("WINSPOOL")
int DocumentPropertiesW(HWND hWnd, HANDLE hPrinter, PWSTR pDeviceName, DEVMODEW* pDevModeOutput, 
                        DEVMODEW* pDevModeInput, uint fMode);

@DllImport("WINSPOOL")
int AdvancedDocumentPropertiesA(HWND hWnd, HANDLE hPrinter, PSTR pDeviceName, DEVMODEA* pDevModeOutput, 
                                DEVMODEA* pDevModeInput);

@DllImport("WINSPOOL")
int AdvancedDocumentPropertiesW(HWND hWnd, HANDLE hPrinter, PWSTR pDeviceName, DEVMODEW* pDevModeOutput, 
                                DEVMODEW* pDevModeInput);

@DllImport("WINSPOOL")
uint GetPrinterDataA(HANDLE hPrinter, PSTR pValueName, uint* pType, ubyte* pData, uint nSize, uint* pcbNeeded);

@DllImport("WINSPOOL")
uint GetPrinterDataW(HANDLE hPrinter, PWSTR pValueName, uint* pType, ubyte* pData, uint nSize, uint* pcbNeeded);

@DllImport("WINSPOOL")
uint GetPrinterDataExA(HANDLE hPrinter, const(PSTR) pKeyName, const(PSTR) pValueName, uint* pType, ubyte* pData, 
                       uint nSize, uint* pcbNeeded);

@DllImport("WINSPOOL")
uint GetPrinterDataExW(HANDLE hPrinter, const(PWSTR) pKeyName, const(PWSTR) pValueName, uint* pType, ubyte* pData, 
                       uint nSize, uint* pcbNeeded);

@DllImport("WINSPOOL")
uint EnumPrinterDataA(HANDLE hPrinter, uint dwIndex, PSTR pValueName, uint cbValueName, uint* pcbValueName, 
                      uint* pType, ubyte* pData, uint cbData, uint* pcbData);

@DllImport("SPOOLSS")
uint EnumPrinterDataW(HANDLE hPrinter, uint dwIndex, PWSTR pValueName, uint cbValueName, uint* pcbValueName, 
                      uint* pType, ubyte* pData, uint cbData, uint* pcbData);

@DllImport("WINSPOOL")
uint EnumPrinterDataExA(HANDLE hPrinter, const(PSTR) pKeyName, ubyte* pEnumValues, uint cbEnumValues, 
                        uint* pcbEnumValues, uint* pnEnumValues);

@DllImport("SPOOLSS")
uint EnumPrinterDataExW(HANDLE hPrinter, const(PWSTR) pKeyName, ubyte* pEnumValues, uint cbEnumValues, 
                        uint* pcbEnumValues, uint* pnEnumValues);

@DllImport("WINSPOOL")
uint EnumPrinterKeyA(HANDLE hPrinter, const(PSTR) pKeyName, PSTR pSubkey, uint cbSubkey, uint* pcbSubkey);

@DllImport("SPOOLSS")
uint EnumPrinterKeyW(HANDLE hPrinter, const(PWSTR) pKeyName, PWSTR pSubkey, uint cbSubkey, uint* pcbSubkey);

@DllImport("WINSPOOL")
uint SetPrinterDataA(HANDLE hPrinter, PSTR pValueName, uint Type, ubyte* pData, uint cbData);

@DllImport("WINSPOOL")
uint SetPrinterDataW(HANDLE hPrinter, PWSTR pValueName, uint Type, ubyte* pData, uint cbData);

@DllImport("WINSPOOL")
uint SetPrinterDataExA(HANDLE hPrinter, const(PSTR) pKeyName, const(PSTR) pValueName, uint Type, ubyte* pData, 
                       uint cbData);

@DllImport("WINSPOOL")
uint SetPrinterDataExW(HANDLE hPrinter, const(PWSTR) pKeyName, const(PWSTR) pValueName, uint Type, ubyte* pData, 
                       uint cbData);

@DllImport("WINSPOOL")
uint DeletePrinterDataA(HANDLE hPrinter, PSTR pValueName);

@DllImport("WINSPOOL")
uint DeletePrinterDataW(HANDLE hPrinter, PWSTR pValueName);

@DllImport("WINSPOOL")
uint DeletePrinterDataExA(HANDLE hPrinter, const(PSTR) pKeyName, const(PSTR) pValueName);

@DllImport("WINSPOOL")
uint DeletePrinterDataExW(HANDLE hPrinter, const(PWSTR) pKeyName, const(PWSTR) pValueName);

@DllImport("WINSPOOL")
uint DeletePrinterKeyA(HANDLE hPrinter, const(PSTR) pKeyName);

@DllImport("SPOOLSS")
uint DeletePrinterKeyW(HANDLE hPrinter, const(PWSTR) pKeyName);

@DllImport("SPOOLSS")
uint WaitForPrinterChange(HANDLE hPrinter, uint Flags);

@DllImport("WINSPOOL")
HANDLE FindFirstPrinterChangeNotification(HANDLE hPrinter, uint fdwFilter, uint fdwOptions, 
                                          void* pPrinterNotifyOptions);

@DllImport("WINSPOOL")
BOOL FindNextPrinterChangeNotification(HANDLE hChange, uint* pdwChange, void* pvReserved, 
                                       void** ppPrinterNotifyInfo);

@DllImport("WINSPOOL")
BOOL FreePrinterNotifyInfo(PRINTER_NOTIFY_INFO* pPrinterNotifyInfo);

@DllImport("SPOOLSS")
BOOL FindClosePrinterChangeNotification(HANDLE hChange);

@DllImport("WINSPOOL")
uint PrinterMessageBoxA(HANDLE hPrinter, uint Error, HWND hWnd, PSTR pText, PSTR pCaption, uint dwType);

@DllImport("SPOOLSS")
uint PrinterMessageBoxW(HANDLE hPrinter, uint Error, HWND hWnd, PWSTR pText, PWSTR pCaption, uint dwType);

@DllImport("WINSPOOL")
BOOL ClosePrinter(HANDLE hPrinter);

@DllImport("WINSPOOL")
BOOL AddFormA(HANDLE hPrinter, uint Level, ubyte* pForm);

@DllImport("SPOOLSS")
BOOL AddFormW(HANDLE hPrinter, uint Level, ubyte* pForm);

@DllImport("WINSPOOL")
BOOL DeleteFormA(HANDLE hPrinter, PSTR pFormName);

@DllImport("SPOOLSS")
BOOL DeleteFormW(HANDLE hPrinter, PWSTR pFormName);

@DllImport("WINSPOOL")
BOOL GetFormA(HANDLE hPrinter, PSTR pFormName, uint Level, ubyte* pForm, uint cbBuf, uint* pcbNeeded);

@DllImport("SPOOLSS")
BOOL GetFormW(HANDLE hPrinter, PWSTR pFormName, uint Level, ubyte* pForm, uint cbBuf, uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL SetFormA(HANDLE hPrinter, PSTR pFormName, uint Level, ubyte* pForm);

@DllImport("SPOOLSS")
BOOL SetFormW(HANDLE hPrinter, PWSTR pFormName, uint Level, ubyte* pForm);

@DllImport("WINSPOOL")
BOOL EnumFormsA(HANDLE hPrinter, uint Level, ubyte* pForm, uint cbBuf, uint* pcbNeeded, uint* pcReturned);

@DllImport("SPOOLSS")
BOOL EnumFormsW(HANDLE hPrinter, uint Level, ubyte* pForm, uint cbBuf, uint* pcbNeeded, uint* pcReturned);

@DllImport("WINSPOOL")
BOOL EnumMonitorsA(PSTR pName, uint Level, ubyte* pMonitor, uint cbBuf, uint* pcbNeeded, uint* pcReturned);

@DllImport("SPOOLSS")
BOOL EnumMonitorsW(PWSTR pName, uint Level, ubyte* pMonitor, uint cbBuf, uint* pcbNeeded, uint* pcReturned);

@DllImport("WINSPOOL")
BOOL AddMonitorA(PSTR pName, uint Level, ubyte* pMonitors);

@DllImport("SPOOLSS")
BOOL AddMonitorW(PWSTR pName, uint Level, ubyte* pMonitors);

@DllImport("WINSPOOL")
BOOL DeleteMonitorA(PSTR pName, PSTR pEnvironment, PSTR pMonitorName);

@DllImport("SPOOLSS")
BOOL DeleteMonitorW(PWSTR pName, PWSTR pEnvironment, PWSTR pMonitorName);

@DllImport("WINSPOOL")
BOOL EnumPortsA(PSTR pName, uint Level, ubyte* pPort, uint cbBuf, uint* pcbNeeded, uint* pcReturned);

@DllImport("WINSPOOL")
BOOL EnumPortsW(PWSTR pName, uint Level, ubyte* pPort, uint cbBuf, uint* pcbNeeded, uint* pcReturned);

@DllImport("WINSPOOL")
BOOL AddPortA(PSTR pName, HWND hWnd, PSTR pMonitorName);

@DllImport("SPOOLSS")
BOOL AddPortW(PWSTR pName, HWND hWnd, PWSTR pMonitorName);

@DllImport("WINSPOOL")
BOOL ConfigurePortA(PSTR pName, HWND hWnd, PSTR pPortName);

@DllImport("SPOOLSS")
BOOL ConfigurePortW(PWSTR pName, HWND hWnd, PWSTR pPortName);

@DllImport("WINSPOOL")
BOOL DeletePortA(PSTR pName, HWND hWnd, PSTR pPortName);

@DllImport("SPOOLSS")
BOOL DeletePortW(PWSTR pName, HWND hWnd, PWSTR pPortName);

@DllImport("WINSPOOL")
BOOL XcvDataW(HANDLE hXcv, const(PWSTR) pszDataName, ubyte* pInputData, uint cbInputData, ubyte* pOutputData, 
              uint cbOutputData, uint* pcbOutputNeeded, uint* pdwStatus);

@DllImport("WINSPOOL")
BOOL GetDefaultPrinterA(PSTR pszBuffer, uint* pcchBuffer);

@DllImport("WINSPOOL")
BOOL GetDefaultPrinterW(PWSTR pszBuffer, uint* pcchBuffer);

@DllImport("WINSPOOL")
BOOL SetDefaultPrinterA(const(PSTR) pszPrinter);

@DllImport("WINSPOOL")
BOOL SetDefaultPrinterW(const(PWSTR) pszPrinter);

@DllImport("WINSPOOL")
BOOL SetPortA(PSTR pName, PSTR pPortName, uint dwLevel, ubyte* pPortInfo);

@DllImport("SPOOLSS")
BOOL SetPortW(PWSTR pName, PWSTR pPortName, uint dwLevel, ubyte* pPortInfo);

@DllImport("WINSPOOL")
BOOL AddPrinterConnectionA(PSTR pName);

@DllImport("WINSPOOL")
BOOL AddPrinterConnectionW(PWSTR pName);

@DllImport("WINSPOOL")
BOOL DeletePrinterConnectionA(PSTR pName);

@DllImport("WINSPOOL")
BOOL DeletePrinterConnectionW(PWSTR pName);

@DllImport("WINSPOOL")
HANDLE ConnectToPrinterDlg(HWND hwnd, uint Flags);

@DllImport("WINSPOOL")
BOOL AddPrintProvidorA(PSTR pName, uint Level, ubyte* pProvidorInfo);

@DllImport("SPOOLSS")
BOOL AddPrintProvidorW(PWSTR pName, uint Level, ubyte* pProvidorInfo);

@DllImport("WINSPOOL")
BOOL DeletePrintProvidorA(PSTR pName, PSTR pEnvironment, PSTR pPrintProvidorName);

@DllImport("SPOOLSS")
BOOL DeletePrintProvidorW(PWSTR pName, PWSTR pEnvironment, PWSTR pPrintProvidorName);

@DllImport("WINSPOOL")
BOOL IsValidDevmodeA(DEVMODEA* pDevmode, size_t DevmodeSize);

@DllImport("WINSPOOL")
BOOL IsValidDevmodeW(DEVMODEW* pDevmode, size_t DevmodeSize);

@DllImport("WINSPOOL")
BOOL OpenPrinter2A(const(PSTR) pPrinterName, HANDLE* phPrinter, PRINTER_DEFAULTSA* pDefault, 
                   PRINTER_OPTIONSA* pOptions);

@DllImport("SPOOLSS")
BOOL OpenPrinter2W(const(PWSTR) pPrinterName, HANDLE* phPrinter, PRINTER_DEFAULTSW* pDefault, 
                   PRINTER_OPTIONSW* pOptions);

@DllImport("WINSPOOL")
BOOL AddPrinterConnection2A(HWND hWnd, const(PSTR) pszName, uint dwLevel, void* pConnectionInfo);

@DllImport("WINSPOOL")
BOOL AddPrinterConnection2W(HWND hWnd, const(PWSTR) pszName, uint dwLevel, void* pConnectionInfo);

@DllImport("WINSPOOL")
HRESULT InstallPrinterDriverFromPackageA(const(PSTR) pszServer, const(PSTR) pszInfPath, const(PSTR) pszDriverName, 
                                         const(PSTR) pszEnvironment, uint dwFlags);

@DllImport("WINSPOOL")
HRESULT InstallPrinterDriverFromPackageW(const(PWSTR) pszServer, const(PWSTR) pszInfPath, 
                                         const(PWSTR) pszDriverName, const(PWSTR) pszEnvironment, uint dwFlags);

@DllImport("WINSPOOL")
HRESULT UploadPrinterDriverPackageA(const(PSTR) pszServer, const(PSTR) pszInfPath, const(PSTR) pszEnvironment, 
                                    uint dwFlags, HWND hwnd, PSTR pszDestInfPath, uint* pcchDestInfPath);

@DllImport("WINSPOOL")
HRESULT UploadPrinterDriverPackageW(const(PWSTR) pszServer, const(PWSTR) pszInfPath, const(PWSTR) pszEnvironment, 
                                    uint dwFlags, HWND hwnd, PWSTR pszDestInfPath, uint* pcchDestInfPath);

@DllImport("WINSPOOL")
HRESULT GetCorePrinterDriversA(const(PSTR) pszServer, const(PSTR) pszEnvironment, 
                               const(PSTR) pszzCoreDriverDependencies, uint cCorePrinterDrivers, 
                               CORE_PRINTER_DRIVERA* pCorePrinterDrivers);

@DllImport("WINSPOOL")
HRESULT GetCorePrinterDriversW(const(PWSTR) pszServer, const(PWSTR) pszEnvironment, 
                               const(PWSTR) pszzCoreDriverDependencies, uint cCorePrinterDrivers, 
                               CORE_PRINTER_DRIVERW* pCorePrinterDrivers);

@DllImport("WINSPOOL")
HRESULT CorePrinterDriverInstalledA(const(PSTR) pszServer, const(PSTR) pszEnvironment, GUID CoreDriverGUID, 
                                    FILETIME ftDriverDate, ulong dwlDriverVersion, BOOL* pbDriverInstalled);

@DllImport("WINSPOOL")
HRESULT CorePrinterDriverInstalledW(const(PWSTR) pszServer, const(PWSTR) pszEnvironment, GUID CoreDriverGUID, 
                                    FILETIME ftDriverDate, ulong dwlDriverVersion, BOOL* pbDriverInstalled);

@DllImport("WINSPOOL")
HRESULT GetPrinterDriverPackagePathA(const(PSTR) pszServer, const(PSTR) pszEnvironment, const(PSTR) pszLanguage, 
                                     const(PSTR) pszPackageID, PSTR pszDriverPackageCab, uint cchDriverPackageCab, 
                                     uint* pcchRequiredSize);

@DllImport("WINSPOOL")
HRESULT GetPrinterDriverPackagePathW(const(PWSTR) pszServer, const(PWSTR) pszEnvironment, const(PWSTR) pszLanguage, 
                                     const(PWSTR) pszPackageID, PWSTR pszDriverPackageCab, uint cchDriverPackageCab, 
                                     uint* pcchRequiredSize);

@DllImport("WINSPOOL")
HRESULT DeletePrinterDriverPackageA(const(PSTR) pszServer, const(PSTR) pszInfPath, const(PSTR) pszEnvironment);

@DllImport("WINSPOOL")
HRESULT DeletePrinterDriverPackageW(const(PWSTR) pszServer, const(PWSTR) pszInfPath, const(PWSTR) pszEnvironment);

@DllImport("WINSPOOL")
HRESULT ReportJobProcessingProgress(HANDLE printerHandle, uint jobId, EPrintXPSJobOperation jobOperation, 
                                    EPrintXPSJobProgress jobProgress);

@DllImport("WINSPOOL")
BOOL GetPrinterDriver2A(HWND hWnd, HANDLE hPrinter, PSTR pEnvironment, uint Level, ubyte* pDriverInfo, uint cbBuf, 
                        uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL GetPrinterDriver2W(HWND hWnd, HANDLE hPrinter, PWSTR pEnvironment, uint Level, ubyte* pDriverInfo, uint cbBuf, 
                        uint* pcbNeeded);

@DllImport("WINSPOOL")
BOOL GetPrintExecutionData(PRINT_EXECUTION_DATA* pData);

@DllImport("SPOOLSS")
uint GetJobNamedPropertyValue(HANDLE hPrinter, uint JobId, const(PWSTR) pszName, PrintPropertyValue* pValue);

@DllImport("SPOOLSS")
void FreePrintPropertyValue(PrintPropertyValue* pValue);

@DllImport("WINSPOOL")
void FreePrintNamedPropertyArray(uint cProperties, PrintNamedProperty** ppProperties);

@DllImport("WINSPOOL")
uint SetJobNamedProperty(HANDLE hPrinter, uint JobId, const(PrintNamedProperty)* pProperty);

@DllImport("SPOOLSS")
uint DeleteJobNamedProperty(HANDLE hPrinter, uint JobId, const(PWSTR) pszName);

@DllImport("WINSPOOL")
uint EnumJobNamedProperties(HANDLE hPrinter, uint JobId, uint* pcProperties, PrintNamedProperty** ppProperties);

@DllImport("WINSPOOL")
HRESULT GetPrintOutputInfo(HWND hWnd, const(PWSTR) pszPrinter, HANDLE* phFile, PWSTR* ppszOutputFile);

///Creates an IVssExpressWriter interface object and returns a pointer to it.<div class="alert"><b>Note</b> This
///function is exported as <b>CreateVssExpressWriterInternal</b>, but you should call <b>CreateVssExpressWriter</b>, not
///<b>CreateVssExpressWriterInternal</b>.</div> <div> </div>
///Params:
///    ppWriter = Doubly indirect pointer to the newly created IVssExpressWriter object.
@DllImport("VSSAPI")
HRESULT CreateVssExpressWriterInternal(IVssExpressWriter* ppWriter);

@DllImport("GDI32")
BOOL EngQueryEMFInfo(ptrdiff_t hdev, EMFINFO* pEMFInfo);

///Determines whether the specified function in a delay-loaded DLL is available on the system.
///Params:
///    hParentModule = A handle to the calling module. Desktop applications can use the GetModuleHandle or GetModuleHandleEx function to
///                    get this handle. Windows Store apps should set this parameter to
///                    <code>static_cast&lt;HMODULE&gt;(&amp;__ImageBase)</code>.
///    lpDllName = The file name of the delay-loaded DLL that exports the specified function. This parameter is case-insensitive.
///                Windows Store apps should specify API sets, rather than monolithic DLLs. For example,
///                api-ms-win-core-memory-l1-1-1.dll, rather than kernel32.dll.
///    lpProcName = The name of the function to query. This parameter is case-sensitive.
///    Reserved = This parameter is reserved and must be zero (0).
///Returns:
///    TRUE if the specified function is available on the system. If the specified function is not available on the
///    system, this function returns FALSE. To get extended error information, call GetLastError.
///    
@DllImport("api-ms-win-core-libraryloader-l2-1-0")
BOOL QueryOptionalDelayLoadedAPI(ptrdiff_t hParentModule, const(PSTR) lpDllName, const(PSTR) lpProcName, 
                                 uint Reserved);

///Gets an enclave attestation report that describes the current enclave and is signed by the authority that is
///responsible for the type of the enclave.
///Params:
///    EnclaveData = A pointer to a 64-byte buffer of data that the enclave wants to insert into its signed report. For example, this
///                  buffer could include a 256-bit nonce that the relying party supplied, followed by a SHA-256 hash of additional
///                  data that the enclave wants to convey, such as a public key that corresponds to a private key that the enclave
///                  owns. If this parameter is NULL, the corresponding field of the report is filled with zeroes.
///    Report = A pointer to a buffer where the report should be placed. This report may be stored either within the address
///             range of the enclave or within the address space of the host process. Specify NULL to indicate that only the size
///             of the buffer required for the output should be calculated, and not the report itself.
///    BufferSize = The size of the buffer to which the <i>Report</i> parameter points. If <i>Report</i> is NULL, <i>BufferSize</i>
///                 must be zero. If <i>Report</i> is not NULL, and if the size of the report is larger than this value, an error is
///                 returned.
///    OutputSize = A pointer to a variable that receives the size of the report.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("vertdll")
HRESULT EnclaveGetAttestationReport(const(ubyte)* EnclaveData, void* Report, uint BufferSize, uint* OutputSize);

///Verifies an attestation report that was generated on the current system.
///Params:
///    EnclaveType = The type of the enclave for which the report was generated. Must be <b>ENCLAVE_TYPE_VBS</b>.
///    Report = A pointer to a buffer that stores the report. This report may be stored either within the address range of the
///             enclave or within the address space of the host process.
///    ReportSize = The size of the report, in bytes.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("vertdll")
HRESULT EnclaveVerifyAttestationReport(uint EnclaveType, const(void)* Report, uint ReportSize);

///Generates an encrypted binary large object (blob) from unencypted data.
///Params:
///    DataToEncrypt = A pointer to the data that you want to seal. This data can be stored either within the address range of the
///                    enclave or within the address range of the host process.
///    DataToEncryptSize = The size of the data that you want to seal, in bytes.
///    IdentityPolicy = A value that specifies how another enclave must be related to the enclave that calls <b>EnclaveSealData</b> for
///                     the enclave to unseal the data.
///    RuntimePolicy = A value that indicates whether an enclave that runs with debugging turned on is permitted to unseal the data the
///                    this call to <b>EnclaveSealData</b> seals. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                    width="40%"><a id="ENCLAVE_RUNTIME_POLICY_ALLOW_FULL_DEBUG"></a><a
///                    id="enclave_runtime_policy_allow_full_debug"></a><dl> <dt><b>ENCLAVE_RUNTIME_POLICY_ALLOW_FULL_DEBUG</b></dt>
///                    <dt>1</dt> </dl> </td> <td width="60%"> If specified, indicates that an enclave that runs with debugging turned
///                    on is permitted to unseal the data. If not specified, indicates that an enclave that runs with debugging turned
///                    on is not permitted to unseal the data. This flag is automatically included if the calling enclave is running
///                    with debugging turned on. </td> </tr> <tr> <td width="40%"><a
///                    id="ENCLAVE_RUNTIME_POLICY_ALLOW_DYNAMIC_DEBUG"></a><a id="enclave_runtime_policy_allow_dynamic_debug"></a><dl>
///                    <dt><b>ENCLAVE_RUNTIME_POLICY_ALLOW_DYNAMIC_DEBUG</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> If specified,
///                    indicates that an enclave that runs with dynamic debugging turned on is permitted to unseal the data. If not
///                    specified, indicates that an enclave that runs with dynamic debugging turned on is not permitted to unseal the
///                    data. This flag is automatically included if the calling enclave is running with dynamic debugging turned on
///                    </td> </tr> </table>
///    ProtectedBlob = A pointer to a buffer where the sealed data should be placed. This data may be stored either within the address
///                    range of the enclave or within the address space of the host process. If this parameter is NULL, only the size of
///                    the protected blob is calculated.
///    BufferSize = A pointer to a variable that holds the size of the buffer to which the <i>ProtectedBlob</i> parameter points. If
///                 <i>ProtectedBlob</i> is NULL, this value must be zero. If <i>ProtectedBlob</i> is not NULL, and if the size of
///                 the encrypted data is larger than this value, an error occurs.
///    ProtectedBlobSize = A pointer to a variable that receives the actual size of the encrypted blob.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("vertdll")
HRESULT EnclaveSealData(const(void)* DataToEncrypt, uint DataToEncryptSize, 
                        ENCLAVE_SEALING_IDENTITY_POLICY IdentityPolicy, uint RuntimePolicy, void* ProtectedBlob, 
                        uint BufferSize, uint* ProtectedBlobSize);

///Decrypts an encrypted binary large object (blob).
///Params:
///    ProtectedBlob = A pointer to the sealed data to unseal. This data may be stored either within the address range of the enclave or
///                    within the address space of the host process
///    ProtectedBlobSize = The size of the sealed data to unseal, in bytes.
///    DecryptedData = A pointer to a buffer where the unencrypted data should be placed. This data may be stored either within the
///                    address range of the enclave or within the address space of the host process. If this parameter is NULL, only the
///                    size of the decrypted data is calculated.
///    BufferSize = The size of the buffer to which the <i>DecryptedData</i> parameter points, in bytes. If <i>DecryptedData</i> is
///                 NULL, <i>BufferSize</i> must be zero. If <i>DecryptedData</i> is not NULL, and if the size of the decrypted data
///                 is larger than this value, an error is returned.
///    DecryptedDataSize = A pointer to a variable that receives the actual size of the decrypted data, in bytes.
///    SealingIdentity = An optional pointer to a buffer that should be filled with the identity of the enclave that sealed the data. If
///                      this pointer is NULL, the identity of the sealing enclave is not returned.
///    UnsealingFlags = An optional pointer to a variable that receives zero or more of the following flags that describe the encrypted
///                     binary large object. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                     id="ENCLAVE_UNSEAL_FLAG_STALE_KEY"></a><a id="enclave_unseal_flag_stale_key"></a><dl>
///                     <dt><b>ENCLAVE_UNSEAL_FLAG_STALE_KEY</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The data was encrypted with
///                     a stale key. Sealing keys are rotated when required for security, and the system can only maintain a fixed number
///                     of recently known keys. An enclave that determines that data was encrypted with a stale key should reencrypt the
///                     data with a current key to minimize the chances that the key used to encrypt the data is no longer maintained in
///                     the key list. </td> </tr> </table>
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("vertdll")
HRESULT EnclaveUnsealData(const(void)* ProtectedBlob, uint ProtectedBlobSize, void* DecryptedData, uint BufferSize, 
                          uint* DecryptedDataSize, ENCLAVE_IDENTITY* SealingIdentity, uint* UnsealingFlags);

///Gets information about the currently executing enclave.
///Params:
///    InformationSize = The size of the ENCLAVE_INFORMATION structure that the <i>EnclaveInformation</i> parameter points to, in bytes.
///    EnclaveInformation = Information about the currently executing enclave.
///Returns:
///    If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
///    
@DllImport("vertdll")
HRESULT EnclaveGetEnclaveInformation(uint InformationSize, ENCLAVE_INFORMATION* EnclaveInformation);

///Sets or retrieves power information.
///Params:
///    InformationLevel = The information level requested. This value indicates the specific power information to be set or retrieved. This
///                       parameter must be one of the following <b>POWER_INFORMATION_LEVEL</b> enumeration type values. <table> <tr>
///                       <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AdministratorPowerPolicy"></a><a
///                       id="administratorpowerpolicy"></a><a id="ADMINISTRATORPOWERPOLICY"></a><dl>
///                       <dt><b>AdministratorPowerPolicy</b></dt> <dt>9</dt> </dl> </td> <td width="60%"> This information level is not
///                       supported. </td> </tr> <tr> <td width="40%"><a id="LastSleepTime"></a><a id="lastsleeptime"></a><a
///                       id="LASTSLEEPTIME"></a><dl> <dt><b>LastSleepTime</b></dt> <dt>15</dt> </dl> </td> <td width="60%"> The
///                       <i>lpInBuffer</i> parameter must be <b>NULL</b>; otherwise, the function returns <b>ERROR_INVALID_PARAMETER</b>.
///                       The <i>lpOutputBuffer</i> buffer receives a <b>ULONGLONG</b> that specifies the interrupt-time count, in
///                       100-nanosecond units, at the last system sleep time. </td> </tr> <tr> <td width="40%"><a id="LastWakeTime"></a><a
///                       id="lastwaketime"></a><a id="LASTWAKETIME"></a><dl> <dt><b>LastWakeTime</b></dt> <dt>14</dt> </dl> </td> <td
///                       width="60%"> The <i>lpInBuffer</i> parameter must be <b>NULL</b>; otherwise, the function returns
///                       <b>ERROR_INVALID_PARAMETER</b>. The <i>lpOutputBuffer</i> buffer receives a <b>ULONGLONG</b> that specifies the
///                       interrupt-time count, in 100-nanosecond units, at the last system wake time. </td> </tr> <tr> <td width="40%"><a
///                       id="ProcessorInformation"></a><a id="processorinformation"></a><a id="PROCESSORINFORMATION"></a><dl>
///                       <dt><b>ProcessorInformation</b></dt> <dt>11</dt> </dl> </td> <td width="60%"> The <i>lpInBuffer</i> parameter
///                       must be <b>NULL</b>; otherwise the function returns <b>ERROR_INVALID_PARAMETER</b>. The <i>lpOutputBuffer</i>
///                       buffer receives one PROCESSOR_POWER_INFORMATION structure for each processor that is installed on the system. Use
///                       the GetSystemInfo function to retrieve the number of processors. </td> </tr> <tr> <td width="40%"><a
///                       id="ProcessorPowerPolicyAc"></a><a id="processorpowerpolicyac"></a><a id="PROCESSORPOWERPOLICYAC"></a><dl>
///                       <dt><b>ProcessorPowerPolicyAc</b></dt> <dt>18</dt> </dl> </td> <td width="60%"> This information level is not
///                       supported. </td> </tr> <tr> <td width="40%"><a id="ProcessorPowerPolicyCurrent"></a><a
///                       id="processorpowerpolicycurrent"></a><a id="PROCESSORPOWERPOLICYCURRENT"></a><dl>
///                       <dt><b>ProcessorPowerPolicyCurrent</b></dt> <dt>22</dt> </dl> </td> <td width="60%"> This information level is
///                       not supported. </td> </tr> <tr> <td width="40%"><a id="ProcessorPowerPolicyDc"></a><a
///                       id="processorpowerpolicydc"></a><a id="PROCESSORPOWERPOLICYDC"></a><dl> <dt><b>ProcessorPowerPolicyDc</b></dt>
///                       <dt>19</dt> </dl> </td> <td width="60%"> This information level is not supported. </td> </tr> <tr> <td
///                       width="40%"><a id="SystemBatteryState"></a><a id="systembatterystate"></a><a id="SYSTEMBATTERYSTATE"></a><dl>
///                       <dt><b>SystemBatteryState</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> The <i>lpInBuffer</i> parameter must
///                       be <b>NULL</b>; otherwise, the function returns <b>ERROR_INVALID_PARAMETER</b>. The <i>lpOutputBuffer</i> buffer
///                       receives a SYSTEM_BATTERY_STATE structure containing information about the current system battery. </td> </tr>
///                       <tr> <td width="40%"><a id="SystemExecutionState"></a><a id="systemexecutionstate"></a><a
///                       id="SYSTEMEXECUTIONSTATE"></a><dl> <dt><b>SystemExecutionState</b></dt> <dt>16</dt> </dl> </td> <td width="60%">
///                       The <i>lpInBuffer</i> parameter must be <b>NULL</b>; otherwise the function returns
///                       <b>ERROR_INVALID_PARAMETER</b>. The <i>lpOutputBuffer</i> buffer receives a <b>ULONG</b> value containing the
///                       system execution state buffer. This value may contain any combination of the following values:
///                       <b>ES_SYSTEM_REQUIRED</b>, <b>ES_DISPLAY_REQUIRED</b>, or <b>ES_USER_PRESENT</b>. For more information, see the
///                       SetThreadExecutionState function. </td> </tr> <tr> <td width="40%"><a id="SystemPowerCapabilities"></a><a
///                       id="systempowercapabilities"></a><a id="SYSTEMPOWERCAPABILITIES"></a><dl> <dt><b>SystemPowerCapabilities</b></dt>
///                       <dt>4</dt> </dl> </td> <td width="60%"> The <i>lpInBuffer</i> parameter must be <b>NULL</b>, otherwise, the
///                       function returns <b>ERROR_INVALID_PARAMETER</b>. The <i>lpOutputBuffer</i> buffer receives a
///                       SYSTEM_POWER_CAPABILITIES structure containing the current system power capabilities. This information represents
///                       the currently supported power capabilities. It may change as drivers are installed in the system. For example,
///                       installation of legacy device drivers that do not support power management disables all system sleep states.
///                       </td> </tr> <tr> <td width="40%"><a id="SystemPowerInformation"></a><a id="systempowerinformation"></a><a
///                       id="SYSTEMPOWERINFORMATION"></a><dl> <dt><b>SystemPowerInformation</b></dt> <dt>12</dt> </dl> </td> <td
///                       width="60%"> The <i>lpInBuffer</i> parameter must be <b>NULL</b>; otherwise, the function returns
///                       <b>ERROR_INVALID_PARAMETER</b>. The <i>lpOutputBuffer</i> buffer receives a SYSTEM_POWER_INFORMATION structure.
///                       Applications can use this level to retrieve information about the idleness of the system. </td> </tr> <tr> <td
///                       width="40%"><a id="SystemPowerPolicyAc"></a><a id="systempowerpolicyac"></a><a id="SYSTEMPOWERPOLICYAC"></a><dl>
///                       <dt><b>SystemPowerPolicyAc</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> If <i>lpInBuffer</i> is not
///                       <b>NULL</b>, the function applies the SYSTEM_POWER_POLICY values passed in <i>lpInBuffer</i> to the current
///                       system power policy used while the system is running on AC (utility) power. The <i>lpOutputBuffer</i> buffer
///                       receives a SYSTEM_POWER_POLICY structure containing the current system power policy used while the system is
///                       running on AC (utility) power. </td> </tr> <tr> <td width="40%"><a id="SystemPowerPolicyCurrent"></a><a
///                       id="systempowerpolicycurrent"></a><a id="SYSTEMPOWERPOLICYCURRENT"></a><dl>
///                       <dt><b>SystemPowerPolicyCurrent</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> The <i>lpInBuffer</i> parameter
///                       must be <b>NULL</b>; otherwise, the function returns <b>ERROR_INVALID_PARAMETER</b>. The <i>lpOutputBuffer</i>
///                       buffer receives a SYSTEM_POWER_POLICY structure containing the current system power policy used while the system
///                       is running on AC (utility) power. </td> </tr> <tr> <td width="40%"><a id="SystemPowerPolicyDc"></a><a
///                       id="systempowerpolicydc"></a><a id="SYSTEMPOWERPOLICYDC"></a><dl> <dt><b>SystemPowerPolicyDc</b></dt> <dt>1</dt>
///                       </dl> </td> <td width="60%"> If <i>lpInBuffer</i> is not <b>NULL</b>, the function applies the
///                       SYSTEM_POWER_POLICY values passed in <i>lpInBuffer</i> to the current system power policy used while the system
///                       is running on battery power. The <i>lpOutputBuffer</i> buffer receives a SYSTEM_POWER_POLICY structure containing
///                       the current system power policy used while the system is running on battery power. </td> </tr> <tr> <td
///                       width="40%"><a id="SystemReserveHiberFile"></a><a id="systemreservehiberfile"></a><a
///                       id="SYSTEMRESERVEHIBERFILE"></a><dl> <dt><b>SystemReserveHiberFile</b></dt> <dt>10</dt> </dl> </td> <td
///                       width="60%"> If <i>lpInBuffer</i> is not <b>NULL</b> and the current user has sufficient privileges, the function
///                       commits or decommits the storage required to hold the hibernation image on the boot volume. The <i>lpInBuffer</i>
///                       parameter must point to a <b>BOOLEAN</b> value indicating the desired request. If the value is <b>TRUE</b>, the
///                       hibernation file is reserved; if the value is <b>FALSE</b>, the hibernation file is removed. </td> </tr> <tr> <td
///                       width="40%"><a id="VerifyProcessorPowerPolicyAc"></a><a id="verifyprocessorpowerpolicyac"></a><a
///                       id="VERIFYPROCESSORPOWERPOLICYAC"></a><dl> <dt><b>VerifyProcessorPowerPolicyAc</b></dt> <dt>20</dt> </dl> </td>
///                       <td width="60%"> This information level is not supported. </td> </tr> <tr> <td width="40%"><a
///                       id="VerifyProcessorPowerPolicyDc"></a><a id="verifyprocessorpowerpolicydc"></a><a
///                       id="VERIFYPROCESSORPOWERPOLICYDC"></a><dl> <dt><b>VerifyProcessorPowerPolicyDc</b></dt> <dt>21</dt> </dl> </td>
///                       <td width="60%"> This information level is not supported. </td> </tr> <tr> <td width="40%"><a
///                       id="VerifySystemPolicyAc"></a><a id="verifysystempolicyac"></a><a id="VERIFYSYSTEMPOLICYAC"></a><dl>
///                       <dt><b>VerifySystemPolicyAc</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> This information level is not
///                       supported. </td> </tr> <tr> <td width="40%"><a id="VerifySystemPolicyDc"></a><a id="verifysystempolicydc"></a><a
///                       id="VERIFYSYSTEMPOLICYDC"></a><dl> <dt><b>VerifySystemPolicyDc</b></dt> <dt>3</dt> </dl> </td> <td width="60%">
///                       This information level is not supported. </td> </tr> </table>
///    InputBuffer = A pointer to an optional input buffer. The data type of this buffer depends on the information level requested in
///                  the <i>InformationLevel</i> parameter.
///    InputBufferLength = The size of the input buffer, in bytes.
///    OutputBuffer = A pointer to an optional output buffer. The data type of this buffer depends on the information level requested
///                   in the <i>InformationLevel</i> parameter. If the buffer is too small to contain the information, the function
///                   returns STATUS_BUFFER_TOO_SMALL.
///    OutputBufferLength = The size of the output buffer, in bytes. Depending on the information level requested, this may be a variably
///                         sized buffer.
///Returns:
///    If the function succeeds, the return value is <b>STATUS_SUCCESS</b>. If the function fails, the return value can
///    be one the following status codes. <table> <tr> <th>Status</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>STATUS_BUFFER_TOO_SMALL</b></dt> </dl> </td> <td width="60%"> The output buffer is of insufficient size to
///    contain the data to be returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>STATUS_ACCESS_DENIED</b></dt>
///    </dl> </td> <td width="60%"> The caller had insufficient access rights to perform the requested action. </td>
///    </tr> </table>
///    
@DllImport("POWRPROF")
NTSTATUS CallNtPowerInformation(POWER_INFORMATION_LEVEL InformationLevel, void* InputBuffer, 
                                uint InputBufferLength, void* OutputBuffer, uint OutputBufferLength);

///Retrieves information about the system power capabilities.
///Params:
///    lpspc = A pointer to a SYSTEM_POWER_CAPABILITIES structure that receives the information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("api-ms-win-power-base-l1-1-0")
ubyte GetPwrCapabilities(SYSTEM_POWER_CAPABILITIES* lpspc);

///Determines the computer role for the specified platform.
///Params:
///    Version = The version of the POWER_PLATFORM_ROLE enumeration for the platform. This parameter can be one of the following
///              values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="POWER_PLATFORM_ROLE_VERSION"></a><a id="power_platform_role_version"></a><dl>
///              <dt><b>POWER_PLATFORM_ROLE_VERSION</b></dt> </dl> </td> <td width="60%"> The version of the POWER_PLATFORM_ROLE
///              enumeration for the current build target. </td> </tr> <tr> <td width="40%"><a id="POWER_PLATFORM_ROLE_V1"></a><a
///              id="power_platform_role_v1"></a><dl> <dt><b>POWER_PLATFORM_ROLE_V1</b></dt> </dl> </td> <td width="60%"> The
///              version of the POWER_PLATFORM_ROLE enumeration for Windows 7, Windows Server 2008 R2, Windows Vista or Windows
///              Server 2008. Calling <b>PowerDeterminePlatformRoleEx</b> with this value returns the same result as calling
///              PowerDeterminePlatformRole on Windows 7, Windows Server 2008 R2, Windows Vista or Windows Server 2008. </td>
///              </tr> <tr> <td width="40%"><a id="POWER_PLATFORM_ROLE_V2"></a><a id="power_platform_role_v2"></a><dl>
///              <dt><b>POWER_PLATFORM_ROLE_V2</b></dt> </dl> </td> <td width="60%"> The version of the POWER_PLATFORM_ROLE
///              enumeration for Windows 8 and Windows Server 2012. </td> </tr> </table>
///Returns:
///    The return value is one of the values from the specified version of the POWER_PLATFORM_ROLE enumeration.
///    
@DllImport("api-ms-win-power-base-l1-1-0")
POWER_PLATFORM_ROLE PowerDeterminePlatformRoleEx(uint Version);

///Registers to receive notification when the system is suspended or resumed.
///Params:
///    Flags = This parameter must be <b>DEVICE_NOTIFY_CALLBACK</b>.
///    Recipient = This parameter is a pointer to a DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS structure. In this case, the callback
///                function is DeviceNotifyCallbackRoutine. When the <b>Callback</b> function executes, the <i>Type</i> parameter is
///                set indicating the type of event that occurred. Possible values include <b>PBT_APMSUSPEND</b>,
///                <b>PBT_APMRESUMESUSPEND</b>, and <b>PBT_APMRESUMEAUTOMATIC</b> - see Power Management Events for more info. The
///                <i>Setting</i> parameter is not used with suspend/resume notifications.
///    RegistrationHandle = A handle to the registration. Use this handle to unregister for notifications.
///Returns:
///    Returns ERROR_SUCCESS (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("api-ms-win-power-base-l1-1-0")
uint PowerRegisterSuspendResumeNotification(uint Flags, HANDLE Recipient, void** RegistrationHandle);

///Cancels a registration to receive notification when the system is suspended or resumed.
///Params:
///    RegistrationHandle = A handle to a registration obtained by calling the PowerRegisterSuspendResumeNotification function.
///Returns:
///    Returns ERROR_SUCCESS (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("api-ms-win-power-base-l1-1-0")
uint PowerUnregisterSuspendResumeNotification(void* RegistrationHandle);

///Retrieves the AC power value for the specified power setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to retrieve the setting for the default power scheme. <table> <tr> <th>Value</th>
///                                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Type = A pointer to a variable that receives the type of data for the value. The possible values are listed in Registry
///           Value Types. This parameter can be <b>NULL</b> and the type of data is not returned.
///    Buffer = A pointer to a buffer that receives the data value. If this parameter is <b>NULL</b>, the <i>BufferSize</i>
///             parameter receives the required buffer size.
///    BufferSize = A pointer to a variable that contains the size of the buffer pointed to by the <i>Buffer</i> parameter. If the
///                 <i>Buffer</i> parameter is <b>NULL</b>, the function returns ERROR_SUCCESS and the variable receives the required
///                 buffer size. If the specified buffer size is not large enough to hold the requested data, the function returns
///                 <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size specified by the <i>BufferSize</i> parameter is too small, <b>ERROR_MORE_DATA</b> will be returned
///    and the <b>DWORD</b> pointed to by the <i>BufferSize</i> parameter will be filled in with the required buffer
///    size.
///    
@DllImport("api-ms-win-power-setting-l1-1-0")
uint PowerReadACValue(HKEY RootPowerKey, const(GUID)* SchemeGuid, const(GUID)* SubGroupOfPowerSettingsGuid, 
                      const(GUID)* PowerSettingGuid, uint* Type, ubyte* Buffer, uint* BufferSize);

///Retrieves the DC power value for the specified power setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to retrieve the setting for the default power scheme. <table> <tr> <th>Value</th>
///                                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Type = A pointer to a variable that receives the type of data for the value. The possible values are listed in Registry
///           Value Types. This parameter can be <b>NULL</b> and the type of data is not returned.
///    Buffer = A pointer to a variable that receives the data value. If this parameter is <b>NULL</b>, the <i>BufferSize</i>
///             parameter receives the required buffer size.
///    BufferSize = A pointer to a variable that contains the size of the buffer pointed to by the <i>Buffer</i> parameter. If the
///                 <i>Buffer</i> parameter is <b>NULL</b>, the function returns ERROR_SUCCESS and the variable receives the required
///                 buffer size. If the specified buffer size is not large enough to hold the requested data, the function returns
///                 <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size specified by the <i>BufferSize</i> parameter is too small, <b>ERROR_MORE_DATA</b> will be returned
///    and the <b>DWORD</b> pointed to by the <i>BufferSize</i> parameter will be filled in with the required buffer
///    size.
///    
@DllImport("api-ms-win-power-setting-l1-1-0")
uint PowerReadDCValue(HKEY RootPowerKey, const(GUID)* SchemeGuid, const(GUID)* SubGroupOfPowerSettingsGuid, 
                      const(GUID)* PowerSettingGuid, uint* Type, ubyte* Buffer, uint* BufferSize);

///Retrieves the active power scheme and returns a <b>GUID</b> that identifies the scheme.
///Params:
///    UserRootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    ActivePolicyGuid = A pointer that receives a pointer to a <b>GUID</b> structure. Use the LocalFree function to free this memory.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("api-ms-win-power-setting-l1-1-0")
uint PowerGetActiveScheme(HKEY UserRootPowerKey, GUID** ActivePolicyGuid);

///Sets the active power scheme for the current user.
///Params:
///    UserRootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("api-ms-win-power-setting-l1-1-0")
uint PowerSetActiveScheme(HKEY UserRootPowerKey, const(GUID)* SchemeGuid);

///Registers to receive notification when a power setting changes.
///Params:
///    SettingGuid = A GUID that represents the power setting.
///    Flags = Information about the recipient of the notification. This parameter can be one of the following values: <table>
///            <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="DEVICE_NOTIFY_SERVICE_HANDLE"></a><a
///            id="device_notify_service_handle"></a><dl> <dt><b>DEVICE_NOTIFY_SERVICE_HANDLE</b></dt> </dl> </td> <td
///            width="60%"> The <i>Recipient</i> parameter is a handle to a service.Use the CreateService or OpenService
///            function to obtain this handle. </td> </tr> <tr> <td width="40%"><a id="DEVICE_NOTIFY_CALLBACK"></a><a
///            id="device_notify_callback"></a><dl> <dt><b>DEVICE_NOTIFY_CALLBACK</b></dt> </dl> </td> <td width="60%"> The
///            <i>Recipient</i> parameter is a pointer to a callback function to call when the power setting changes. </td>
///            </tr> </table>
///    Recipient = A handle to the recipient of the notifications.
///    RegistrationHandle = A handle to the registration. Use this handle to unregister for notifications.
///Returns:
///    Returns ERROR_SUCCESS (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("api-ms-win-power-setting-l1-1-0")
uint PowerSettingRegisterNotification(GUID* SettingGuid, uint Flags, HANDLE Recipient, void** RegistrationHandle);

///Cancels a registration to receive notification when a power setting changes.
///Params:
///    RegistrationHandle = A handle to a registration obtained by calling the PowerSettingRegisterNotification function.
///Returns:
///    Returns ERROR_SUCCESS (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("api-ms-win-power-setting-l1-1-0")
uint PowerSettingUnregisterNotification(void* RegistrationHandle);

///Registers a callback to receive effective power mode change notifications.
///Params:
///    Version = Supplies the maximum effective power mode version the caller understands. If the effective power mode comes from
///              a later version, it is reduced to a compatible version that is then passed to the callback. The following values
///              can be passed in: - EFFECTIVE_POWER_MODE_V1 is available starting with Windows 10, version 1809 and tracks the
///              performance power slider and battery saver states. - EFFECTIVE_POWER_MODE_V2 is available starting with Windows
///              10, version 1903 and tracks the performance power slider, battery saver, game mode and windows mixed reality
///              power states.
///    Callback = A pointer to the callback to call when the effective power mode changes. This will also be called once upon
///               registration to supply the current mode. If multiple callbacks are registered using this API, those callbacks can
///               be called concurrently.
///    Context = Caller-specified opaque context.
///    RegistrationHandle = A handle to the registration. Use this handle to unregister for notifications.
///Returns:
///    Returns S_OK (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("api-ms-win-power-setting-l1-1-1")
HRESULT PowerRegisterForEffectivePowerModeNotifications(uint Version, EFFECTIVE_POWER_MODE_CALLBACK* Callback, 
                                                        void* Context, void** RegistrationHandle);

///Unregisters from effective power mode change notifications. This function is intended to be called from cleanup code
///and will wait for all callbacks to complete before unregistering.
///Params:
///    RegistrationHandle = The handle corresponding to a single power mode registration. This handle should have been saved by the caller
///                         after the call to PowerRegisterForEffectivePowerModeNotifications and passed in here.
///Returns:
///    Returns S_OK (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("api-ms-win-power-setting-l1-1-1")
HRESULT PowerUnregisterFromEffectivePowerModeNotifications(void* RegistrationHandle);

///<p class="CCE_Message">[<b>GetPwrDiskSpindownRange</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. See Remarks.] Retrieves the disk
///spindown range.
///Params:
///    puiMax = The maximum disk spindown time, in seconds.
///    puiMin = The minimum disk spindown time, in seconds.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte GetPwrDiskSpindownRange(uint* puiMax, uint* puiMin);

///<p class="CCE_Message">[<b>EnumPwrSchemes</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Applications written for Windows Vista
///and later should use PowerEnumerate instead.] Enumerates all power schemes. For each power scheme enumerated, the
///function calls a callback function with information about the power scheme.
///Params:
///    lpfn = A pointer to a callback function to be called for each power scheme enumerated. For more information, see
///           Remarks.
///    lParam = A user-defined value to be passed to the callback function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte EnumPwrSchemes(PWRSCHEMESENUMPROC lpfn, LPARAM lParam);

///<p class="CCE_Message">[<b>ReadGlobalPwrPolicy</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. See Remarks.] Retrieves the current
///global power policy settings.
///Params:
///    pGlobalPowerPolicy = A pointer to a GLOBAL_POWER_POLICY structure that receives the information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte ReadGlobalPwrPolicy(GLOBAL_POWER_POLICY* pGlobalPowerPolicy);

///<p class="CCE_Message">[<b>ReadPwrScheme</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. See Remarks.] Retrieves the power
///policy settings that are unique to the specified power scheme.
///Params:
///    uiID = The index of the power scheme to be read.
///    pPowerPolicy = A pointer to a POWER_POLICY structure that receives the power policy settings.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte ReadPwrScheme(uint uiID, POWER_POLICY* pPowerPolicy);

///<p class="CCE_Message">[<b>WritePwrScheme</b> is no longer available for use as of Windows Vista. Instead, use the
///PowerEnumerate function to enumerate power settings for a specified scheme, and the power write functions to write
///individual settings.] Writes policy settings that are unique to the specified power scheme.
///Params:
///    puiID = The index of the power scheme to be written. If a power scheme with the same index already exists, it is
///            replaced. Otherwise, a new power scheme is created.
///    lpszSchemeName = The name of the power scheme.
///    lpszDescription = The description of the power scheme.
///    lpScheme = A pointer to a POWER_POLICY structure that contains the power policy settings to be written.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte WritePwrScheme(uint* puiID, const(PWSTR) lpszSchemeName, const(PWSTR) lpszDescription, 
                     POWER_POLICY* lpScheme);

///<p class="CCE_Message">[<b>WriteGlobalPwrPolicy</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. See Remarks.] Writes global power
///policy settings.
///Params:
///    pGlobalPowerPolicy = A pointer to a GLOBAL_POWER_POLICY structure that contains the power policy settings to be written.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte WriteGlobalPwrPolicy(GLOBAL_POWER_POLICY* pGlobalPowerPolicy);

///<p class="CCE_Message">[<b>DeletePwrScheme</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Applications written for Windows Vista
///and later should use PowerDeleteScheme instead.] Deletes the specified power scheme.
///Params:
///    uiID = The index of the power scheme to be deleted.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte DeletePwrScheme(uint uiID);

///<p class="CCE_Message">[<b>GetActivePwrScheme</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Applications written for Windows Vista
///and later should use PowerGetActiveScheme instead.] Retrieves the index of the active power scheme.
///Params:
///    puiID = A pointer to a variable that receives the index of the active power scheme.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte GetActivePwrScheme(uint* puiID);

///<p class="CCE_Message">[<b>SetActivePwrScheme</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Applications written for Windows Vista
///and later should use PowerSetActiveScheme instead.] Sets the active power scheme.
///Params:
///    uiID = The index of the power scheme to be activated.
///    pGlobalPowerPolicy = A pointer to an optional GLOBAL_POWER_POLICY structure, which provides global power policy settings to be merged
///                         with the power scheme when it becomes active.
///    pPowerPolicy = A pointer to an optional POWER_POLICY structure, which provides power policy settings to be merged with the power
///                   scheme when it becomes active.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte SetActivePwrScheme(uint uiID, GLOBAL_POWER_POLICY* pGlobalPowerPolicy, POWER_POLICY* pPowerPolicy);

///<p class="CCE_Message">[<b>IsPwrSuspendAllowed</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Applications written for Windows Vista
///and later should use GetPwrCapabilities instead.] Determines whether the computer supports the sleep states.
///Returns:
///    If the computer supports the sleep states (S1, S2, and S3), the function returns <b>TRUE</b>. Otherwise, the
///    function returns <b>FALSE</b>.
///    
@DllImport("POWRPROF")
ubyte IsPwrSuspendAllowed();

///<p class="CCE_Message">[<b>IsPwrHibernateAllowed</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Applications written for Windows Vista
///and later should use GetPwrCapabilities instead.] Determines whether the computer supports hibernation.
///Returns:
///    If the computer supports hibernation (power state S4) and the file Hiberfil.sys is present on the system, the
///    function returns <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b>.
///    
@DllImport("POWRPROF")
ubyte IsPwrHibernateAllowed();

///<p class="CCE_Message">[<b>IsPwrShutdownAllowed</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. See Remarks.] Determines whether the
///computer supports the soft off power state.
///Returns:
///    If the computer supports soft off (power state S5), the function returns <b>TRUE</b>. Otherwise, the function
///    returns <b>FALSE</b>.
///    
@DllImport("POWRPROF")
ubyte IsPwrShutdownAllowed();

@DllImport("POWRPROF")
ubyte IsAdminOverrideActive(ADMINISTRATOR_POWER_POLICY* papp);

///Suspends the system by shutting power down. Depending on the <i>Hibernate</i> parameter, the system either enters a
///suspend (sleep) state or hibernation (S4).
///Params:
///    bHibernate = If this parameter is <b>TRUE</b>, the system hibernates. If the parameter is <b>FALSE</b>, the system is
///                 suspended.
///    bForce = This parameter has no effect.
///    bWakeupEventsDisabled = If this parameter is <b>TRUE</b>, the system disables all wake events. If the parameter is <b>FALSE</b>, any
///                            system wake events remain enabled.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte SetSuspendState(ubyte bHibernate, ubyte bForce, ubyte bWakeupEventsDisabled);

///Retrieves the current system power policy settings.
///Params:
///    pGlobalPowerPolicy = A pointer to a GLOBAL_POWER_POLICY structure that receives the current global power policy settings.
///    pPowerPolicy = A pointer to a POWER_POLICY structure that receives the power policy settings that are unique to the active power
///                   scheme.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte GetCurrentPowerPolicies(GLOBAL_POWER_POLICY* pGlobalPowerPolicy, POWER_POLICY* pPowerPolicy);

///<p class="CCE_Message">[<b>CanUserWritePwrScheme</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Applications written for Windows Vista
///and later should use PowerSettingAccessCheck instead.] Determines whether the current user has sufficient privilege
///to write a power scheme.
///Returns:
///    If the current user has sufficient privilege to write a power scheme, the function returns <b>TRUE</b>. If the
///    function fails, the return value is zero. To get extended error information, call GetLastError. Possible error
///    values include the following. <table> <tr> <th>Error</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The current user does not have sufficient
///    privilege to write a power scheme. </td> </tr> </table>
///    
@DllImport("POWRPROF")
ubyte CanUserWritePwrScheme();

///<p class="CCE_Message">[<b>ReadProcessorPwrScheme</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. See Remarks.] Retrieves the processor
///power policy settings for the specified power scheme.
///Params:
///    uiID = The index of the power scheme to be read.
///    pMachineProcessorPowerPolicy = A pointer to a MACHINE_PROCESSOR_POWER_POLICY structure that receives the processor power policy settings.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte ReadProcessorPwrScheme(uint uiID, MACHINE_PROCESSOR_POWER_POLICY* pMachineProcessorPowerPolicy);

///<p class="CCE_Message">[<b>WriteProcessorPwrScheme</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. See Remarks.] Writes processor power
///policy settings for the specified power scheme.
///Params:
///    uiID = The index of the power scheme to be written.
///    pMachineProcessorPowerPolicy = A pointer to a MACHINE_PROCESSOR_POWER_POLICY structure that contains the power policy settings to be written.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
ubyte WriteProcessorPwrScheme(uint uiID, MACHINE_PROCESSOR_POWER_POLICY* pMachineProcessorPowerPolicy);

@DllImport("POWRPROF")
ubyte ValidatePowerPolicies(GLOBAL_POWER_POLICY* pGlobalPowerPolicy, POWER_POLICY* pPowerPolicy);

///Queries whether the specified power setting represents a range of possible values.
///Params:
///    SubKeyGuid = The identifier of the subkey to search.
///    SettingGuid = The identifier of the power setting to query.
@DllImport("POWRPROF")
ubyte PowerIsSettingRangeDefined(const(GUID)* SubKeyGuid, const(GUID)* SettingGuid);

///Queries for a group policy override for specified power settings and specifies the requested access for the setting.
///Params:
///    AccessFlags = The type of access to check for group policy overrides. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                  <td width="40%"><a id="ACCESS_AC_POWER_SETTING_INDEX"></a><a id="access_ac_power_setting_index"></a><dl>
///                  <dt><b>ACCESS_AC_POWER_SETTING_INDEX</b></dt> <dt>0 (0x0)</dt> </dl> </td> <td width="60%"> Check for overrides
///                  on AC power settings. </td> </tr> <tr> <td width="40%"><a id="ACCESS_DC_POWER_SETTING_INDEX"></a><a
///                  id="access_dc_power_setting_index"></a><dl> <dt><b>ACCESS_DC_POWER_SETTING_INDEX</b></dt> <dt>1 (0x1)</dt> </dl>
///                  </td> <td width="60%"> Check for overrides on DC power settings. </td> </tr> <tr> <td width="40%"><a
///                  id="ACCESS_SCHEME"></a><a id="access_scheme"></a><dl> <dt><b>ACCESS_SCHEME</b></dt> <dt>16 (0x10)</dt> </dl>
///                  </td> <td width="60%"> Check for restrictions on specific power schemes. </td> </tr> <tr> <td width="40%"><a
///                  id="ACCESS_ACTIVE_SCHEME"></a><a id="access_active_scheme"></a><dl> <dt><b>ACCESS_ACTIVE_SCHEME</b></dt> <dt>19
///                  (0x13)</dt> </dl> </td> <td width="60%"> Check for restrictions on active power schemes. </td> </tr> <tr> <td
///                  width="40%"><a id="ACCESS_CREATE_SCHEME"></a><a id="access_create_scheme"></a><dl>
///                  <dt><b>ACCESS_CREATE_SCHEME</b></dt> <dt>20 (0x14)</dt> </dl> </td> <td width="60%"> Check for restrictions on
///                  creating or restoring power schemes. </td> </tr> </table>
///    PowerGuid = The identifier of the power setting.
///    AccessType = The type of security access for the setting. For more information, see Registry Key Security and Access Rights.
///                 This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                 width="40%"><a id="KEY_READ"></a><a id="key_read"></a><dl> <dt><b>KEY_READ</b></dt> </dl> </td> <td width="60%">
///                 Combines the STANDARD_RIGHTS_READ, KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY values. </td> </tr>
///                 <tr> <td width="40%"><a id="KEY_WRITE"></a><a id="key_write"></a><dl> <dt><b>KEY_WRITE</b></dt> </dl> </td> <td
///                 width="60%"> Combines the STANDARD_RIGHTS_WRITE, KEY_SET_VALUE, and KEY_CREATE_SUB_KEY access rights. </td> </tr>
///                 </table>
@DllImport("POWRPROF")
uint PowerSettingAccessCheckEx(POWER_DATA_ACCESSOR AccessFlags, const(GUID)* PowerGuid, uint AccessType);

///Queries for a group policy override for specified power settings.
///Params:
///    AccessFlags = The type of access to check for group policy overrides. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                  <td width="40%"><a id="ACCESS_AC_POWER_SETTING_INDEX"></a><a id="access_ac_power_setting_index"></a><dl>
///                  <dt><b>ACCESS_AC_POWER_SETTING_INDEX</b></dt> <dt>0 (0x0)</dt> </dl> </td> <td width="60%"> Check for overrides
///                  on AC power settings. </td> </tr> <tr> <td width="40%"><a id="ACCESS_DC_POWER_SETTING_INDEX"></a><a
///                  id="access_dc_power_setting_index"></a><dl> <dt><b>ACCESS_DC_POWER_SETTING_INDEX</b></dt> <dt>1 (0x1)</dt> </dl>
///                  </td> <td width="60%"> Check for overrides on DC power settings. </td> </tr> <tr> <td width="40%"><a
///                  id="ACCESS_SCHEME"></a><a id="access_scheme"></a><dl> <dt><b>ACCESS_SCHEME</b></dt> <dt>16 (0x10)</dt> </dl>
///                  </td> <td width="60%"> Check for restrictions on specific power schemes. </td> </tr> <tr> <td width="40%"><a
///                  id="ACCESS_ACTIVE_SCHEME"></a><a id="access_active_scheme"></a><dl> <dt><b>ACCESS_ACTIVE_SCHEME</b></dt> <dt>19
///                  (0x13)</dt> </dl> </td> <td width="60%"> Check for restrictions on active power schemes. </td> </tr> <tr> <td
///                  width="40%"><a id="ACCESS_CREATE_SCHEME"></a><a id="access_create_scheme"></a><dl>
///                  <dt><b>ACCESS_CREATE_SCHEME</b></dt> <dt>20 (0x14)</dt> </dl> </td> <td width="60%"> Check for restrictions on
///                  creating or restoring power schemes. </td> </tr> </table>
///    PowerGuid = The identifier of the power setting.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. <table>
///    <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SUCCESS</b></dt> <dt>0 (0x0)</dt> </dl> </td> <td width="60%"> The specified power setting is not
///    currently overridden by a group policy. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DISABLED_BY_POLICY</b></dt> <dt>1260 (0x4EC)</dt> </dl> </td> <td width="60%"> This program
///    is blocked by group policy. For more information, contact your system administrator. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INSTALL_REMOTE_DISALLOWED</b></dt> <dt>1640 (0x668)</dt> </dl> </td> <td
///    width="60%"> Only Administrators can remotely access power settings. </td> </tr> </table>
///    
@DllImport("POWRPROF")
uint PowerSettingAccessCheck(POWER_DATA_ACCESSOR AccessFlags, const(GUID)* PowerGuid);

///Retrieves the friendly name for the specified power setting, subgroup, or scheme. If the <i>SchemeGuid</i> parameter
///is not <b>NULL</b> but both the <i>SubGroupOfPowerSettingsGuid</i> and <i>PowerSettingGuid</i> parameters are
///<b>NULL</b>, the friendly name of the power scheme will be returned. If the <i>SchemeGuid</i> and
///<i>SubGroupOfPowerSettingsGuid</i> parameters are not <b>NULL</b>and the <i>PowerSettingGuid</i> parameter is
///<b>NULL</b>, the friendly name of the subgroup will be returned. If the <i>SchemeGuid</i>,
///<i>SubGroupOfPowerSettingsGuid</i>, and <i>PowerSettingGuid</i> parameters are not <b>NULL</b>, the friendly name of
///the power setting will be returned.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. Use <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr>
///                                  <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a
///                                  id="no_subgroup_guid"></a><dl> <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt>
///                                  </dl> </td> <td width="60%"> Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being used.
///    Buffer = A pointer to a buffer that receives the friendly name. If this parameter is <b>NULL</b>, the <i>BufferSize</i>
///             parameter receives the required buffer size. The strings returned are all wide (Unicode) strings.
///    BufferSize = A pointer to a variable that contains the size of the buffer pointed to by the <i>Buffer</i> parameter. If the
///                 <i>Buffer</i> parameter is <b>NULL</b>, the function returns ERROR_SUCCESS and the variable receives the required
///                 buffer size. If the specified buffer size is not large enough to hold the requested data, the function returns
///                 <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size specified by the <i>BufferSize</i> parameter is too small, <b>ERROR_MORE_DATA</b> will be returned
///    and the <b>DWORD</b> pointed to by the <i>BufferSize</i> parameter will be filled in with the required buffer
///    size.
///    
@DllImport("POWRPROF")
uint PowerReadFriendlyName(HKEY RootPowerKey, const(GUID)* SchemeGuid, const(GUID)* SubGroupOfPowerSettingsGuid, 
                           const(GUID)* PowerSettingGuid, ubyte* Buffer, uint* BufferSize);

///Retrieves the description for the specified power setting, subgroup, or scheme. If the <i>SchemeGuid</i> parameter is
///not <b>NULL</b> but both the <i>SubGroupOfPowerSettingsGuid</i> and <i>PowerSettingGuid</i> parameters are
///<b>NULL</b>, the description of the power scheme will be returned. If the <i>SchemeGuid</i> and
///<i>SubGroupOfPowerSettingsGuid</i> parameters are not <b>NULL</b>and the <i>PowerSettingGuid</i> parameter is
///<b>NULL</b>, the description of the subgroup will be returned. If the <i>SchemeGuid</i>,
///<i>SubGroupOfPowerSettingsGuid</i>, and <i>PowerSettingGuid</i> parameters are not <b>NULL</b>, the description of
///the power setting will be returned.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being used.
///    Buffer = A pointer to a buffer that receives the description. If this parameter is <b>NULL</b>, the <i>BufferSize</i>
///             parameter receives the required buffer size. The strings returned are all wide (Unicode) strings.
///    BufferSize = A pointer to a variable that contains the size of the buffer pointed to by the <i>Buffer</i> parameter. If the
///                 <i>Buffer</i> parameter is <b>NULL</b>, the function returns ERROR_SUCCESS and the variable receives the required
///                 buffer size. If the specified buffer size is not large enough to hold the requested data, the function returns
///                 <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size specified by the <i>BufferSize</i> parameter is too small, the function returns <b>ERROR_SUCCESS</b>
///    and the <b>DWORD</b> pointed to by the <i>BufferSize</i> parameter is filled in with the required buffer size.
///    
@DllImport("POWRPROF")
uint PowerReadDescription(HKEY RootPowerKey, const(GUID)* SchemeGuid, const(GUID)* SubGroupOfPowerSettingsGuid, 
                          const(GUID)* PowerSettingGuid, ubyte* Buffer, uint* BufferSize);

///Retrieves the value for a possible value of a power setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Type = A pointer to a variable that receives the type of data for the value. The possible values are listed in Registry
///           Value Types. This parameter can be <b>NULL</b> and the type of data is not returned.
///    PossibleSettingIndex = The zero-based index of the possible setting.
///    Buffer = A pointer to a buffer that receives the value. If this parameter is <b>NULL</b>, the <i>BufferSize</i> parameter
///             receives the required buffer size.
///    BufferSize = A pointer to a variable that contains the size of the buffer pointed to by the <i>Buffer</i> parameter. If the
///                 <i>Buffer</i> parameter is <b>NULL</b>, the function returns ERROR_SUCCESS and the variable receives the required
///                 buffer size. If the specified buffer size is not large enough to hold the requested data, the function returns
///                 <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size specified by the <i>BufferSize</i> parameter is too small, <b>ERROR_MORE_DATA</b> will be returned
///    and the <b>DWORD</b> pointed to by the <i>BufferSize</i> parameter will be filled in with the required buffer
///    size.
///    
@DllImport("POWRPROF")
uint PowerReadPossibleValue(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                            const(GUID)* PowerSettingGuid, uint* Type, uint PossibleSettingIndex, ubyte* Buffer, 
                            uint* BufferSize);

///Retrieves the friendly name for one of the possible choices of a power setting value.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    PossibleSettingIndex = The zero-based index for the possible setting.
///    Buffer = A pointer to a buffer that receives the friendly name. If this parameter is <b>NULL</b>, the <i>BufferSize</i>
///             parameter receives the required buffer size. The strings returned are all wide (Unicode) strings.
///    BufferSize = A pointer to a variable that contains the size of the buffer pointed to by the <i>Buffer</i> parameter. If the
///                 <i>Buffer</i> parameter is <b>NULL</b>, the function returns ERROR_SUCCESS and the variable receives the required
///                 buffer size. If the specified buffer size is not large enough to hold the requested data, the function returns
///                 <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size specified by the <i>BufferSize</i> parameter is too small, <b>ERROR_MORE_DATA</b> will be returned
///    and the <b>DWORD</b> pointed to by the <i>BufferSize</i> parameter will be filled in with the required buffer
///    size.
///    
@DllImport("POWRPROF")
uint PowerReadPossibleFriendlyName(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                                   const(GUID)* PowerSettingGuid, uint PossibleSettingIndex, ubyte* Buffer, 
                                   uint* BufferSize);

///Retrieves the description for one of the possible choices of a power setting value.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being used.
///    PossibleSettingIndex = The zero-based index for the possible setting.
///    Buffer = A pointer to a buffer that receives the description. If this parameter is <b>NULL</b>, the <i>BufferSize</i>
///             parameter receives the required buffer size. The strings returned are all wide (Unicode) strings.
///    BufferSize = A pointer to a variable that contains the size of the buffer pointed to by the <i>Buffer</i> parameter. If the
///                 <i>Buffer</i> parameter is <b>NULL</b>, the function returns ERROR_SUCCESS and the variable receives the required
///                 buffer size. If the specified buffer size is not large enough to hold the requested data, the function returns
///                 <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size specified by the <i>BufferSize</i> parameter is too small, <b>ERROR_MORE_DATA</b> will be returned
///    and the <b>DWORD</b> pointed to by the <i>BufferSize</i> parameter will be filled in with the required buffer
///    size.
///    
@DllImport("POWRPROF")
uint PowerReadPossibleDescription(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                                  const(GUID)* PowerSettingGuid, uint PossibleSettingIndex, ubyte* Buffer, 
                                  uint* BufferSize);

///Retrieves the minimum value for the specified power setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being used.
///    ValueMinimum = A pointer to a variable that receives the minimum value for the specified power setting.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerReadValueMin(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, const(GUID)* PowerSettingGuid, 
                       uint* ValueMinimum);

///Retrieves the maximum value for the specified power setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being used.
///    ValueMaximum = A pointer to a variable that receives the maximum for the specified power setting.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerReadValueMax(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, const(GUID)* PowerSettingGuid, 
                       uint* ValueMaximum);

///Retrieves the increment for valid values between the power settings minimum and maximum. If the power setting is not
///defined with a range of possible values then this function will return an error.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being used.
///    ValueIncrement = A pointer to a variable that receives the increment for the specified power setting.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerReadValueIncrement(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                             const(GUID)* PowerSettingGuid, uint* ValueIncrement);

///Reads the string used to describe the units of a power setting that supports a range of values. For example "minutes"
///may be used to describe a timeout setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being used.
///    Buffer = A pointer to a buffer that receives the string. If this parameter is <b>NULL</b>, the <i>BufferSize</i> parameter
///             receives the required buffer size. The strings returned are all wide (Unicode) strings.
///    BufferSize = A pointer to a variable that contains the size of the buffer pointed to by the <i>Buffer</i> parameter. If the
///                 <i>Buffer</i> parameter is <b>NULL</b>, the function returns ERROR_SUCCESS and the variable receives the required
///                 buffer size. If the specified buffer size is not large enough to hold the requested data, the function returns
///                 <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size specified by the <i>BufferSize</i> parameter is too small, <b>ERROR_MORE_DATA</b> will be returned
///    and the <b>DWORD</b> pointed to by the <i>BufferSize</i> parameter will be filled in with the required buffer
///    size.
///    
@DllImport("POWRPROF")
uint PowerReadValueUnitsSpecifier(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                                  const(GUID)* PowerSettingGuid, ubyte* Buffer, uint* BufferSize);

///Retrieves the icon resource for the specified power setting, subgroup, or scheme. If the <i>SchemeGuid</i> parameter
///is not <b>NULL</b> but both the <i>SubGroupOfPowerSettingsGuid</i> and <i>PowerSettingGuid</i> parameters are
///<b>NULL</b>, the friendly name of the power scheme will be returned. If the <i>SchemeGuid</i> and
///<i>SubGroupOfPowerSettingsGuid</i> parameters are not <b>NULL</b>and the <i>PowerSettingGuid</i> parameter is
///<b>NULL</b>, the friendly name of the subgroup will be returned. If the <i>SchemeGuid</i>,
///<i>SubGroupOfPowerSettingsGuid</i>, and <i>PowerSettingGuid</i> parameters are not <b>NULL</b>, the friendly name of
///the power setting will be returned.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Buffer = A pointer to a buffer that receives the icon resource. If this parameter is <b>NULL</b>, the <i>BufferSize</i>
///             parameter receives the required buffer size.
///    BufferSize = A pointer to a variable that contains the size of the buffer pointed to by the <i>Buffer</i> parameter. If the
///                 <i>Buffer</i> parameter is <b>NULL</b>, the function returns ERROR_SUCCESS and the variable receives the required
///                 buffer size. If the specified buffer size is not large enough to hold the requested data, the function returns
///                 <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size specified by the <i>BufferSize</i> parameter is too small, <b>ERROR_MORE_DATA</b> will be returned
///    and the <b>DWORD</b> pointed to by the <i>BufferSize</i> parameter will be filled in with the required buffer
///    size.
///    
@DllImport("POWRPROF")
uint PowerReadIconResourceSpecifier(HKEY RootPowerKey, const(GUID)* SchemeGuid, 
                                    const(GUID)* SubGroupOfPowerSettingsGuid, const(GUID)* PowerSettingGuid, 
                                    ubyte* Buffer, uint* BufferSize);

///Returns the current attribute of the specified power setting. If the <i>SubGroupGuid</i> parameter is <b>NULL</b>
///then the attribute for <i>PowerSettingGuid</i> is returned. If the <i>PowerSettingGuid</i> parameter is <b>NULL</b>
///then the attribute for <i>SubGroupGuid</i> is returned. If both the <i>SubGroupGuid</i> and <i>PowerSettingGuid</i>
///parameters are valid then the return value is the combination (bitwise OR) of the attributes of the subgroup and the
///power setting.
///Params:
///    SubGroupGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                   <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. These values are the subgroup values included with
///                   Windows. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a
///                   id="no_subgroup_guid"></a><dl> <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt>
///                   </dl> </td> <td width="60%"> Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td
///                   width="40%"><a id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                   <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                   power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                   id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                   <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                   width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                   width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                   <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                   width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                   <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                   <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                   Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                   width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                   <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                   Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                   id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                   <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                   system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                   id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                   <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                   Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being used.
///Returns:
///    Returns the current power setting attributes of the specified power setting. The attribute is a combination of
///    the attributes of the power setting and the attributes of its subgroup. <table> <tr> <th>Return code/value</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>POWER_ATTRIBUTE_HIDE</b></dt> <dt>1</dt> </dl> </td>
///    <td width="60%"> Hide this power setting. </td> </tr> </table>
///    
@DllImport("POWRPROF")
uint PowerReadSettingAttributes(const(GUID)* SubGroupGuid, const(GUID)* PowerSettingGuid);

///Sets the friendly name for the specified power setting, subgroup, or scheme. If the <i>SchemeGuid</i> parameter is
///not <b>NULL</b> but both the <i>SubGroupOfPowerSettingsGuid</i> and <i>PowerSettingGuid</i> parameters are
///<b>NULL</b>, the friendly name of the power scheme will be set. If the <i>SchemeGuid</i> and
///<i>SubGroupOfPowerSettingsGuid</i> parameters are not <b>NULL</b>and the <i>PowerSettingGuid</i> parameter is
///<b>NULL</b>, the friendly name of the subgroup will be set. If the <i>SchemeGuid</i>,
///<i>SubGroupOfPowerSettingsGuid</i>, and <i>PowerSettingGuid</i> parameters are not <b>NULL</b>, the friendly name of
///the power setting will be set.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Buffer = The friendly name, in wide (Unicode) characters.
///    BufferSize = The size of the friendly name specified by the <i>Buffer</i> parameter, including the terminating <b>NULL</b>
///                 character.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWriteFriendlyName(HKEY RootPowerKey, const(GUID)* SchemeGuid, const(GUID)* SubGroupOfPowerSettingsGuid, 
                            const(GUID)* PowerSettingGuid, ubyte* Buffer, uint BufferSize);

///Sets the description for the specified power setting, subgroup, or scheme.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Buffer = The description, in wide (Unicode) characters.
///    BufferSize = The size of the buffer pointed to by the <i>Buffer</i> parameter.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWriteDescription(HKEY RootPowerKey, const(GUID)* SchemeGuid, const(GUID)* SubGroupOfPowerSettingsGuid, 
                           const(GUID)* PowerSettingGuid, ubyte* Buffer, uint BufferSize);

///Sets the value for a possible value of a power setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Type = The type of data for the value. The possible values are listed in Registry Value Types.
///    PossibleSettingIndex = The zero-based index for the possible setting.
///    Buffer = The value for the possible setting.
///    BufferSize = The size of the buffer pointed to by the <i>Buffer</i> parameter.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWritePossibleValue(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                             const(GUID)* PowerSettingGuid, uint Type, uint PossibleSettingIndex, ubyte* Buffer, 
                             uint BufferSize);

///Sets the friendly name for the specified possible setting of a power setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    PossibleSettingIndex = The zero-based index for the possible setting.
///    Buffer = The friendly name, in wide (Unicode) characters.
///    BufferSize = The size of the buffer pointed to by the <i>Buffer</i> parameter.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWritePossibleFriendlyName(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                                    const(GUID)* PowerSettingGuid, uint PossibleSettingIndex, ubyte* Buffer, 
                                    uint BufferSize);

///Sets the description for one of the possible choices of a power setting value.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being used.
///    PossibleSettingIndex = The zero-based index for the possible setting.
///    Buffer = The description, in wide (Unicode) characters.
///    BufferSize = The size of the buffer pointed to by the <i>Buffer</i> parameter.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWritePossibleDescription(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                                   const(GUID)* PowerSettingGuid, uint PossibleSettingIndex, ubyte* Buffer, 
                                   uint BufferSize);

///Sets the minimum value for the specified power setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    ValueMinimum = The minimum value to be set.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWriteValueMin(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, const(GUID)* PowerSettingGuid, 
                        uint ValueMinimum);

///Sets the maximum value for the specified power setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    ValueMaximum = The maximum value to be set.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWriteValueMax(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, const(GUID)* PowerSettingGuid, 
                        uint ValueMaximum);

///Sets the increment for valid values between the power settings minimum and maximum.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    ValueIncrement = The increment to be set.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWriteValueIncrement(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                              const(GUID)* PowerSettingGuid, uint ValueIncrement);

///Writes the string used to describe the units of a power setting that supports a range of values. For example
///"minutes" may be used to describe a timeout setting.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Buffer = The units specifier, in wide (Unicode) characters.
///    BufferSize = The size of the buffer pointed to by the <i>Buffer</i> parameter.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWriteValueUnitsSpecifier(HKEY RootPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                                   const(GUID)* PowerSettingGuid, ubyte* Buffer, uint BufferSize);

///Sets the icon resource for the specified power setting, subgroup, or scheme.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                                  <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                                  <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                                  <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Buffer = The icon resource.
///    BufferSize = The size of the buffer pointed to by the <i>Buffer</i> parameter.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWriteIconResourceSpecifier(HKEY RootPowerKey, const(GUID)* SchemeGuid, 
                                     const(GUID)* SubGroupOfPowerSettingsGuid, const(GUID)* PowerSettingGuid, 
                                     ubyte* Buffer, uint BufferSize);

///Sets the power attributes of a power key. If the <i>PowerSettingGuid</i> parameter is <b>NULL</b> then the attribute
///for <i>SubGroupGuid</i> is set, otherwise the attribute for <i>PowerSettingGuid</i> is set.
///Params:
///    SubGroupGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                   <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                   <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                   <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                   Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                   id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                   <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                   power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                   id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                   <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                   width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                   width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                   <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                   width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                   <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                   <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                   Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                   width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                   <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                   Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                   id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                   <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                   system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                   id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                   <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                   Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting.
///    Attributes = The attributes to be associated with the specified power setting. <table> <tr> <th>Value</th> <th>Meaning</th>
///                 </tr> <tr> <td width="40%"><a id="POWER_ATTRIBUTE_HIDE"></a><a id="power_attribute_hide"></a><dl>
///                 <dt><b>POWER_ATTRIBUTE_HIDE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Hide this power setting. </td> </tr>
///                 </table>
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerWriteSettingAttributes(const(GUID)* SubGroupGuid, const(GUID)* PowerSettingGuid, uint Attributes);

///Duplicates an existing power scheme.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SourceSchemeGuid = The identifier of the power scheme that is to be duplicated.
///    DestinationSchemeGuid = The address of a pointer to a <b>GUID</b>. If the pointer contains <b>NULL</b>, the function allocates memory for
///                            a new <b>GUID</b> and puts the address of this memory in the pointer. The caller can free this memory using
///                            LocalFree.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. <table>
///    <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b><b>ERROR_SUCCESS</b></b></dt> <dt>0 (0x0)</dt> </dl> </td> <td width="60%"> The power scheme was
///    successfully duplicated. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>ERROR_INVALID_PARAMETER</b></b></dt>
///    <dt>87 (0x57)</dt> </dl> </td> <td width="60%"> One of the parameters is not valid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b><b>ERROR_ALREADY_EXISTS</b></b></dt> <dt>183 (0xB7)</dt> </dl> </td> <td width="60%">
///    The <i>DestinationSchemeGuid</i> parameter refers to an existing power scheme. PowerDeleteScheme can be used to
///    delete this scheme. </td> </tr> </table>
///    
@DllImport("POWRPROF")
uint PowerDuplicateScheme(HKEY RootPowerKey, const(GUID)* SourceSchemeGuid, GUID** DestinationSchemeGuid);

///Imports a power scheme from a file.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    ImportFileNamePath = The path to a power scheme backup file created by <b>PowerCfg.Exe /Export</b>.
///    DestinationSchemeGuid = A pointer to a pointer to a <b>GUID</b>. If the pointer contains <b>NULL</b>, the function allocates memory for a
///                            new <b>GUID</b> and puts the address of this memory in the pointer. The caller can free this memory using
///                            LocalFree.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerImportPowerScheme(HKEY RootPowerKey, const(PWSTR) ImportFileNamePath, GUID** DestinationSchemeGuid);

///Deletes the specified power scheme from the database.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerDeleteScheme(HKEY RootPowerKey, const(GUID)* SchemeGuid);

///Deletes the specified power setting.
///Params:
///    PowerSettingSubKeyGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. Use
///                             <b>NO_SUBGROUP_GUID</b> to refer to the default power scheme. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                             <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl>
///                             <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%">
///                             Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td width="40%"><a
///                             id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                             <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                             power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                             id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                             <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                             width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                             width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                             <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                             width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                             <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                             <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                             Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                             width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                             <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                             Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                             id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                             <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                             system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                             id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                             <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                             Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting to be deleted.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerRemovePowerSetting(const(GUID)* PowerSettingSubKeyGuid, const(GUID)* PowerSettingGuid);

///Creates a setting value for a specified power setting.
///Params:
///    RootSystemPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. <table>
///                                  <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a
///                                  id="no_subgroup_guid"></a><dl> <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt>
///                                  </dl> </td> <td width="60%"> Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being created.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerCreateSetting(HKEY RootSystemPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                        const(GUID)* PowerSettingGuid);

///Creates a possible setting value for a specified power setting.
///Params:
///    RootSystemPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. This parameter can be one of the following values defined in WinNT.h. <table>
///                                  <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NO_SUBGROUP_GUID"></a><a
///                                  id="no_subgroup_guid"></a><dl> <dt><b>NO_SUBGROUP_GUID</b></dt> <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt>
///                                  </dl> </td> <td width="60%"> Settings in this subgroup are part of the default power scheme. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_DISK_SUBGROUP"></a><a id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt>
///                                  <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  power management configuration of the system's hard disk drives. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a id="guid_system_button_subgroup"></a><dl>
///                                  <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt> <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of the system power buttons. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    PowerSettingGuid = The identifier of the power setting that is being created.
///    PossibleSettingIndex = The zero-based index for the possible setting being created.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerCreatePossibleSetting(HKEY RootSystemPowerKey, const(GUID)* SubGroupOfPowerSettingsGuid, 
                                const(GUID)* PowerSettingGuid, uint PossibleSettingIndex);

///Enumerates the specified elements in a power scheme. This function is normally called in a loop incrementing the
///<i>Index</i> parameter to retrieve subkeys until they've all been enumerated.
///Params:
///    RootPowerKey = This parameter is reserved for future use and must be set to <b>NULL</b>.
///    SchemeGuid = The identifier of the power scheme. If this parameter is <b>NULL</b>, an enumeration of the power policies is
///                 returned.
///    SubGroupOfPowerSettingsGuid = The subgroup of power settings. If this parameter is <b>NULL</b>, an enumeration of settings under the
///                                  <b>PolicyGuid</b> key is returned. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                                  id="NO_SUBGROUP_GUID"></a><a id="no_subgroup_guid"></a><dl> <dt><b>NO_SUBGROUP_GUID</b></dt>
///                                  <dt>fea3413e-7e05-4911-9a71-700331f1c294</dt> </dl> </td> <td width="60%"> Settings in this subgroup will be part
///                                  of the default power scheme. </td> </tr> <tr> <td width="40%"><a id="GUID_DISK_SUBGROUP"></a><a
///                                  id="guid_disk_subgroup"></a><dl> <dt><b>GUID_DISK_SUBGROUP</b></dt> <dt>0012ee47-9041-4b5d-9b77-535fba8b1442</dt>
///                                  </dl> </td> <td width="60%"> Settings in this subgroup control power management configuration of the system's
///                                  hard disk drives. </td> </tr> <tr> <td width="40%"><a id="GUID_SYSTEM_BUTTON_SUBGROUP"></a><a
///                                  id="guid_system_button_subgroup"></a><dl> <dt><b>GUID_SYSTEM_BUTTON_SUBGROUP</b></dt>
///                                  <dt>4f971e89-eebd-4455-a8de-9e59040e7347</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  configuration of the system power buttons. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_PROCESSOR_SETTINGS_SUBGROUP"></a><a id="guid_processor_settings_subgroup"></a><dl>
///                                  <dt><b>GUID_PROCESSOR_SETTINGS_SUBGROUP</b></dt> <dt>54533251-82be-4824-96c1-47b60b740d00</dt> </dl> </td> <td
///                                  width="60%"> Settings in this subgroup control configuration of processor power management features. </td> </tr>
///                                  <tr> <td width="40%"><a id="GUID_VIDEO_SUBGROUP"></a><a id="guid_video_subgroup"></a><dl>
///                                  <dt><b>GUID_VIDEO_SUBGROUP</b></dt> <dt>7516b95f-f776-4464-8c53-06167f40cc99</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control configuration of the video power management features. </td> </tr> <tr> <td
///                                  width="40%"><a id="GUID_BATTERY_SUBGROUP"></a><a id="guid_battery_subgroup"></a><dl>
///                                  <dt><b>GUID_BATTERY_SUBGROUP</b></dt> <dt>e73a048d-bf27-4f12-9731-8b2076e8891f</dt> </dl> </td> <td width="60%">
///                                  Settings in this subgroup control battery alarm trip points and actions. </td> </tr> <tr> <td width="40%"><a
///                                  id="GUID_SLEEP_SUBGROUP"></a><a id="guid_sleep_subgroup"></a><dl> <dt><b>GUID_SLEEP_SUBGROUP</b></dt>
///                                  <dt>238C9FA8-0AAD-41ED-83F4-97BE242C8F20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control
///                                  system sleep settings. </td> </tr> <tr> <td width="40%"><a id="GUID_PCIEXPRESS_SETTINGS_SUBGROUP"></a><a
///                                  id="guid_pciexpress_settings_subgroup"></a><dl> <dt><b>GUID_PCIEXPRESS_SETTINGS_SUBGROUP</b></dt>
///                                  <dt>501a4d13-42af-4429-9fd1-a8218c268e20</dt> </dl> </td> <td width="60%"> Settings in this subgroup control PCI
///                                  Express settings. </td> </tr> </table>
///    AccessFlags = A set of flags that specifies what will be enumerated <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                  width="40%"><a id="ACCESS_SCHEME"></a><a id="access_scheme"></a><dl> <dt><b>ACCESS_SCHEME</b></dt> <dt>16</dt>
///                  </dl> </td> <td width="60%"> Enumerate power schemes. The <i>SchemeGuid</i> and
///                  <i>SubgroupOfPowerSettingsGuid</i> parameters will be ignored. </td> </tr> <tr> <td width="40%"><a
///                  id="ACCESS_SUBGROUP"></a><a id="access_subgroup"></a><dl> <dt><b>ACCESS_SUBGROUP</b></dt> <dt>17</dt> </dl> </td>
///                  <td width="60%"> Enumerate subgroups under <i>SchemeGuid</i>. The <i>SubgroupOfPowerSettingsGuid</i> parameter
///                  will be ignored. </td> </tr> <tr> <td width="40%"><a id="ACCESS_INDIVIDUAL_SETTING"></a><a
///                  id="access_individual_setting"></a><dl> <dt><b>ACCESS_INDIVIDUAL_SETTING</b></dt> <dt>18</dt> </dl> </td> <td
///                  width="60%"> Enumerate individual power settings under <i>SchemeGuid</i>&
///    Index = The zero-based index of the scheme, subgroup, or setting that is being enumerated.
///    Buffer = A pointer to a variable to receive the elements. If this parameter is <b>NULL</b>, the function retrieves the
///             size of the buffer required.
///    BufferSize = A pointer to a variable that on input contains the size of the buffer pointed to by the <i>Buffer</i> parameter.
///                 If the <i>Buffer</i> parameter is <b>NULL</b> or if the <i>BufferSize</i> is not large enough, the function will
///                 return <b>ERROR_MORE_DATA</b> and the variable receives the required buffer size.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed. If the
///    buffer size passed in the <i>BufferSize</i> parameter is too small, or if the <i>Buffer</i> parameter is
///    <b>NULL</b>, <b>ERROR_MORE_DATA</b> will be returned and the <b>DWORD</b> pointed to by the <i>BufferSize</i>
///    parameter will be filled in with the required buffer size.
///    
@DllImport("POWRPROF")
uint PowerEnumerate(HKEY RootPowerKey, const(GUID)* SchemeGuid, const(GUID)* SubGroupOfPowerSettingsGuid, 
                    POWER_DATA_ACCESSOR AccessFlags, uint Index, ubyte* Buffer, uint* BufferSize);

@DllImport("POWRPROF")
uint PowerOpenUserPowerKey(HKEY* phUserPowerKey, uint Access, BOOL OpenExisting);

@DllImport("POWRPROF")
uint PowerOpenSystemPowerKey(HKEY* phSystemPowerKey, uint Access, BOOL OpenExisting);

///Determines if the current user has access to the data for the specified power scheme so that it could be restored if
///necessary.
///Params:
///    SchemeGuid = The identifier of the power scheme.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerCanRestoreIndividualDefaultPowerScheme(const(GUID)* SchemeGuid);

///Replaces a specific power scheme for the current user with one from the default user (stored in
///<b>HKEY_USERS</b>&#92;<b>.Default</b>)
///Params:
///    SchemeGuid = The identifier of the power scheme.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerRestoreIndividualDefaultPowerScheme(const(GUID)* SchemeGuid);

///Replaces the power schemes for the system with default power schemes. All current power schemes and settings are
///deleted and replaced with the default system power schemes.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerRestoreDefaultPowerSchemes();

///Replaces the default power schemes with the current user's power schemes. This allows an administrator to change the
///default power schemes for the system. Replacing the default schemes enables users to use the <b>Restore Defaults</b>
///option in the Control Panel <b>Power Options</b> application to restore customized power scheme defaults instead of
///the original Windows power scheme defaults.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerReplaceDefaultPowerSchemes();

///Determines the computer role for Windows 7, Windows Server 2008 R2, Windows Vista or Windows Server 2008. To specify
///a different platform, use the PowerDeterminePlatformRoleEx function. To query additional power platform roles defined
///after Windows 7 and Windows Server 2008 R2, use PowerDeterminePlatformRoleEx.
///Returns:
///    The return value is one of the values from the POWER_PLATFORM_ROLE enumeration.
///    
@DllImport("POWRPROF")
POWER_PLATFORM_ROLE PowerDeterminePlatformRole();

///Enumerates devices on the system that meet the specified criteria.
///Params:
///    QueryIndex = The index of the requested device. For initial calls, this value should be zero.
///    QueryInterpretationFlags = The criteria applied to the search results. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                               width="40%"><a id="DEVICEPOWER_HARDWAREID"></a><a id="devicepower_hardwareid"></a><dl>
///                               <dt><b>DEVICEPOWER_HARDWAREID</b></dt> <dt>0x80000000</dt> </dl> </td> <td width="60%"> Return a hardware ID
///                               string rather than friendly device name. </td> </tr> <tr> <td width="40%"><a
///                               id="DEVICEPOWER_FILTER_DEVICES_PRESENT"></a><a id="devicepower_filter_devices_present"></a><dl>
///                               <dt><b>DEVICEPOWER_FILTER_DEVICES_PRESENT</b></dt> <dt>0x20000000</dt> </dl> </td> <td width="60%"> Ignore
///                               devices not currently present in the system. </td> </tr> <tr> <td width="40%"><a
///                               id="DEVICEPOWER_AND_OPERATION"></a><a id="devicepower_and_operation"></a><dl>
///                               <dt><b>DEVICEPOWER_AND_OPERATION</b></dt> <dt>0x40000000</dt> </dl> </td> <td width="60%"> Perform an AND
///                               operation on <i>QueryFlags</i>. </td> </tr> <tr> <td width="40%"><a id="DEVICEPOWER_FILTER_WAKEENABLED"></a><a
///                               id="devicepower_filter_wakeenabled"></a><dl> <dt><b>DEVICEPOWER_FILTER_WAKEENABLED</b></dt> <dt>0x08000000</dt>
///                               </dl> </td> <td width="60%"> Check whether the device is currently enabled to wake the system from a sleep state.
///                               </td> </tr> <tr> <td width="40%"><a id="DEVICEPOWER_FILTER_ON_NAME"></a><a
///                               id="devicepower_filter_on_name"></a><dl> <dt><b>DEVICEPOWER_FILTER_ON_NAME</b></dt> <dt>0x02000000</dt> </dl>
///                               </td> <td width="60%"> Find a device whose name matches the string passed in <i>pReturnBuffer</i> and check its
///                               capabilities against <i>QueryFlags</i>. </td> </tr> </table>
///    QueryFlags = The query criteria. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                 id="PDCAP_D0_SUPPORTED"></a><a id="pdcap_d0_supported"></a><dl> <dt><b>PDCAP_D0_SUPPORTED</b></dt>
///                 <dt>0x00000001</dt> </dl> </td> <td width="60%"> The device supports system power state D0. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_D1_SUPPORTED"></a><a id="pdcap_d1_supported"></a><dl> <dt><b>PDCAP_D1_SUPPORTED</b></dt>
///                 <dt>0x00000002</dt> </dl> </td> <td width="60%"> The device supports system power state D1. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_D2_SUPPORTED"></a><a id="pdcap_d2_supported"></a><dl> <dt><b>PDCAP_D2_SUPPORTED</b></dt>
///                 <dt>0x00000004</dt> </dl> </td> <td width="60%"> The device supports system power state D2. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_D3_SUPPORTED"></a><a id="pdcap_d3_supported"></a><dl> <dt><b>PDCAP_D3_SUPPORTED</b></dt>
///                 <dt>0x00000008</dt> </dl> </td> <td width="60%"> The device supports system power state D3. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_S0_SUPPORTED"></a><a id="pdcap_s0_supported"></a><dl> <dt><b>PDCAP_S0_SUPPORTED</b></dt>
///                 <dt>0x00010000</dt> </dl> </td> <td width="60%"> The device supports system sleep state S0. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_S1_SUPPORTED"></a><a id="pdcap_s1_supported"></a><dl> <dt><b>PDCAP_S1_SUPPORTED</b></dt>
///                 <dt>0x00020000</dt> </dl> </td> <td width="60%"> The device supports system sleep state S1. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_S2_SUPPORTED"></a><a id="pdcap_s2_supported"></a><dl> <dt><b>PDCAP_S2_SUPPORTED</b></dt>
///                 <dt>0x00040000</dt> </dl> </td> <td width="60%"> The device supports system sleep state S2. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_S3_SUPPORTED"></a><a id="pdcap_s3_supported"></a><dl> <dt><b>PDCAP_S3_SUPPORTED</b></dt>
///                 <dt>0x00080000</dt> </dl> </td> <td width="60%"> The device supports system sleep state S3. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_S4_SUPPORTED"></a><a id="pdcap_s4_supported"></a><dl> <dt><b>PDCAP_S4_SUPPORTED</b></dt>
///                 <dt>0x01000000</dt> </dl> </td> <td width="60%"> The device supports system sleep state S4. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_S5_SUPPORTED"></a><a id="pdcap_s5_supported"></a><dl> <dt><b>PDCAP_S5_SUPPORTED</b></dt>
///                 <dt>0x02000000</dt> </dl> </td> <td width="60%"> The device supports system sleep state S5. </td> </tr> <tr> <td
///                 width="40%"><a id="PDCAP_WAKE_FROM_D0_SUPPORTED"></a><a id="pdcap_wake_from_d0_supported"></a><dl>
///                 <dt><b>PDCAP_WAKE_FROM_D0_SUPPORTED</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> The device supports
///                 waking from system power state D0. </td> </tr> <tr> <td width="40%"><a id="PDCAP_WAKE_FROM_D1_SUPPORTED"></a><a
///                 id="pdcap_wake_from_d1_supported"></a><dl> <dt><b>PDCAP_WAKE_FROM_D1_SUPPORTED</b></dt> <dt>0x00000020</dt> </dl>
///                 </td> <td width="60%"> The device supports waking from system power state D1. </td> </tr> <tr> <td width="40%"><a
///                 id="PDCAP_WAKE_FROM_D2_SUPPORTED"></a><a id="pdcap_wake_from_d2_supported"></a><dl>
///                 <dt><b>PDCAP_WAKE_FROM_D2_SUPPORTED</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> The device supports
///                 waking from system power state D2. </td> </tr> <tr> <td width="40%"><a id="PDCAP_WAKE_FROM_D3_SUPPORTED"></a><a
///                 id="pdcap_wake_from_d3_supported"></a><dl> <dt><b>PDCAP_WAKE_FROM_D3_SUPPORTED</b></dt> <dt>0x00000080</dt> </dl>
///                 </td> <td width="60%"> The device supports waking from system power state D3. </td> </tr> <tr> <td width="40%"><a
///                 id="PDCAP_WAKE_FROM_S0_SUPPORTED"></a><a id="pdcap_wake_from_s0_supported"></a><dl>
///                 <dt><b>PDCAP_WAKE_FROM_S0_SUPPORTED</b></dt> <dt>0x00100000</dt> </dl> </td> <td width="60%"> The device supports
///                 waking from system sleep state S0. </td> </tr> <tr> <td width="40%"><a id="PDCAP_WAKE_FROM_S1_SUPPORTED"></a><a
///                 id="pdcap_wake_from_s1_supported"></a><dl> <dt><b>PDCAP_WAKE_FROM_S1_SUPPORTED</b></dt> <dt>0x00200000</dt> </dl>
///                 </td> <td width="60%"> The device supports waking from system sleep state S1. </td> </tr> <tr> <td width="40%"><a
///                 id="PDCAP_WAKE_FROM_S2_SUPPORTED"></a><a id="pdcap_wake_from_s2_supported"></a><dl>
///                 <dt><b>PDCAP_WAKE_FROM_S2_SUPPORTED</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> The device supports
///                 waking from system sleep state S2. </td> </tr> <tr> <td width="40%"><a id="PDCAP_WAKE_FROM_S3_SUPPORTED"></a><a
///                 id="pdcap_wake_from_s3_supported"></a><dl> <dt><b>PDCAP_WAKE_FROM_S3_SUPPORTED</b></dt> <dt>0x00800000</dt> </dl>
///                 </td> <td width="60%"> The device supports waking from system sleep state S3. </td> </tr> <tr> <td width="40%"><a
///                 id="PDCAP_WARM_EJECT_SUPPORTED"></a><a id="pdcap_warm_eject_supported"></a><dl>
///                 <dt><b>PDCAP_WARM_EJECT_SUPPORTED</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> The device supports
///                 warm eject. </td> </tr> </table>
///    pReturnBuffer = Pointer to a buffer that receives the requested information.
///    pBufferSize = The size, in bytes, of the return buffer. <div class="alert"><b>Note</b> If <i>pReturnBuffer</i> is <b>NULL</b>,
///                  <i>pBufferSize</i> will be filled with the size needed to return the data.</div> <div> </div>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.
///    
@DllImport("POWRPROF")
ubyte DevicePowerEnumDevices(uint QueryIndex, uint QueryInterpretationFlags, uint QueryFlags, ubyte* pReturnBuffer, 
                             uint* pBufferSize);

///Modifies the specified data on the specified device.
///Params:
///    DeviceDescription = The name or hardware identifier string of the device to be modified.
///    SetFlags = The properties of the device that are to be modified. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///               width="40%"><a id="DEVICEPOWER_SET_WAKEENABLED"></a><a id="devicepower_set_wakeenabled"></a><dl>
///               <dt><b>DEVICEPOWER_SET_WAKEENABLED</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enables the
///               specified device to wake the system. </td> </tr> <tr> <td width="40%"><a
///               id="DEVICEPOWER_CLEAR_WAKEENABLED"></a><a id="devicepower_clear_wakeenabled"></a><dl>
///               <dt><b>DEVICEPOWER_CLEAR_WAKEENABLED</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Stops the
///               specified device from being able to wake the system. </td> </tr> </table>
///    SetData = Reserved, must be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("POWRPROF")
uint DevicePowerSetDeviceState(const(PWSTR) DeviceDescription, uint SetFlags, void* SetData);

///Initializes a device list by querying all the devices.
///Params:
///    DebugMask = Reserved; must be 0.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.
///    
@DllImport("POWRPROF")
ubyte DevicePowerOpen(uint DebugMask);

///Frees all nodes in the device list and destroys the device list.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.
///    
@DllImport("POWRPROF")
ubyte DevicePowerClose();

///Notifies the operating system of thermal events.
///Params:
///    Event = The thermal event structure, THERMAL_EVENT.
///Returns:
///    Returns <b>ERROR_SUCCESS</b> (zero) if the call was successful, and a nonzero value if the call failed.
///    
@DllImport("POWRPROF")
uint PowerReportThermalEvent(THERMAL_EVENT* Event);

///Sends a control code directly to a specified device driver, causing the corresponding device to perform the
///corresponding operation.
///Params:
///    hDevice = A handle to the device on which the operation is to be performed. The device is typically a volume, directory,
///              file, or stream. To retrieve a device handle, use the CreateFile function. For more information, see Remarks.
///    dwIoControlCode = The control code for the operation. This value identifies the specific operation to be performed and the type of
///                      device on which to perform it. For a list of the control codes, see Remarks. The documentation for each control
///                      code provides usage details for the <i>lpInBuffer</i>, <i>nInBufferSize</i>, <i>lpOutBuffer</i>, and
///                      <i>nOutBufferSize</i> parameters.
///    lpInBuffer = A pointer to the input buffer that contains the data required to perform the operation. The format of this data
///                 depends on the value of the <i>dwIoControlCode</i> parameter. This parameter can be <b>NULL</b> if
///                 <i>dwIoControlCode</i> specifies an operation that does not require input data.
///    nInBufferSize = The size of the input buffer, in bytes.
///    lpOutBuffer = A pointer to the output buffer that is to receive the data returned by the operation. The format of this data
///                  depends on the value of the <i>dwIoControlCode</i> parameter. This parameter can be <b>NULL</b> if
///                  <i>dwIoControlCode</i> specifies an operation that does not return data.
///    nOutBufferSize = The size of the output buffer, in bytes.
///    lpBytesReturned = A pointer to a variable that receives the size of the data stored in the output buffer, in bytes. If the output
///                      buffer is too small to receive any data, the call fails, GetLastError returns <b>ERROR_INSUFFICIENT_BUFFER</b>,
///                      and <i>lpBytesReturned</i> is zero. If the output buffer is too small to hold all of the data but can hold some
///                      entries, some drivers will return as much data as fits. In this case, the call fails, GetLastError returns
///                      <b>ERROR_MORE_DATA</b>, and <i>lpBytesReturned</i> indicates the amount of data received. Your application should
///                      call <b>DeviceIoControl</b> again with the same operation, specifying a new starting point. If
///                      <i>lpOverlapped</i> is <b>NULL</b>, <i>lpBytesReturned</i> cannot be <b>NULL</b>. Even when an operation returns
///                      no output data and <i>lpOutBuffer</i> is <b>NULL</b>, <b>DeviceIoControl</b> makes use of <i>lpBytesReturned</i>.
///                      After such an operation, the value of <i>lpBytesReturned</i> is meaningless. If <i>lpOverlapped</i> is not
///                      <b>NULL</b>, <i>lpBytesReturned</i> can be <b>NULL</b>. If this parameter is not <b>NULL</b> and the operation
///                      returns data, <i>lpBytesReturned</i> is meaningless until the overlapped operation has completed. To retrieve the
///                      number of bytes returned, call GetOverlappedResult. If <i>hDevice</i> is associated with an I/O completion port,
///                      you can retrieve the number of bytes returned by calling GetQueuedCompletionStatus.
///    lpOverlapped = A pointer to an OVERLAPPED structure. If <i>hDevice</i> was opened without specifying
///                   <b>FILE_FLAG_OVERLAPPED</b>, <i>lpOverlapped</i> is ignored. If <i>hDevice</i> was opened with the
///                   <b>FILE_FLAG_OVERLAPPED</b> flag, the operation is performed as an overlapped (asynchronous) operation. In this
///                   case, <i>lpOverlapped</i> must point to a valid OVERLAPPED structure that contains a handle to an event object.
///                   Otherwise, the function fails in unpredictable ways. For overlapped operations, <b>DeviceIoControl</b> returns
///                   immediately, and the event object is signaled when the operation has been completed. Otherwise, the function does
///                   not return until the operation has been completed or an error occurs.
///Returns:
///    If the operation completes successfully, the return value is nonzero. If the operation fails or is pending, the
///    return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeviceIoControl(HANDLE hDevice, uint dwIoControlCode, void* lpInBuffer, uint nInBufferSize, void* lpOutBuffer, 
                     uint nOutBufferSize, uint* lpBytesReturned, OVERLAPPED* lpOverlapped);

///Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device. To
///specify a timeout interval or wait on an alertable thread, use GetOverlappedResultEx.
///Params:
///    hFile = A handle to the file, named pipe, or communications device. This is the same handle that was specified when the
///            overlapped operation was started by a call to any of the following functions: -
///            [ReadFile](../fileapi/nf-fileapi-readfile.md) - [WriteFile](../fileapi/nf-fileapi-writefile.md) -
///            [ConnectNamedPipe](../namedpipeapi/nf-namedpipeapi-connectnamedpipe.md) -
///            [TransactNamedPipe](../namedpipeapi/nf-namedpipeapi-transactnamedpipe.md) -
///            [DeviceIoControl](./nf-ioapiset-deviceiocontrol.md) - [WaitCommEvent](../winbase/nf-winbase-waitcommevent.md) -
///            [ReadDirectoryChangesW](../winbase/nf-winbase-readdirectorychangesw.md) -
///            [LockFileEx](../fileapi/nf-fileapi-lockfileex.md) -
///            [ReadDirectoryChangesW](../winbase/nf-winbase-readdirectorychangesw.md)
///    lpOverlapped = A pointer to an OVERLAPPED structure that was specified when the overlapped operation was started.
///    lpNumberOfBytesTransferred = A pointer to a variable that receives the number of bytes that were actually transferred by a read or write
///                                 operation. For a TransactNamedPipe operation, this is the number of bytes that were read from the pipe. For a
///                                 DeviceIoControl operation, this is the number of bytes of output data returned by the device driver. For a
///                                 ConnectNamedPipe or WaitCommEvent operation, this value is undefined.
///    bWait = If this parameter is <b>TRUE</b>, and the <b>Internal</b> member of the <i>lpOverlapped</i> structure is
///            <b>STATUS_PENDING</b>, the function does not return until the operation has been completed. If this parameter is
///            <b>FALSE</b> and the operation is still pending, the function returns <b>FALSE</b> and the GetLastError function
///            returns <b>ERROR_IO_INCOMPLETE</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetOverlappedResult(HANDLE hFile, OVERLAPPED* lpOverlapped, uint* lpNumberOfBytesTransferred, BOOL bWait);

///Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device within
///the specified time-out interval. The calling thread can perform an alertable wait.
///Params:
///    hFile = A handle to the file, named pipe, or communications device. This is the same handle that was specified when the
///            overlapped operation was started by a call to the ReadFile, WriteFile, ConnectNamedPipe, TransactNamedPipe,
///            DeviceIoControl, or WaitCommEvent function.
///    lpOverlapped = A pointer to an OVERLAPPED structure that was specified when the overlapped operation was started.
///    lpNumberOfBytesTransferred = A pointer to a variable that receives the number of bytes that were actually transferred by a read or write
///                                 operation. For a TransactNamedPipe operation, this is the number of bytes that were read from the pipe. For a
///                                 DeviceIoControl operation, this is the number of bytes of output data returned by the device driver. For a
///                                 ConnectNamedPipe or WaitCommEvent operation, this value is undefined.
///    dwMilliseconds = The time-out interval, in milliseconds. If <i>dwMilliseconds</i> is zero and the operation is still in progress,
///                     the function returns immediately and the GetLastError function returns <b>ERROR_IO_INCOMPLETE</b>. If
///                     <i>dwMilliseconds</i> is nonzero and the operation is still in progress, the function waits until the object is
///                     signaled, an I/O completion routine or APC is queued, or the interval elapses before returning. Use GetLastError
///                     to get extended error information. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function returns only when
///                     the object is signaled or an I/O completion routine or APC is queued.
///    bAlertable = If this parameter is <b>TRUE</b> and the calling thread is in the waiting state, the function returns when the
///                 system queues an I/O completion routine or APC. The calling thread then runs the routine or function. Otherwise,
///                 the function does not return, and the completion routine or APC function is not executed. A completion routine is
///                 queued when the ReadFileEx or WriteFileEx function in which it was specified has completed. The function returns
///                 and the completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the
///                 thread that initiated the read or write operation. An APC is queued when you call QueueUserAPC.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Common error codes include the following: <ul> <li>If
///    <i>dwMilliseconds</i> is zero and the operation is still in progress, GetLastError returns
///    <b>ERROR_IO_INCOMPLETE</b>.</li> <li>If <i>dwMilliseconds</i> is nonzero, and an I/O completion routine or APC is
///    queued, GetLastError returns <b>WAIT_IO_COMPLETION</b>. </li> <li>If <i>dwMilliseconds</i> is nonzero and the
///    specified timeout interval elapses, GetLastError returns <b>WAIT_TIMEOUT</b>. </li> </ul>
///    
@DllImport("KERNEL32")
BOOL GetOverlappedResultEx(HANDLE hFile, OVERLAPPED* lpOverlapped, uint* lpNumberOfBytesTransferred, 
                           uint dwMilliseconds, BOOL bAlertable);

///Determines whether the specified process is running under WOW64 or an Intel64 of x64 processor.
///Params:
///    hProcess = A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION
///               access right. For more information, see Process Security and Access Rights. <b>Windows Server 2003 and Windows
///               XP: </b>The handle must have the PROCESS_QUERY_INFORMATION access right.
///    Wow64Process = A pointer to a value that is set to TRUE if the process is running under WOW64 on an Intel64 or x64 processor. If
///                   the process is running under 32-bit Windows, the value is set to FALSE. If the process is a 32-bit application
///                   running under 64-bit Windows 10 on ARM, the value is set to FALSE. If the process is a 64-bit application running
///                   under 64-bit Windows, the value is also set to FALSE.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL IsWow64Process(HANDLE hProcess, BOOL* Wow64Process);

///Determines whether the specified process is running under WOW64; also returns additional machine process and
///architecture information.
///Params:
///    hProcess = A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or
///               <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see Process Security and Access
///               Rights.
///    pProcessMachine = On success, returns a pointer to an IMAGE_FILE_MACHINE_* value. The value will be
///                      <b>IMAGE_FILE_MACHINE_UNKNOWN</b> if the target process is not a WOW64 process; otherwise, it will identify the
///                      type of WoW process.
///    pNativeMachine = On success, returns a pointer to a possible IMAGE_FILE_MACHINE_* value identifying the native architecture of
///                     host system.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL IsWow64Process2(HANDLE hProcess, ushort* pProcessMachine, ushort* pNativeMachine);

///Logs off the interactive user, shuts down the system, or shuts down and restarts the system. It sends the
///WM_QUERYENDSESSION message to all applications to determine if they can be terminated.
///Params:
///    uFlags = The shutdown type. This parameter must include one of the following values. <table> <tr> <th>Value</th>
///             <th>Meaning</th> </tr> <tr> <td width="40%"><a id="EWX_HYBRID_SHUTDOWN"></a><a id="ewx_hybrid_shutdown"></a><dl>
///             <dt><b>EWX_HYBRID_SHUTDOWN</b></dt> <dt>0x00400000</dt> </dl> </td> <td width="60%"> <b>Beginning with Windows 8:
///             </b>You can prepare the system for a faster startup by combining the <b>EWX_HYBRID_SHUTDOWN</b> flag with the
///             <b>EWX_SHUTDOWN</b> flag. </td> </tr> <tr> <td width="40%"><a id="EWX_LOGOFF"></a><a id="ewx_logoff"></a><dl>
///             <dt><b>EWX_LOGOFF</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Shuts down all processes running in the logon
///             session of the process that called the <b>ExitWindowsEx</b> function. Then it logs the user off. This flag can be
///             used only by processes running in an interactive user's logon session. </td> </tr> <tr> <td width="40%"><a
///             id="EWX_POWEROFF"></a><a id="ewx_poweroff"></a><dl> <dt><b>EWX_POWEROFF</b></dt> <dt>0x00000008</dt> </dl> </td>
///             <td width="60%"> Shuts down the system and turns off the power. The system must support the power-off feature.
///             The calling process must have the SE_SHUTDOWN_NAME privilege. For more information, see the following Remarks
///             section. </td> </tr> <tr> <td width="40%"><a id="EWX_REBOOT"></a><a id="ewx_reboot"></a><dl>
///             <dt><b>EWX_REBOOT</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Shuts down the system and then
///             restarts the system. The calling process must have the SE_SHUTDOWN_NAME privilege. For more information, see the
///             following Remarks section. </td> </tr> <tr> <td width="40%"><a id="EWX_RESTARTAPPS"></a><a
///             id="ewx_restartapps"></a><dl> <dt><b>EWX_RESTARTAPPS</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%">
///             Shuts down the system and then restarts it, as well as any applications that have been registered for restart
///             using the RegisterApplicationRestart function. These application receive the WM_QUERYENDSESSION message with
///             <i>lParam</i> set to the ENDSESSION_CLOSEAPP value. For more information, see Guidelines for Applications. </td>
///             </tr> <tr> <td width="40%"><a id="EWX_SHUTDOWN"></a><a id="ewx_shutdown"></a><dl> <dt><b>EWX_SHUTDOWN</b></dt>
///             <dt>0x00000001</dt> </dl> </td> <td width="60%"> Shuts down the system to a point at which it is safe to turn off
///             the power. All file buffers have been flushed to disk, and all running processes have stopped. The calling
///             process must have the SE_SHUTDOWN_NAME privilege. For more information, see the following Remarks section.
///             Specifying this flag will not turn off the power even if the system supports the power-off feature. You must
///             specify EWX_POWEROFF to do this.<b>Windows XP with SP1: </b>If the system supports the power-off feature,
///             specifying this flag turns off the power. </td> </tr> </table> This parameter can optionally include one of the
///             following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="EWX_FORCE"></a><a id="ewx_force"></a><dl> <dt><b>EWX_FORCE</b></dt> <dt>0x00000004</dt> </dl> </td> <td
///             width="60%"> This flag has no effect if terminal services is enabled. Otherwise, the system does not send the
///             WM_QUERYENDSESSION message. This can cause applications to lose data. Therefore, you should only use this flag in
///             an emergency. </td> </tr> <tr> <td width="40%"><a id="EWX_FORCEIFHUNG"></a><a id="ewx_forceifhung"></a><dl>
///             <dt><b>EWX_FORCEIFHUNG</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Forces processes to terminate if
///             they do not respond to the WM_QUERYENDSESSION or WM_ENDSESSION message within the timeout interval. For more
///             information, see the Remarks. </td> </tr> </table>
///    dwReason = The reason for initiating the shutdown. This parameter must be one of the system shutdown reason codes. If this
///               parameter is zero, the SHTDN_REASON_FLAG_PLANNED reason code will not be set and therefore the default action is
///               an undefined shutdown that is logged as "No title for this reason could be found". By default, it is also an
///               unplanned shutdown. Depending on how the system is configured, an unplanned shutdown triggers the creation of a
///               file that contains the system state information, which can delay shutdown. Therefore, do not use zero for this
///               parameter.
///Returns:
///    If the function succeeds, the return value is nonzero. Because the function executes asynchronously, a nonzero
///    return value indicates that the shutdown has been initiated. It does not indicate whether the shutdown will
///    succeed. It is possible that the system, the user, or another application will abort the shutdown. If the
///    function fails, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL ExitWindowsEx(uint uFlags, uint dwReason);

///Determines whether the last message read from the current thread's queue originated from a WOW64 process.
///Returns:
///    The function returns TRUE if the last message read from the current thread's queue originated from a WOW64
///    process, and FALSE otherwise.
///    
@DllImport("USER32")
BOOL IsWow64Message();

///Registers the device or type of device for which a window will receive notifications.
///Params:
///    hRecipient = A handle to the window or service that will receive device events for the devices specified in the
///                 <i>NotificationFilter</i> parameter. The same window handle can be used in multiple calls to
///                 <b>RegisterDeviceNotification</b>. Services can specify either a window handle or service status handle.
///    NotificationFilter = A pointer to a block of data that specifies the type of device for which notifications should be sent. This block
///                         always begins with the DEV_BROADCAST_HDR structure. The data following this header is dependent on the value of
///                         the <b>dbch_devicetype</b> member, which can be <b>DBT_DEVTYP_DEVICEINTERFACE</b> or <b>DBT_DEVTYP_HANDLE</b>.
///                         For more information, see Remarks.
///    Flags = This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///            width="40%"><a id="DEVICE_NOTIFY_WINDOW_HANDLE"></a><a id="device_notify_window_handle"></a><dl>
///            <dt><b>DEVICE_NOTIFY_WINDOW_HANDLE</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> The
///            <i>hRecipient</i> parameter is a window handle. </td> </tr> <tr> <td width="40%"><a
///            id="DEVICE_NOTIFY_SERVICE_HANDLE"></a><a id="device_notify_service_handle"></a><dl>
///            <dt><b>DEVICE_NOTIFY_SERVICE_HANDLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The
///            <i>hRecipient</i> parameter is a service status handle. </td> </tr> </table> In addition, you can specify the
///            following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="DEVICE_NOTIFY_ALL_INTERFACE_CLASSES"></a><a id="device_notify_all_interface_classes"></a><dl>
///            <dt><b>DEVICE_NOTIFY_ALL_INTERFACE_CLASSES</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Notifies the
///            recipient of device interface events for all device interface classes. (The <b>dbcc_classguid</b> member is
///            ignored.) This value can be used only if the <b>dbch_devicetype</b> member is <b>DBT_DEVTYP_DEVICEINTERFACE</b>.
///            </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a device notification handle. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
void* RegisterDeviceNotificationA(HANDLE hRecipient, void* NotificationFilter, uint Flags);

///Registers the device or type of device for which a window will receive notifications.
///Params:
///    hRecipient = A handle to the window or service that will receive device events for the devices specified in the
///                 <i>NotificationFilter</i> parameter. The same window handle can be used in multiple calls to
///                 <b>RegisterDeviceNotification</b>. Services can specify either a window handle or service status handle.
///    NotificationFilter = A pointer to a block of data that specifies the type of device for which notifications should be sent. This block
///                         always begins with the DEV_BROADCAST_HDR structure. The data following this header is dependent on the value of
///                         the <b>dbch_devicetype</b> member, which can be <b>DBT_DEVTYP_DEVICEINTERFACE</b> or <b>DBT_DEVTYP_HANDLE</b>.
///                         For more information, see Remarks.
///    Flags = This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///            width="40%"><a id="DEVICE_NOTIFY_WINDOW_HANDLE"></a><a id="device_notify_window_handle"></a><dl>
///            <dt><b>DEVICE_NOTIFY_WINDOW_HANDLE</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> The
///            <i>hRecipient</i> parameter is a window handle. </td> </tr> <tr> <td width="40%"><a
///            id="DEVICE_NOTIFY_SERVICE_HANDLE"></a><a id="device_notify_service_handle"></a><dl>
///            <dt><b>DEVICE_NOTIFY_SERVICE_HANDLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The
///            <i>hRecipient</i> parameter is a service status handle. </td> </tr> </table> In addition, you can specify the
///            following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="DEVICE_NOTIFY_ALL_INTERFACE_CLASSES"></a><a id="device_notify_all_interface_classes"></a><dl>
///            <dt><b>DEVICE_NOTIFY_ALL_INTERFACE_CLASSES</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Notifies the
///            recipient of device interface events for all device interface classes. (The <b>dbcc_classguid</b> member is
///            ignored.) This value can be used only if the <b>dbch_devicetype</b> member is <b>DBT_DEVTYP_DEVICEINTERFACE</b>.
///            </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a device notification handle. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
void* RegisterDeviceNotificationW(HANDLE hRecipient, void* NotificationFilter, uint Flags);

///Closes the specified device notification handle.
///Params:
///    Handle = Device notification handle returned by the RegisterDeviceNotification function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL UnregisterDeviceNotification(void* Handle);

///Registers the application to receive power setting notifications for the specific power setting event.
///Params:
///    hRecipient = Handle indicating where the power setting notifications are to be sent. For interactive applications, the
///                 <i>Flags</i> parameter should be zero, and the <i>hRecipient</i> parameter should be a window handle. For
///                 services, the <i>Flags</i> parameter should be one, and the <i>hRecipient</i> parameter should be a
///                 <b>SERVICE_STATUS_HANDLE</b> as returned from RegisterServiceCtrlHandlerEx.
///    PowerSettingGuid = The <b>GUID</b> of the power setting for which notifications are to be sent. For more information see <a
///                       href="/windows/desktop/Power/registering-for-power-events">Registering for Power Events</a>.
///    Flags = <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///            id="DEVICE_NOTIFY_WINDOW_HANDLE"></a><a id="device_notify_window_handle"></a><dl>
///            <dt><b>DEVICE_NOTIFY_WINDOW_HANDLE</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Notifications are sent using
///            WM_POWERBROADCAST messages with a <i>wParam</i> parameter of PBT_POWERSETTINGCHANGE. </td> </tr> <tr> <td
///            width="40%"><a id="DEVICE_NOTIFY_SERVICE_HANDLE"></a><a id="device_notify_service_handle"></a><dl>
///            <dt><b>DEVICE_NOTIFY_SERVICE_HANDLE</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Notifications are sent to
///            the HandlerEx callback function with a <i>dwControl</i> parameter of <b>SERVICE_CONTROL_POWEREVENT</b> and a
///            <i>dwEventType</i> of PBT_POWERSETTINGCHANGE. </td> </tr> </table>
///Returns:
///    Returns a notification handle for unregistering for power notifications. If the function fails, the return value
///    is NULL. To get extended error information, call GetLastError.
///    
@DllImport("USER32")
void* RegisterPowerSettingNotification(HANDLE hRecipient, GUID* PowerSettingGuid, uint Flags);

///Unregisters the power setting notification.
///Params:
///    Handle = The handle returned from the RegisterPowerSettingNotification function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL UnregisterPowerSettingNotification(void* Handle);

///Registers to receive notification when the system is suspended or resumed. Similar to
///PowerRegisterSuspendResumeNotification, but operates in user mode and can take a window handle.
///Params:
///    hRecipient = This parameter contains parameters for subscribing to a power notification or a window handle representing the
///                 subscribing process. If <i>Flags</i> is <b>DEVICE_NOTIFY_CALLBACK</b>, <i>hRecipient</i> is interpreted as a
///                 pointer to a DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS structure. In this case, the callback function is
///                 DeviceNotifyCallbackRoutine. When the <b>Callback</b> function executes, the <i>Type</i> parameter is set
///                 indicating the type of event that occurred. Possible values include <b>PBT_APMSUSPEND</b>,
///                 <b>PBT_APMRESUMESUSPEND</b>, and <b>PBT_APMRESUMEAUTOMATIC</b> - see Power Management Events for more info. The
///                 <i>Setting</i> parameter is not used with suspend/resume notifications. If <i>Flags</i> is
///                 <b>DEVICE_NOTIFY_WINDOW_HANDLE</b>, <i>hRecipient</i> is a handle to the window to deliver events to.
///    Flags = This parameter can be <b>DEVICE_NOTIFY_WINDOW_HANDLE</b> or <b>DEVICE_NOTIFY_CALLBACK</b>.
///Returns:
///    A handle to the registration. Use this handle to unregister for notifications. If the function fails, the return
///    value is NULL. To get extended error information call GetLastError.
///    
@DllImport("USER32")
void* RegisterSuspendResumeNotification(HANDLE hRecipient, uint Flags);

///Cancels a registration to receive notification when the system is suspended or resumed. Similar to
///PowerUnregisterSuspendResumeNotification but operates in user mode.
///Params:
///    Handle = A handle to a registration obtained by calling the RegisterSuspendResumeNotification function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL UnregisterSuspendResumeNotification(void* Handle);

///Attaches or detaches the input processing mechanism of one thread to that of another thread.
///Params:
///    idAttach = The identifier of the thread to be attached to another thread. The thread to be attached cannot be a system
///               thread.
///    idAttachTo = The identifier of the thread to which <i>idAttach</i> will be attached. This thread cannot be a system thread. A
///                 thread cannot attach to itself. Therefore, <i>idAttachTo</i> cannot equal <i>idAttach</i>.
///    fAttach = If this parameter is <b>TRUE</b>, the two threads are attached. If the parameter is <b>FALSE</b>, the threads are
///              detached.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. <b>Windows Server 2003 and Windows XP: </b>There is no extended
///    error information; do not call GetLastError. This behavior changed as of Windows Vista.
///    
@DllImport("USER32")
BOOL AttachThreadInput(uint idAttach, uint idAttachTo, BOOL fAttach);

///Waits until the specified process has finished processing its initial input and is waiting for user input with no
///input pending, or until the time-out interval has elapsed.
///Params:
///    hProcess = A handle to the process. If this process is a console application or does not have a message queue,
///               <b>WaitForInputIdle</b> returns immediately.
///    dwMilliseconds = The time-out interval, in milliseconds. If <i>dwMilliseconds</i> is INFINITE, the function does not return until
///                     the process is idle.
///Returns:
///    The following table shows the possible return values for this function. <table> <tr> <th>Return code/value</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The wait was
///    satisfied successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_TIMEOUT</b></dt> </dl> </td> <td
///    width="60%"> The wait was terminated because the time-out interval elapsed. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WAIT_FAILED</b></dt> </dl> </td> <td width="60%"> An error occurred. </td> </tr> </table>
///    
@DllImport("USER32")
uint WaitForInputIdle(HANDLE hProcess, uint dwMilliseconds);

///Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. The
///objects can include input event objects, which you specify using the <i>dwWakeMask</i> parameter. To enter an
///alertable wait state, use the MsgWaitForMultipleObjectsEx function.
///Params:
///    nCount = The number of object handles in the array pointed to by <i>pHandles</i>. The maximum number of object handles is
///             <b>MAXIMUM_WAIT_OBJECTS</b> minus one. If this parameter has the value zero, then the function waits only for an
///             input event.
///    pHandles = An array of object handles. For a list of the object types whose handles can be specified, see the following
///               Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies
///               of the same handle. If one of these handles is closed while the wait is still pending, the function's behavior is
///               undefined. The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see Standard Access
///               Rights.
///    fWaitAll = If this parameter is <b>TRUE</b>, the function returns when the states of all objects in the <i>pHandles</i>
///               array have been set to signaled and an input event has been received. If this parameter is <b>FALSE</b>, the
///               function returns when the state of any one of the objects is set to signaled or an input event has been received.
///               In this case, the return value indicates the object whose state caused the function to return.
///    dwMilliseconds = The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified
///                     objects are signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a
///                     wait state if the specified objects are not signaled; it always returns immediately. If <i>dwMilliseconds</i> is
///                     <b>INFINITE</b>, the function will return only when the specified objects are signaled. <b>Windows XP, Windows
///                     Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2: </b>The
///                     <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep
///                     counting down while the computer is asleep. <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012
///                     R2, Windows 10 and Windows Server 2016: </b>The <i>dwMilliseconds</i> value does not include time spent in
///                     low-power states. For example, the timeout does not keep counting down while the computer is asleep.
///    dwWakeMask = The input types for which an input event object handle will be added to the array of object handles. This
///                 parameter can be any combination of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                 <td width="40%"><a id="QS_ALLEVENTS"></a><a id="qs_allevents"></a><dl> <dt><b>QS_ALLEVENTS</b></dt>
///                 <dt>0x04BF</dt> </dl> </td> <td width="60%"> An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the
///                 queue. This value is a combination of <b>QS_INPUT</b>, <b>QS_POSTMESSAGE</b>, <b>QS_TIMER</b>, <b>QS_PAINT</b>,
///                 and <b>QS_HOTKEY</b>. </td> </tr> <tr> <td width="40%"><a id="QS_ALLINPUT"></a><a id="qs_allinput"></a><dl>
///                 <dt><b>QS_ALLINPUT</b></dt> <dt>0x04FF</dt> </dl> </td> <td width="60%"> Any message is in the queue. This value
///                 is a combination of <b>QS_INPUT</b>, <b>QS_POSTMESSAGE</b>, <b>QS_TIMER</b>, <b>QS_PAINT</b>, <b>QS_HOTKEY</b>,
///                 and <b>QS_SENDMESSAGE</b>. </td> </tr> <tr> <td width="40%"><a id="QS_ALLPOSTMESSAGE"></a><a
///                 id="qs_allpostmessage"></a><dl> <dt><b>QS_ALLPOSTMESSAGE</b></dt> <dt>0x0100</dt> </dl> </td> <td width="60%"> A
///                 posted message is in the queue. This value is cleared when you call GetMessage or PeekMessage without filtering
///                 messages. </td> </tr> <tr> <td width="40%"><a id="QS_HOTKEY"></a><a id="qs_hotkey"></a><dl>
///                 <dt><b>QS_HOTKEY</b></dt> <dt>0x0080</dt> </dl> </td> <td width="60%"> A WM_HOTKEY message is in the queue. </td>
///                 </tr> <tr> <td width="40%"><a id="QS_INPUT"></a><a id="qs_input"></a><dl> <dt><b>QS_INPUT</b></dt> <dt>0x407</dt>
///                 </dl> </td> <td width="60%"> An input message is in the queue. This value is a combination of <b>QS_MOUSE</b>,
///                 <b>QS_KEY</b>, and <b>QS_RAWINPUT</b>. </td> </tr> <tr> <td width="40%"><a id="QS_KEY"></a><a
///                 id="qs_key"></a><dl> <dt><b>QS_KEY</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> A WM_KEYUP, WM_KEYDOWN,
///                 WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue. </td> </tr> <tr> <td width="40%"><a id="QS_MOUSE"></a><a
///                 id="qs_mouse"></a><dl> <dt><b>QS_MOUSE</b></dt> <dt>0x0006</dt> </dl> </td> <td width="60%"> A WM_MOUSEMOVE
///                 message or mouse-button message (<b>WM_LBUTTONUP</b>, WM_RBUTTONDOWN, and so on). This value is a combination of
///                 <b>QS_MOUSEMOVE</b> and <b>QS_MOUSEBUTTON</b>. </td> </tr> <tr> <td width="40%"><a id="QS_MOUSEBUTTON"></a><a
///                 id="qs_mousebutton"></a><dl> <dt><b>QS_MOUSEBUTTON</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> A
///                 mouse-button message (<b>WM_LBUTTONUP</b>, WM_RBUTTONDOWN, and so on). </td> </tr> <tr> <td width="40%"><a
///                 id="QS_MOUSEMOVE"></a><a id="qs_mousemove"></a><dl> <dt><b>QS_MOUSEMOVE</b></dt> <dt>0x0002</dt> </dl> </td> <td
///                 width="60%"> A WM_MOUSEMOVE message is in the queue. </td> </tr> <tr> <td width="40%"><a id="QS_PAINT"></a><a
///                 id="qs_paint"></a><dl> <dt><b>QS_PAINT</b></dt> <dt>0x0020</dt> </dl> </td> <td width="60%"> A WM_PAINT message
///                 is in the queue. </td> </tr> <tr> <td width="40%"><a id="QS_POSTMESSAGE"></a><a id="qs_postmessage"></a><dl>
///                 <dt><b>QS_POSTMESSAGE</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> A posted message is in the queue.
///                 This value is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages. </td>
///                 </tr> <tr> <td width="40%"><a id="QS_RAWINPUT"></a><a id="qs_rawinput"></a><dl> <dt><b>QS_RAWINPUT</b></dt>
///                 <dt>0x0400</dt> </dl> </td> <td width="60%"> A raw input message is in the queue. For more information, see Raw
///                 Input. </td> </tr> <tr> <td width="40%"><a id="QS_SENDMESSAGE"></a><a id="qs_sendmessage"></a><dl>
///                 <dt><b>QS_SENDMESSAGE</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%"> A message sent by another thread or
///                 application is in the queue. </td> </tr> <tr> <td width="40%"><a id="QS_TIMER"></a><a id="qs_timer"></a><dl>
///                 <dt><b>QS_TIMER</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> A WM_TIMER message is in the queue. </td>
///                 </tr> </table>
///Returns:
///    If the function succeeds, the return value indicates the event that caused the function to return. It can be one
///    of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined
///    as 0x00000080L.) <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WAIT_OBJECT_0</b> to (<b>WAIT_OBJECT_0</b> + <i>nCount</i>– 1)</dt> </dl> </td> <td width="60%"> If
///    <i>bWaitAll</i> is <b>TRUE</b>, a return value within the specified range indicates that the state of all
///    specified objects is signaled. If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_OBJECT_0</b>
///    indicates the <i>pHandles</i> array index of the object that satisfied the wait. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WAIT_OBJECT_0</b> + <i>nCount</i></dt> </dl> </td> <td width="60%"> New input of the
///    type specified in the <i>dwWakeMask</i> parameter is available in the thread's input queue. Functions such as
///    PeekMessage, GetMessage, and WaitMessage mark messages in the queue as old messages. Therefore, after you call
///    one of these functions, a subsequent call to MsgWaitForMultipleObjects will not return until new input of the
///    specified type arrives. This value is also returned upon the occurrence of a system event that requires the
///    thread's action, such as foreground activation. Therefore, MsgWaitForMultipleObjects can return even though no
///    appropriate input is available and even if <i>dwWakeMask</i> is set to 0. If this occurs, call GetMessage or
///    PeekMessage to process the system event before trying the call to <b>MsgWaitForMultipleObjects</b> again. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_ABANDONED_0</b> to (<b>WAIT_ABANDONED_0</b> + <i>nCount</i>–
///    1)</dt> </dl> </td> <td width="60%"> If <i>bWaitAll</i> is <b>TRUE</b>, a return value within the specified range
///    indicates that the state of all specified objects is signaled and at least one of the objects is an abandoned
///    mutex object. If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_ABANDONED_0</b> indicates the
///    <i>pHandles</i> array index of an abandoned mutex object that satisfied the wait. Ownership of the mutex object
///    is granted to the calling thread, and the mutex is set to nonsignaled. If the mutex was protecting persistent
///    state information, you should check it for consistency. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WAIT_TIMEOUT</b></dt> <dt>258L</dt> </dl> </td> <td width="60%"> The time-out interval elapsed and the
///    conditions specified by the <i>bWaitAll</i> and <i>dwWakeMask</i> parameters were not satisfied. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WAIT_FAILED</b></dt> <dt>(DWORD)0xFFFFFFFF</dt> </dl> </td> <td width="60%"> The
///    function has failed. To get extended error information, call GetLastError. </td> </tr> </table>
///    
@DllImport("USER32")
uint MsgWaitForMultipleObjects(uint nCount, const(HANDLE)* pHandles, BOOL fWaitAll, uint dwMilliseconds, 
                               uint dwWakeMask);

///Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous
///procedure call (APC) is queued to the thread, or the time-out interval elapses. The array of objects can include
///input event objects, which you specify using the <i>dwWakeMask</i> parameter.
///Params:
///    nCount = The number of object handles in the array pointed to by <i>pHandles</i>. The maximum number of object handles is
///             <b>MAXIMUM_WAIT_OBJECTS</b> minus one. If this parameter has the value zero, then the function waits only for an
///             input event.
///    pHandles = An array of object handles. For a list of the object types whose handles you can specify, see the Remarks section
///               later in this topic. The array can contain handles to multiple types of objects. It may not contain multiple
///               copies of the same handle. If one of these handles is closed while the wait is still pending, the function's
///               behavior is undefined. The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see
///               Standard Access Rights.
///    dwMilliseconds = The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified
///                     objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If
///                     <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always
///                     returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the
///                     specified objects are signaled or an I/O completion routine or APC is queued. <b>Windows XP, Windows Server 2003,
///                     Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2: </b>The <i>dwMilliseconds</i> value
///                     does include time spent in low-power states. For example, the timeout does keep counting down while the computer
///                     is asleep. <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server
///                     2016: </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the
///                     timeout does not keep counting down while the computer is asleep.
///    dwWakeMask = The input types for which an input event object handle will be added to the array of object handles. This
///                 parameter can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                 width="40%"><a id="QS_ALLEVENTS"></a><a id="qs_allevents"></a><dl> <dt><b>QS_ALLEVENTS</b></dt> <dt>0x04BF</dt>
///                 </dl> </td> <td width="60%"> An input, WM_TIMER, WM_PAINT, WM_HOTKEY, or posted message is in the queue. This
///                 value is a combination of <b>QS_INPUT</b>, <b>QS_POSTMESSAGE</b>, <b>QS_TIMER</b>, <b>QS_PAINT</b>, and
///                 <b>QS_HOTKEY</b>. </td> </tr> <tr> <td width="40%"><a id="QS_ALLINPUT"></a><a id="qs_allinput"></a><dl>
///                 <dt><b>QS_ALLINPUT</b></dt> <dt>0x04FF</dt> </dl> </td> <td width="60%"> Any message is in the queue. This value
///                 is a combination of <b>QS_INPUT</b>, <b>QS_POSTMESSAGE</b>, <b>QS_TIMER</b>, <b>QS_PAINT</b>, <b>QS_HOTKEY</b>,
///                 and <b>QS_SENDMESSAGE</b>. </td> </tr> <tr> <td width="40%"><a id="QS_ALLPOSTMESSAGE"></a><a
///                 id="qs_allpostmessage"></a><dl> <dt><b>QS_ALLPOSTMESSAGE</b></dt> <dt>0x0100</dt> </dl> </td> <td width="60%"> A
///                 posted message is in the queue. This value is cleared when you call GetMessage or PeekMessage without filtering
///                 messages. </td> </tr> <tr> <td width="40%"><a id="QS_HOTKEY"></a><a id="qs_hotkey"></a><dl>
///                 <dt><b>QS_HOTKEY</b></dt> <dt>0x0080</dt> </dl> </td> <td width="60%"> A WM_HOTKEY message is in the queue. </td>
///                 </tr> <tr> <td width="40%"><a id="QS_INPUT"></a><a id="qs_input"></a><dl> <dt><b>QS_INPUT</b></dt> <dt>0x407</dt>
///                 </dl> </td> <td width="60%"> An input message is in the queue. This value is a combination of <b>QS_MOUSE</b>,
///                 <b>QS_KEY</b>, and <b>QS_RAWINPUT</b>. </td> </tr> <tr> <td width="40%"><a id="QS_KEY"></a><a
///                 id="qs_key"></a><dl> <dt><b>QS_KEY</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> A WM_KEYUP, WM_KEYDOWN,
///                 WM_SYSKEYUP, or WM_SYSKEYDOWN message is in the queue. </td> </tr> <tr> <td width="40%"><a id="QS_MOUSE"></a><a
///                 id="qs_mouse"></a><dl> <dt><b>QS_MOUSE</b></dt> <dt>0x0006</dt> </dl> </td> <td width="60%"> A WM_MOUSEMOVE
///                 message or mouse-button message (<b>WM_LBUTTONUP</b>, WM_RBUTTONDOWN, and so on). This value is a combination of
///                 <b>QS_MOUSEMOVE</b> and <b>QS_MOUSEBUTTON</b>. </td> </tr> <tr> <td width="40%"><a id="QS_MOUSEBUTTON"></a><a
///                 id="qs_mousebutton"></a><dl> <dt><b>QS_MOUSEBUTTON</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> A
///                 mouse-button message (<b>WM_LBUTTONUP</b>, WM_RBUTTONDOWN, and so on). </td> </tr> <tr> <td width="40%"><a
///                 id="QS_MOUSEMOVE"></a><a id="qs_mousemove"></a><dl> <dt><b>QS_MOUSEMOVE</b></dt> <dt>0x0002</dt> </dl> </td> <td
///                 width="60%"> A WM_MOUSEMOVE message is in the queue. </td> </tr> <tr> <td width="40%"><a id="QS_PAINT"></a><a
///                 id="qs_paint"></a><dl> <dt><b>QS_PAINT</b></dt> <dt>0x0020</dt> </dl> </td> <td width="60%"> A WM_PAINT message
///                 is in the queue. </td> </tr> <tr> <td width="40%"><a id="QS_POSTMESSAGE"></a><a id="qs_postmessage"></a><dl>
///                 <dt><b>QS_POSTMESSAGE</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> A posted message is in the queue.
///                 This value is cleared when you call GetMessage or PeekMessage, whether or not you are filtering messages. </td>
///                 </tr> <tr> <td width="40%"><a id="QS_RAWINPUT"></a><a id="qs_rawinput"></a><dl> <dt><b>QS_RAWINPUT</b></dt>
///                 <dt>0x0400</dt> </dl> </td> <td width="60%"> A raw input message is in the queue. For more information, see Raw
///                 Input. </td> </tr> <tr> <td width="40%"><a id="QS_SENDMESSAGE"></a><a id="qs_sendmessage"></a><dl>
///                 <dt><b>QS_SENDMESSAGE</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%"> A message sent by another thread or
///                 application is in the queue. </td> </tr> <tr> <td width="40%"><a id="QS_TIMER"></a><a id="qs_timer"></a><dl>
///                 <dt><b>QS_TIMER</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> A WM_TIMER message is in the queue. </td>
///                 </tr> </table>
///    dwFlags = The wait type. This parameter can be one or more of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The function returns
///              when any one of the objects is signaled. The return value indicates the object whose state caused the function to
///              return. </td> </tr> <tr> <td width="40%"><a id="MWMO_ALERTABLE"></a><a id="mwmo_alertable"></a><dl>
///              <dt><b>MWMO_ALERTABLE</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> The function also returns if an APC
///              has been queued to the thread with QueueUserAPC while the thread is in the waiting state. </td> </tr> <tr> <td
///              width="40%"><a id="MWMO_INPUTAVAILABLE"></a><a id="mwmo_inputavailable"></a><dl>
///              <dt><b>MWMO_INPUTAVAILABLE</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> The function returns if input
///              exists for the queue, even if the input has been seen (but not removed) using a call to another function, such as
///              PeekMessage. </td> </tr> <tr> <td width="40%"><a id="MWMO_WAITALL"></a><a id="mwmo_waitall"></a><dl>
///              <dt><b>MWMO_WAITALL</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> The function returns when all objects
///              in the <i>pHandles</i> array are signaled and an input event has been received, all at the same time. </td> </tr>
///              </table>
///Returns:
///    If the function succeeds, the return value indicates the event that caused the function to return. It can be one
///    of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined
///    as 0x00000080L.) <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WAIT_OBJECT_0</b> to (<b>WAIT_OBJECT_0</b> + <i>nCount</i> - 1)</dt> </dl> </td> <td width="60%"> If the
///    <b>MWMO_WAITALL</b> flag is used, a return value within the specified range indicates that the state of all
///    specified objects is signaled. Otherwise, the return value minus <b>WAIT_OBJECT_0</b> indicates the
///    <i>pHandles</i> array index of the object that caused the function to return. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WAIT_OBJECT_0</b> + <i>nCount</i></dt> </dl> </td> <td width="60%"> New input of the type specified
///    in the <i>dwWakeMask</i> parameter is available in the thread's input queue. Functions such as PeekMessage,
///    GetMessage, GetQueueStatus, and WaitMessage mark messages in the queue as old messages. Therefore, after you call
///    one of these functions, a subsequent call to MsgWaitForMultipleObjectsEx will not return until new input of the
///    specified type arrives. This value is also returned upon the occurrence of a system event that requires the
///    thread's action, such as foreground activation. Therefore, MsgWaitForMultipleObjectsEx can return even though no
///    appropriate input is available and even if <i>dwWakeMask</i> is set to 0. If this occurs, call GetMessage or
///    PeekMessage to process the system event before trying the call to <b>MsgWaitForMultipleObjectsEx</b> again. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_ABANDONED_0</b> to (<b>WAIT_ABANDONED_0</b> + <i>nCount</i> -
///    1)</dt> </dl> </td> <td width="60%"> If the <b>MWMO_WAITALL</b> flag is used, a return value within the specified
///    range indicates that the state of all specified objects is signaled and at least one of the objects is an
///    abandoned mutex object. Otherwise, the return value minus <b>WAIT_ABANDONED_0</b> indicates the <i>pHandles</i>
///    array index of an abandoned mutex object that caused the function to return. Ownership of the mutex object is
///    granted to the calling thread, and the mutex is set to nonsignaled. If the mutex was protecting persistent state
///    information, you should check it for consistency. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WAIT_IO_COMPLETION</b></dt> <dt>0x000000C0L</dt> </dl> </td> <td width="60%"> The wait was ended by one or
///    more user-mode asynchronous procedure calls (APC) queued to the thread. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WAIT_TIMEOUT</b></dt> <dt>258L</dt> </dl> </td> <td width="60%"> The time-out interval elapsed, but the
///    conditions specified by the <i>dwFlags</i> and <i>dwWakeMask</i> parameters were not met. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WAIT_FAILED</b></dt> <dt>(DWORD)0xFFFFFFFF</dt> </dl> </td> <td width="60%"> The
///    function has failed. To get extended error information, call GetLastError. </td> </tr> </table>
///    
@DllImport("USER32")
uint MsgWaitForMultipleObjectsEx(uint nCount, const(HANDLE)* pHandles, uint dwMilliseconds, uint dwWakeMask, 
                                 uint dwFlags);

///Retrieves the count of handles to graphical user interface (GUI) objects in use by the specified process.
///Params:
///    hProcess = A handle to the process. The handle must refer to a process in the current session, and must have the
///               **PROCESS_QUERY_INFORMATION** access right (see [Process security and access
///               rights](/windows/win32/procthread/process-security-and-access-rights)). If this parameter is the special value
///               **GR_GLOBAL**, then the resource usage is reported across all processes in the current session. **Windows Server
///               2008, Windows Vista, Windows Server 2003, and Windows XP:** The **GR_GLOBAL** value is not supported until
///               Windows 7 and Windows Server 2008 R2.
///    uiFlags = The GUI object type. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="GR_GDIOBJECTS"></a><a id="gr_gdiobjects"></a><dl>
///              <dt><b>GR_GDIOBJECTS</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Return the count of GDI objects. </td>
///              </tr> <tr> <td width="40%"><a id="GR_GDIOBJECTS_PEAK"></a><a id="gr_gdiobjects_peak"></a><dl>
///              <dt><b>GR_GDIOBJECTS_PEAK</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Return the peak count of GDI objects.
///              <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until
///              Windows 7 and Windows Server 2008 R2. </td> </tr> <tr> <td width="40%"><a id="GR_USEROBJECTS"></a><a
///              id="gr_userobjects"></a><dl> <dt><b>GR_USEROBJECTS</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Return the
///              count of USER objects. </td> </tr> <tr> <td width="40%"><a id="GR_USEROBJECTS_PEAK"></a><a
///              id="gr_userobjects_peak"></a><dl> <dt><b>GR_USEROBJECTS_PEAK</b></dt> <dt>4</dt> </dl> </td> <td width="60%">
///              Return the peak count of USER objects. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:
///              </b>This value is not supported until Windows 7 and Windows Server 2008 R2. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is the count of handles to GUI objects in use by the process. If no
///    GUI objects are in use, the return value is zero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("USER32")
uint GetGuiResources(HANDLE hProcess, uint uiFlags);

///Locks the workstation's display. Locking a workstation protects it from unauthorized use.
///Returns:
///    If the function succeeds, the return value is nonzero. Because the function executes asynchronously, a nonzero
///    return value indicates that the operation has been initiated. It does not indicate whether the workstation has
///    been successfully locked. If the function fails, the return value is zero. To get extended error information,
///    call GetLastError.
///    
@DllImport("USER32")
BOOL LockWorkStation();

///Grants or denies access to a handle to a User object to a job that has a user-interface restriction. When access is
///granted, all processes associated with the job can subsequently recognize and use the handle. When access is denied,
///the processes can no longer use the handle. For more information see User Objects.
///Params:
///    hUserHandle = A handle to the User object.
///    hJob = A handle to the job to be granted access to the User handle. The CreateJobObject or OpenJobObject function
///           returns this handle.
///    bGrant = If this parameter is TRUE, all processes associated with the job can recognize and use the handle. If the
///             parameter is FALSE, the processes cannot use the handle.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant);

///Indicates that the system cannot be shut down and sets a reason string to be displayed to the user if system shutdown
///is initiated.
///Params:
///    hWnd = A handle to the main window of the application.
///    pwszReason = The reason the application must block system shutdown. This string will be truncated for display purposes after
///                 MAX_STR_BLOCKREASON characters.
///Returns:
///    If the call succeeds, the return value is nonzero. If the call fails, the return value is zero. To get extended
///    error information, call GetLastError.
///    
@DllImport("USER32")
BOOL ShutdownBlockReasonCreate(HWND hWnd, const(PWSTR) pwszReason);

///Retrieves the reason string set by the ShutdownBlockReasonCreate function.
///Params:
///    hWnd = A handle to the main window of the application.
///    pwszBuff = A pointer to a buffer that receives the reason string. If this parameter is <b>NULL</b>, the function retrieves
///               the number of characters in the reason string.
///    pcchBuff = A pointer to a variable that specifies the size of the <i>pwszBuff</i> buffer, in characters. If the function
///               succeeds, this variable receives the number of characters copied into the buffer, including the
///               <b>null</b>-terminating character. If the buffer is too small, the variable receives the required buffer size, in
///               characters, not including the <b>null</b>-terminating character.
///Returns:
///    If the call succeeds, the return value is nonzero. If the call fails, the return value is zero. To get extended
///    error information, call GetLastError.
///    
@DllImport("USER32")
BOOL ShutdownBlockReasonQuery(HWND hWnd, PWSTR pwszBuff, uint* pcchBuff);

///Indicates that the system can be shut down and frees the reason string.
///Params:
///    hWnd = A handle to the main window of the application.
///Returns:
///    If the call succeeds, the return value is nonzero. If the call fails, the return value is zero. To get extended
///    error information, call GetLastError.
///    
@DllImport("USER32")
BOOL ShutdownBlockReasonDestroy(HWND hWnd);

///Retrieves an AR_STATE value containing the state of screen auto-rotation for the system, for example whether
///auto-rotation is supported, and whether it is enabled by the user. <b>GetAutoRotationState</b> provides a robust and
///diverse way of querying for auto-rotation state, and more. For example, if you want your app to behave differently
///when multiple monitors are attached then you can determine that from the <b>AR_STATE</b> returned.
///Params:
///    pState = Pointer to a location in memory that will receive the current state of auto-rotation for the system.
@DllImport("USER32")
BOOL GetAutoRotationState(AR_STATE* pState);

///Retrieves the screen auto-rotation preferences for the current process.
///Params:
///    pOrientation = Pointer to a location in memory that will receive the current orientation preference setting for the calling
///                   process.
@DllImport("USER32")
BOOL GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE* pOrientation);

///Sets the screen auto-rotation preferences for the current process.
///Params:
///    orientation = Pointer to a location in memory with the screen orientation preferences to set for the calling process.
@DllImport("USER32")
BOOL SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation);

///Determines whether the process belongs to a Windows Store app.
///Params:
///    hProcess = Target process handle.
@DllImport("USER32")
BOOL IsImmersiveProcess(HANDLE hProcess);

///Exempts the calling process from restrictions preventing desktop processes from interacting with the Windows Store
///app environment. This function is used by development and debugging tools. This function only succeeds if a developer
///license is present on the system. Once successful the calling process will be able to perform the following actions,
///subject to User Interface Privilege Isolation (UIPI) restrictions: <ul> <li> Attach global hooks (and event hooks) to
///Windows Store app processes. </li> <li> Attach input queues between Windows Store app processes, Windows Store app
///browsers, system processes, and desktop application processes. </li> <li> Change foreground arbitrarily between the
///Windows Store app and desktop environments. </li> </ul>
///Params:
///    fEnableExemption = When set to TRUE, indicates a request to disable exemption for the calling process.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("USER32")
BOOL SetProcessRestrictionExemption(BOOL fEnableExemption);

@DllImport("api-ms-win-core-rtlsupport-l1-1-0")
size_t RtlCompareMemory(const(void)* Source1, const(void)* Source2, size_t Length);

///Initializes the head of a singly linked list.
///Params:
///    ListHead = A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list. This structure is
///               for system use only.
///Returns:
///    This function does not return a value.
///    
@DllImport("ntdll")
void RtlInitializeSListHead(SLIST_HEADER* ListHead);

///Retrieves the first entry in a singly linked list. Access to the list is synchronized on a multiprocessor system.
///Params:
///    ListHead = A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list. This structure is
///               for system use only. The list must be previously initialized with the InitializeSListHead function.
///Returns:
///    The return value is a pointer to the first entry in the list. If the list is empty, the return value is
///    <b>NULL</b>.
///    
@DllImport("ntdll")
SINGLE_LIST_ENTRY* RtlFirstEntrySList(const(SLIST_HEADER)* ListHead);

///Removes an item from the front of a singly linked list. Access to the list is synchronized on a multiprocessor
///system.
///Params:
///    ListHead = A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list.
///Returns:
///    The return value is a pointer to the item removed from the list. If the list is empty, the return value is
///    <b>NULL</b>.
///    
@DllImport("ntdll")
SINGLE_LIST_ENTRY* RtlInterlockedPopEntrySList(SLIST_HEADER* ListHead);

///Inserts an item at the front of a singly linked list. Access to the list is synchronized on a multiprocessor system.
///Params:
///    ListHead = A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list.
///    ListEntry = A pointer to an [SLIST_ENTRY](./ns-winnt-slist_entry.md) structure that represents an item in a singly linked
///                list.
///Returns:
///    The return value is the previous first item in the list. If the list was previously empty, the return value is
///    <b>NULL</b>.
///    
@DllImport("ntdll")
SINGLE_LIST_ENTRY* RtlInterlockedPushEntrySList(SLIST_HEADER* ListHead, SINGLE_LIST_ENTRY* ListEntry);

@DllImport("ntdll")
SINGLE_LIST_ENTRY* RtlInterlockedPushListSListEx(SLIST_HEADER* ListHead, SINGLE_LIST_ENTRY* List, 
                                                 SINGLE_LIST_ENTRY* ListEnd, uint Count);

///Removes all items from a singly linked list. Access to the list is synchronized on a multiprocessor system.
///Params:
///    ListHead = A pointer to an <b>SLIST_HEADER</b> structure that represents the head of the singly linked list. This structure
///               is for system use only.
///Returns:
///    The return value is a pointer to the items removed from the list. If the list is empty, the return value is
///    <b>NULL</b>.
///    
@DllImport("ntdll")
SINGLE_LIST_ENTRY* RtlInterlockedFlushSList(SLIST_HEADER* ListHead);

///Retrieves the number of entries in the specified singly linked list.
///Params:
///    ListHead = A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list. This structure is
///               for system use only. The list must be previously initialized with the InitializeSListHead function.
///Returns:
///    The function returns the number of entries in the list.
///    
@DllImport("ntdll")
ushort RtlQueryDepthSList(SLIST_HEADER* ListHead);

@DllImport("ntdll")
size_t RtlGetReturnAddressHijackTarget();

@DllImport("ntdll")
ubyte RtlGetProductInfo(uint OSMajorVersion, uint OSMinorVersion, uint SpMajorVersion, uint SpMinorVersion, 
                        uint* ReturnedProductType);

@DllImport("ntdll")
uint RtlCrc32(const(void)* Buffer, size_t Size, uint InitialCrc);

@DllImport("ntdll")
ulong RtlCrc64(const(void)* Buffer, size_t Size, ulong InitialCrc);

@DllImport("ntdll")
OS_DEPLOYEMENT_STATE_VALUES RtlOsDeploymentState(uint Flags);

@DllImport("ntdll")
uint RtlInitializeCorrelationVector(CORRELATION_VECTOR* CorrelationVector, int Version, const(GUID)* Guid);

@DllImport("ntdll")
uint RtlIncrementCorrelationVector(CORRELATION_VECTOR* CorrelationVector);

@DllImport("ntdll")
uint RtlExtendCorrelationVector(CORRELATION_VECTOR* CorrelationVector);

@DllImport("ntdll")
uint RtlValidateCorrelationVector(CORRELATION_VECTOR* Vector);

@DllImport("ntdll")
uint RtlRaiseCustomSystemEventTrigger(CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG* TriggerConfig);

@DllImport("ntdll")
ubyte RtlIsZeroMemory(void* Buffer, size_t Length);

@DllImport("ntdll")
ubyte RtlNormalizeSecurityDescriptor(void** SecurityDescriptor, uint SecurityDescriptorLength, 
                                     void** NewSecurityDescriptor, uint* NewSecurityDescriptorLength, 
                                     ubyte CheckOnly);

@DllImport("ntdll")
void RtlGetDeviceFamilyInfoEnum(ulong* pullUAPInfo, uint* pulDeviceFamily, uint* pulDeviceForm);

@DllImport("ntdll")
uint RtlConvertDeviceFamilyInfoToString(uint* pulDeviceFamilyBufferSize, uint* pulDeviceFormBufferSize, 
                                        PWSTR DeviceFamily, PWSTR DeviceForm);

@DllImport("ntdll")
uint RtlSwitchedVVI(OSVERSIONINFOEXW* VersionInfo, uint TypeMask, ulong ConditionMask);

///Allocates a fiber local storage (FLS) index. Any fiber in the process can subsequently use this index to store and
///retrieve values that are local to the fiber.
///Params:
///    lpCallback = A pointer to the application-defined callback function of type <b>PFLS_CALLBACK_FUNCTION</b>. This parameter is
///                 optional. For more information, see FlsCallback.
///Returns:
///    If the function succeeds, the return value is an FLS index initialized to zero. If the function fails, the return
///    value is FLS_OUT_OF_INDEXES. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback);

///Retrieves the value in the calling fiber's fiber local storage (FLS) slot for the specified FLS index. Each fiber has
///its own slot for each FLS index.
///Params:
///    dwFlsIndex = The FLS index that was allocated by the FlsAlloc function.
///Returns:
///    If the function succeeds, the return value is the value stored in the calling fiber's FLS slot associated with
///    the specified index. If the function fails, the return value is NULL. To get extended error information, call
///    GetLastError.
///    
@DllImport("KERNEL32")
void* FlsGetValue(uint dwFlsIndex);

///Stores a value in the calling fiber's fiber local storage (FLS) slot for the specified FLS index. Each fiber has its
///own slot for each FLS index.
///Params:
///    dwFlsIndex = The FLS index that was allocated by the FlsAlloc function.
///    lpFlsData = The value to be stored in the FLS slot for the calling fiber.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The following errors can be returned. <table> <tr> <th>Return
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl>
///    </td> <td width="60%"> The index is not in range. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_MEMORY</b></dt> </dl> </td> <td width="60%"> The FLS array has not been allocated. </td> </tr>
///    </table>
///    
@DllImport("KERNEL32")
BOOL FlsSetValue(uint dwFlsIndex, void* lpFlsData);

///Releases a fiber local storage (FLS) index, making it available for reuse.
///Params:
///    dwFlsIndex = The FLS index that was allocated by the FlsAlloc function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FlsFree(uint dwFlsIndex);

///Determines whether the current thread is a fiber.
///Returns:
///    The function returns <b>TRUE</b> if the thread is a fiber and <b>FALSE</b> otherwise.
///    
@DllImport("KERNEL32")
BOOL IsThreadAFiber();

///Initialize a slim reader/writer (SRW) lock.
///Params:
///    SRWLock = A pointer to the SRW lock.
@DllImport("KERNEL32")
void InitializeSRWLock(RTL_SRWLOCK* SRWLock);

///Releases a slim reader/writer (SRW) lock that was acquired in exclusive mode.
///Params:
///    SRWLock = A pointer to the SRW lock.
@DllImport("KERNEL32")
void ReleaseSRWLockExclusive(RTL_SRWLOCK* SRWLock);

///Releases a slim reader/writer (SRW) lock that was acquired in shared mode.
///Params:
///    SRWLock = A pointer to the SRW lock.
@DllImport("KERNEL32")
void ReleaseSRWLockShared(RTL_SRWLOCK* SRWLock);

///Acquires a slim reader/writer (SRW) lock in exclusive mode.
///Params:
///    SRWLock = A pointer to the SRW lock.
@DllImport("KERNEL32")
void AcquireSRWLockExclusive(RTL_SRWLOCK* SRWLock);

///Acquires a slim reader/writer (SRW) lock in shared mode.
///Params:
///    SRWLock = A pointer to the SRW lock.
@DllImport("KERNEL32")
void AcquireSRWLockShared(RTL_SRWLOCK* SRWLock);

///Attempts to acquire a slim reader/writer (SRW) lock in exclusive mode. If the call is successful, the calling thread
///takes ownership of the lock.
///Params:
///    SRWLock = A pointer to the SRW lock.
///Returns:
///    If the lock is successfully acquired, the return value is nonzero. if the current thread could not acquire the
///    lock, the return value is zero.
///    
@DllImport("KERNEL32")
ubyte TryAcquireSRWLockExclusive(RTL_SRWLOCK* SRWLock);

///Attempts to acquire a slim reader/writer (SRW) lock in shared mode. If the call is successful, the calling thread
///takes ownership of the lock.
///Params:
///    SRWLock = A pointer to the SRW lock.
///Returns:
///    If the lock is successfully acquired, the return value is nonzero. if the current thread could not acquire the
///    lock, the return value is zero.
///    
@DllImport("KERNEL32")
ubyte TryAcquireSRWLockShared(RTL_SRWLOCK* SRWLock);

///Initializes a critical section object.
///Params:
///    lpCriticalSection = A pointer to the critical section object.
///Returns:
///    This function does not return a value. <b>Windows Server 2003 and Windows XP: </b>In low memory situations,
///    <b>InitializeCriticalSection</b> can raise a <b>STATUS_NO_MEMORY</b> exception. Starting with Windows Vista, this
///    exception was eliminated and <b>InitializeCriticalSection</b> always succeeds, even in low memory situations.
///    
@DllImport("KERNEL32")
void InitializeCriticalSection(RTL_CRITICAL_SECTION* lpCriticalSection);

///Releases ownership of the specified critical section object.
///Params:
///    lpCriticalSection = A pointer to the critical section object.
@DllImport("KERNEL32")
void LeaveCriticalSection(RTL_CRITICAL_SECTION* lpCriticalSection);

///Initializes a critical section object and sets the spin count for the critical section. When a thread tries to
///acquire a critical section that is locked, the thread <i>spins</i>: it enters a loop which iterates spin count times,
///checking to see if the lock is released. If the lock is not released before the loop finishes, the thread goes to
///sleep to wait for the lock to be released.
///Params:
///    lpCriticalSection = A pointer to the critical section object.
///    dwSpinCount = The spin count for the critical section object. On single-processor systems, the spin count is ignored and the
///                  critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is
///                  unavailable, the calling thread spins <i>dwSpinCount</i> times before performing a wait operation on a semaphore
///                  associated with the critical section. If the critical section becomes free during the spin operation, the calling
///                  thread avoids the wait operation.
///Returns:
///    This function always succeeds and returns a nonzero value. <b>Windows Server 2003 and Windows XP: </b>If the
///    function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To get
///    extended error information, call GetLastError. Starting with Windows Vista, the
///    <b>InitializeCriticalSectionAndSpinCount</b> function always succeeds, even in low memory situations.
///    
@DllImport("KERNEL32")
BOOL InitializeCriticalSectionAndSpinCount(RTL_CRITICAL_SECTION* lpCriticalSection, uint dwSpinCount);

///Initializes a critical section object with a spin count and optional flags.
///Params:
///    lpCriticalSection = A pointer to the critical section object.
///    dwSpinCount = The spin count for the critical section object. On single-processor systems, the spin count is ignored and the
///                  critical section spin count is set to 0 (zero). On multiprocessor systems, if the critical section is
///                  unavailable, the calling thread spin <i>dwSpinCount</i> times before performing a wait operation on a semaphore
///                  associated with the critical section. If the critical section becomes free during the spin operation, the calling
///                  thread avoids the wait operation.
///    Flags = This parameter can be 0 or the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///            width="40%"><a id="CRITICAL_SECTION_NO_DEBUG_INFO"></a><a id="critical_section_no_debug_info"></a><dl>
///            <dt><b>CRITICAL_SECTION_NO_DEBUG_INFO</b></dt> </dl> </td> <td width="60%"> The critical section is created
///            without debug information. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero (0). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL InitializeCriticalSectionEx(RTL_CRITICAL_SECTION* lpCriticalSection, uint dwSpinCount, uint Flags);

///Sets the spin count for the specified critical section. Spinning means that when a thread tries to acquire a critical
///section that is locked, the thread enters a loop, checks to see if the lock is released, and if the lock is not
///released, the thread goes to sleep.
///Params:
///    lpCriticalSection = A pointer to the critical section object.
///    dwSpinCount = The spin count for the critical section object. On single-processor systems, the spin count is ignored and the
///                  critical section spin count is set to zero (0). On multiprocessor systems, if the critical section is
///                  unavailable, the calling thread spins <i>dwSpinCount</i> times before performing a wait operation on a semaphore
///                  associated with the critical section. If the critical section becomes free during the spin operation, the calling
///                  thread avoids the wait operation.
///Returns:
///    The function returns the previous spin count for the critical section.
///    
@DllImport("KERNEL32")
uint SetCriticalSectionSpinCount(RTL_CRITICAL_SECTION* lpCriticalSection, uint dwSpinCount);

///Attempts to enter a critical section without blocking. If the call is successful, the calling thread takes ownership
///of the critical section.
///Params:
///    lpCriticalSection = A pointer to the critical section object.
///Returns:
///    If the critical section is successfully entered or the current thread already owns the critical section, the
///    return value is nonzero. If another thread already owns the critical section, the return value is zero.
///    
@DllImport("KERNEL32")
BOOL TryEnterCriticalSection(RTL_CRITICAL_SECTION* lpCriticalSection);

///Releases all resources used by an unowned critical section object.
///Params:
///    lpCriticalSection = A pointer to the critical section object. The object must have been previously initialized with the
///                        InitializeCriticalSection function.
@DllImport("KERNEL32")
void DeleteCriticalSection(RTL_CRITICAL_SECTION* lpCriticalSection);

///Initializes a one-time initialization structure.
///Params:
///    InitOnce = A pointer to the one-time initialization structure.
@DllImport("KERNEL32")
void InitOnceInitialize(RTL_RUN_ONCE* InitOnce);

///Executes the specified function successfully one time. No other threads that specify the same one-time initialization
///structure can execute the specified function while it is being executed by the current thread.
///Params:
///    InitOnce = A pointer to the one-time initialization structure.
///    InitFn = A pointer to an application-defined InitOnceCallback function.
///    Parameter = A parameter to be passed to the callback function.
///    Context = A parameter that receives data stored with the one-time initialization structure upon success. The low-order
///              <b>INIT_ONCE_CTX_RESERVED_BITS</b> bits of the data are always zero.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL InitOnceExecuteOnce(RTL_RUN_ONCE* InitOnce, PINIT_ONCE_FN InitFn, void* Parameter, void** Context);

///Begins one-time initialization.
///Params:
///    lpInitOnce = A pointer to the one-time initialization structure.
///    dwFlags = This parameter can have a value of 0, or one or more of the following flags. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="INIT_ONCE_ASYNC"></a><a id="init_once_async"></a><dl>
///              <dt><b>INIT_ONCE_ASYNC</b></dt> <dt>0x00000002UL</dt> </dl> </td> <td width="60%"> Enables multiple
///              initialization attempts to execute in parallel. If this flag is used, subsequent calls to this function will fail
///              unless this flag is also specified. </td> </tr> <tr> <td width="40%"><a id="INIT_ONCE_CHECK_ONLY"></a><a
///              id="init_once_check_only"></a><dl> <dt><b>INIT_ONCE_CHECK_ONLY</b></dt> <dt>0x00000001UL</dt> </dl> </td> <td
///              width="60%"> This function call does not begin initialization. The return value indicates whether initialization
///              has already completed. If the function returns <b>TRUE</b>, the <i>lpContext</i> parameter receives the data.
///              </td> </tr> </table>
///    fPending = If the function succeeds, this parameter indicates the current initialization status. If this parameter is
///               **TRUE** and *dwFlags* contains **INIT_ONCE_CHECK_ONLY**, the initialization is pending and the context data is
///               invalid. If this parameter is **FALSE**, initialization has already completed and the caller can retrieve the
///               context data from the *lpContext* parameter. If this parameter is **TRUE** and *dwFlags* does not contain
///               **INIT_ONCE_CHECK_ONLY**, initialization has been started and the caller can perform the initialization tasks.
///    lpContext = An optional parameter that receives the data stored with the one-time initialization structure upon success. The
///                low-order **INIT_ONCE_CTX_RESERVED_BITS** bits of the data are always zero.
///Returns:
///    If **INIT_ONCE_CHECK_ONLY** is not specified and the function succeeds, the return value is <b>TRUE</b>. If
///    **INIT_ONCE_CHECK_ONLY** is specified and initialization has completed, the return value is <b>TRUE</b>.
///    Otherwise, the return value is **FALSE**. To get extended error information, call
///    [GetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror).
///    
@DllImport("KERNEL32")
BOOL InitOnceBeginInitialize(RTL_RUN_ONCE* lpInitOnce, uint dwFlags, BOOL* fPending, void** lpContext);

///Completes one-time initialization started with the InitOnceBeginInitialize function.
///Params:
///    lpInitOnce = A pointer to the one-time initialization structure.
///    dwFlags = This parameter can be one of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"><a id="INIT_ONCE_ASYNC"></a><a id="init_once_async"></a><dl> <dt><b>INIT_ONCE_ASYNC</b></dt>
///              <dt>0x00000002UL</dt> </dl> </td> <td width="60%"> Operate in asynchronous mode. This enables multiple completion
///              attempts to execute in parallel. This flag must match the flag passed in the corresponding call to the
///              InitOnceBeginInitialize function. This flag may not be combined with <b>INIT_ONCE_INIT_FAILED</b>. </td> </tr>
///              <tr> <td width="40%"><a id="INIT_ONCE_INIT_FAILED"></a><a id="init_once_init_failed"></a><dl>
///              <dt><b>INIT_ONCE_INIT_FAILED</b></dt> <dt>0x00000004UL</dt> </dl> </td> <td width="60%"> The initialization
///              attempt failed. This flag may not be combined with <b>INIT_ONCE_ASYNC</b>. To fail an asynchronous
///              initialization, merely abandon it (that is, do not call the <b>InitOnceComplete</b> function). </td> </tr>
///              </table>
///    lpContext = A pointer to the data to be stored with the one-time initialization structure. This data is returned in the
///                <i>lpContext</i> parameter passed to subsequent calls to the InitOnceBeginInitialize function. If
///                <i>lpContext</i> points to a value, the low-order <b>INIT_ONCE_CTX_RESERVED_BITS</b> of the value must be zero.
///                If <i>lpContext</i> points to a data structure, the data structure must be <b>DWORD</b>-aligned.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL InitOnceComplete(RTL_RUN_ONCE* lpInitOnce, uint dwFlags, void* lpContext);

///Initializes a condition variable.
///Params:
///    ConditionVariable = A pointer to the condition variable.
@DllImport("KERNEL32")
void InitializeConditionVariable(RTL_CONDITION_VARIABLE* ConditionVariable);

///Wake a single thread waiting on the specified condition variable.
///Params:
///    ConditionVariable = A pointer to the condition variable.
@DllImport("KERNEL32")
void WakeConditionVariable(RTL_CONDITION_VARIABLE* ConditionVariable);

///Wake all threads waiting on the specified condition variable.
///Params:
///    ConditionVariable = A pointer to the condition variable.
@DllImport("KERNEL32")
void WakeAllConditionVariable(RTL_CONDITION_VARIABLE* ConditionVariable);

///Sleeps on the specified condition variable and releases the specified critical section as an atomic operation.
///Params:
///    ConditionVariable = A pointer to the condition variable. This variable must be initialized using the InitializeConditionVariable
///                        function.
///    CriticalSection = A pointer to the critical section object. This critical section must be entered exactly once by the caller at the
///                      time <b>SleepConditionVariableCS</b> is called.
///    dwMilliseconds = The time-out interval, in milliseconds. If the time-out interval elapses, the function re-acquires the critical
///                     section and returns zero. If <i>dwMilliseconds</i> is zero, the function tests the states of the specified
///                     objects and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval
///                     never elapses. For more information, see Remarks.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails or the time-out interval elapses,
///    the return value is zero. To get extended error information, call GetLastError. Possible error codes include
///    <b>ERROR_TIMEOUT</b>, which indicates that the time-out interval has elapsed before another thread has attempted
///    to wake the sleeping thread.
///    
@DllImport("KERNEL32")
BOOL SleepConditionVariableCS(RTL_CONDITION_VARIABLE* ConditionVariable, RTL_CRITICAL_SECTION* CriticalSection, 
                              uint dwMilliseconds);

///Sleeps on the specified condition variable and releases the specified lock as an atomic operation.
///Params:
///    ConditionVariable = A pointer to the condition variable. This variable must be initialized using the InitializeConditionVariable
///                        function.
///    SRWLock = A pointer to the lock. This lock must be held in the manner specified by the <i>Flags</i> parameter.
///    dwMilliseconds = The time-out interval, in milliseconds. The function returns if the interval elapses. If <i>dwMilliseconds</i> is
///                     zero, the function tests the states of the specified objects and returns immediately. If <i>dwMilliseconds</i> is
///                     <b>INFINITE</b>, the function's time-out interval never elapses.
///    Flags = If this parameter is <b>CONDITION_VARIABLE_LOCKMODE_SHARED</b>, the SRW lock is in shared mode. Otherwise, the
///            lock is in exclusive mode.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the timeout expires the function returns FALSE and GetLastError
///    returns ERROR_TIMEOUT.
///    
@DllImport("KERNEL32")
BOOL SleepConditionVariableSRW(RTL_CONDITION_VARIABLE* ConditionVariable, RTL_SRWLOCK* SRWLock, 
                               uint dwMilliseconds, uint Flags);

///Sets the specified event object to the signaled state.
///Params:
///    hEvent = A handle to the event object. The CreateEvent or OpenEvent function returns this handle. The handle must have the
///             EVENT_MODIFY_STATE access right. For more information, see Synchronization Object Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetEvent(HANDLE hEvent);

///Sets the specified event object to the nonsignaled state.
///Params:
///    hEvent = A handle to the event object. The CreateEvent or OpenEvent function returns this handle. The handle must have the
///             EVENT_MODIFY_STATE access right. For more information, see Synchronization Object Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL ResetEvent(HANDLE hEvent);

///Increases the count of the specified semaphore object by a specified amount.
///Params:
///    hSemaphore = A handle to the semaphore object. The CreateSemaphore or OpenSemaphore function returns this handle. This handle
///                 must have the <b>SEMAPHORE_MODIFY_STATE</b> access right. For more information, see Synchronization Object
///                 Security and Access Rights.
///    lReleaseCount = The amount by which the semaphore object's current count is to be increased. The value must be greater than zero.
///                    If the specified amount would cause the semaphore's count to exceed the maximum count that was specified when the
///                    semaphore was created, the count is not changed and the function returns <b>FALSE</b>.
///    lpPreviousCount = A pointer to a variable to receive the previous count for the semaphore. This parameter can be <b>NULL</b> if the
///                      previous count is not required.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL ReleaseSemaphore(HANDLE hSemaphore, int lReleaseCount, int* lpPreviousCount);

///Releases ownership of the specified mutex object.
///Params:
///    hMutex = A handle to the mutex object. The CreateMutex or OpenMutex function returns this handle.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL ReleaseMutex(HANDLE hMutex);

///Waits until the specified object is in the signaled state or the time-out interval elapses. To enter an alertable
///wait state, use the WaitForSingleObjectEx function. To wait for multiple objects, use WaitForMultipleObjects.
///Params:
///    hHandle = A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks
///              section. If this handle is closed while the wait is still pending, the function's behavior is undefined. The
///              handle must have the <b>SYNCHRONIZE</b> access right. For more information, see Standard Access Rights.
///    dwMilliseconds = The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is
///                     signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if
///                     the object is not signaled; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the
///                     function will return only when the object is signaled. <b>Windows XP, Windows Server 2003, Windows Vista, Windows
///                     7, Windows Server 2008 and Windows Server 2008 R2: </b>The <i>dwMilliseconds</i> value does include time spent in
///                     low-power states. For example, the timeout does keep counting down while the computer is asleep. <b>Windows 8,
///                     Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016: </b>The
///                     <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not
///                     keep counting down while the computer is asleep.
///Returns:
///    If the function succeeds, the return value indicates the event that caused the function to return. It can be one
///    of the following values. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WAIT_ABANDONED</b></dt> <dt>0x00000080L</dt> </dl> </td> <td width="60%"> The specified object is a
///    mutex object that was not released by the thread that owned the mutex object before the owning thread terminated.
///    Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled. If the
///    mutex was protecting persistent state information, you should check it for consistency. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WAIT_OBJECT_0</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The state of
///    the specified object is signaled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_TIMEOUT</b></dt>
///    <dt>0x00000102L</dt> </dl> </td> <td width="60%"> The time-out interval elapsed, and the object's state is
///    nonsignaled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_FAILED</b></dt> <dt>(DWORD)0xFFFFFFFF</dt> </dl>
///    </td> <td width="60%"> The function has failed. To get extended error information, call GetLastError. </td> </tr>
///    </table>
///    
@DllImport("KERNEL32")
uint WaitForSingleObject(HANDLE hHandle, uint dwMilliseconds);

///Suspends the current thread until the specified condition is met. Execution resumes when one of the following occurs:
///<ul> <li>An I/O completion callback function is called.</li> <li>An asynchronous procedure call (APC) is queued to
///the thread.</li> <li>The time-out interval elapses.</li> </ul>
///Params:
///    dwMilliseconds = The time interval for which execution is to be suspended, in milliseconds. A value of zero, together with the
///                     bAlertable parameter set to FALSE, causes the thread to relinquish the remainder of its time slice to any other
///                     thread that is ready to run, if there are no pending user APCs on the calling thread. If there are no other
///                     threads ready to run and no user APCs are queued, the function returns immediately, and the thread continues
///                     execution.<b>Windows XP: </b>A value of zero causes the thread to relinquish the remainder of its time slice to
///                     any other thread of equal priority that is ready to run. If there are no other threads of equal priority ready to
///                     run, the function returns immediately, and the thread continues execution. This behavior changed starting with
///                     Windows Server 2003. A value of INFINITE indicates that the suspension should not time out.
///    bAlertable = If this parameter is FALSE, the function does not return until the time-out period has elapsed. If an I/O
///                 completion callback occurs, the function does not return and the I/O completion function is not executed. If an
///                 APC is queued to the thread, the function does not return and the APC function is not executed. If the parameter
///                 is TRUE and the thread that called this function is the same thread that called the extended I/O function
///                 (ReadFileEx or WriteFileEx), the function returns when either the time-out period has elapsed or when an I/O
///                 completion callback function occurs. If an I/O completion callback occurs, the I/O completion function is called.
///                 If an APC is queued to the thread (QueueUserAPC), the function returns when either the timer-out period has
///                 elapsed or when the APC function is called.
///Returns:
///    The return value is zero if the specified time interval expired. The return value is <b>WAIT_IO_COMPLETION</b> if
///    the function returned due to one or more I/O completion callback functions. This can happen only if
///    <i>bAlertable</i> is TRUE, and if the thread that called the <b>SleepEx</b> function is the same thread that
///    called the extended I/O function.
///    
@DllImport("KERNEL32")
uint SleepEx(uint dwMilliseconds, BOOL bAlertable);

///Waits until the specified object is in the signaled state, an I/O completion routine or asynchronous procedure call
///(APC) is queued to the thread, or the time-out interval elapses. To wait for multiple objects, use the
///WaitForMultipleObjectsEx.
///Params:
///    hHandle = A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks
///              section. If this handle is closed while the wait is still pending, the function's behavior is undefined. The
///              handle must have the <b>SYNCHRONIZE</b> access right. For more information, see Standard Access Rights.
///    dwMilliseconds = The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is
///                     signaled, an I/O completion routine or APC is queued, or the interval elapses. If <i>dwMilliseconds</i> is zero,
///                     the function does not enter a wait state if the criteria is not met; it always returns immediately. If
///                     <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the object is signaled or an I/O
///                     completion routine or APC is queued. <b>Windows XP, Windows Server 2003, Windows Vista, Windows 7, Windows Server
///                     2008 and Windows Server 2008 R2: </b>The <i>dwMilliseconds</i> value does include time spent in low-power states.
///                     For example, the timeout does keep counting down while the computer is asleep. <b>Windows 8, Windows Server 2012,
///                     Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server 2016: </b>The <i>dwMilliseconds</i> value does
///                     not include time spent in low-power states. For example, the timeout does not keep counting down while the
///                     computer is asleep.
///    bAlertable = If this parameter is <b>TRUE</b> and the thread is in the waiting state, the function returns when the system
///                 queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function
///                 does not return, and the completion routine or APC function is not executed. A completion routine is queued when
///                 the ReadFileEx or WriteFileEx function in which it was specified has completed. The wait function returns and the
///                 completion routine is called only if <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that
///                 initiated the read or write operation. An APC is queued when you call QueueUserAPC.
///Returns:
///    If the function succeeds, the return value indicates the event that caused the function to return. It can be one
///    of the following values. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WAIT_ABANDONED</b></dt> <dt>0x00000080L</dt> </dl> </td> <td width="60%"> The specified object is a
///    mutex object that was not released by the thread that owned the mutex object before the owning thread terminated.
///    Ownership of the mutex object is granted to the calling thread and the mutex is set to nonsignaled. If the mutex
///    was protecting persistent state information, you should check it for consistency. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WAIT_IO_COMPLETION</b></dt> <dt>0x000000C0L</dt> </dl> </td> <td width="60%"> The wait
///    was ended by one or more user-mode asynchronous procedure calls (APC) queued to the thread. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WAIT_OBJECT_0</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The state of
///    the specified object is signaled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_TIMEOUT</b></dt>
///    <dt>0x00000102L</dt> </dl> </td> <td width="60%"> The time-out interval elapsed, and the object's state is
///    nonsignaled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_FAILED</b></dt> <dt>(<b>DWORD</b>)0xFFFFFFFF</dt>
///    </dl> </td> <td width="60%"> The function has failed. To get extended error information, call GetLastError. </td>
///    </tr> </table>
///    
@DllImport("KERNEL32")
uint WaitForSingleObjectEx(HANDLE hHandle, uint dwMilliseconds, BOOL bAlertable);

///Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous
///procedure call (APC) is queued to the thread, or the time-out interval elapses.
///Params:
///    nCount = The number of object handles to wait for in the array pointed to by <i>lpHandles</i>. The maximum number of
///             object handles is <b>MAXIMUM_WAIT_OBJECTS</b>. This parameter cannot be zero.
///    lpHandles = An array of object handles. For a list of the object types whose handles can be specified, see the following
///                Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies
///                of the same handle. If one of these handles is closed while the wait is still pending, the function's behavior is
///                undefined. The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see Standard Access
///                Rights.
///    bWaitAll = If this parameter is <b>TRUE</b>, the function returns when the state of all objects in the <i>lpHandles</i>
///               array is set to signaled. If <b>FALSE</b>, the function returns when the state of any one of the objects is set
///               to signaled. In the latter case, the return value indicates the object whose state caused the function to return.
///    dwMilliseconds = The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified
///                     objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If
///                     <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always
///                     returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the
///                     specified objects are signaled or an I/O completion routine or APC is queued. <b>Windows XP, Windows Server 2003,
///                     Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2: </b>The <i>dwMilliseconds</i> value
///                     does include time spent in low-power states. For example, the timeout does keep counting down while the computer
///                     is asleep. <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2, Windows 10 and Windows Server
///                     2016: </b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the
///                     timeout does not keep counting down while the computer is asleep.
///    bAlertable = If this parameter is <b>TRUE</b> and the thread is in the waiting state, the function returns when the system
///                 queues an I/O completion routine or APC, and the thread runs the routine or function. Otherwise, the function
///                 does not return and the completion routine or APC function is not executed. A completion routine is queued when
///                 the ReadFileEx or WriteFileEx function in which it was specified has completed. The wait function returns and the
///                 completion routine is called only if <i>bAlertable</i> is <b>TRUE</b> and the calling thread is the thread that
///                 initiated the read or write operation. An APC is queued when you call QueueUserAPC.
///Returns:
///    If the function succeeds, the return value indicates the event that caused the function to return. It can be one
///    of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined
///    as 0x00000080L.) <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WAIT_OBJECT_0</b> to (<b>WAIT_OBJECT_0</b> + <i>nCount</i>– 1)</dt> </dl> </td> <td width="60%"> If
///    <i>bWaitAll</i> is <b>TRUE</b>, a return value in this range indicates that the state of all specified objects is
///    signaled. If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_OBJECT_0</b> indicates the
///    <i>lpHandles</i> array index of the object that satisfied the wait. If more than one object became signaled
///    during the call, this is the array index of the signaled object with the smallest index value of all the signaled
///    objects. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_ABANDONED_0</b> to (<b>WAIT_ABANDONED_0</b> +
///    <i>nCount</i>– 1)</dt> </dl> </td> <td width="60%"> If <i>bWaitAll</i> is <b>TRUE</b>, a return value in this
///    range indicates that the state of all specified objects is signaled, and at least one of the objects is an
///    abandoned mutex object. If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_ABANDONED_0</b>
///    indicates the <i>lpHandles</i> array index of an abandoned mutex object that satisfied the wait. Ownership of the
///    mutex object is granted to the calling thread, and the mutex is set to nonsignaled. If a mutex was protecting
///    persistent state information, you should check it for consistency. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WAIT_IO_COMPLETION</b></dt> <dt>0x000000C0L</dt> </dl> </td> <td width="60%"> The wait was ended by one or
///    more user-mode asynchronous procedure calls (APC) queued to the thread. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WAIT_TIMEOUT</b></dt> <dt>0x00000102L</dt> </dl> </td> <td width="60%"> The time-out interval elapsed, the
///    conditions specified by the <i>bWaitAll</i> parameter were not satisfied, and no completion routines are queued.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_FAILED</b></dt> <dt>(<b>DWORD</b>)0xFFFFFFFF</dt> </dl> </td>
///    <td width="60%"> The function has failed. To get extended error information, call GetLastError. </td> </tr>
///    </table>
///    
@DllImport("KERNEL32")
uint WaitForMultipleObjectsEx(uint nCount, const(HANDLE)* lpHandles, BOOL bWaitAll, uint dwMilliseconds, 
                              BOOL bAlertable);

///Creates or opens a named or unnamed mutex object. To specify an access mask for the object, use the CreateMutexEx
///function.
///Params:
///    lpMutexAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by
///                        child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the
///                        new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in
///                        the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more
///                        information, see Synchronization Object Security and Access Rights.
///    bInitialOwner = If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of
///                    the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the
///                    caller created the mutex, see the Return Values section.
///    lpName = The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> matches the name of an existing named mutex object, this function requests the
///             <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has
///             already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it
///             determines whether the handle can be inherited, but its security-descriptor member is ignored. If <i>lpName</i>
///             is <b>NULL</b>, the mutex object is created without a name. If <i>lpName</i> matches the name of an existing
///             event, semaphore, waitable timer, job, or file-mapping object, the function fails and the GetLastError function
///             returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can
///             have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The
///             remainder of the name can contain any character except the backslash character (\\). For more information, see
///             Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object
///             names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
///             The object can be created in a private namespace. For more information, see Object Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the newly created mutex object. If the function fails,
///    the return value is <b>NULL</b>. To get extended error information, call GetLastError. If the mutex is a named
///    mutex and the object existed before this function call, the return value is a handle to the existing object, and
///    the [GetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns
///    **ERROR_ALREADY_EXISTS**.
///    
@DllImport("KERNEL32")
HANDLE CreateMutexA(SECURITY_ATTRIBUTES* lpMutexAttributes, BOOL bInitialOwner, const(PSTR) lpName);

///Creates or opens a named or unnamed mutex object. To specify an access mask for the object, use the CreateMutexEx
///function.
///Params:
///    lpMutexAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by
///                        child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the
///                        new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security descriptor. The ACLs in
///                        the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more
///                        information, see Synchronization Object Security and Access Rights.
///    bInitialOwner = If this value is <b>TRUE</b> and the caller created the mutex, the calling thread obtains initial ownership of
///                    the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the
///                    caller created the mutex, see the Return Values section.
///    lpName = The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> matches the name of an existing named mutex object, this function requests the
///             <b>MUTEX_ALL_ACCESS</b> access right. In this case, the <i>bInitialOwner</i> parameter is ignored because it has
///             already been set by the creating process. If the <i>lpMutexAttributes</i> parameter is not <b>NULL</b>, it
///             determines whether the handle can be inherited, but its security-descriptor member is ignored. If <i>lpName</i>
///             is <b>NULL</b>, the mutex object is created without a name. If <i>lpName</i> matches the name of an existing
///             event, semaphore, waitable timer, job, or file-mapping object, the function fails and the GetLastError function
///             returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can
///             have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The
///             remainder of the name can contain any character except the backslash character (\\). For more information, see
///             Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object
///             names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
///             The object can be created in a private namespace. For more information, see Object Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the newly created mutex object. If the function fails,
///    the return value is <b>NULL</b>. To get extended error information, call GetLastError. If the mutex is a named
///    mutex and the object existed before this function call, the return value is a handle to the existing object, and
///    the GetLastError function returns <b>ERROR_ALREADY_EXISTS</b>.
///    
@DllImport("KERNEL32")
HANDLE CreateMutexW(SECURITY_ATTRIBUTES* lpMutexAttributes, BOOL bInitialOwner, const(PWSTR) lpName);

///Opens an existing named mutex object.
///Params:
///    dwDesiredAccess = The access to the mutex object. Only the <b>SYNCHRONIZE</b> access right is required to use a mutex; to change
///                      the mutex's security, specify <b>MUTEX_ALL_ACCESS</b>. The function fails if the security descriptor of the
///                      specified object does not permit the requested access for the calling process. For a list of access rights, see
///                      Synchronization Object Security and Access Rights.
///    bInheritHandle = If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes
///                     do not inherit this handle.
///    lpName = The name of the mutex to be opened. Name comparisons are case sensitive. This function can open objects in a
///             private namespace. For more information, see Object Namespaces. <b>Terminal Services: </b>The name can have a
///             "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces. <b>Note</b> Fast user switching is implemented using Terminal Services sessions. The first user to
///             log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the
///             guidelines outlined for Terminal Services so that applications can support multiple users.
///Returns:
///    If the function succeeds, the return value is a handle to the mutex object. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError. If a named mutex does not exist, the
///    function fails and GetLastError returns <b>ERROR_FILE_NOT_FOUND</b>.
///    
@DllImport("KERNEL32")
HANDLE OpenMutexW(uint dwDesiredAccess, BOOL bInheritHandle, const(PWSTR) lpName);

///Creates or opens a named or unnamed event object. To specify an access mask for the object, use the CreateEventEx
///function.
///Params:
///    lpEventAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by
///                        child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the
///                        new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in
///                        the default security descriptor for an event come from the primary or impersonation token of the creator.
///    bManualReset = If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the
///                   ResetEvent function to set the event state to nonsignaled. If this parameter is <b>FALSE</b>, the function
///                   creates an auto-reset event object, and system automatically resets the event state to nonsignaled after a single
///                   waiting thread has been released.
///    bInitialState = If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is
///                    nonsignaled.
///    lpName = The name of the event object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> matches the name of an existing named event object, this function requests the
///             <b>EVENT_ALL_ACCESS</b> access right. In this case, the <i>bManualReset</i> and <i>bInitialState</i> parameters
///             are ignored because they have already been set by the creating process. If the <i>lpEventAttributes</i> parameter
///             is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is
///             ignored. If <i>lpName</i> is <b>NULL</b>, the event object is created without a name. If <i>lpName</i> matches
///             the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer,
///             job, or file-mapping object), the function fails and the GetLastError function returns
///             <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a
///             "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow
///             the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be
///             created in a private namespace. For more information, see Object Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the event object. If the named event object existed
///    before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateEventA(SECURITY_ATTRIBUTES* lpEventAttributes, BOOL bManualReset, BOOL bInitialState, 
                    const(PSTR) lpName);

///Creates or opens a named or unnamed event object. To specify an access mask for the object, use the CreateEventEx
///function.
///Params:
///    lpEventAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by
///                        child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the
///                        new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security descriptor. The ACLs in
///                        the default security descriptor for an event come from the primary or impersonation token of the creator.
///    bManualReset = If this parameter is <b>TRUE</b>, the function creates a manual-reset event object, which requires the use of the
///                   ResetEvent function to set the event state to nonsignaled. If this parameter is <b>FALSE</b>, the function
///                   creates an auto-reset event object, and system automatically resets the event state to nonsignaled after a single
///                   waiting thread has been released.
///    bInitialState = If this parameter is <b>TRUE</b>, the initial state of the event object is signaled; otherwise, it is
///                    nonsignaled.
///    lpName = The name of the event object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> matches the name of an existing named event object, this function requests the
///             <b>EVENT_ALL_ACCESS</b> access right. In this case, the <i>bManualReset</i> and <i>bInitialState</i> parameters
///             are ignored because they have already been set by the creating process. If the <i>lpEventAttributes</i> parameter
///             is not <b>NULL</b>, it determines whether the handle can be inherited, but its security-descriptor member is
///             ignored. If <i>lpName</i> is <b>NULL</b>, the event object is created without a name. If <i>lpName</i> matches
///             the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer,
///             job, or file-mapping object), the function fails and the GetLastError function returns
///             <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a
///             "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow
///             the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be
///             created in a private namespace. For more information, see Object Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the event object. If the named event object existed
///    before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateEventW(SECURITY_ATTRIBUTES* lpEventAttributes, BOOL bManualReset, BOOL bInitialState, 
                    const(PWSTR) lpName);

///Opens an existing named event object.
///Params:
///    dwDesiredAccess = The access to the event object. The function fails if the security descriptor of the specified object does not
///                      permit the requested access for the calling process. For a list of access rights, see Synchronization Object
///                      Security and Access Rights.
///    bInheritHandle = If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes
///                     do not inherit this handle.
///    lpName = The name of the event to be opened. Name comparisons are case sensitive. This function can open objects in a
///             private namespace. For more information, see Object Namespaces. <b>Terminal Services: </b>The name can have a
///             "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces. <b>Note</b> Fast user switching is implemented using Terminal Services sessions. The first user to
///             log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the
///             guidelines outlined for Terminal Services so that applications can support multiple users.
///Returns:
///    If the function succeeds, the return value is a handle to the event object. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenEventA(uint dwDesiredAccess, BOOL bInheritHandle, const(PSTR) lpName);

///Opens an existing named event object.
///Params:
///    dwDesiredAccess = The access to the event object. The function fails if the security descriptor of the specified object does not
///                      permit the requested access for the calling process. For a list of access rights, see Synchronization Object
///                      Security and Access Rights.
///    bInheritHandle = If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes
///                     do not inherit this handle.
///    lpName = The name of the event to be opened. Name comparisons are case sensitive. This function can open objects in a
///             private namespace. For more information, see Object Namespaces. <b>Terminal Services: </b>The name can have a
///             "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces. <b>Note</b> Fast user switching is implemented using Terminal Services sessions. The first user to
///             log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the
///             guidelines outlined for Terminal Services so that applications can support multiple users.
///Returns:
///    If the function succeeds, the return value is a handle to the event object. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenEventW(uint dwDesiredAccess, BOOL bInheritHandle, const(PWSTR) lpName);

///Opens an existing named semaphore object.
///Params:
///    dwDesiredAccess = The access to the semaphore object. The function fails if the security descriptor of the specified object does
///                      not permit the requested access for the calling process. For a list of access rights, see Synchronization Object
///                      Security and Access Rights.
///    bInheritHandle = If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes
///                     do not inherit this handle.
///    lpName = The name of the semaphore to be opened. Name comparisons are case sensitive. This function can open objects in a
///             private namespace. For more information, see Object Namespaces. <b>Terminal Services: </b>The name can have a
///             "Global\" or "Local\" prefix to explicitly open an object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces. <b>Note</b> Fast user switching is implemented using Terminal Services sessions. The first user to
///             log on uses session 0, the next user to log on uses session 1, and so on. Kernel object names must follow the
///             guidelines outlined for Terminal Services so that applications can support multiple users.
///Returns:
///    If the function succeeds, the return value is a handle to the semaphore object. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenSemaphoreW(uint dwDesiredAccess, BOOL bInheritHandle, const(PWSTR) lpName);

///Opens an existing named waitable timer object.
///Params:
///    dwDesiredAccess = The access to the timer object. The function fails if the security descriptor of the specified object does not
///                      permit the requested access for the calling process. For a list of access rights, see Synchronization Object
///                      Security and Access Rights.
///    bInheritHandle = If this value is <b>TRUE</b>, processes created by this process will inherit the handle. Otherwise, the processes
///                     do not inherit this handle.
///    lpTimerName = The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///                  sensitive. This function can open objects in a private namespace. For more information, see Object Namespaces.
///                  <b>Terminal Services: </b>The name can have a "Global\" or "Local\" prefix to explicitly open an object in the
///                  global or session namespace. The remainder of the name can contain any character except the backslash character
///                  (\\). For more information, see Kernel Object Namespaces. <b>Note</b> Fast user switching is implemented using
///                  Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session 1, and
///                  so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can
///                  support multiple users.
///Returns:
///    If the function succeeds, the return value is a handle to the timer object. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenWaitableTimerW(uint dwDesiredAccess, BOOL bInheritHandle, const(PWSTR) lpTimerName);

///Activates the specified waitable timer and provides context information for the timer. When the due time arrives, the
///timer is signaled and the thread that set the timer calls the optional completion routine.
///Params:
///    hTimer = A handle to the timer object. The [CreateWaitableTimer](./nf-synchapi-createwaitabletimerexw.md) or
///             [OpenWaitableTimer](./nf-synchapi-openwaitabletimerw.md) function returns this handle. The handle must have the
///             <b>TIMER_MODIFY_STATE</b> access right. For more information, see Synchronization Object Security and Access
///             Rights.
///    lpDueTime = The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format
///                described by the FILETIME structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute
///                time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer
///                accuracy depends on the capability of your hardware. For more information about UTC-based time, see System Time.
///    lPeriod = The period of the timer, in milliseconds. If <i>lPeriod</i> is zero, the timer is signaled once. If
///              <i>lPeriod</i> is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time
///              the period elapses, until the timer is canceled using the CancelWaitableTimer function or reset using
///              <b>SetWaitableTimerEx</b>. If <i>lPeriod</i> is less than zero, the function fails.
///    pfnCompletionRoutine = A pointer to an optional completion routine. The completion routine is application-defined function of type
///                           <b>PTIMERAPCROUTINE</b> to be executed when the timer is signaled. For more information on the timer callback
///                           function, see TimerAPCProc. For more information about APCs and thread pool threads, see Remarks.
///    lpArgToCompletionRoutine = A pointer to a structure that is passed to the completion routine.
///    WakeContext = Pointer to a REASON_CONTEXT structure that contains context information for the timer.
///    TolerableDelay = The tolerable delay for expiration time, in milliseconds.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetWaitableTimerEx(HANDLE hTimer, const(LARGE_INTEGER)* lpDueTime, int lPeriod, 
                        PTIMERAPCROUTINE pfnCompletionRoutine, void* lpArgToCompletionRoutine, 
                        REASON_CONTEXT* WakeContext, uint TolerableDelay);

///Activates the specified waitable timer. When the due time arrives, the timer is signaled and the thread that set the
///timer calls the optional completion routine.
///Params:
///    hTimer = A handle to the timer object. The CreateWaitableTimer or OpenWaitableTimer function returns this handle. The
///             handle must have the <b>TIMER_MODIFY_STATE</b> access right. For more information, see Synchronization Object
///             Security and Access Rights.
///    lpDueTime = The time after which the state of the timer is to be set to signaled, in 100 nanosecond intervals. Use the format
///                described by the FILETIME structure. Positive values indicate absolute time. Be sure to use a UTC-based absolute
///                time, as the system uses UTC-based time internally. Negative values indicate relative time. The actual timer
///                accuracy depends on the capability of your hardware. For more information about UTC-based time, see System Time.
///    lPeriod = The period of the timer, in milliseconds. If <i>lPeriod</i> is zero, the timer is signaled once. If
///              <i>lPeriod</i> is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time
///              the period elapses, until the timer is canceled using the CancelWaitableTimer function or reset using
///              <b>SetWaitableTimer</b>. If <i>lPeriod</i> is less than zero, the function fails.
///    pfnCompletionRoutine = A pointer to an optional completion routine. The completion routine is application-defined function of type
///                           <b>PTIMERAPCROUTINE</b> to be executed when the timer is signaled. For more information on the timer callback
///                           function, see TimerAPCProc. For more information about APCs and thread pool threads, see Remarks.
///    lpArgToCompletionRoutine = A pointer to a structure that is passed to the completion routine.
///    fResume = If this parameter is <b>TRUE</b>, restores a system in suspended power conservation mode when the timer state is
///              set to signaled. Otherwise, the system is not restored. If the system does not support a restore, the call
///              succeeds, but GetLastError returns <b>ERROR_NOT_SUPPORTED</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetWaitableTimer(HANDLE hTimer, const(LARGE_INTEGER)* lpDueTime, int lPeriod, 
                      PTIMERAPCROUTINE pfnCompletionRoutine, void* lpArgToCompletionRoutine, BOOL fResume);

///Sets the specified waitable timer to the inactive state.
///Params:
///    hTimer = A handle to the timer object. The [CreateWaitableTimer](./nf-synchapi-createwaitabletimerw.md) or
///             [OpenWaitableTimer](./nf-synchapi-openwaitabletimerw.md) function returns this handle. The handle must have the
///             <b>TIMER_MODIFY_STATE</b> access right. For more information, see Synchronization Object Security and Access
///             Rights.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL CancelWaitableTimer(HANDLE hTimer);

///Creates or opens a named or unnamed mutex object and returns a handle to the object.
///Params:
///    lpMutexAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the mutex handle cannot be
///                        inherited by child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
///                        descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security
///                        descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token
///                        of the creator. For more information, see Synchronization Object Security and Access Rights.
///    lpName = The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name. If <i>lpName</i> matches
///             the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
///             GetLastError function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same
///             namespace. The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or
///             session namespace. The remainder of the name can contain any character except the backslash character (\\). For
///             more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services
///             sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can
///             support multiple users. The object can be created in a private namespace. For more information, see Object
///             Namespaces.
///    dwFlags = This parameter can be 0 or the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"><a id="CREATE_MUTEX_INITIAL_OWNER"></a><a id="create_mutex_initial_owner"></a><dl>
///              <dt><b>CREATE_MUTEX_INITIAL_OWNER</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The object creator is
///              the initial owner of the mutex. </td> </tr> </table>
///    dwDesiredAccess = The access mask for the mutex object. For a list of access rights, see Synchronization Object Security and Access
///                      Rights.
///Returns:
///    If the function succeeds, the return value is a handle to the newly created mutex object. If the function fails,
///    the return value is <b>NULL</b>. To get extended error information, call GetLastError. If the mutex is a named
///    mutex and the object existed before this function call, the return value is a handle to the existing object, and
///    the [GetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns
///    **ERROR_ALREADY_EXISTS**.
///    
@DllImport("KERNEL32")
HANDLE CreateMutexExA(SECURITY_ATTRIBUTES* lpMutexAttributes, const(PSTR) lpName, uint dwFlags, 
                      uint dwDesiredAccess);

///Creates or opens a named or unnamed mutex object and returns a handle to the object.
///Params:
///    lpMutexAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the mutex handle cannot be
///                        inherited by child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
///                        descriptor for the new mutex. If <i>lpMutexAttributes</i> is <b>NULL</b>, the mutex gets a default security
///                        descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token
///                        of the creator. For more information, see Synchronization Object Security and Access Rights.
///    lpName = The name of the mutex object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> is <b>NULL</b>, the mutex object is created without a name. If <i>lpName</i> matches
///             the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the
///             GetLastError function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same
///             namespace. The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or
///             session namespace. The remainder of the name can contain any character except the backslash character (\\). For
///             more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services
///             sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can
///             support multiple users. The object can be created in a private namespace. For more information, see Object
///             Namespaces.
///    dwFlags = This parameter can be 0 or the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"><a id="CREATE_MUTEX_INITIAL_OWNER"></a><a id="create_mutex_initial_owner"></a><dl>
///              <dt><b>CREATE_MUTEX_INITIAL_OWNER</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The object creator is
///              the initial owner of the mutex. </td> </tr> </table>
///    dwDesiredAccess = The access mask for the mutex object. For a list of access rights, see Synchronization Object Security and Access
///                      Rights.
///Returns:
///    If the function succeeds, the return value is a handle to the newly created mutex object. If the function fails,
///    the return value is <b>NULL</b>. To get extended error information, call GetLastError. If the mutex is a named
///    mutex and the object existed before this function call, the return value is a handle to the existing object, and
///    the [GetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror) function returns
///    **ERROR_ALREADY_EXISTS**.
///    
@DllImport("KERNEL32")
HANDLE CreateMutexExW(SECURITY_ATTRIBUTES* lpMutexAttributes, const(PWSTR) lpName, uint dwFlags, 
                      uint dwDesiredAccess);

///Creates or opens a named or unnamed event object and returns a handle to the object.
///Params:
///    lpEventAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If <i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot
///                        be inherited by child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
///                        descriptor for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security
///                        descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token
///                        of the creator.
///    lpName = The name of the event object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> is <b>NULL</b>, the event object is created without a name. If <i>lpName</i> matches
///             the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer,
///             job, or file-mapping object), the function fails and the GetLastError function returns
///             <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a
///             "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow
///             the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be
///             created in a private namespace. For more information, see Object Namespaces.
///    dwFlags = This parameter can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///              <tr> <td width="40%"><a id="CREATE_EVENT_INITIAL_SET"></a><a id="create_event_initial_set"></a><dl>
///              <dt><b>CREATE_EVENT_INITIAL_SET</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The initial state of
///              the event object is signaled; otherwise, it is nonsignaled. </td> </tr> <tr> <td width="40%"><a
///              id="CREATE_EVENT_MANUAL_RESET"></a><a id="create_event_manual_reset"></a><dl>
///              <dt><b>CREATE_EVENT_MANUAL_RESET</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The event must be
///              manually reset using the ResetEvent function. Any number of waiting threads, or threads that subsequently begin
///              wait operations for the specified event object, can be released while the object's state is signaled. If this
///              flag is not specified, the system automatically resets the event after releasing a single waiting thread. </td>
///              </tr> </table>
///    dwDesiredAccess = The access mask for the event object. For a list of access rights, see Synchronization Object Security and Access
///                      Rights.
///Returns:
///    If the function succeeds, the return value is a handle to the event object. If the named event object existed
///    before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateEventExA(SECURITY_ATTRIBUTES* lpEventAttributes, const(PSTR) lpName, uint dwFlags, 
                      uint dwDesiredAccess);

///Creates or opens a named or unnamed event object and returns a handle to the object.
///Params:
///    lpEventAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If <i>lpEventAttributes</i> is <b>NULL</b>, the event handle cannot
///                        be inherited by child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
///                        descriptor for the new event. If <i>lpEventAttributes</i> is <b>NULL</b>, the event gets a default security
///                        descriptor. The ACLs in the default security descriptor for an event come from the primary or impersonation token
///                        of the creator.
///    lpName = The name of the event object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> is <b>NULL</b>, the event object is created without a name. If <i>lpName</i> matches
///             the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer,
///             job, or file-mapping object), the function fails and the GetLastError function returns
///             <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a
///             "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow
///             the guidelines outlined for Terminal Services so that applications can support multiple users. The object can be
///             created in a private namespace. For more information, see Object Namespaces.
///    dwFlags = This parameter can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///              <tr> <td width="40%"><a id="CREATE_EVENT_INITIAL_SET"></a><a id="create_event_initial_set"></a><dl>
///              <dt><b>CREATE_EVENT_INITIAL_SET</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> The initial state of
///              the event object is signaled; otherwise, it is nonsignaled. </td> </tr> <tr> <td width="40%"><a
///              id="CREATE_EVENT_MANUAL_RESET"></a><a id="create_event_manual_reset"></a><dl>
///              <dt><b>CREATE_EVENT_MANUAL_RESET</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The event must be
///              manually reset using the ResetEvent function. Any number of waiting threads, or threads that subsequently begin
///              wait operations for the specified event object, can be released while the object's state is signaled. If this
///              flag is not specified, the system automatically resets the event after releasing a single waiting thread. </td>
///              </tr> </table>
///    dwDesiredAccess = The access mask for the event object. For a list of access rights, see Synchronization Object Security and Access
///                      Rights.
///Returns:
///    If the function succeeds, the return value is a handle to the event object. If the named event object existed
///    before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateEventExW(SECURITY_ATTRIBUTES* lpEventAttributes, const(PWSTR) lpName, uint dwFlags, 
                      uint dwDesiredAccess);

///Creates or opens a named or unnamed semaphore object and returns a handle to the object.
///Params:
///    lpSemaphoreAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be
///                            inherited by child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
///                            descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security
///                            descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation
///                            token of the creator.
///    lInitialCount = The initial count for the semaphore object. This value must be greater than or equal to zero and less than or
///                    equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and
///                    nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was
///                    waiting for the semaphore. The count is increased by a specified amount by calling the ReleaseSemaphore function.
///    lMaximumCount = The maximum count for the semaphore object. This value must be greater than zero.
///    lpName = A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to
///             <b>MAX_PATH</b> characters. Name comparison is case sensitive. If <i>lpName</i> matches the name of an existing
///             named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they
///             have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>,
///             it determines whether the handle can be inherited. If <i>lpName</i> is <b>NULL</b>, the semaphore object is
///             created without a name. If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or
///             file-mapping object, the function fails and the GetLastError function returns <b>ERROR_INVALID_HANDLE</b>. This
///             occurs because these objects share the same namespace. The name can have a "Global\" or "Local\" prefix to
///             explicitly create the object in the global or session namespace. The remainder of the name can contain any
///             character except the backslash character (\\). For more information, see Kernel Object Namespaces. Fast user
///             switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines
///             outlined for Terminal Services so that applications can support multiple users. The object can be created in a
///             private namespace. For more information, see Object Namespaces.
///    dwFlags = This parameter is reserved and must be 0.
///    dwDesiredAccess = The access mask for the semaphore object. For a list of access rights, see Synchronization Object Security and
///                      Access Rights.
///Returns:
///    If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object
///    existed before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateSemaphoreExW(SECURITY_ATTRIBUTES* lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, 
                          const(PWSTR) lpName, uint dwFlags, uint dwDesiredAccess);

///Creates or opens a waitable timer object and returns a handle to the object.
///Params:
///    lpTimerAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the timer handle cannot be
///                        inherited by child processes. If <i>lpTimerAttributes</i> is <b>NULL</b>, the timer object gets a default
///                        security descriptor and the handle cannot be inherited. The ACLs in the default security descriptor for a timer
///                        come from the primary or impersonation token of the creator.
///    lpTimerName = The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///                  sensitive. If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name. If
///                  <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the
///                  function fails and GetLastError returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the
///                  same namespace. The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or
///                  session namespace. The remainder of the name can contain any character except the backslash character (\\). For
///                  more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services
///                  sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can
///                  support multiple users. The object can be created in a private namespace. For more information, see Object
///                  Namespaces.
///    dwFlags = This parameter can be 0 or the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"><a id="CREATE_WAITABLE_TIMER_MANUAL_RESET"></a><a id="create_waitable_timer_manual_reset"></a><dl>
///              <dt><b>CREATE_WAITABLE_TIMER_MANUAL_RESET</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The timer
///              must be manually reset. Otherwise, the system automatically resets the timer after releasing a single waiting
///              thread. </td> </tr> </table>
///    dwDesiredAccess = The access mask for the timer object. For a list of access rights, see Synchronization Object Security and Access
///                      Rights.
///Returns:
///    If the function succeeds, the return value is a handle to the timer object. If the named timer object exists
///    before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateWaitableTimerExW(SECURITY_ATTRIBUTES* lpTimerAttributes, const(PWSTR) lpTimerName, uint dwFlags, 
                              uint dwDesiredAccess);

///Causes the calling thread to wait at a synchronization barrier until the maximum number of threads have entered the
///barrier.
///Params:
///    lpBarrier = A pointer to an initialized synchronization barrier. Use the InitializeSynchronizationBarrier function to
///                initialize the barrier. <b>SYNCHRONIZATION_BARRIER</b> is an opaque structure that should not be modified by the
///                application.
///    dwFlags = Flags that control the behavior of threads that enter this barrier. This parameter can be one or more of the
///              following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY"></a><a id="synchronization_barrier_flags_block_only"></a><dl>
///              <dt><b>SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY</b></dt> <dt></dt> </dl> </td> <td width="60%"> Specifies that
///              the thread entering the barrier should block immediately until the last thread enters the barrier. For more
///              information, see Remarks. </td> </tr> <tr> <td width="40%"><a id="SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY"></a><a
///              id="synchronization_barrier_flags_spin_only"></a><dl> <dt><b>SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY</b></dt>
///              <dt></dt> </dl> </td> <td width="60%"> Specifies that the thread entering the barrier should spin until the last
///              thread enters the barrier, even if the spinning thread exceeds the barrier's maximum spin count. For more
///              information, see Remarks. </td> </tr> <tr> <td width="40%"><a id="SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE"></a><a
///              id="synchronization_barrier_flags_no_delete"></a><dl> <dt><b>SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE</b></dt>
///              <dt></dt> </dl> </td> <td width="60%"> Specifies that the function can skip the work required to ensure that it
///              is safe to delete the barrier, which can improve performance. All threads that enter this barrier must specify
///              the flag; otherwise, the flag is ignored. This flag should be used only if the barrier will never be deleted.
///              </td> </tr> </table>
///Returns:
///    <b>TRUE</b> for the last thread to signal the barrier. Threads that signal the barrier before the last thread
///    signals it receive a return value of <b>FALSE</b>.
///    
@DllImport("KERNEL32")
BOOL EnterSynchronizationBarrier(RTL_BARRIER* lpBarrier, uint dwFlags);

///Initializes a new synchronization barrier.
///Params:
///    lpBarrier = A pointer to the <b>SYNCHRONIZATION_BARRIER</b> structure to initialize. This is an opaque structure that should
///                not be modified by applications.
///    lTotalThreads = The maximum number of threads that can enter this barrier. After the maximum number of threads have entered the
///                    barrier, all threads continue.
///    lSpinCount = The number of times an individual thread should spin while waiting for other threads to arrive at the barrier. If
///                 this parameter is -1, the thread spins 2000 times. If the thread exceeds <i>lSpinCount</i>, the thread blocks
///                 unless it called EnterSynchronizationBarrier with <b>SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY</b>.
///Returns:
///    <b>TRUE </b>if the barrier was successfully initialized. If the barrier was not successfully initialized, this
///    function returns <b>FALSE</b>. Use GetLastError to get extended error information.
///    
@DllImport("KERNEL32")
BOOL InitializeSynchronizationBarrier(RTL_BARRIER* lpBarrier, int lTotalThreads, int lSpinCount);

///Deletes a synchronization barrier.
///Params:
///    lpBarrier = A pointer to the synchronization barrier to delete.
///Returns:
///    The <b>DeleteSynchronizationBarrier</b> function always returns <b>TRUE</b>.
///    
@DllImport("KERNEL32")
BOOL DeleteSynchronizationBarrier(RTL_BARRIER* lpBarrier);

///Suspends the execution of the current thread until the time-out interval elapses. To enter an alertable wait state,
///use the SleepEx function.
///Params:
///    dwMilliseconds = The time interval for which execution is to be suspended, in milliseconds. A value of zero causes the thread to
///                     relinquish the remainder of its time slice to any other thread that is ready to run. If there are no other
///                     threads ready to run, the function returns immediately, and the thread continues execution.<b>Windows XP: </b>A
///                     value of zero causes the thread to relinquish the remainder of its time slice to any other thread of equal
///                     priority that is ready to run. If there are no other threads of equal priority ready to run, the function returns
///                     immediately, and the thread continues execution. This behavior changed starting with Windows Server 2003. A value
///                     of INFINITE indicates that the suspension should not time out.
@DllImport("KERNEL32")
void Sleep(uint dwMilliseconds);

///Waits for the value at the specified address to change.
///Params:
///    Address = The address on which to wait. If the value at <i>Address</i> differs from the value at <i>CompareAddress</i>, the
///              function returns immediately. If the values are the same, the function does not return until another thread in
///              the same process signals that the value at Address has changed by calling WakeByAddressSingle or WakeByAddressAll
///              or the timeout elapses, whichever comes first.
///    CompareAddress = A pointer to the location of the previously observed value at <i>Address</i>. The function returns when the value
///                     at <i>Address</i> differs from the value at <i>CompareAddress</i>.
///    AddressSize = The size of the value, in bytes. This parameter can be 1, 2, 4, or 8.
///    dwMilliseconds = The number of milliseconds to wait before the operation times out. If this parameter is <b>INFINITE</b>, the
///                     thread waits indefinitely.
///Returns:
///    TRUE if the wait succeeded. If the operation fails, the function returns FALSE. If the wait fails, call
///    GetLastError to obtain extended error information. In particular, if the operation times out, <b>GetLastError</b>
///    returns <b>ERROR_TIMEOUT</b>.
///    
@DllImport("api-ms-win-core-synch-l1-2-0")
BOOL WaitOnAddress(void* Address, void* CompareAddress, size_t AddressSize, uint dwMilliseconds);

///Wakes one thread that is waiting for the value of an address to change.
///Params:
///    Address = The address to signal. If another thread has previously called WaitOnAddress for this address, the system wakes
///              the waiting thread. If multiple threads are waiting for this address, the system wakes the first thread to wait.
@DllImport("api-ms-win-core-synch-l1-2-0")
void WakeByAddressSingle(void* Address);

///Wakes all threads that are waiting for the value of an address to change.
///Params:
///    Address = The address to signal. If any threads have previously called WaitOnAddress for this address, the system wakes all
///              of the waiting threads.
@DllImport("api-ms-win-core-synch-l1-2-0")
void WakeByAddressAll(void* Address);

///Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. To enter
///an alertable wait state, use the WaitForMultipleObjectsEx function.
///Params:
///    nCount = The number of object handles in the array pointed to by <i>lpHandles</i>. The maximum number of object handles is
///             <b>MAXIMUM_WAIT_OBJECTS</b>. This parameter cannot be zero.
///    lpHandles = An array of object handles. For a list of the object types whose handles can be specified, see the following
///                Remarks section. The array can contain handles to objects of different types. It may not contain multiple copies
///                of the same handle. If one of these handles is closed while the wait is still pending, the function's behavior is
///                undefined. The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see Standard Access
///                Rights.
///    bWaitAll = If this parameter is <b>TRUE</b>, the function returns when the state of all objects in the <i>lpHandles</i>
///               array is signaled. If <b>FALSE</b>, the function returns when the state of any one of the objects is set to
///               signaled. In the latter case, the return value indicates the object whose state caused the function to return.
///    dwMilliseconds = The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified
///                     objects are signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a
///                     wait state if the specified objects are not signaled; it always returns immediately. If <i>dwMilliseconds</i> is
///                     <b>INFINITE</b>, the function will return only when the specified objects are signaled. <b>Windows XP, Windows
///                     Server 2003, Windows Vista, Windows 7, Windows Server 2008 and Windows Server 2008 R2: </b>The
///                     <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep
///                     counting down while the computer is asleep. <b>Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012
///                     R2, Windows 10 and Windows Server 2016: </b>The <i>dwMilliseconds</i> value does not include time spent in
///                     low-power states. For example, the timeout does not keep counting down while the computer is asleep.
///Returns:
///    If the function succeeds, the return value indicates the event that caused the function to return. It can be one
///    of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined
///    as 0x00000080L.) <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WAIT_OBJECT_0</b> to (<b>WAIT_OBJECT_0</b> + <i>nCount</i>– 1)</dt> </dl> </td> <td width="60%"> If
///    <i>bWaitAll</i> is <b>TRUE</b>, a return value within the specified range indicates that the state of all
///    specified objects is signaled. If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_OBJECT_0</b>
///    indicates the <i>lpHandles</i> array index of the object that satisfied the wait. If more than one object became
///    signaled during the call, this is the array index of the signaled object with the smallest index value of all the
///    signaled objects. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_ABANDONED_0</b> to (<b>WAIT_ABANDONED_0</b>
///    + <i>nCount</i>– 1)</dt> </dl> </td> <td width="60%"> If <i>bWaitAll</i> is <b>TRUE</b>, a return value within
///    the specified range indicates that the state of all specified objects is signaled and at least one of the objects
///    is an abandoned mutex object. If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus
///    [WAIT_ABANDONED_0](nf-synchapi-waitforsingleobject.md) indicates the <i>lpHandles</i> array index of an abandoned
///    mutex object that satisfied the wait. Ownership of the mutex object is granted to the calling thread, and the
///    mutex is set to nonsignaled. If a mutex was protecting persistent state information, you should check it for
///    consistency. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_TIMEOUT</b></dt> <dt>0x00000102L</dt> </dl> </td>
///    <td width="60%"> The time-out interval elapsed and the conditions specified by the <i>bWaitAll</i> parameter are
///    not satisfied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_FAILED</b></dt>
///    <dt>(<b>DWORD</b>)0xFFFFFFFF</dt> </dl> </td> <td width="60%"> The function has failed. To get extended error
///    information, call GetLastError. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint WaitForMultipleObjects(uint nCount, const(HANDLE)* lpHandles, BOOL bWaitAll, uint dwMilliseconds);

///Creates or opens a named or unnamed semaphore object. To specify an access mask for the object, use the
///CreateSemaphoreEx function.
///Params:
///    lpSemaphoreAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by
///                            child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the
///                            new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in
///                            the default security descriptor for a semaphore come from the primary or impersonation token of the creator.
///    lInitialCount = The initial count for the semaphore object. This value must be greater than or equal to zero and less than or
///                    equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and
///                    nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was
///                    waiting for the semaphore. The count is increased by a specified amount by calling the ReleaseSemaphore function.
///    lMaximumCount = The maximum count for the semaphore object. This value must be greater than zero.
///    lpName = The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the
///             <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i>
///             parameters are ignored because they have already been set by the creating process. If the
///             <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but
///             its security-descriptor member is ignored. If <i>lpName</i> is <b>NULL</b>, the semaphore object is created
///             without a name. If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or
///             file-mapping object, the function fails and the GetLastError function returns <b>ERROR_INVALID_HANDLE</b>. This
///             occurs because these objects share the same namespace. The name can have a "Global\" or "Local\" prefix to
///             explicitly create the object in the global or session namespace. The remainder of the name can contain any
///             character except the backslash character (\\). For more information, see Kernel Object Namespaces. Fast user
///             switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines
///             outlined for Terminal Services so that applications can support multiple users. The object can be created in a
///             private namespace. For more information, see Object Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object
///    existed before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateSemaphoreW(SECURITY_ATTRIBUTES* lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, 
                        const(PWSTR) lpName);

///Creates or opens a waitable timer object. To specify an access mask for the object, use the
///[CreateWaitableTimerEx](./nf-synchapi-createwaitabletimerexw.md) function.
///Params:
///    lpTimerAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new timer object and
///                        determines whether child processes can inherit the returned handle. If <i>lpTimerAttributes</i> is <b>NULL</b>,
///                        the timer object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default
///                        security descriptor for a timer come from the primary or impersonation token of the creator.
///    bManualReset = If this parameter is <b>TRUE</b>, the timer is a manual-reset notification timer. Otherwise, the timer is a
///                   synchronization timer.
///    lpTimerName = The name of the timer object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///                  sensitive. If <i>lpTimerName</i> is <b>NULL</b>, the timer object is created without a name. If
///                  <i>lpTimerName</i> matches the name of an existing event, semaphore, mutex, job, or file-mapping object, the
///                  function fails and GetLastError returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the
///                  same namespace. The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or
///                  session namespace. The remainder of the name can contain any character except the backslash character (\\). For
///                  more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services
///                  sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can
///                  support multiple users. The object can be created in a private namespace. For more information, see Object
///                  Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the timer object. If the named timer object exists
///    before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateWaitableTimerW(SECURITY_ATTRIBUTES* lpTimerAttributes, BOOL bManualReset, const(PWSTR) lpTimerName);

///Initializes the head of a singly linked list.
///Params:
///    ListHead = A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list. This structure is
///               for system use only.
@DllImport("KERNEL32")
void InitializeSListHead(SLIST_HEADER* ListHead);

///Removes an item from the front of a singly linked list. Access to the list is synchronized on a multiprocessor
///system.
///Params:
///    ListHead = Pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list.
///Returns:
///    The return value is a pointer to the item removed from the list. If the list is empty, the return value is
///    <b>NULL</b>.
///    
@DllImport("KERNEL32")
SINGLE_LIST_ENTRY* InterlockedPopEntrySList(SLIST_HEADER* ListHead);

///Inserts an item at the front of a singly linked list. Access to the list is synchronized on a multiprocessor system.
///Params:
///    ListHead = Pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list.
///    ListEntry = Pointer to an SLIST_ENTRY structure that represents an item in a singly linked list.
///Returns:
///    The return value is the previous first item in the list. If the list was previously empty, the return value is
///    <b>NULL</b>.
///    
@DllImport("KERNEL32")
SINGLE_LIST_ENTRY* InterlockedPushEntrySList(SLIST_HEADER* ListHead, SINGLE_LIST_ENTRY* ListEntry);

///Inserts a singly-linked list at the front of another singly linked list. Access to the lists is synchronized on a
///multiprocessor system. This version of the method does not use the __fastcall calling convention.
///Params:
///    ListHead = Pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list. The list specified
///               by the <i>List</i> and <i>ListEnd</i> parameters is inserted at the front of this list.
///    List = Pointer to an SLIST_ENTRY structure that represents the first item in the list to be inserted.
///    ListEnd = Pointer to an SLIST_ENTRY structure that represents the last item in the list to be inserted.
///    Count = The number of items in the list to be inserted.
///Returns:
///    The return value is the previous first item in the list specified by the <i>ListHead</i> parameter. If the list
///    was previously empty, the return value is <b>NULL</b>.
///    
@DllImport("KERNEL32")
SINGLE_LIST_ENTRY* InterlockedPushListSListEx(SLIST_HEADER* ListHead, SINGLE_LIST_ENTRY* List, 
                                              SINGLE_LIST_ENTRY* ListEnd, uint Count);

///Removes all items from a singly linked list. Access to the list is synchronized on a multiprocessor system.
///Params:
///    ListHead = Pointer to an <b>SLIST_HEADER</b> structure that represents the head of the singly linked list. This structure is
///               for system use only.
///Returns:
///    The return value is a pointer to the items removed from the list. If the list is empty, the return value is
///    <b>NULL</b>.
///    
@DllImport("KERNEL32")
SINGLE_LIST_ENTRY* InterlockedFlushSList(SLIST_HEADER* ListHead);

///Retrieves the number of entries in the specified singly linked list.
///Params:
///    ListHead = A pointer to an <b>SLIST_HEADER</b> structure that represents the head of a singly linked list. This structure is
///               for system use only. The list must be previously initialized with the InitializeSListHead function.
///Returns:
///    The function returns the number of entries in the list, up to a maximum value of 65535.
///    
@DllImport("KERNEL32")
ushort QueryDepthSList(SLIST_HEADER* ListHead);

///Queues a work item to a worker thread in the thread pool.
///Params:
///    Function = A pointer to the application-defined callback function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by
///               the thread in the thread pool. This value represents the starting address of the thread. This callback function
///               must not call the TerminateThread function. The return value of the callback function is not used. For more
///               information, see ThreadProc.
///    Context = A single parameter value to be passed to the thread function.
///    Flags = The flags that control execution. This parameter can be one or more of the following values. <table> <tr>
///            <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WT_EXECUTEDEFAULT"></a><a
///            id="wt_executedefault"></a><dl> <dt><b>WT_EXECUTEDEFAULT</b></dt> <dt>0x00000000</dt> </dl> </td> <td
///            width="60%"> By default, the callback function is queued to a non-I/O worker thread. The callback function is
///            queued to a thread that uses I/O completion ports, which means they cannot perform an alertable wait. Therefore,
///            if I/O completes and generates an APC, the APC might wait indefinitely because there is no guarantee that the
///            thread will enter an alertable wait state after the callback completes. </td> </tr> <tr> <td width="40%"><a
///            id="WT_EXECUTEINIOTHREAD"></a><a id="wt_executeiniothread"></a><dl> <dt><b>WT_EXECUTEINIOTHREAD</b></dt>
///            <dt>0x00000001</dt> </dl> </td> <td width="60%"> This flag is not used. <b>Windows Server 2003 and Windows XP:
///            </b>The callback function is queued to an I/O worker thread. This flag should be used if the function should be
///            executed in a thread that waits in an alertable state. I/O worker threads were removed starting with Windows
///            Vista and Windows Server 2008. </td> </tr> <tr> <td width="40%"><a id="WT_EXECUTEINPERSISTENTTHREAD"></a><a
///            id="wt_executeinpersistentthread"></a><dl> <dt><b>WT_EXECUTEINPERSISTENTTHREAD</b></dt> <dt>0x00000080</dt> </dl>
///            </td> <td width="60%"> The callback function is queued to a thread that never terminates. It does not guarantee
///            that the same thread is used each time. This flag should be used only for short tasks or it could affect other
///            timer operations. This flag must be set if the thread calls functions that use APCs. For more information, see
///            Asynchronous Procedure Calls. Note that currently no worker thread is truly persistent, although worker threads
///            do not terminate if there are any pending I/O requests. </td> </tr> <tr> <td width="40%"><a
///            id="WT_EXECUTELONGFUNCTION"></a><a id="wt_executelongfunction"></a><dl> <dt><b>WT_EXECUTELONGFUNCTION</b></dt>
///            <dt>0x00000010</dt> </dl> </td> <td width="60%"> The callback function can perform a long wait. This flag helps
///            the system to decide if it should create a new thread. </td> </tr> <tr> <td width="40%"><a
///            id="WT_TRANSFER_IMPERSONATION"></a><a id="wt_transfer_impersonation"></a><dl>
///            <dt><b>WT_TRANSFER_IMPERSONATION</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Callback functions
///            will use the current access token, whether it is a process or impersonation token. If this flag is not specified,
///            callback functions execute only with the process token. <b>Windows XP: </b>This flag is not supported until
///            Windows XP SP2 and Windows Server 2003. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, void* Context, uint Flags);

///Cancels a registered wait operation issued by the RegisterWaitForSingleObject function.
///Params:
///    WaitHandle = The wait handle. This handle is returned by the RegisterWaitForSingleObject function.
///    CompletionEvent = A handle to the event object to be signaled when the wait operation has been unregistered. This parameter can be
///                      <b>NULL</b>. If this parameter is <b>INVALID_HANDLE_VALUE</b>, the function waits for all callback functions to
///                      complete before returning. If this parameter is <b>NULL</b>, the function marks the timer for deletion and
///                      returns immediately. However, most callers should wait for the callback function to complete so they can perform
///                      any needed cleanup. If the caller provides this event and the function succeeds or the function fails with
///                      <b>ERROR_IO_PENDING</b>, do not close the event until it is signaled.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent);

///Creates a queue for timers. Timer-queue timers are lightweight objects that enable you to specify a callback function
///to be called at a specified time.
///Returns:
///    If the function succeeds, the return value is a handle to the timer queue. This handle can be used only in
///    functions that require a handle to a timer queue. If the function fails, the return value is <b>NULL</b>. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateTimerQueue();

///Creates a timer-queue timer. This timer expires at the specified due time, then after every specified period. When
///the timer expires, the callback function is called.
///Params:
///    phNewTimer = A pointer to a buffer that receives a handle to the timer-queue timer on return. When this handle has expired and
///                 is no longer required, release it by calling DeleteTimerQueueTimer.
///    TimerQueue = A handle to the timer queue. This handle is returned by the CreateTimerQueue function. If this parameter is
///                 <b>NULL</b>, the timer is associated with the default timer queue.
///    Callback = A pointer to the application-defined function of type <b>WAITORTIMERCALLBACK</b> to be executed when the timer
///               expires. For more information, see WaitOrTimerCallback.
///    Parameter = A single parameter value that will be passed to the callback function.
///    DueTime = The amount of time in milliseconds relative to the current time that must elapse before the timer is signaled for
///              the first time.
///    Period = The period of the timer, in milliseconds. If this parameter is zero, the timer is signaled once. If this
///             parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the
///             period elapses, until the timer is canceled.
///    Flags = This parameter can be one or more of the following values from WinNT.h. <table> <tr> <th>Value</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="WT_EXECUTEDEFAULT"></a><a id="wt_executedefault"></a><dl>
///            <dt><b>WT_EXECUTEDEFAULT</b></dt> <dt>0x00000000</dt> </dl> </td> <td width="60%"> By default, the callback
///            function is queued to a non-I/O worker thread. </td> </tr> <tr> <td width="40%"><a
///            id="WT_EXECUTEINTIMERTHREAD"></a><a id="wt_executeintimerthread"></a><dl> <dt><b>WT_EXECUTEINTIMERTHREAD</b></dt>
///            <dt>0x00000020</dt> </dl> </td> <td width="60%"> The callback function is invoked by the timer thread itself.
///            This flag should be used only for short tasks or it could affect other timer operations. The callback function is
///            queued as an APC. It should not perform alertable wait operations. </td> </tr> <tr> <td width="40%"><a
///            id="WT_EXECUTEINIOTHREAD"></a><a id="wt_executeiniothread"></a><dl> <dt><b>WT_EXECUTEINIOTHREAD</b></dt>
///            <dt>0x00000001</dt> </dl> </td> <td width="60%"> This flag is not used. <b>Windows Server 2003 and Windows XP:
///            </b>The callback function is queued to an I/O worker thread. This flag should be used if the function should be
///            executed in a thread that waits in an alertable state. I/O worker threads were removed starting with Windows
///            Vista and Windows Server 2008. </td> </tr> <tr> <td width="40%"><a id="WT_EXECUTEINPERSISTENTTHREAD"></a><a
///            id="wt_executeinpersistentthread"></a><dl> <dt><b>WT_EXECUTEINPERSISTENTTHREAD</b></dt> <dt>0x00000080</dt> </dl>
///            </td> <td width="60%"> The callback function is queued to a thread that never terminates. It does not guarantee
///            that the same thread is used each time. This flag should be used only for short tasks or it could affect other
///            timer operations. This flag must be set if the thread calls functions that use APCs. For more information, see
///            Asynchronous Procedure Calls. Note that currently no worker thread is truly persistent, although no worker thread
///            will terminate if there are any pending I/O requests. </td> </tr> <tr> <td width="40%"><a
///            id="WT_EXECUTELONGFUNCTION"></a><a id="wt_executelongfunction"></a><dl> <dt><b>WT_EXECUTELONGFUNCTION</b></dt>
///            <dt>0x00000010</dt> </dl> </td> <td width="60%"> The callback function can perform a long wait. This flag helps
///            the system to decide if it should create a new thread. </td> </tr> <tr> <td width="40%"><a
///            id="WT_EXECUTEONLYONCE"></a><a id="wt_executeonlyonce"></a><dl> <dt><b>WT_EXECUTEONLYONCE</b></dt>
///            <dt>0x00000008</dt> </dl> </td> <td width="60%"> The timer will be set to the signaled state only once. If this
///            flag is set, the <i>Period</i> parameter must be zero. </td> </tr> <tr> <td width="40%"><a
///            id="WT_TRANSFER_IMPERSONATION"></a><a id="wt_transfer_impersonation"></a><dl>
///            <dt><b>WT_TRANSFER_IMPERSONATION</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Callback functions
///            will use the current access token, whether it is a process or impersonation token. If this flag is not specified,
///            callback functions execute only with the process token. <b>Windows XP: </b>This flag is not supported until
///            Windows XP with SP2 and Windows Server 2003. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL CreateTimerQueueTimer(HANDLE* phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, void* Parameter, 
                           uint DueTime, uint Period, uint Flags);

///Updates a timer-queue timer that was created by the CreateTimerQueueTimer function.
///Params:
///    TimerQueue = A handle to the timer queue. This handle is returned by the CreateTimerQueue function. If this parameter is
///                 <b>NULL</b>, the timer is associated with the default timer queue.
///    Timer = A handle to the timer-queue timer. This handle is returned by the CreateTimerQueueTimer function.
///    DueTime = The time after which the timer should expire, in milliseconds.
///    Period = The period of the timer, in milliseconds. If this parameter is zero, the timer is signaled once. If this
///             parameter is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the
///             period elapses, until the timer is canceled using the DeleteTimerQueueTimer function or reset using
///             <b>ChangeTimerQueueTimer</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, uint DueTime, uint Period);

///Removes a timer from the timer queue and optionally waits for currently running timer callback functions to complete
///before deleting the timer.
///Params:
///    TimerQueue = A handle to the timer queue. This handle is returned by the CreateTimerQueue function. If the timer was created
///                 using the default timer queue, this parameter should be <b>NULL</b>.
///    Timer = A handle to the timer-queue timer. This handle is returned by the CreateTimerQueueTimer function.
///    CompletionEvent = A handle to the event object to be signaled when the system has canceled the timer and all callback functions
///                      have completed. This parameter can be <b>NULL</b>. If this parameter is <b>INVALID_HANDLE_VALUE</b>, the function
///                      waits for any running timer callback functions to complete before returning. If this parameter is <b>NULL</b>,
///                      the function marks the timer for deletion and returns immediately. If the timer has already expired, the timer
///                      callback function will run to completion. However, there is no notification sent when the timer callback function
///                      has completed. Most callers should not use this option, and should wait for running timer callback functions to
///                      complete so they can perform any needed cleanup.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the error code is <b>ERROR_IO_PENDING</b>, it is not necessary
///    to call this function again. For any other error, you should retry the call.
///    
@DllImport("KERNEL32")
BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);

///Deletes a timer queue. Any pending timers in the queue are canceled and deleted.
///Params:
///    TimerQueue = A handle to the timer queue. This handle is returned by the CreateTimerQueue function.
///    CompletionEvent = A handle to the event object to be signaled when the function is successful and all callback functions have
///                      completed. This parameter can be <b>NULL</b>. If this parameter is <b>INVALID_HANDLE_VALUE</b>, the function
///                      waits for all callback functions to complete before returning. If this parameter is <b>NULL</b>, the function
///                      marks the timer for deletion and returns immediately. However, most callers should wait for the callback function
///                      to complete so they can perform any needed cleanup.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent);

///Allocates a new pool of threads to execute callbacks.
///Params:
///    reserved = This parameter is reserved and must be NULL.
///Returns:
///    If the function succeeds, it returns a pointer to a <b>TP_POOL</b> structure representing the newly allocated
///    thread pool. Applications do not modify the members of this structure. If function fails, it returns NULL. To
///    retrieve extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
PTP_POOL CreateThreadpool(void* reserved);

///Sets the maximum number of threads that the specified thread pool can allocate to process callbacks.
///Params:
///    ptpp = A pointer to a <b>TP_POOL</b> structure that defines the thread pool. The CreateThreadpool function returns this
///           pointer.
///    cthrdMost = The maximum number of threads.
@DllImport("KERNEL32")
void SetThreadpoolThreadMaximum(PTP_POOL ptpp, uint cthrdMost);

///Sets the minimum number of threads that the specified thread pool must make available to process callbacks.
///Params:
///    ptpp = A pointer to a <b>TP_POOL</b> structure that defines the thread pool. The CreateThreadpool function returns this
///           pointer.
///    cthrdMic = The minimum number of threads.
///Returns:
///    If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. To retrieve extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, uint cthrdMic);

///Sets the stack reserve and commit sizes for new threads in the specified thread pool. Stack reserve and commit sizes
///for existing threads are not changed.
///Params:
///    ptpp = A pointer to a <b>TP_POOL</b> structure that specifies the thread pool. The CreateThreadpool function returns
///           this [pomter.
///    ptpsi = A pointer to a <b>TP_POOL_STACK_INFORMATION</b> structure that specifies the stack reserve and commit size for
///            threads in the pool.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, TP_POOL_STACK_INFORMATION* ptpsi);

///Retrieves the stack reserve and commit sizes for threads in the specified thread pool.
///Params:
///    ptpp = A pointer to a <b>TP_POOL</b> structure that specifies the thread pool. The CreateThreadpool function returns
///           this pointer.
///    ptpsi = A pointer to a <b>TP_POOL_STACK_INFORMATION</b> structure that receives the stack reserve and commit size.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, TP_POOL_STACK_INFORMATION* ptpsi);

///Closes the specified thread pool.
///Params:
///    ptpp = A pointer to a <b>TP_POOL</b> structure that defines the thread pool. The CreateThreadpool function returns this
///           pointer.
@DllImport("KERNEL32")
void CloseThreadpool(PTP_POOL ptpp);

///Creates a cleanup group that applications can use to track one or more thread pool callbacks.
///Returns:
///    If the function succeeds, it returns a pointer to a <b>TP_CLEANUP_GROUP</b> structure of the newly allocated
///    cleanup group. Applications do not modify the members of this structure. If function fails, it returns NULL. To
///    retrieve extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t CreateThreadpoolCleanupGroup();

///Releases the members of the specified cleanup group, waits for all callback functions to complete, and optionally
///cancels any outstanding callback functions.
///Params:
///    ptpcg = A pointer to a <b>TP_CLEANUP_GROUP</b> structure that defines the cleanup group. The CreateThreadpoolCleanupGroup
///            function returns this pointer.
///    fCancelPendingCallbacks = If this parameter is TRUE, the function cancels outstanding callbacks that have not yet started. If this
///                              parameter is FALSE, the function waits for outstanding callback functions to complete.
///    pvCleanupContext = The application-defined data to pass to the application's cleanup group callback function. You can specify the
///                       callback function when you call SetThreadpoolCallbackCleanupGroup.
@DllImport("KERNEL32")
void CloseThreadpoolCleanupGroupMembers(ptrdiff_t ptpcg, BOOL fCancelPendingCallbacks, void* pvCleanupContext);

///Closes the specified cleanup group.
///Params:
///    ptpcg = A pointer to a <b>TP_CLEANUP_GROUP</b> structure that defines the cleanup group. The CreateThreadpoolCleanupGroup
///            returns this pointer.
@DllImport("KERNEL32")
void CloseThreadpoolCleanupGroup(ptrdiff_t ptpcg);

///Specifies the event that the thread pool will set when the current callback completes.
///Params:
///    pci = A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to
///          the callback function.
///    evt = A handle to the event to be set.
@DllImport("KERNEL32")
void SetEventWhenCallbackReturns(TP_CALLBACK_INSTANCE* pci, HANDLE evt);

///Specifies the semaphore that the thread pool will release when the current callback completes.
///Params:
///    pci = A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to
///          the callback function.
///    sem = A handle to the semaphore.
///    crel = The amount by which to increment the semaphore object's count.
@DllImport("KERNEL32")
void ReleaseSemaphoreWhenCallbackReturns(TP_CALLBACK_INSTANCE* pci, HANDLE sem, uint crel);

///Specifies the mutex that the thread pool will release when the current callback completes.
///Params:
///    pci = A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to
///          the callback function.
///    mut = A handle to the mutex.
@DllImport("KERNEL32")
void ReleaseMutexWhenCallbackReturns(TP_CALLBACK_INSTANCE* pci, HANDLE mut);

///Specifies the critical section that the thread pool will release when the current callback completes.
///Params:
///    pci = A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to
///          the callback function.
///    pcs = The critical section.
@DllImport("KERNEL32")
void LeaveCriticalSectionWhenCallbackReturns(TP_CALLBACK_INSTANCE* pci, RTL_CRITICAL_SECTION* pcs);

///Specifies the DLL that the thread pool will unload when the current callback completes.
///Params:
///    pci = A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to
///          the callback function.
///    mod = A handle to the DLL.
@DllImport("KERNEL32")
void FreeLibraryWhenCallbackReturns(TP_CALLBACK_INSTANCE* pci, ptrdiff_t mod);

///Indicates that the callback may not return quickly.
///Params:
///    pci = A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to
///          the callback function.
///Returns:
///    The function returns TRUE if another thread in the thread pool is available for processing callbacks or the
///    thread pool was able to create a new thread. In this case, the current callback function may use the current
///    thread indefinitely. The function returns FALSE if another thread in the thread pool is not available to process
///    callbacks and the thread pool was not able to create a new thread. The thread pool will attempt to create a new
///    thread after a delay, but if the current callback function runs long, the thread pool may lose efficiency.
///    
@DllImport("KERNEL32")
BOOL CallbackMayRunLong(TP_CALLBACK_INSTANCE* pci);

///Removes the association between the currently executing callback function and the object that initiated the callback.
///The current thread will no longer count as executing a callback on behalf of the object.
///Params:
///    pci = A pointer to a <b>TP_CALLBACK_INSTANCE</b> structure that defines the callback instance. The pointer is passed to
///          the callback function.
@DllImport("KERNEL32")
void DisassociateCurrentThreadFromCallback(TP_CALLBACK_INSTANCE* pci);

///Requests that a thread pool worker thread call the specified callback function.
///Params:
///    pfns = The callback function. For details, see SimpleCallback.
///    pv = Optional application-defined data to pass to the callback function.
///    pcbe = A pointer to a <b>TP_CALLBACK_ENVIRON</b> structure that defines the environment in which to execute the callback
///           function. Use the InitializeThreadpoolEnvironment function to initialize the structure before calling this
///           function. If this parameter is NULL, the callback executes in the default callback environment. For more
///           information, see InitializeThreadpoolEnvironment.
///Returns:
///    If the function succeeds, it returns TRUE. If the function fails, it returns FALSE. To retrieve extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, void* pv, TP_CALLBACK_ENVIRON_V3* pcbe);

///Creates a new work object.
///Params:
///    pfnwk = The callback function. A worker thread calls this callback each time you call SubmitThreadpoolWork to post the
///            work object. For details, see WorkCallback.
///    pv = Optional application-defined data to pass to the callback function.
///    pcbe = A pointer to a <b>TP_CALLBACK_ENVIRON</b> structure that defines the environment in which to execute the
///           callback. Use the InitializeThreadpoolEnvironment function to initialize the structure before calling this
///           function. If this parameter is NULL, the callback executes in the default callback environment. For more
///           information, see InitializeThreadpoolEnvironment.
///Returns:
///    If the function succeeds, it returns a pointer to a <b>TP_WORK</b> structure that defines the work object.
///    Applications do not modify the members of this structure. If the function fails, it returns NULL. To retrieve
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
TP_WORK* CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, void* pv, TP_CALLBACK_ENVIRON_V3* pcbe);

///Posts a work object to the thread pool. A worker thread calls the work object's callback function.
///Params:
///    pwk = A pointer to a <b>TP_WORK</b> structure that defines the work object. The CreateThreadpoolWork function returns
///          this pointer.
@DllImport("KERNEL32")
void SubmitThreadpoolWork(TP_WORK* pwk);

///Waits for outstanding work callbacks to complete and optionally cancels pending callbacks that have not yet started
///to execute.
///Params:
///    pwk = A pointer to a <b>TP_WORK</b> structure that defines the work object. The CreateThreadpoolWork function returns
///          this pointer.
///    fCancelPendingCallbacks = Indicates whether to cancel queued callbacks that have not yet started to execute.
@DllImport("KERNEL32")
void WaitForThreadpoolWorkCallbacks(TP_WORK* pwk, BOOL fCancelPendingCallbacks);

///Releases the specified work object.
///Params:
///    pwk = A pointer to a <b>TP_WORK</b> structure that defines the work object. The CreateThreadpoolWork function returns
///          this pointer.
@DllImport("KERNEL32")
void CloseThreadpoolWork(TP_WORK* pwk);

///Creates a new timer object.
///Params:
///    pfnti = The callback function to call each time the timer object expires. For details, see TimerCallback.
///    pv = Optional application-defined data to pass to the callback function.
///    pcbe = A <b>TP_CALLBACK_ENVIRON</b> structure that defines the environment in which to execute the callback. The
///           InitializeThreadpoolEnvironment function returns this structure. If this parameter is NULL, the callback executes
///           in the default callback environment. For more information, see InitializeThreadpoolEnvironment.
///Returns:
///    If the function succeeds, it returns a pointer to a <b>TP_TIMER</b> structure that defines the timer object.
///    Applications do not modify the members of this structure. If the function fails, it returns NULL. To retrieve
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
TP_TIMER* CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, void* pv, TP_CALLBACK_ENVIRON_V3* pcbe);

///Sets the timer object, replacing the previous timer, if any. A worker thread calls the timer object's callback after
///the specified timeout expires.
///Params:
///    pti = A pointer to a <b>TP_TIMER</b> structure that defines the timer object to set. The CreateThreadpoolTimer function
///          returns this pointer.
///    pftDueTime = A pointer to a FILETIME structure that specifies the absolute or relative time at which the timer should expire.
///                 If positive or zero, it indicates the absolute time since January 1, 1601 (UTC), measured in 100 nanosecond
///                 units. If negative, it indicates the amount of time to wait relative to the current time. For more information
///                 about time values, see File Times. If this parameter is NULL, the timer object will cease to queue new callbacks
///                 (but callbacks already queued will still occur). The timer is set if the <i>pftDueTime</i> parameter is non-NULL.
///    msPeriod = The timer period, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is
///               greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period
///               elapses, until the timer is canceled.
///    msWindowLength = The maximum amount of time the system can delay before calling the timer callback. If this parameter is set, the
///                     system can batch calls to conserve power.
@DllImport("KERNEL32")
void SetThreadpoolTimer(TP_TIMER* pti, FILETIME* pftDueTime, uint msPeriod, uint msWindowLength);

///Determines whether the specified timer object is currently set.
///Params:
///    pti = A pointer to a <b>TP_TIMER</b> structure that defines the timer object. The CreateThreadpoolTimer function
///          returns this pointer.
///Returns:
///    The return value is TRUE if the timer is set; otherwise, the return value is FALSE.
///    
@DllImport("KERNEL32")
BOOL IsThreadpoolTimerSet(TP_TIMER* pti);

///Waits for outstanding timer callbacks to complete and optionally cancels pending callbacks that have not yet started
///to execute.
///Params:
///    pti = A pointer to a <b>TP_TIMER</b> structure that defines the timer object. The CreateThreadpoolTimer function
///          returns this pointer.
///    fCancelPendingCallbacks = Indicates whether to cancel queued callbacks that have not yet started to execute.
@DllImport("KERNEL32")
void WaitForThreadpoolTimerCallbacks(TP_TIMER* pti, BOOL fCancelPendingCallbacks);

///Releases the specified timer object.
///Params:
///    pti = A pointer to <b>TP_TIMER</b> structure that defines the timer object. The CreateThreadpoolTimer function returns
///          this pointer.
@DllImport("KERNEL32")
void CloseThreadpoolTimer(TP_TIMER* pti);

///Creates a new wait object.
///Params:
///    pfnwa = The callback function to call when the wait completes or times out. For details, see WaitCallback.
///    pv = Optional application-defined data to pass to the callback function.
///    pcbe = A <b>TP_CALLBACK_ENVIRON</b> structure that defines the environment in which to execute the callback. The
///           InitializeThreadpoolEnvironment function returns this structure. If this parameter is NULL, the callback executes
///           in the default callback environment. For more information, see InitializeThreadpoolEnvironment.
///Returns:
///    If the function succeeds, it returns a pointer to a <b>TP_WAIT</b> structure that defines the wait object.
///    Applications do not modify the members of this structure. If the function fails, it returns NULL. To retrieve
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
TP_WAIT* CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, void* pv, TP_CALLBACK_ENVIRON_V3* pcbe);

///Sets the wait object, replacing the previous wait object, if any. A worker thread calls the wait object's callback
///function after the handle becomes signaled or after the specified timeout expires.
///Params:
///    pwa = A pointer to a <b>TP_WAIT</b> structure that defines the wait object. The CreateThreadpoolWait function returns
///          this pointer.
///    h = A handle. If this parameter is NULL, the wait object will cease to queue new callbacks (but callbacks already
///        queued will still occur). If this parameter is not NULL, it must refer to a valid waitable object. If this handle
///        is closed while the wait is still pending, the function's behavior is undefined. If the wait is still pending and
///        the handle must be closed, use CloseThreadpoolWait to cancel the wait and then close the handle. The wait is
///        considered set if this parameter is non-NULL.
///    pftTimeout = A pointer to a FILETIME structure that specifies the absolute or relative time at which the wait operation should
///                 time out. If this parameter points to a positive value, it indicates the absolute time since January 1, 1601
///                 (UTC), in 100-nanosecond intervals. If this parameter points to a negative value, it indicates the amount of time
///                 to wait relative to the current time. For more information about time values, see File Times. If this parameter
///                 points to 0, the wait times out immediately. If this parameter is NULL, the wait will not time out.
@DllImport("KERNEL32")
void SetThreadpoolWait(TP_WAIT* pwa, HANDLE h, FILETIME* pftTimeout);

///Waits for outstanding wait callbacks to complete and optionally cancels pending callbacks that have not yet started
///to execute.
///Params:
///    pwa = A pointer to a <b>TP_WAIT</b> structure that defines the wait object. The CreateThreadpoolWait function returns
///          this pointer.
///    fCancelPendingCallbacks = Indicates whether to cancel queued callbacks that have not yet started to execute.
@DllImport("KERNEL32")
void WaitForThreadpoolWaitCallbacks(TP_WAIT* pwa, BOOL fCancelPendingCallbacks);

///Releases the specified wait object.
///Params:
///    pwa = A pointer to a <b>TP_WAIT</b> structure that defines the wait object. The CreateThreadpoolWait function returns
///          this pointer.
@DllImport("KERNEL32")
void CloseThreadpoolWait(TP_WAIT* pwa);

///Creates a new I/O completion object.
///Params:
///    fl = The file handle to bind to this I/O completion object.
///    pfnio = The callback function to be called each time an overlapped I/O operation completes on the file. For details, see
///            IoCompletionCallback.
///    pv = Optional application-defined data to pass to the callback function.
///    pcbe = A pointer to a <b>TP_CALLBACK_ENVIRON</b> structure that defines the environment in which to execute the
///           callback. Use the InitializeThreadpoolEnvironment function to initialize the structure before calling this
///           function. If this parameter is NULL, the callback executes in the default callback environment. For more
///           information, see InitializeThreadpoolEnvironment.
///Returns:
///    If the function succeeds, it returns a pointer to a <b>TP_IO</b> structure that defines the I/O object.
///    Applications do not modify the members of this structure. If the function fails, it returns NULL. To retrieve
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
TP_IO* CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, void* pv, TP_CALLBACK_ENVIRON_V3* pcbe);

///Notifies the thread pool that I/O operations may possibly begin for the specified I/O completion object. A worker
///thread calls the I/O completion object's callback function after the operation completes on the file handle bound to
///this object.
///Params:
///    pio = A pointer to a <b>TP_IO</b> structure that defines the I/O completion object. The CreateThreadpoolIo function
///          returns this pointer.
@DllImport("KERNEL32")
void StartThreadpoolIo(TP_IO* pio);

///Cancels the notification from the StartThreadpoolIo function.
///Params:
///    pio = A pointer to a <b>TP_IO</b> structure that defines the I/O completion object. The CreateThreadpoolIo function
///          returns this pointer.
@DllImport("KERNEL32")
void CancelThreadpoolIo(TP_IO* pio);

///Waits for outstanding I/O completion callbacks to complete and optionally cancels pending callbacks that have not yet
///started to execute.
///Params:
///    pio = A pointer to a <b>TP_IO</b> structure that defines the I/O completion object. The CreateThreadpoolIo function
///          returns this pointer.
///    fCancelPendingCallbacks = Indicates whether to cancel queued callbacks that have not yet started to execute.
@DllImport("KERNEL32")
void WaitForThreadpoolIoCallbacks(TP_IO* pio, BOOL fCancelPendingCallbacks);

///Releases the specified I/O completion object.
///Params:
///    pio = A pointer to a <b>TP_IO</b> structure that defines the I/O completion object. The CreateThreadpoolIo function
///          returns this pointer.
@DllImport("KERNEL32")
void CloseThreadpoolIo(TP_IO* pio);

///Sets the timer object, replacing the previous timer, if any. A worker thread calls the timer object's callback after
///the specified timeout expires.
///Params:
///    pti = A pointer to a <b>TP_TIMER</b> structure that defines the timer object to set. The CreateThreadpoolTimer function
///          returns this pointer.
///    pftDueTime = A pointer to a FILETIME structure that specifies the absolute or relative time at which the timer should expire.
///                 If this parameter points to a positive value, it indicates the absolute time since January 1, 1601 (UTC),
///                 measured in 100 nanosecond units. If this parameter points to a negative value, it indicates the amount of time
///                 to wait relative to the current time. If this parameter points to zero, then the timer expires immediately. For
///                 more information about time values, see File Times. If this parameter is NULL, the timer object will cease to
///                 queue new callbacks (but callbacks already queued will still occur). The timer is set if the <i>pftDueTime</i>
///                 parameter is non-NULL.
///    msPeriod = The timer period, in milliseconds. If this parameter is zero, the timer is signaled once. If this parameter is
///               greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period
///               elapses, until the timer is canceled.
///    msWindowLength = The maximum amount of time the system can delay before calling the timer callback. If this parameter is set, the
///                     system can batch calls to conserve power.
///Returns:
///    Returns TRUE if the timer was previously set and was canceled. Otherwise returns FALSE. If the timer's previous
///    state was "set", and the function returns FALSE, then a callback is in progress or about to commence. See the
///    remarks for further discussion.
///    
@DllImport("KERNEL32")
BOOL SetThreadpoolTimerEx(TP_TIMER* pti, FILETIME* pftDueTime, uint msPeriod, uint msWindowLength);

///Sets the wait object, replacing the previous wait object, if any. A worker thread calls the wait object's callback
///function after the handle becomes signaled or after the specified timeout expires.
///Params:
///    pwa = A pointer to a <b>TP_WAIT</b> structure that defines the wait object. The CreateThreadpoolWait function returns
///          this pointer.
///    h = A handle. If this parameter is NULL, the wait object will cease to queue new callbacks (but callbacks already
///        queued will still occur). If this parameter is not NULL, it must refer to a valid waitable object. If this handle
///        is closed while the wait is still pending, the function's behavior is undefined. If the wait is still pending and
///        the handle must be closed, use CloseThreadpoolWait to cancel the wait and then close the handle. The wait is
///        considered set if this parameter is non-NULL.
///    pftTimeout = A pointer to a FILETIME structure that specifies the absolute or relative time at which the wait operation should
///                 time out. If this parameter points to a positive value, it indicates the absolute time since January 1, 1601
///                 (UTC), in 100-nanosecond intervals. If this parameter points to a negative value, it indicates the amount of time
///                 to wait relative to the current time. If this parameter points to zero, then the wait times out immediately. For
///                 more information about time values, see File Times. If this parameter is NULL, then the wait does not time out.
///    Reserved = Reserved. Must be NULL.
///Returns:
///    Returns TRUE if the wait was previously set and was canceled. Otherwise returns FALSE. If the wait's previous
///    state was "set", and the function returns FALSE, then a callback is in progress or about to commence. See the
///    remarks for further discussion.
///    
@DllImport("KERNEL32")
BOOL SetThreadpoolWaitEx(TP_WAIT* pwa, HANDLE h, FILETIME* pftTimeout, void* Reserved);

///Determines whether the process is running in the specified job.
///Params:
///    ProcessHandle = A handle to the process to be tested. The handle must have the PROCESS_QUERY_INFORMATION or
///                    PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights.
///                    <b>Windows Server 2003 and Windows XP: </b>The handle must have the PROCESS_QUERY_INFORMATION access right.
///    JobHandle = A handle to the job. If this parameter is NULL, the function tests if the process is running under any job. If
///                this parameter is not NULL, the handle must have the JOB_OBJECT_QUERY access right. For more information, see Job
///                Object Security and Access Rights.
///    Result = A pointer to a value that receives TRUE if the process is running in the job, and FALSE otherwise.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, BOOL* Result);

///Creates or opens a job object.
///Params:
///    lpJobAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies the security descriptor for the job object and
///                      determines whether child processes can inherit the returned handle. If <i>lpJobAttributes</i> is <b>NULL</b>, the
///                      job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default
///                      security descriptor for a job object come from the primary or impersonation token of the creator.
///    lpName = The name of the job. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case-sensitive. If
///             <i>lpName</i> is <b>NULL</b>, the job is created without a name. If <i>lpName</i> matches the name of an existing
///             event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the GetLastError function
///             returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The object can
///             be created in a private namespace. For more information, see Object Namespaces. <b>Terminal Services: </b>The
///             name can have a "Global\\" or "Local\\" prefix to explicitly create the object in the global or session
///             namespace. The remainder of the name can contain any character except the backslash character (\\). For more
///             information, see Kernel Object Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the job object. The handle has the
///    <b>JOB_OBJECT_ALL_ACCESS</b> access right. If the object existed before the function call, the function returns a
///    handle to the existing job object and GetLastError returns <b>ERROR_ALREADY_EXISTS</b>. If the function fails,
///    the return value is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateJobObjectW(SECURITY_ATTRIBUTES* lpJobAttributes, const(PWSTR) lpName);

///Frees memory that a function related to job objects allocated. Functions related to job objects that allocate memory
///include QueryIoRateControlInformationJobObject.
///Params:
///    Buffer = A pointer to the buffer of allocated memory that you want to free.
@DllImport("KERNEL32")
void FreeMemoryJobObject(void* Buffer);

///Opens an existing job object.
///Params:
///    dwDesiredAccess = The access to the job object. This parameter can be one or more of the job object access rights. This access
///                      right is checked against any security descriptor for the object.
///    bInheritHandle = If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not
///                     inherit this handle.
///    lpName = The name of the job to be opened. Name comparisons are case sensitive. This function can open objects in a
///             private namespace. For more information, see Object Namespaces. <b>Terminal Services: </b>The name can have a
///             "Global\\" or "Local\\" prefix to explicitly open the object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the job. The handle provides the requested access to
///    the job. If the function fails, the return value is <b>NULL</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenJobObjectW(uint dwDesiredAccess, BOOL bInheritHandle, const(PWSTR) lpName);

///Assigns a process to an existing job object.
///Params:
///    hJob = A handle to the job object to which the process will be associated. The CreateJobObject or OpenJobObject function
///           returns this handle. The handle must have the JOB_OBJECT_ASSIGN_PROCESS access right. For more information, see
///           Job Object Security and Access Rights.
///    hProcess = A handle to the process to associate with the job object. The handle must have the PROCESS_SET_QUOTA and
///               PROCESS_TERMINATE access rights. For more information, see Process Security and Access Rights. If the process is
///               already associated with a job, the job specified by <i>hJob</i> must be empty or it must be in the hierarchy of
///               nested jobs to which the process already belongs, and it cannot have UI limits set (SetInformationJobObject with
///               <b>JobObjectBasicUIRestrictions</b>). For more information, see Remarks. <b>Windows 7, Windows Server 2008 R2,
///               Windows XP with SP3, Windows Server 2008, Windows Vista and Windows Server 2003: </b>The process must not already
///               be assigned to a job; if it is, the function fails with ERROR_ACCESS_DENIED. This behavior changed starting in
///               Windows 8 and Windows Server 2012. <b>Terminal Services: </b>All processes within a job must run within the same
///               session as the job.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess);

///Terminates all processes currently associated with the job. If the job is nested, this function terminates all
///processes currently associated with the job and all of its child jobs in the hierarchy.
///Params:
///    hJob = A handle to the job whose processes will be terminated. The CreateJobObject or OpenJobObject function returns
///           this handle. This handle must have the JOB_OBJECT_TERMINATE access right. For more information, see Job Object
///           Security and Access Rights. The handle for each process in the job object must have the PROCESS_TERMINATE access
///           right. For more information, see Process Security and Access Rights.
///    uExitCode = The exit code to be used by all processes and threads in the job object. Use the GetExitCodeProcess function to
///                retrieve each process's exit value. Use the GetExitCodeThread function to retrieve each thread's exit value.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL TerminateJobObject(HANDLE hJob, uint uExitCode);

///Sets limits for a job object.
///Params:
///    hJob = A handle to the job whose limits are being set. The CreateJobObject or OpenJobObject function returns this
///           handle. The handle must have the <b>JOB_OBJECT_SET_ATTRIBUTES</b> access right. For more information, see Job
///           Object Security and Access Rights.
///    JobObjectInformationClass = The information class for the limits to be set. This parameter can be one of the following values. <table> <tr>
///                                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                                id="JobObjectAssociateCompletionPortInformation"></a><a id="jobobjectassociatecompletionportinformation"></a><a
///                                id="JOBOBJECTASSOCIATECOMPLETIONPORTINFORMATION"></a><dl>
///                                <dt><b>JobObjectAssociateCompletionPortInformation</b></dt> <dt>7</dt> </dl> </td> <td width="60%"> The
///                                <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_ASSOCIATE_COMPLETION_PORT structure. </td> </tr>
///                                <tr> <td width="40%"><a id="JobObjectBasicLimitInformation"></a><a id="jobobjectbasiclimitinformation"></a><a
///                                id="JOBOBJECTBASICLIMITINFORMATION"></a><dl> <dt><b>JobObjectBasicLimitInformation</b></dt> <dt>2</dt> </dl>
///                                </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_BASIC_LIMIT_INFORMATION
///                                structure. </td> </tr> <tr> <td width="40%"><a id="JobObjectBasicUIRestrictions"></a><a
///                                id="jobobjectbasicuirestrictions"></a><a id="JOBOBJECTBASICUIRESTRICTIONS"></a><dl>
///                                <dt><b>JobObjectBasicUIRestrictions</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i>
///                                parameter is a pointer to a JOBOBJECT_BASIC_UI_RESTRICTIONS structure. </td> </tr> <tr> <td width="40%"><a
///                                id="JobObjectCpuRateControlInformation"></a><a id="jobobjectcpuratecontrolinformation"></a><a
///                                id="JOBOBJECTCPURATECONTROLINFORMATION"></a><dl> <dt><b>JobObjectCpuRateControlInformation</b></dt> <dt>15</dt>
///                                </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a
///                                JOBOBJECT_CPU_RATE_CONTROL_INFORMATION structure. <b>Windows 7, Windows Server 2008 R2, Windows Server 2008,
///                                Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td
///                                width="40%"><a id="JobObjectEndOfJobTimeInformation"></a><a id="jobobjectendofjobtimeinformation"></a><a
///                                id="JOBOBJECTENDOFJOBTIMEINFORMATION"></a><dl> <dt><b>JobObjectEndOfJobTimeInformation</b></dt> <dt>6</dt> </dl>
///                                </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a
///                                JOBOBJECT_END_OF_JOB_TIME_INFORMATION structure. </td> </tr> <tr> <td width="40%"><a
///                                id="JobObjectExtendedLimitInformation"></a><a id="jobobjectextendedlimitinformation"></a><a
///                                id="JOBOBJECTEXTENDEDLIMITINFORMATION"></a><dl> <dt><b>JobObjectExtendedLimitInformation</b></dt> <dt>9</dt>
///                                </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a
///                                JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure. </td> </tr> <tr> <td width="40%"><a
///                                id="JobObjectGroupInformation"></a><a id="jobobjectgroupinformation"></a><a
///                                id="JOBOBJECTGROUPINFORMATION"></a><dl> <dt><b>JobObjectGroupInformation</b></dt> <dt>11</dt> </dl> </td> <td
///                                width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a <b>USHORT</b> value that specifies the list
///                                of processor groups to assign the job to. The <i>cbJobObjectInfoLength</i> parameter is set to the size of the
///                                group data. Divide this value by <code>sizeof(USHORT)</code> to determine the number of groups. <b>Windows Server
///                                2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td
///                                width="40%"><a id="JobObjectGroupInformationEx"></a><a id="jobobjectgroupinformationex"></a><a
///                                id="JOBOBJECTGROUPINFORMATIONEX"></a><dl> <dt><b>JobObjectGroupInformationEx</b></dt> <dt>14</dt> </dl> </td> <td
///                                width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a buffer that contains an array of
///                                GROUP_AFFINITY structures that specify the affinity of the job for the processor groups to which the job is
///                                currently assigned. The <i>cbJobObjectInfoLength</i> parameter is set to the size of the group affinity data.
///                                Divide this value by <code>sizeof(GROUP_AFFINITY)</code> to determine the number of groups. <b>Windows 7, Windows
///                                Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not
///                                supported. </td> </tr> <tr> <td width="40%"><a id="JobObjectLimitViolationInformation2"></a><a
///                                id="jobobjectlimitviolationinformation2"></a><a id="JOBOBJECTLIMITVIOLATIONINFORMATION2"></a><dl>
///                                <dt><b>JobObjectLimitViolationInformation2</b></dt> <dt>34</dt> </dl> </td> <td width="60%"> The
///                                <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 structure. <b>Windows
///                                8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server
///                                2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td
///                                width="40%"><a id="JobObjectNetRateControlInformation"></a><a id="jobobjectnetratecontrolinformation"></a><a
///                                id="JOBOBJECTNETRATECONTROLINFORMATION"></a><dl> <dt><b>JobObjectNetRateControlInformation</b></dt> <dt>32</dt>
///                                </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a
///                                JOBOBJECT_NET_RATE_CONTROL_INFORMATION structure. <b>Windows 8.1, Windows Server 2012 R2, Windows 8, Windows
///                                Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and
///                                Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td width="40%"><a
///                                id="JobObjectNotificationLimitInformation"></a><a id="jobobjectnotificationlimitinformation"></a><a
///                                id="JOBOBJECTNOTIFICATIONLIMITINFORMATION"></a><dl> <dt><b>JobObjectNotificationLimitInformation</b></dt>
///                                <dt>12</dt> </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a
///                                JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION structure. <b>Windows 7, Windows Server 2008 R2, Windows Server 2008,
///                                Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td
///                                width="40%"><a id="JobObjectNotificationLimitInformation2"></a><a
///                                id="jobobjectnotificationlimitinformation2"></a><a id="JOBOBJECTNOTIFICATIONLIMITINFORMATION2"></a><dl>
///                                <dt><b>JobObjectNotificationLimitInformation2</b></dt> <dt>33</dt> </dl> </td> <td width="60%"> The
///                                <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 structure.
///                                <b>Windows 8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2,
///                                Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported. </td>
///                                </tr> <tr> <td width="40%"><a id="JobObjectSecurityLimitInformation"></a><a
///                                id="jobobjectsecuritylimitinformation"></a><a id="JOBOBJECTSECURITYLIMITINFORMATION"></a><dl>
///                                <dt><b>JobObjectSecurityLimitInformation</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> This flag is not
///                                supported. Applications must set security limitations individually for each process. <b>Windows Server 2003 and
///                                Windows XP: </b>The <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_SECURITY_LIMIT_INFORMATION
///                                structure. The <i>hJob</i> handle must have the <b>JOB_OBJECT_SET_SECURITY_ATTRIBUTES</b> access right associated
///                                with it. </td> </tr> </table>
///    lpJobObjectInformation = The limits or job state to be set for the job. The format of this data depends on the value of
///                             <i>JobObjectInfoClass</i>.
///    cbJobObjectInformationLength = The size of the job information being set, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, 
                             void* lpJobObjectInformation, uint cbJobObjectInformationLength);

///Sets I/O limits on a job object.
///Params:
///    hJob = A handle to the job on which to set I/O limits. Get this handle from the CreateJobObject or OpenJobObject
///           function. The handle must have the <b>JOB_OBJECT_SET_ATTRIBUTES</b> access right. For more information about
///           access rights, see Job Object Security and Access Rights.
///    IoRateControlInfo = A pointer to a JOBOBJECT_IO_RATE_CONTROL_INFORMATION structure that specifies the I/O limits to set for the job.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION* IoRateControlInfo);

///Retrieves limit and job state information from the job object.
///Params:
///    hJob = A handle to the job whose information is being queried. The CreateJobObject or OpenJobObject function returns
///           this handle. The handle must have the <b>JOB_OBJECT_QUERY</b> access right. For more information, see Job Object
///           Security and Access Rights. If this value is NULL and the calling process is associated with a job, the job
///           associated with the calling process is used. If the job is nested, the immediate job of the calling process is
///           used.
///    JobObjectInformationClass = The information class for the limits to be queried. This parameter can be one of the following values. <table>
///                                <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                                id="JobObjectBasicAccountingInformation"></a><a id="jobobjectbasicaccountinginformation"></a><a
///                                id="JOBOBJECTBASICACCOUNTINGINFORMATION"></a><dl> <dt><b>JobObjectBasicAccountingInformation</b></dt> <dt>1</dt>
///                                </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a
///                                JOBOBJECT_BASIC_ACCOUNTING_INFORMATION structure. </td> </tr> <tr> <td width="40%"><a
///                                id="JobObjectBasicAndIoAccountingInformation"></a><a id="jobobjectbasicandioaccountinginformation"></a><a
///                                id="JOBOBJECTBASICANDIOACCOUNTINGINFORMATION"></a><dl> <dt><b>JobObjectBasicAndIoAccountingInformation</b></dt>
///                                <dt>8</dt> </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a
///                                JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION structure. </td> </tr> <tr> <td width="40%"><a
///                                id="JobObjectBasicLimitInformation"></a><a id="jobobjectbasiclimitinformation"></a><a
///                                id="JOBOBJECTBASICLIMITINFORMATION"></a><dl> <dt><b>JobObjectBasicLimitInformation</b></dt> <dt>2</dt> </dl>
///                                </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_BASIC_LIMIT_INFORMATION
///                                structure. </td> </tr> <tr> <td width="40%"><a id="JobObjectBasicProcessIdList"></a><a
///                                id="jobobjectbasicprocessidlist"></a><a id="JOBOBJECTBASICPROCESSIDLIST"></a><dl>
///                                <dt><b>JobObjectBasicProcessIdList</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i>
///                                parameter is a pointer to a JOBOBJECT_BASIC_PROCESS_ID_LIST structure. </td> </tr> <tr> <td width="40%"><a
///                                id="JobObjectBasicUIRestrictions"></a><a id="jobobjectbasicuirestrictions"></a><a
///                                id="JOBOBJECTBASICUIRESTRICTIONS"></a><dl> <dt><b>JobObjectBasicUIRestrictions</b></dt> <dt>4</dt> </dl> </td>
///                                <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_BASIC_UI_RESTRICTIONS
///                                structure. </td> </tr> <tr> <td width="40%"><a id="JobObjectCpuRateControlInformation"></a><a
///                                id="jobobjectcpuratecontrolinformation"></a><a id="JOBOBJECTCPURATECONTROLINFORMATION"></a><dl>
///                                <dt><b>JobObjectCpuRateControlInformation</b></dt> <dt>15</dt> </dl> </td> <td width="60%"> The
///                                <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_CPU_RATE_CONTROL_INFORMATION structure. <b>Windows
///                                7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag
///                                is not supported. </td> </tr> <tr> <td width="40%"><a id="JobObjectEndOfJobTimeInformation"></a><a
///                                id="jobobjectendofjobtimeinformation"></a><a id="JOBOBJECTENDOFJOBTIMEINFORMATION"></a><dl>
///                                <dt><b>JobObjectEndOfJobTimeInformation</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The
///                                <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_END_OF_JOB_TIME_INFORMATION structure. </td> </tr>
///                                <tr> <td width="40%"><a id="JobObjectExtendedLimitInformation"></a><a
///                                id="jobobjectextendedlimitinformation"></a><a id="JOBOBJECTEXTENDEDLIMITINFORMATION"></a><dl>
///                                <dt><b>JobObjectExtendedLimitInformation</b></dt> <dt>9</dt> </dl> </td> <td width="60%"> The
///                                <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_EXTENDED_LIMIT_INFORMATION structure. </td> </tr>
///                                <tr> <td width="40%"><a id="JobObjectGroupInformation"></a><a id="jobobjectgroupinformation"></a><a
///                                id="JOBOBJECTGROUPINFORMATION"></a><dl> <dt><b>JobObjectGroupInformation</b></dt> <dt>11</dt> </dl> </td> <td
///                                width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a buffer that receives the list of processor
///                                groups to which the job is currently assigned. The variable pointed to by the <i>lpReturnLength</i> parameter is
///                                set to the size of the group data. Divide this value by <code>sizeof(USHORT)</code> to determine the number of
///                                groups. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not
///                                supported. </td> </tr> <tr> <td width="40%"><a id="JobObjectGroupInformationEx"></a><a
///                                id="jobobjectgroupinformationex"></a><a id="JOBOBJECTGROUPINFORMATIONEX"></a><dl>
///                                <dt><b>JobObjectGroupInformationEx</b></dt> <dt>14</dt> </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i>
///                                parameter is a pointer to a buffer that receives an array of GROUP_AFFINITY structures that indicate the affinity
///                                of the job in the processor groups to which the job is currently assigned. The variable pointed to by the
///                                <i>lpReturnLength</i> parameter is set to the size of the group affinity data. Divide this value by
///                                <code>sizeof(GROUP_AFFINITY)</code> to determine the number of groups. <b>Windows 7, Windows Server 2008 R2,
///                                Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported. </td>
///                                </tr> <tr> <td width="40%"><a id="JobObjectLimitViolationInformation"></a><a
///                                id="jobobjectlimitviolationinformation"></a><a id="JOBOBJECTLIMITVIOLATIONINFORMATION"></a><dl>
///                                <dt><b>JobObjectLimitViolationInformation</b></dt> <dt>13</dt> </dl> </td> <td width="60%"> The
///                                <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_LIMIT_VIOLATION_INFORMATION structure. <b>Windows 7,
///                                Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is
///                                not supported. </td> </tr> <tr> <td width="40%"><a id="JobObjectLimitViolationInformation2"></a><a
///                                id="jobobjectlimitviolationinformation2"></a><a id="JOBOBJECTLIMITVIOLATIONINFORMATION2"></a><dl>
///                                <dt><b>JobObjectLimitViolationInformation2</b></dt> <dt>34</dt> </dl> </td> <td width="60%"> The
///                                <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 structure. <b>Windows
///                                8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2, Windows Server
///                                2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td
///                                width="40%"><a id="JobObjectNetRateControlInformation"></a><a id="jobobjectnetratecontrolinformation"></a><a
///                                id="JOBOBJECTNETRATECONTROLINFORMATION"></a><dl> <dt><b>JobObjectNetRateControlInformation</b></dt> <dt>32</dt>
///                                </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a
///                                JOBOBJECT_NET_RATE_CONTROL_INFORMATION structure. <b>Windows 8.1, Windows Server 2012 R2, Windows 8, Windows
///                                Server 2012, Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and
///                                Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td width="40%"><a
///                                id="JobObjectNotificationLimitInformation"></a><a id="jobobjectnotificationlimitinformation"></a><a
///                                id="JOBOBJECTNOTIFICATIONLIMITINFORMATION"></a><dl> <dt><b>JobObjectNotificationLimitInformation</b></dt>
///                                <dt>12</dt> </dl> </td> <td width="60%"> The <i>lpJobObjectInfo</i> parameter is a pointer to a
///                                JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION structure. <b>Windows 7, Windows Server 2008 R2, Windows Server 2008,
///                                Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported. </td> </tr> <tr> <td
///                                width="40%"><a id="JobObjectNotificationLimitInformation2"></a><a
///                                id="jobobjectnotificationlimitinformation2"></a><a id="JOBOBJECTNOTIFICATIONLIMITINFORMATION2"></a><dl>
///                                <dt><b>JobObjectNotificationLimitInformation2</b></dt> <dt>33</dt> </dl> </td> <td width="60%"> The
///                                <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 structure.
///                                <b>Windows 8.1, Windows Server 2012 R2, Windows 8, Windows Server 2012, Windows 7, Windows Server 2008 R2,
///                                Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This flag is not supported. </td>
///                                </tr> <tr> <td width="40%"><a id="JobObjectSecurityLimitInformation"></a><a
///                                id="jobobjectsecuritylimitinformation"></a><a id="JOBOBJECTSECURITYLIMITINFORMATION"></a><dl>
///                                <dt><b>JobObjectSecurityLimitInformation</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> This flag is not
///                                supported. Applications must set security limits individually for each process. <b>Windows Server 2003 and
///                                Windows XP: </b>The <i>lpJobObjectInfo</i> parameter is a pointer to a JOBOBJECT_SECURITY_LIMIT_INFORMATION
///                                structure. </td> </tr> </table>
///    lpJobObjectInformation = The limit or job state information. The format of this data depends on the value of the <i>JobObjectInfoClass</i>
///                             parameter.
///    cbJobObjectInformationLength = The count of the job information being queried, in bytes. This value depends on the value of the
///                                   <i>JobObjectInfoClass</i> parameter.
///    lpReturnLength = A pointer to a variable that receives the length of data written to the structure pointed to by the
///                     <i>lpJobObjectInfo</i> parameter. Specify <b>NULL</b> to not receive this information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, 
                               void* lpJobObjectInformation, uint cbJobObjectInformationLength, uint* lpReturnLength);

///Gets information about the control of the I/O rate for a job object.
///Params:
///    hJob = A handle to the job to query for information. Get this handle from the CreateJobObject or OpenJobObject function.
///           The handle must have the <b>JOB_OBJECT_QUERY</b> access right. For more information about access rights, see Job
///           Object Security and Access Rights. If this value is NULL and the process that calls
///           <b>QueryIoRateControlInformationJobObject</b> is associated with a job, the function uses job that is associated
///           with the process. If the job is nested within another job, the function uses the immediate job for the process.
///    VolumeName = The name of the volume to query. If this value is NULL, the function gets the information about I/O rate control
///                 for the job for all of the volumes for the system.
///    InfoBlocks = A pointer to array of JOBOBJECT_IO_RATE_CONTROL_INFORMATION structures that contain the information about I/O
///                 rate control for the job. Your code must free the memory for this array by calling the FreeMemoryJobObject
///                 function with the address of the array.
///    InfoBlockCount = The number of JOBOBJECT_IO_RATE_CONTROL_INFORMATION structures that the function allocated in the array to which
///                     the <i>InfoBlocks</i> parameter points.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint QueryIoRateControlInformationJobObject(HANDLE hJob, const(PWSTR) VolumeName, 
                                            JOBOBJECT_IO_RATE_CONTROL_INFORMATION** InfoBlocks, uint* InfoBlockCount);

@DllImport("KERNEL32")
NamespaceHandle CreatePrivateNamespaceW(SECURITY_ATTRIBUTES* lpPrivateNamespaceAttributes, 
                                        void* lpBoundaryDescriptor, const(PWSTR) lpAliasPrefix);

@DllImport("KERNEL32")
NamespaceHandle OpenPrivateNamespaceW(void* lpBoundaryDescriptor, const(PWSTR) lpAliasPrefix);

///Closes an open namespace handle.
///Params:
///    Handle = The namespace handle. This handle is created by CreatePrivateNamespace or OpenPrivateNamespace.
///    Flags = If this parameter is <b>PRIVATE_NAMESPACE_FLAG_DESTROY</b> (0x00000001), the namespace is destroyed.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ubyte ClosePrivateNamespace(NamespaceHandle Handle, uint Flags);

@DllImport("KERNEL32")
BoundaryDescriptorHandle CreateBoundaryDescriptorW(const(PWSTR) Name, uint Flags);

///Adds a security identifier (SID) to the specified boundary descriptor.
///Params:
///    BoundaryDescriptor = A handle to the boundary descriptor. The CreateBoundaryDescriptor function returns this handle.
///    RequiredSid = A pointer to a SID structure.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL AddSIDToBoundaryDescriptor(HANDLE* BoundaryDescriptor, void* RequiredSid);

///Deletes the specified boundary descriptor.
///Params:
///    BoundaryDescriptor = A handle to the boundary descriptor. The CreateBoundaryDescriptor function returns this handle.
@DllImport("KERNEL32")
void DeleteBoundaryDescriptor(BoundaryDescriptorHandle BoundaryDescriptor);

///Retrieves the node that currently has the highest number.
///Params:
///    HighestNodeNumber = The number of the highest node.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNumaHighestNodeNumber(uint* HighestNodeNumber);

///Retrieves the processor mask for a node regardless of the processor group the node belongs to.
///Params:
///    Node = The node number.
///    ProcessorMask = A pointer to a GROUP_AFFINITY structure that receives the processor mask for the specified node. A processor mask
///                    is a bit vector in which each bit represents a processor and whether it is in the node. If the specified node has
///                    no processors configured, the <b>Mask</b> member is zero and the <b>Group</b> member is undefined.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.
///    
@DllImport("KERNEL32")
BOOL GetNumaNodeProcessorMaskEx(ushort Node, GROUP_AFFINITY* ProcessorMask);

///Retrieves the NUMA node number that corresponds to the specified proximity identifier as a <b>USHORT</b> value.
///Params:
///    ProximityId = The proximity identifier of the node.
///    NodeNumber = Points to a variable to receive the node number for the specified proximity identifier.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.
///    
@DllImport("KERNEL32")
BOOL GetNumaProximityNodeEx(uint ProximityId, ushort* NodeNumber);

///Retrieves the processor group affinity of the specified process.
///Params:
///    hProcess = A handle to the process. This handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION
///               access right. For more information, see Process Security and Access Rights.
///    GroupCount = On input, specifies the number of elements in <i>GroupArray</i> array. On output, specifies the number of
///                 processor groups written to the array. If the array is too small, the function fails with
///                 ERROR_INSUFFICIENT_BUFFER and sets the <i>GroupCount</i> parameter to the number of elements required.
///    GroupArray = An array of processor group numbers. A group number is included in the array if a thread in the process is
///                 assigned to a processor in the group.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, use GetLastError. If the error value is ERROR_INSUFFICIENT_BUFFER, the
///    <i>GroupCount</i> parameter contains the required buffer size in number of elements.
///    
@DllImport("KERNEL32")
BOOL GetProcessGroupAffinity(HANDLE hProcess, ushort* GroupCount, ushort* GroupArray);

///Retrieves the processor group affinity of the specified thread.
///Params:
///    hThread = A handle to the thread for which the processor group affinity is desired. The handle must have the
///              THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see Thread
///              Security and Access Rights.
///    GroupAffinity = A pointer to a GROUP_AFFINITY structure to receive the group affinity of the thread.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, use GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetThreadGroupAffinity(HANDLE hThread, GROUP_AFFINITY* GroupAffinity);

///Sets the processor group affinity for the specified thread.
///Params:
///    hThread = A handle to the thread. The handle must have the THREAD_SET_INFORMATION access right. For more information, see
///              Thread Security and Access Rights.
///    GroupAffinity = A GROUP_AFFINITY structure that specifies the processor group affinity to be used for the specified thread.
///    PreviousGroupAffinity = A pointer to a GROUP_AFFINITY structure to receive the thread's previous group affinity. This parameter can be
///                            NULL.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, use GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetThreadGroupAffinity(HANDLE hThread, const(GROUP_AFFINITY)* GroupAffinity, 
                            GROUP_AFFINITY* PreviousGroupAffinity);

///Retrieves the command-line string for the current process.
///Returns:
///    The return value is a pointer to the command-line string for the current process.
///    
@DllImport("KERNEL32")
PSTR GetCommandLineA();

///Retrieves the command-line string for the current process.
///Returns:
///    The return value is a pointer to the command-line string for the current process.
///    
@DllImport("KERNEL32")
PWSTR GetCommandLineW();

///Retrieves the environment variables for the current process.
///Returns:
///    If the function succeeds, the return value is a pointer to the environment block of the current process. If the
///    function fails, the return value is NULL.
///    
@DllImport("KERNEL32")
PSTR GetEnvironmentStrings();

///Retrieves the environment variables for the current process.
///Returns:
///    If the function succeeds, the return value is a pointer to the environment block of the current process. If the
///    function fails, the return value is NULL.
///    
@DllImport("KERNEL32")
PWSTR GetEnvironmentStringsW();

///Frees a block of environment strings.
///Params:
///    penv = A pointer to a block of environment strings. The pointer to the block must be obtained by calling the
///           GetEnvironmentStrings function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FreeEnvironmentStringsA(/*PARAM ATTR: NullNullTerminated : CustomAttributeSig([], [])*/PSTR penv);

///Frees a block of environment strings.
///Params:
///    penv = A pointer to a block of environment strings. The pointer to the block must be obtained by calling the
///           GetEnvironmentStrings function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL FreeEnvironmentStringsW(/*PARAM ATTR: NullNullTerminated : CustomAttributeSig([], [])*/PWSTR penv);

///Retrieves the contents of the specified variable from the environment block of the calling process.
///Params:
///    lpName = The name of the environment variable.
///    lpBuffer = A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated
///               string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating
///               character.
///    nSize = The size of the buffer pointed to by the *lpBuffer* parameter, including the null-terminating character, in
///            characters.
///Returns:
///    If the function succeeds, the return value is the number of characters stored in the buffer pointed to by
///    *lpBuffer*, not including the terminating null character. If *lpBuffer* is not large enough to hold the data, the
///    return value is the buffer size, in characters, required to hold the string and its terminating null character
///    and the contents of *lpBuffer* are undefined. If the function fails, the return value is zero. If the specified
///    environment variable was not found in the environment block, GetLastError returns ERROR_ENVVAR_NOT_FOUND.
///    
@DllImport("KERNEL32")
uint GetEnvironmentVariableA(const(PSTR) lpName, PSTR lpBuffer, uint nSize);

///Retrieves the contents of the specified variable from the environment block of the calling process.
///Params:
///    lpName = The name of the environment variable.
///    lpBuffer = A pointer to a buffer that receives the contents of the specified environment variable as a null-terminated
///               string. The maximum size of a user-defined environment variable is 32,767 characters. There is no technical
///               limitation on the size of the environment block. However, there are practical limits depending on the mechanism
///               used to access the block. For example, a batch file cannot set a variable that is longer than the maximum command
///               line length. For more information, see [Environment
///               Variables](/windows/desktop/ProcThread/environment-variables).
///    nSize = The size of the buffer pointed to by the <i>lpBuffer</i> parameter, including the null-terminating character, in
///            characters.
///Returns:
///    If the function succeeds, the return value is the number of characters stored in the buffer pointed to by
///    <i>lpBuffer</i>, not including the terminating null character. If <i>lpBuffer</i> is not large enough to hold the
///    data, the return value is the buffer size, in characters, required to hold the string and its terminating null
///    character and the contents of <i>lpBuffer</i> are undefined. If the function fails, the return value is zero. If
///    the specified environment variable was not found in the environment block, GetLastError returns
///    ERROR_ENVVAR_NOT_FOUND.
///    
@DllImport("KERNEL32")
uint GetEnvironmentVariableW(const(PWSTR) lpName, PWSTR lpBuffer, uint nSize);

///Sets the contents of the specified environment variable for the current process.
///Params:
///    lpName = The name of the environment variable. The operating system creates the environment variable if it does not exist
///             and <i>lpValue</i> is not NULL.
///    lpValue = The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767
///              characters. For more information, see Environment Variables. <b>Windows Server 2003 and Windows XP: </b>The total
///              size of the environment block for a process may not exceed 32,767 characters. If this parameter is NULL, the
///              variable is deleted from the current process's environment.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetEnvironmentVariableA(const(PSTR) lpName, const(PSTR) lpValue);

///Sets the contents of the specified environment variable for the current process.
///Params:
///    lpName = The name of the environment variable. The operating system creates the environment variable if it does not exist
///             and <i>lpValue</i> is not NULL.
///    lpValue = The contents of the environment variable. The maximum size of a user-defined environment variable is 32,767
///              characters. There is no technical limitation on the size of the environment block. However, there are practical
///              limits depending on the mechanism used to access the block. For example, a batch file cannot set a variable that
///              is longer than the maximum command line length. For more information, see [Environment
///              Variables](/windows/desktop/ProcThread/environment-variables). <b>Windows Server 2003 and Windows XP: </b>The
///              total size of the environment block for a process may not exceed 32,767 characters. If this parameter is NULL,
///              the variable is deleted from the current process's environment.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetEnvironmentVariableW(const(PWSTR) lpName, const(PWSTR) lpValue);

///Determines whether the current directory should be included in the search path for the specified executable.
///Params:
///    ExeName = The name of the executable file.
///Returns:
///    If the current directory should be part of the search path, the return value is TRUE. Otherwise, the return value
///    is FALSE.
///    
@DllImport("KERNEL32")
BOOL NeedCurrentDirectoryForExePathA(const(PSTR) ExeName);

///Determines whether the current directory should be included in the search path for the specified executable.
///Params:
///    ExeName = The name of the executable file.
///Returns:
///    If the current directory should be part of the search path, the return value is TRUE. Otherwise, the return value
///    is FALSE.
///    
@DllImport("KERNEL32")
BOOL NeedCurrentDirectoryForExePathW(const(PWSTR) ExeName);

///Adds a user-mode asynchronous procedure call (APC) object to the APC queue of the specified thread.
///Params:
///    pfnAPC = A pointer to the application-supplied APC function to be called when the specified thread performs an alertable
///             wait operation. For more information, see APCProc.
///    hThread = A handle to the thread. The handle must have the <b>THREAD_SET_CONTEXT</b> access right. For more information,
///              see Synchronization Object Security and Access Rights.
///    dwData = A single value that is passed to the APC function pointed to by the <i>pfnAPC</i> parameter.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. <b>Windows Server 2003 and Windows XP: </b>There are no error
///    values defined for this function that can be retrieved by calling GetLastError.
///    
@DllImport("KERNEL32")
uint QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, size_t dwData);

///Retrieves timing information for the specified process.
///Params:
///    hProcess = A handle to the process whose timing information is sought. The handle must have the
///               <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information,
///               see Process Security and Access Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the
///               <b>PROCESS_QUERY_INFORMATION</b> access right.
///    lpCreationTime = A pointer to a FILETIME structure that receives the creation time of the process.
///    lpExitTime = A pointer to a FILETIME structure that receives the exit time of the process. If the process has not exited, the
///                 content of this structure is undefined.
///    lpKernelTime = A pointer to a FILETIME structure that receives the amount of time that the process has executed in kernel mode.
///                   The time that each of the threads of the process has executed in kernel mode is determined, and then all of those
///                   times are summed together to obtain this value.
///    lpUserTime = A pointer to a FILETIME structure that receives the amount of time that the process has executed in user mode.
///                 The time that each of the threads of the process has executed in user mode is determined, and then all of those
///                 times are summed together to obtain this value. Note that this value can exceed the amount of real time elapsed
///                 (between <i>lpCreationTime</i> and <i>lpExitTime</i>) if the process executes across multiple CPU cores.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessTimes(HANDLE hProcess, FILETIME* lpCreationTime, FILETIME* lpExitTime, FILETIME* lpKernelTime, 
                     FILETIME* lpUserTime);

///Retrieves a pseudo handle for the current process.
///Returns:
///    The return value is a pseudo handle to the current process.
///    
@DllImport("KERNEL32")
HANDLE GetCurrentProcess();

///Retrieves the process identifier of the calling process.
///Returns:
///    The return value is the process identifier of the calling process.
///    
@DllImport("KERNEL32")
uint GetCurrentProcessId();

///Ends the calling process and all its threads.
///Params:
///    uExitCode = The exit code for the process and all threads.
@DllImport("KERNEL32")
void ExitProcess(uint uExitCode);

///Terminates the specified process and all of its threads.
///Params:
///    hProcess = A handle to the process to be terminated. The handle must have the <b>PROCESS_TERMINATE</b> access right. For
///               more information, see Process Security and Access Rights.
///    uExitCode = The exit code to be used by the process and threads terminated as a result of this call. Use the
///                GetExitCodeProcess function to retrieve a process's exit value. Use the GetExitCodeThread function to retrieve a
///                thread's exit value.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL TerminateProcess(HANDLE hProcess, uint uExitCode);

///Retrieves the termination status of the specified process.
///Params:
///    hProcess = A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or
///               <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see Process Security and Access
///               Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b>
///               access right.
///    lpExitCode = A pointer to a variable to receive the process termination status. For more information, see Remarks.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetExitCodeProcess(HANDLE hProcess, uint* lpExitCode);

///Causes the calling thread to yield execution to another thread that is ready to run on the current processor. The
///operating system selects the next thread to be executed.
///Returns:
///    If calling the <b>SwitchToThread</b> function caused the operating system to switch execution to another thread,
///    the return value is nonzero. If there are no other threads ready to execute, the operating system does not switch
///    execution to another thread, and the return value is zero.
///    
@DllImport("KERNEL32")
BOOL SwitchToThread();

///Creates a thread to execute within the virtual address space of the calling process. To create a thread that runs in
///the virtual address space of another process, use the CreateRemoteThread function.
///Params:
///    lpThreadAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by
///                         child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited. The
///                         <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new thread. If
///                         <i>lpThreadAttributes</i> is NULL, the thread gets a default security descriptor. The ACLs in the default
///                         security descriptor for a thread come from the primary token of the creator.
///    dwStackSize = The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is
///                  zero, the new thread uses the default size for the executable. For more information, see Thread Stack Size.
///    lpStartAddress = A pointer to the application-defined function to be executed by the thread. This pointer represents the starting
///                     address of the thread. For more information on the thread function, see ThreadProc.
///    lpParameter = A pointer to a variable to be passed to the thread.
///    dwCreationFlags = The flags that control the creation of the thread. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                      width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The thread runs immediately after creation. </td> </tr>
///                      <tr> <td width="40%"><a id="CREATE_SUSPENDED"></a><a id="create_suspended"></a><dl>
///                      <dt><b>CREATE_SUSPENDED</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The thread is created in a
///                      suspended state, and does not run until the ResumeThread function is called. </td> </tr> <tr> <td width="40%"><a
///                      id="STACK_SIZE_PARAM_IS_A_RESERVATION"></a><a id="stack_size_param_is_a_reservation"></a><dl>
///                      <dt><b>STACK_SIZE_PARAM_IS_A_RESERVATION</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> The
///                      <i>dwStackSize</i> parameter specifies the initial reserve size of the stack. If this flag is not specified,
///                      <i>dwStackSize</i> specifies the commit size. </td> </tr> </table>
///    lpThreadId = A pointer to a variable that receives the thread identifier. If this parameter is <b>NULL</b>, the thread
///                 identifier is not returned.
///Returns:
///    If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call GetLastError. Note that <b>CreateThread</b> may succeed
///    even if <i>lpStartAddress</i> points to data, code, or is not accessible. If the start address is invalid when
///    the thread runs, an exception occurs, and the thread terminates. Thread termination due to a invalid start
///    address is handled as an error exit for the thread's process. This behavior is similar to the asynchronous nature
///    of CreateProcess, where the process is created even if it refers to invalid or missing dynamic-link libraries
///    (DLLs).
///    
@DllImport("KERNEL32")
HANDLE CreateThread(SECURITY_ATTRIBUTES* lpThreadAttributes, size_t dwStackSize, 
                    LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, uint dwCreationFlags, uint* lpThreadId);

///Creates a thread that runs in the virtual address space of another process. Use the CreateRemoteThreadEx function to
///create a thread that runs in the virtual address space of another process and optionally specify extended attributes.
///Params:
///    hProcess = A handle to the process in which the thread is to be created. The handle must have the
///               <b>PROCESS_CREATE_THREAD</b>, <b>PROCESS_QUERY_INFORMATION</b>, <b>PROCESS_VM_OPERATION</b>,
///               <b>PROCESS_VM_WRITE</b>, and <b>PROCESS_VM_READ</b> access rights, and may fail without these rights on certain
///               platforms. For more information, see Process Security and Access Rights.
///    lpThreadAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and
///                         determines whether child processes can inherit the returned handle. If <i>lpThreadAttributes</i> is NULL, the
///                         thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in
///                         the default security descriptor for a thread come from the primary token of the creator. <b>Windows XP: </b>The
///                         ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator.
///                         This behavior changed with Windows XP with SP2 and Windows Server 2003.
///    dwStackSize = The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0
///                  (zero), the new thread uses the default size for the executable. For more information, see Thread Stack Size.
///    lpStartAddress = A pointer to the application-defined function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by the thread
///                     and represents the starting address of the thread in the remote process. The function must exist in the remote
///                     process. For more information, see ThreadProc.
///    lpParameter = A pointer to a variable to be passed to the thread function.
///    dwCreationFlags = The flags that control the creation of the thread. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                      width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The thread runs immediately after creation. </td> </tr>
///                      <tr> <td width="40%"><a id="CREATE_SUSPENDED"></a><a id="create_suspended"></a><dl>
///                      <dt><b>CREATE_SUSPENDED</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The thread is created in a
///                      suspended state, and does not run until the ResumeThread function is called. </td> </tr> <tr> <td width="40%"><a
///                      id="STACK_SIZE_PARAM_IS_A_RESERVATION"></a><a id="stack_size_param_is_a_reservation"></a><dl>
///                      <dt><b>STACK_SIZE_PARAM_IS_A_RESERVATION</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> The
///                      <i>dwStackSize</i> parameter specifies the initial reserve size of the stack. If this flag is not specified,
///                      <i>dwStackSize</i> specifies the commit size. </td> </tr> </table>
///    lpThreadId = A pointer to a variable that receives the thread identifier. If this parameter is <b>NULL</b>, the thread
///                 identifier is not returned.
///Returns:
///    If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call GetLastError. Note that <b>CreateRemoteThread</b> may
///    succeed even if <i>lpStartAddress</i> points to data, code, or is not accessible. If the start address is invalid
///    when the thread runs, an exception occurs, and the thread terminates. Thread termination due to a invalid start
///    address is handled as an error exit for the thread's process. This behavior is similar to the asynchronous nature
///    of CreateProcess, where the process is created even if it refers to invalid or missing dynamic-link libraries
///    (DLL).
///    
@DllImport("KERNEL32")
HANDLE CreateRemoteThread(HANDLE hProcess, SECURITY_ATTRIBUTES* lpThreadAttributes, size_t dwStackSize, 
                          LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, uint dwCreationFlags, 
                          uint* lpThreadId);

///Retrieves a pseudo handle for the calling thread.
///Returns:
///    The return value is a pseudo handle for the current thread.
///    
@DllImport("KERNEL32")
HANDLE GetCurrentThread();

///Retrieves the thread identifier of the calling thread.
///Returns:
///    The return value is the thread identifier of the calling thread.
///    
@DllImport("KERNEL32")
uint GetCurrentThreadId();

///Opens an existing thread object.
///Params:
///    dwDesiredAccess = The access to the thread object. This access right is checked against the security descriptor for the thread.
///                      This parameter can be one or more of the thread access rights. If the caller has enabled the SeDebugPrivilege
///                      privilege, the requested access is granted regardless of the contents of the security descriptor.
///    bInheritHandle = If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not
///                     inherit this handle.
///    dwThreadId = The identifier of the thread to be opened.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified thread. If the function fails, the
///    return value is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenThread(uint dwDesiredAccess, BOOL bInheritHandle, uint dwThreadId);

///Sets the priority value for the specified thread. This value, together with the priority class of the thread's
///process, determines the thread's base priority level.
///Params:
///    hThread = A handle to the thread whose priority value is to be set. The handle must have the <b>THREAD_SET_INFORMATION</b>
///              or <b>THREAD_SET_LIMITED_INFORMATION</b> access right. For more information, see Thread Security and Access
///              Rights.<b>Windows Server 2003: </b>The handle must have the <b>THREAD_SET_INFORMATION</b> access right.
///    nPriority = The priority value for the thread. This parameter can be one of the following values. <table> <tr>
///                <th>Priority</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="THREAD_MODE_BACKGROUND_BEGIN"></a><a
///                id="thread_mode_background_begin"></a><dl> <dt><b>THREAD_MODE_BACKGROUND_BEGIN</b></dt> <dt>0x00010000</dt> </dl>
///                </td> <td width="60%"> Begin background processing mode. The system lowers the resource scheduling priorities of
///                the thread so that it can perform background work without significantly affecting activity in the foreground.
///                This value can be specified only if <i>hThread</i> is a handle to the current thread. The function fails if the
///                thread is already in background processing mode. <b>Windows Server 2003: </b>This value is not supported. </td>
///                </tr> <tr> <td width="40%"><a id="THREAD_MODE_BACKGROUND_END"></a><a id="thread_mode_background_end"></a><dl>
///                <dt><b>THREAD_MODE_BACKGROUND_END</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> End background
///                processing mode. The system restores the resource scheduling priorities of the thread as they were before the
///                thread entered background processing mode. This value can be specified only if <i>hThread</i> is a handle to the
///                current thread. The function fails if the thread is not in background processing mode. <b>Windows Server 2003:
///                </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a id="THREAD_PRIORITY_ABOVE_NORMAL"></a><a
///                id="thread_priority_above_normal"></a><dl> <dt><b>THREAD_PRIORITY_ABOVE_NORMAL</b></dt> <dt>1</dt> </dl> </td>
///                <td width="60%"> Priority 1 point above the priority class. </td> </tr> <tr> <td width="40%"><a
///                id="THREAD_PRIORITY_BELOW_NORMAL"></a><a id="thread_priority_below_normal"></a><dl>
///                <dt><b>THREAD_PRIORITY_BELOW_NORMAL</b></dt> <dt>-1</dt> </dl> </td> <td width="60%"> Priority 1 point below the
///                priority class. </td> </tr> <tr> <td width="40%"><a id="THREAD_PRIORITY_HIGHEST"></a><a
///                id="thread_priority_highest"></a><dl> <dt><b>THREAD_PRIORITY_HIGHEST</b></dt> <dt>2</dt> </dl> </td> <td
///                width="60%"> Priority 2 points above the priority class. </td> </tr> <tr> <td width="40%"><a
///                id="THREAD_PRIORITY_IDLE"></a><a id="thread_priority_idle"></a><dl> <dt><b>THREAD_PRIORITY_IDLE</b></dt>
///                <dt>-15</dt> </dl> </td> <td width="60%"> Base priority of 1 for <b>IDLE_PRIORITY_CLASS</b>,
///                <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or
///                <b>HIGH_PRIORITY_CLASS</b> processes, and a base priority of 16 for <b>REALTIME_PRIORITY_CLASS</b> processes.
///                </td> </tr> <tr> <td width="40%"><a id="THREAD_PRIORITY_LOWEST"></a><a id="thread_priority_lowest"></a><dl>
///                <dt><b>THREAD_PRIORITY_LOWEST</b></dt> <dt>-2</dt> </dl> </td> <td width="60%"> Priority 2 points below the
///                priority class. </td> </tr> <tr> <td width="40%"><a id="THREAD_PRIORITY_NORMAL"></a><a
///                id="thread_priority_normal"></a><dl> <dt><b>THREAD_PRIORITY_NORMAL</b></dt> <dt>0</dt> </dl> </td> <td
///                width="60%"> Normal priority for the priority class. </td> </tr> <tr> <td width="40%"><a
///                id="THREAD_PRIORITY_TIME_CRITICAL"></a><a id="thread_priority_time_critical"></a><dl>
///                <dt><b>THREAD_PRIORITY_TIME_CRITICAL</b></dt> <dt>15</dt> </dl> </td> <td width="60%"> Base priority of 15 for
///                <b>IDLE_PRIORITY_CLASS</b>, <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>,
///                <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or <b>HIGH_PRIORITY_CLASS</b> processes, and a base priority of 31 for
///                <b>REALTIME_PRIORITY_CLASS</b> processes. </td> </tr> </table> If the thread has the
///                <b>REALTIME_PRIORITY_CLASS</b> base class, this parameter can also be -7, -6, -5, -4, -3, 3, 4, 5, or 6. For more
///                information, see Scheduling Priorities.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. <b>Windows Phone 8.1: </b>Windows Phone Store apps may call this
///    function but it has no effect. The function will return a nonzero value indicating success.
///    
@DllImport("KERNEL32")
BOOL SetThreadPriority(HANDLE hThread, int nPriority);

///Disables or enables the ability of the system to temporarily boost the priority of a thread.
///Params:
///    hThread = A handle to the thread whose priority is to be boosted. The handle must have the <b>THREAD_SET_INFORMATION</b> or
///              <b>THREAD_SET_LIMITED_INFORMATION</b> access right. For more information, see Thread Security and Access Rights.
///              <b>Windows Server 2003 and Windows XP: </b>The handle must have the <b>THREAD_SET_INFORMATION</b> access right.
///    bDisablePriorityBoost = If this parameter is <b>TRUE</b>, dynamic boosting is disabled. If the parameter is <b>FALSE</b>, dynamic
///                            boosting is enabled.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost);

///Retrieves the priority boost control state of the specified thread.
///Params:
///    hThread = A handle to the thread. The handle must have the <b>THREAD_QUERY_INFORMATION</b> or
///              <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see Thread Security and Access
///              Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b>
///              access right.
///    pDisablePriorityBoost = A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic
///                            boosting is disabled. A value of FALSE indicates normal behavior.
///Returns:
///    If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the
///    <i>pDisablePriorityBoost</i> parameter receives the priority boost control state. If the function fails, the
///    return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetThreadPriorityBoost(HANDLE hThread, BOOL* pDisablePriorityBoost);

///Retrieves the priority value for the specified thread. This value, together with the priority class of the thread's
///process, determines the thread's base-priority level.
///Params:
///    hThread = A handle to the thread. The handle must have the <b>THREAD_QUERY_INFORMATION</b> or
///              <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see Thread Security and Access
///              Rights. <b>Windows Server 2003: </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b> access right.
///Returns:
///    If the function succeeds, the return value is the thread's priority level. If the function fails, the return
///    value is <b>THREAD_PRIORITY_ERROR_RETURN</b>. To get extended error information, call GetLastError. <b>Windows
///    Phone 8.1: </b>This function will always return <b>THREAD_PRIORITY_NORMAL</b>. The thread's priority level is one
///    of the following values. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>THREAD_PRIORITY_ABOVE_NORMAL</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Priority 1 point above
///    the priority class. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>THREAD_PRIORITY_BELOW_NORMAL</b></dt>
///    <dt>-1</dt> </dl> </td> <td width="60%"> Priority 1 point below the priority class. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>THREAD_PRIORITY_HIGHEST</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Priority 2
///    points above the priority class. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>THREAD_PRIORITY_IDLE</b></dt>
///    <dt>-15</dt> </dl> </td> <td width="60%"> Base priority of 1 for <b>IDLE_PRIORITY_CLASS</b>,
///    <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or
///    <b>HIGH_PRIORITY_CLASS</b> processes, and a base priority of 16 for <b>REALTIME_PRIORITY_CLASS</b> processes.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>THREAD_PRIORITY_LOWEST</b></dt> <dt>-2</dt> </dl> </td> <td
///    width="60%"> Priority 2 points below the priority class. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>THREAD_PRIORITY_NORMAL</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Normal priority for the priority
///    class. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>THREAD_PRIORITY_TIME_CRITICAL</b></dt> <dt>15</dt> </dl>
///    </td> <td width="60%"> Base-priority level of 15 for <b>IDLE_PRIORITY_CLASS</b>,
///    <b>BELOW_NORMAL_PRIORITY_CLASS</b>, <b>NORMAL_PRIORITY_CLASS</b>, <b>ABOVE_NORMAL_PRIORITY_CLASS</b>, or
///    <b>HIGH_PRIORITY_CLASS</b> processes, and a base-priority level of 31 for <b>REALTIME_PRIORITY_CLASS</b>
///    processes. </td> </tr> </table> If the thread has the <b>REALTIME_PRIORITY_CLASS</b> base class, this function
///    can also return one of the following values: -7, -6, -5, -4, -3, 3, 4, 5, or 6. For more information, see
///    Scheduling Priorities.
///    
@DllImport("KERNEL32")
int GetThreadPriority(HANDLE hThread);

///Ends the calling thread.
///Params:
///    dwExitCode = The exit code for the thread.
@DllImport("KERNEL32")
void ExitThread(uint dwExitCode);

///Terminates a thread.
///Params:
///    hThread = A handle to the thread to be terminated. The handle must have the <b>THREAD_TERMINATE</b> access right. For more
///              information, see Thread Security and Access Rights.
///    dwExitCode = The exit code for the thread. Use the GetExitCodeThread function to retrieve a thread's exit value.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL TerminateThread(HANDLE hThread, uint dwExitCode);

///Retrieves the termination status of the specified thread.
///Params:
///    hThread = A handle to the thread. The handle must have the <b>THREAD_QUERY_INFORMATION</b> or
///              <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see Thread Security and Access
///              Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the <b>THREAD_QUERY_INFORMATION</b>
///              access right.
///    lpExitCode = A pointer to a variable to receive the thread termination status. For more information, see Remarks.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetExitCodeThread(HANDLE hThread, uint* lpExitCode);

///Suspends the specified thread. A 64-bit application can suspend a WOW64 thread using the Wow64SuspendThread function.
///Params:
///    hThread = A handle to the thread that is to be suspended. The handle must have the <b>THREAD_SUSPEND_RESUME</b> access
///              right. For more information, see Thread Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is <code>(DWORD)
///    -1</code>. To get extended error information, use the GetLastError function.
///    
@DllImport("KERNEL32")
uint SuspendThread(HANDLE hThread);

///Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is
///resumed.
///Params:
///    hThread = A handle to the thread to be restarted. This handle must have the THREAD_SUSPEND_RESUME access right. For more
///              information, see Thread Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is the thread's previous suspend count. If the function fails, the
///    return value is (DWORD) -1. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint ResumeThread(HANDLE hThread);

///Allocates a thread local storage (TLS) index. Any thread of the process can subsequently use this index to store and
///retrieve values that are local to the thread, because each thread receives its own slot for the index.
///Returns:
///    If the function succeeds, the return value is a TLS index. The slots for the index are initialized to zero. If
///    the function fails, the return value is <b>TLS_OUT_OF_INDEXES</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("KERNEL32")
uint TlsAlloc();

///Retrieves the value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread
///of a process has its own slot for each TLS index.
///Params:
///    dwTlsIndex = The TLS index that was allocated by the TlsAlloc function.
///Returns:
///    If the function succeeds, the return value is the value stored in the calling thread's TLS slot associated with
///    the specified index. If <i>dwTlsIndex</i> is a valid index allocated by a successful call to TlsAlloc, this
///    function always succeeds. If the function fails, the return value is zero. To get extended error information,
///    call GetLastError. The data stored in a TLS slot can have a value of 0 because it still has its initial value or
///    because the thread called the TlsSetValue function with 0. Therefore, if the return value is 0, you must check
///    whether GetLastError returns <b>ERROR_SUCCESS</b> before determining that the function has failed. If
///    <b>GetLastError</b> returns <b>ERROR_SUCCESS</b>, then the function has succeeded and the data stored in the TLS
///    slot is 0. Otherwise, the function has failed. Functions that return indications of failure call SetLastErrorwhen
///    they fail. They generally do not call <b>SetLastError</b>when they succeed. The <b>TlsGetValue</b> function is an
///    exception to this general rule. The <b>TlsGetValue</b> function calls <b>SetLastError</b>to clear a thread's last
///    error when it succeeds. That allows checking for the error-free retrieval of zero values.
///    
@DllImport("KERNEL32")
void* TlsGetValue(uint dwTlsIndex);

///Stores a value in the calling thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a
///process has its own slot for each TLS index.
///Params:
///    dwTlsIndex = The TLS index that was allocated by the TlsAlloc function.
///    lpTlsValue = The value to be stored in the calling thread's TLS slot for the index.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL TlsSetValue(uint dwTlsIndex, void* lpTlsValue);

///Releases a thread local storage (TLS) index, making it available for reuse.
///Params:
///    dwTlsIndex = The TLS index that was allocated by the TlsAlloc function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL TlsFree(uint dwTlsIndex);

///Creates a new process and its primary thread. The new process runs in the security context of the calling process. If
///the calling process is impersonating another user, the new process uses the token for the calling process, not the
///impersonation token. To run the new process in the security context of the user represented by the impersonation
///token, use the CreateProcessAsUser or CreateProcessWithLogonW function.
///Params:
///    lpApplicationName = The name of the module to be executed. This module can be a Windows-based application. It can be some other type
///                        of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer. The
///                        string can specify the full path and file name of the module to execute or it can specify a partial name. In the
///                        case of a partial name, the function uses the current drive and current directory to complete the specification.
///                        The function will not use the search path. This parameter must include the file name extension; no default
///                        extension is assumed. The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name
///                        must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file
///                        name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin;
///                        otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name".
///                        This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the
///                        following order: <b>c:\program.exe</b> <b>c:\program files\sub.exe</b> <b>c:\program files\sub
///                        dir\program.exe</b> <b>c:\program files\sub dir\program name.exe</b> If the executable module is a 16-bit
///                        application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i>
///                        should specify the executable module as well as its arguments. To run a batch file, you must start the command
///                        interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c
///                        plus the name of the batch file.
///    lpCommandLine = The command line to be executed. The maximum length of this string is 32,767 characters, including the Unicode
///                    terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of
///                    <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters. The Unicode version of this function,
///                    <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to
///                    read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string,
///                    the function may cause an access violation. The <i>lpCommandLine</i> parameter can be NULL. In that case, the
///                    function uses the string pointed to by <i>lpApplicationName</i> as the command line. If both
///                    <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, the null-terminated string pointed to by
///                    <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by
///                    <i>lpCommandLine</i> specifies the command line. The new process can use GetCommandLine to retrieve the entire
///                    command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the
///                    command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first
///                    token in the command line. If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the
///                    command line specifies the module name. If you are using a long file name that contains a space, use quoted
///                    strings to indicate where the file name ends and the arguments begin (see the explanation for the
///                    <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore,
///                    if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a
///                    period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does
///                    not contain a directory path, the system searches for the executable file in the following sequence: <ol> <li>The
///                    directory from which the application loaded.</li> <li>The current directory for the parent process.</li> <li>The
///                    32-bit Windows system directory. Use the GetSystemDirectory function to get the path of this directory.</li> <li>
///                    The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is
///                    searched. The name of this directory is System.</li> <li>The Windows directory. Use the GetWindowsDirectory
///                    function to get the path of this directory.</li> <li>The directories that are listed in the PATH environment
///                    variable. Note that this function does not search the per-application path specified by the <b>App Paths</b>
///                    registry key. To include this per-application path in the search sequence, use the ShellExecute function.</li>
///                    </ol> The system adds a terminating null character to the command-line string to separate the file name from the
///                    arguments. This divides the original string into two strings for internal processing.
///    lpProcessAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle to the new process
///                          object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be
///                          inherited. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new
///                          process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a
///                          default security descriptor. The ACLs in the default security descriptor for a process come from the primary
///                          token of the creator.<b>Windows XP: </b>The ACLs in the default security descriptor for a process come from the
///                          primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server
///                          2003.
///    lpThreadAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle to the new thread object
///                         can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited. The
///                         <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If
///                         <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security
///                         descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:
///                         </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the
///                         creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.
///    bInheritHandles = If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the
///                      parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access
///                      rights as the original handles. For additional discussion of inheritable handles, see Remarks. <b>Terminal
///                      Services: </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must
///                      create the process in the same session as the caller. <b>Protected Process Light (PPL) processes: </b>The generic
///                      handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not
///                      allowed from a non-PPL process to a PPL process. See Process Security and Access Rights
///    dwCreationFlags = The flags that control the priority class and the creation of the process. For a list of values, see Process
///                      Creation Flags. This parameter also controls the new process's priority class, which is used to determine the
///                      scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the
///                      priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the
///                      priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In
///                      this case, the child process receives the default priority class of the calling process. If the dwCreationFlags
///                      parameter has a value of 0: - The process inherits both the error mode of the caller and the parent's console. -
///                      The environment block for the new process is assumed to contain ANSI characters (see *lpEnvironment* parameter
///                      for additional information). - A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).
///    lpEnvironment = A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses
///                    the environment of the calling process. An environment block consists of a null-terminated block of
///                    null-terminated strings. Each string is in the following form: <i>name</i>=<i>value</i>\0 Because the equal sign
///                    is used as a separator, it must not be used in the name of an environment variable. An environment block can
///                    contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains
///                    Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this
///                    parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must
///                    also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. The ANSI version of this
///                    function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767
///                    characters. Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one
///                    more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last
///                    string, two more to terminate the block.
///    lpCurrentDirectory = The full path to the current directory for the process. The string can also specify a UNC path. If this parameter
///                         is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This
///                         feature is provided primarily for shells that need to start an application and specify its initial drive and
///                         working directory.)
///    lpStartupInfo = A pointer to a STARTUPINFO or STARTUPINFOEX structure. To set extended attributes, use a STARTUPINFOEX structure
///                    and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter. Handles in STARTUPINFO or
///                    STARTUPINFOEX must be closed with CloseHandle when they are no longer needed. <div class="alert"><b>Important</b>
///                    The caller is responsible for ensuring that the standard handle fields in STARTUPINFO contain valid handle
///                    values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b>
///                    member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash.
///                    Use the Application Verifier runtime verification tool to detect invalid handles. </div> <div> </div>
///    lpProcessInformation = A pointer to a PROCESS_INFORMATION structure that receives identification information about the new process.
///                           Handles in PROCESS_INFORMATION must be closed with CloseHandle when they are no longer needed.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Note that the function returns before the process has finished
///    initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the
///    termination status of a process, call GetExitCodeProcess.
///    
@DllImport("KERNEL32")
BOOL CreateProcessA(const(PSTR) lpApplicationName, PSTR lpCommandLine, SECURITY_ATTRIBUTES* lpProcessAttributes, 
                    SECURITY_ATTRIBUTES* lpThreadAttributes, BOOL bInheritHandles, 
                    PROCESS_CREATION_FLAGS dwCreationFlags, void* lpEnvironment, const(PSTR) lpCurrentDirectory, 
                    STARTUPINFOA* lpStartupInfo, PROCESS_INFORMATION* lpProcessInformation);

///Creates a new process and its primary thread. The new process runs in the security context of the calling process. If
///the calling process is impersonating another user, the new process uses the token for the calling process, not the
///impersonation token. To run the new process in the security context of the user represented by the impersonation
///token, use the CreateProcessAsUser or CreateProcessWithLogonW function.
///Params:
///    lpApplicationName = The name of the module to be executed. This module can be a Windows-based application. It can be some other type
///                        of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer. The
///                        string can specify the full path and file name of the module to execute or it can specify a partial name. In the
///                        case of a partial name, the function uses the current drive and current directory to complete the specification.
///                        The function will not use the search path. This parameter must include the file name extension; no default
///                        extension is assumed. The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name
///                        must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file
///                        name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin;
///                        otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name".
///                        This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the
///                        following order: <b>c:\program.exe</b> <b>c:\program files\sub.exe</b> <b>c:\program files\sub
///                        dir\program.exe</b> <b>c:\program files\sub dir\program name.exe</b> If the executable module is a 16-bit
///                        application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i>
///                        should specify the executable module as well as its arguments. To run a batch file, you must start the command
///                        interpreter; set <i>lpApplicationName</i> to cmd.exe and set <i>lpCommandLine</i> to the following arguments: /c
///                        plus the name of the batch file.
///    lpCommandLine = The command line to be executed. The maximum length of this string is 32,767 characters, including the Unicode
///                    terminating null character. If <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of
///                    <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters. The Unicode version of this function,
///                    <b>CreateProcessW</b>, can modify the contents of this string. Therefore, this parameter cannot be a pointer to
///                    read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string,
///                    the function may cause an access violation. The <i>lpCommandLine</i> parameter can be NULL. In that case, the
///                    function uses the string pointed to by <i>lpApplicationName</i> as the command line. If both
///                    <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, the null-terminated string pointed to by
///                    <i>lpApplicationName</i> specifies the module to execute, and the null-terminated string pointed to by
///                    <i>lpCommandLine</i> specifies the command line. The new process can use GetCommandLine to retrieve the entire
///                    command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to parse the
///                    command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first
///                    token in the command line. If <i>lpApplicationName</i> is NULL, the first white space–delimited token of the
///                    command line specifies the module name. If you are using a long file name that contains a space, use quoted
///                    strings to indicate where the file name ends and the arguments begin (see the explanation for the
///                    <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore,
///                    if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a
///                    period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does
///                    not contain a directory path, the system searches for the executable file in the following sequence: <ol> <li>The
///                    directory from which the application loaded.</li> <li>The current directory for the parent process.</li> <li>The
///                    32-bit Windows system directory. Use the GetSystemDirectory function to get the path of this directory.</li> <li>
///                    The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is
///                    searched. The name of this directory is System.</li> <li>The Windows directory. Use the GetWindowsDirectory
///                    function to get the path of this directory.</li> <li>The directories that are listed in the PATH environment
///                    variable. Note that this function does not search the per-application path specified by the <b>App Paths</b>
///                    registry key. To include this per-application path in the search sequence, use the ShellExecute function.</li>
///                    </ol> The system adds a terminating null character to the command-line string to separate the file name from the
///                    arguments. This divides the original string into two strings for internal processing.
///    lpProcessAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle to the new process
///                          object can be inherited by child processes. If <i>lpProcessAttributes</i> is <b>NULL</b>, the handle cannot be
///                          inherited. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the new
///                          process. If <i>lpProcessAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a
///                          default security descriptor. The ACLs in the default security descriptor for a process come from the primary
///                          token of the creator.<b>Windows XP: </b>The ACLs in the default security descriptor for a process come from the
///                          primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server
///                          2003.
///    lpThreadAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle to the new thread object
///                         can be inherited by child processes. If <i>lpThreadAttributes</i> is NULL, the handle cannot be inherited. The
///                         <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the main thread. If
///                         <i>lpThreadAttributes</i> is NULL or <b>lpSecurityDescriptor</b> is NULL, the thread gets a default security
///                         descriptor. The ACLs in the default security descriptor for a thread come from the process token.<b>Windows XP:
///                         </b>The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the
///                         creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.
///    bInheritHandles = If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the
///                      parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access
///                      rights as the original handles. For additional discussion of inheritable handles, see Remarks. <b>Terminal
///                      Services: </b>You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must
///                      create the process in the same session as the caller. <b>Protected Process Light (PPL) processes: </b>The generic
///                      handle inheritance is blocked when a PPL process creates a non-PPL process since PROCESS_DUP_HANDLE is not
///                      allowed from a non-PPL process to a PPL process. See Process Security and Access Rights
///    dwCreationFlags = The flags that control the priority class and the creation of the process. For a list of values, see Process
///                      Creation Flags. This parameter also controls the new process's priority class, which is used to determine the
///                      scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the
///                      priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the
///                      priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In
///                      this case, the child process receives the default priority class of the calling process. If the dwCreationFlags
///                      parameter has a value of 0: - The process inherits both the error mode of the caller and the parent's console. -
///                      The environment block for the new process is assumed to contain ANSI characters (see *lpEnvironment* parameter
///                      for additional information). - A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).
///    lpEnvironment = A pointer to the environment block for the new process. If this parameter is <b>NULL</b>, the new process uses
///                    the environment of the calling process. An environment block consists of a null-terminated block of
///                    null-terminated strings. Each string is in the following form: <i>name</i>=<i>value</i>\0 Because the equal sign
///                    is used as a separator, it must not be used in the name of an environment variable. An environment block can
///                    contain either Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains
///                    Unicode characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this
///                    parameter is <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must
///                    also ensure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. The ANSI version of this
///                    function, <b>CreateProcessA</b> fails if the total size of the environment block for the process exceeds 32,767
///                    characters. Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one
///                    more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last
///                    string, two more to terminate the block.
///    lpCurrentDirectory = The full path to the current directory for the process. The string can also specify a UNC path. If this parameter
///                         is <b>NULL</b>, the new process will have the same current drive and directory as the calling process. (This
///                         feature is provided primarily for shells that need to start an application and specify its initial drive and
///                         working directory.)
///    lpStartupInfo = A pointer to a STARTUPINFO or STARTUPINFOEX structure. To set extended attributes, use a STARTUPINFOEX structure
///                    and specify EXTENDED_STARTUPINFO_PRESENT in the <i>dwCreationFlags</i> parameter. Handles in STARTUPINFO or
///                    STARTUPINFOEX must be closed with CloseHandle when they are no longer needed. <div class="alert"><b>Important</b>
///                    The caller is responsible for ensuring that the standard handle fields in STARTUPINFO contain valid handle
///                    values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b>
///                    member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash.
///                    Use the Application Verifier runtime verification tool to detect invalid handles. </div> <div> </div>
///    lpProcessInformation = A pointer to a PROCESS_INFORMATION structure that receives identification information about the new process.
///                           Handles in PROCESS_INFORMATION must be closed with CloseHandle when they are no longer needed.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Note that the function returns before the process has finished
///    initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the
///    termination status of a process, call GetExitCodeProcess.
///    
@DllImport("KERNEL32")
BOOL CreateProcessW(const(PWSTR) lpApplicationName, PWSTR lpCommandLine, SECURITY_ATTRIBUTES* lpProcessAttributes, 
                    SECURITY_ATTRIBUTES* lpThreadAttributes, BOOL bInheritHandles, 
                    PROCESS_CREATION_FLAGS dwCreationFlags, void* lpEnvironment, const(PWSTR) lpCurrentDirectory, 
                    STARTUPINFOW* lpStartupInfo, PROCESS_INFORMATION* lpProcessInformation);

///Sets shutdown parameters for the currently calling process. This function sets a shutdown order for a process
///relative to the other processes in the system.
///Params:
///    dwLevel = The shutdown priority for a process relative to other processes in the system. The system shuts down processes
///              from high <i>dwLevel</i> values to low. The highest and lowest shutdown priorities are reserved for system
///              components. This parameter must be in the following range of values. <table> <tr> <th>Value</th> <th>Meaning</th>
///              </tr> <tr> <td width="40%"> <dl> <dt>000-0FF</dt> </dl> </td> <td width="60%"> System reserved last shutdown
///              range. </td> </tr> <tr> <td width="40%"> <dl> <dt>100-1FF</dt> </dl> </td> <td width="60%"> Application reserved
///              last shutdown range. </td> </tr> <tr> <td width="40%"> <dl> <dt>200-2FF</dt> </dl> </td> <td width="60%">
///              Application reserved "in between" shutdown range. </td> </tr> <tr> <td width="40%"> <dl> <dt>300-3FF</dt> </dl>
///              </td> <td width="60%"> Application reserved first shutdown range. </td> </tr> <tr> <td width="40%"> <dl>
///              <dt>400-4FF</dt> </dl> </td> <td width="60%"> System reserved first shutdown range. </td> </tr> </table> All
///              processes start at shutdown level 0x280.
///    dwFlags = This parameter can be the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"><a id="SHUTDOWN_NORETRY"></a><a id="shutdown_noretry"></a><dl> <dt><b>SHUTDOWN_NORETRY</b></dt>
///              <dt>0x00000001</dt> </dl> </td> <td width="60%"> The system terminates the process without displaying a retry
///              dialog box for the user. </td> </tr> </table>
///Returns:
///    If the function is succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetProcessShutdownParameters(uint dwLevel, uint dwFlags);

///Retrieves the major and minor version numbers of the system on which the specified process expects to run.
///Params:
///    ProcessId = The process identifier of the process of interest. A value of zero specifies the calling process.
///Returns:
///    If the function succeeds, the return value is the version of the system on which the process expects to run. The
///    high word of the return value contains the major version number. The low word of the return value contains the
///    minor version number. If the function fails, the return value is zero. To get extended error information, call
///    GetLastError. The function fails if <i>ProcessId</i> is an invalid value.
///    
@DllImport("KERNEL32")
uint GetProcessVersion(uint ProcessId);

///Retrieves the contents of the STARTUPINFO structure that was specified when the calling process was created.
///Params:
///    lpStartupInfo = A pointer to a STARTUPINFO structure that receives the startup information.
///Returns:
///    This function does not return a value. If an error occurs, the ANSI version of this function
///    (<b>GetStartupInfoA</b>) can raise an exception. The Unicode version (<b>GetStartupInfoW</b>) does not fail.
///    
@DllImport("KERNEL32")
void GetStartupInfoW(STARTUPINFOW* lpStartupInfo);

///Creates a new process and its primary thread. The new process runs in the security context of the user represented by
///the specified token. Typically, the process that calls the <b>CreateProcessAsUser</b> function must have the
///<b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token
///is not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the
///CreateProcessWithLogonW function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the
///specified user account must be allowed to log on interactively. Generally, it is best to use
///<b>CreateProcessWithLogonW</b> to create a process with alternate credentials.
///Params:
///    hToken = A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>,
///             <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see Access Rights
///             for Access-Token Objects. The user represented by the token must have read and execute access to the application
///             specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter. To get a primary token that
///             represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx
///             function to convert an impersonation token into a primary token. This allows a server application that is
///             impersonating a client to create a process that has the security context of the client. If <i>hToken</i> is a
///             restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not
///             required. If the necessary privileges are not already enabled, <b>CreateProcessAsUser</b> enables them for the
///             duration of the call. For more information, see Running with Special Privileges. <b>Terminal Services: </b>The
///             process is run in the session specified in the token. By default, this is the same session that called LogonUser.
///             To change the session, use the SetTokenInformation function.
///    lpApplicationName = The name of the module to be executed. This module can be a Windows-based application. It can be some other type
///                        of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer. The
///                        string can specify the full path and file name of the module to execute or it can specify a partial name. In the
///                        case of a partial name, the function uses the current drive and current directory to complete the specification.
///                        The function will not use the search path. This parameter must include the file name extension; no default
///                        extension is assumed. The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name
///                        must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file
///                        name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin;
///                        otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name".
///                        This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the
///                        following order: <b>c:\program.exe</b> <b>c:\program files\sub.exe</b> <b>c:\program files\sub
///                        dir\program.exe</b> <b>c:\program files\sub dir\program name.exe</b> If the executable module is a 16-bit
///                        application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i>
///                        should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications
///                        created by <b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in
///                        CreateProcess).
///    lpCommandLine = The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i>
///                    is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters. The
///                    Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore,
///                    this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If
///                    this parameter is a constant string, the function may cause an access violation. The <i>lpCommandLine</i>
///                    parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i>
///                    as the command line. If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>,
///                    *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line.
///                    The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can
///                    use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module
///                    name, C programmers generally repeat the module name as the first token in the command line. If
///                    <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies
///                    the module name. If you are using a long file name that contains a space, use quoted strings to indicate where
///                    the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If
///                    the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com,
///                    this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if
///                    the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the
///                    system searches for the executable file in the following sequence: <ol> <li>The directory from which the
///                    application loaded.</li> <li>The current directory for the parent process.</li> <li>The 32-bit Windows system
///                    directory. Use the GetSystemDirectory function to get the path of this directory. </li> <li>The 16-bit Windows
///                    system directory. There is no function that obtains the path of this directory, but it is searched. </li> <li>The
///                    Windows directory. Use the GetWindowsDirectory function to get the path of this directory.</li> <li>The
///                    directories that are listed in the PATH environment variable. Note that this function does not search the
///                    per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the
///                    search sequence, use the ShellExecute function.</li> </ol> The system adds a null character to the command line
///                    string to separate the file name from the arguments. This divides the original string into two strings for
///                    internal processing.
///    lpProcessAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new process object and
///                          determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i>
///                          is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and
///                          the handle cannot be inherited. The default security descriptor is that of the user referenced in the
///                          <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process
///                          may not be opened again after it is run. The process handle is valid and will continue to have full access
///                          rights.
///    lpThreadAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread object and
///                         determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is
///                         <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the
///                         handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i>
///                         parameter. This security descriptor may not allow access for the caller.
///    bInheritHandles = If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process.
///                      If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value
///                      and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.
///                      <b>Terminal Services: </b>You cannot inherit handles across sessions. Additionally, if this parameter is
///                      <b>TRUE</b>, you must create the process in the same session as the caller. <b>Protected Process Light (PPL)
///                      processes: </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since
///                      PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See Process Security and Access Rights
///    dwCreationFlags = The flags that control the priority class and the creation of the process. For a list of values, see Process
///                      Creation Flags. This parameter also controls the new process's priority class, which is used to determine the
///                      scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the
///                      priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the
///                      priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In
///                      this case, the child process receives the default priority class of the calling process. If the dwCreationFlags
///                      parameter has a value of 0: - The process inherits both the error mode of the caller and the parent's console. -
///                      The environment block for the new process is assumed to contain ANSI characters (see *lpEnvironment* parameter
///                      for additional information). - A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).
///    lpEnvironment = A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the
///                    environment of the calling process. An environment block consists of a null-terminated block of null-terminated
///                    strings. Each string is in the following form: <i>name</i>=<i>value</i>\0 Because the equal sign is used as a
///                    separator, it must not be used in the name of an environment variable. An environment block can contain either
///                    Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode
///                    characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is
///                    <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure
///                    that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. The ANSI version of this function,
///                    <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767
///                    characters. Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one
///                    more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last
///                    string, two more to terminate the block. <b>Windows Server 2003 and Windows XP: </b>If the size of the combined
///                    user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no
///                    longer runs with the environment block passed to the function by the parent process. Instead, the child process
///                    runs with the environment block returned by the CreateEnvironmentBlock function. To retrieve a copy of the
///                    environment block for a given user, use the CreateEnvironmentBlock function.
///    lpCurrentDirectory = The full path to the current directory for the process. The string can also specify a UNC path. If this parameter
///                         is NULL, the new process will have the same current drive and directory as the calling process. (This feature is
///                         provided primarily for shells that need to start an application and specify its initial drive and working
///                         directory.)
///    lpStartupInfo = A pointer to a STARTUPINFO or STARTUPINFOEX structure. The user must have full access to both the specified
///                    window station and desktop. If you want the process to be interactive, specify winsta0\default. If the
///                    <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process.
///                    If this member is an empty string, "", the new process connects to a window station using the rules described in
///                    Process Connection to a Window Station. To set extended attributes, use a STARTUPINFOEX structure and specify
///                    <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter. Handles in STARTUPINFO or
///                    STARTUPINFOEX must be closed with CloseHandle when they are no longer needed. <div class="alert"><b>Important</b>
///                    The caller is responsible for ensuring that the standard handle fields in STARTUPINFO contain valid handle
///                    values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b>
///                    member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash.
///                    Use the Application Verifier runtime verification tool to detect invalid handles. </div> <div> </div>
///    lpProcessInformation = A pointer to a PROCESS_INFORMATION structure that receives identification information about the new process.
///                           Handles in PROCESS_INFORMATION must be closed with CloseHandle when they are no longer needed.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Note that the function returns before the process has finished
///    initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the
///    termination status of a process, call GetExitCodeProcess.
///    
@DllImport("ADVAPI32")
BOOL CreateProcessAsUserW(HANDLE hToken, const(PWSTR) lpApplicationName, PWSTR lpCommandLine, 
                          SECURITY_ATTRIBUTES* lpProcessAttributes, SECURITY_ATTRIBUTES* lpThreadAttributes, 
                          BOOL bInheritHandles, uint dwCreationFlags, void* lpEnvironment, 
                          const(PWSTR) lpCurrentDirectory, STARTUPINFOW* lpStartupInfo, 
                          PROCESS_INFORMATION* lpProcessInformation);

///Sets the priority class for the specified process. This value together with the priority value of each thread of the
///process determines each thread's base priority level.
///Params:
///    hProcess = A handle to the process. The handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more
///               information, see Process Security and Access Rights.
///    dwPriorityClass = The priority class for the process. This parameter can be one of the following values. <table> <tr>
///                      <th>Priority</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ABOVE_NORMAL_PRIORITY_CLASS"></a><a
///                      id="above_normal_priority_class"></a><dl> <dt><b>ABOVE_NORMAL_PRIORITY_CLASS</b></dt> <dt>0x00008000</dt> </dl>
///                      </td> <td width="60%"> Process that has priority above <b>NORMAL_PRIORITY_CLASS</b> but below
///                      <b>HIGH_PRIORITY_CLASS</b>. </td> </tr> <tr> <td width="40%"><a id="BELOW_NORMAL_PRIORITY_CLASS"></a><a
///                      id="below_normal_priority_class"></a><dl> <dt><b>BELOW_NORMAL_PRIORITY_CLASS</b></dt> <dt>0x00004000</dt> </dl>
///                      </td> <td width="60%"> Process that has priority above <b>IDLE_PRIORITY_CLASS</b> but below
///                      <b>NORMAL_PRIORITY_CLASS</b>. </td> </tr> <tr> <td width="40%"><a id="HIGH_PRIORITY_CLASS"></a><a
///                      id="high_priority_class"></a><dl> <dt><b>HIGH_PRIORITY_CLASS</b></dt> <dt>0x00000080</dt> </dl> </td> <td
///                      width="60%"> Process that performs time-critical tasks that must be executed immediately. The threads of the
///                      process preempt the threads of normal or idle priority class processes. An example is the Task List, which must
///                      respond quickly when called by the user, regardless of the load on the operating system. Use extreme care when
///                      using the high-priority class, because a high-priority class application can use nearly all available CPU time.
///                      </td> </tr> <tr> <td width="40%"><a id="IDLE_PRIORITY_CLASS"></a><a id="idle_priority_class"></a><dl>
///                      <dt><b>IDLE_PRIORITY_CLASS</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> Process whose threads run
///                      only when the system is idle. The threads of the process are preempted by the threads of any process running in a
///                      higher priority class. An example is a screen saver. The idle-priority class is inherited by child processes.
///                      </td> </tr> <tr> <td width="40%"><a id="NORMAL_PRIORITY_CLASS"></a><a id="normal_priority_class"></a><dl>
///                      <dt><b>NORMAL_PRIORITY_CLASS</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Process with no special
///                      scheduling needs. </td> </tr> <tr> <td width="40%"><a id="PROCESS_MODE_BACKGROUND_BEGIN"></a><a
///                      id="process_mode_background_begin"></a><dl> <dt><b>PROCESS_MODE_BACKGROUND_BEGIN</b></dt> <dt>0x00100000</dt>
///                      </dl> </td> <td width="60%"> Begin background processing mode. The system lowers the resource scheduling
///                      priorities of the process (and its threads) so that it can perform background work without significantly
///                      affecting activity in the foreground. This value can be specified only if <i>hProcess</i> is a handle to the
///                      current process. The function fails if the process is already in background processing mode. <b>Windows Server
///                      2003 and Windows XP: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
///                      id="PROCESS_MODE_BACKGROUND_END"></a><a id="process_mode_background_end"></a><dl>
///                      <dt><b>PROCESS_MODE_BACKGROUND_END</b></dt> <dt>0x00200000</dt> </dl> </td> <td width="60%"> End background
///                      processing mode. The system restores the resource scheduling priorities of the process (and its threads) as they
///                      were before the process entered background processing mode. This value can be specified only if <i>hProcess</i>
///                      is a handle to the current process. The function fails if the process is not in background processing mode.
///                      <b>Windows Server 2003 and Windows XP: </b>This value is not supported. </td> </tr> <tr> <td width="40%"><a
///                      id="REALTIME_PRIORITY_CLASS"></a><a id="realtime_priority_class"></a><dl> <dt><b>REALTIME_PRIORITY_CLASS</b></dt>
///                      <dt>0x00000100</dt> </dl> </td> <td width="60%"> Process that has the highest possible priority. The threads of
///                      the process preempt the threads of all other processes, including operating system processes performing important
///                      tasks. For example, a real-time process that executes for more than a very brief interval can cause disk caches
///                      not to flush or cause the mouse to be unresponsive. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetPriorityClass(HANDLE hProcess, uint dwPriorityClass);

///Retrieves the priority class for the specified process. This value, together with the priority value of each thread
///of the process, determines each thread's base priority level.
///Params:
///    hProcess = A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or
///               <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see Process Security and Access
///               Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b>
///               access right.
///Returns:
///    If the function succeeds, the return value is the priority class of the specified process. If the function fails,
///    the return value is zero. To get extended error information, call GetLastError. The process's priority class is
///    one of the following values. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ABOVE_NORMAL_PRIORITY_CLASS</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%">
///    Process that has priority above <b>NORMAL_PRIORITY_CLASS</b> but below <b>HIGH_PRIORITY_CLASS</b>. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>BELOW_NORMAL_PRIORITY_CLASS</b></dt> <dt>0x00004000</dt> </dl> </td> <td
///    width="60%"> Process that has priority above <b>IDLE_PRIORITY_CLASS</b> but below <b>NORMAL_PRIORITY_CLASS</b>.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>HIGH_PRIORITY_CLASS</b></dt> <dt>0x00000080</dt> </dl> </td> <td
///    width="60%"> Process that performs time-critical tasks that must be executed immediately for it to run correctly.
///    The threads of a high-priority class process preempt the threads of normal or idle priority class processes. An
///    example is the Task List, which must respond quickly when called by the user, regardless of the load on the
///    operating system. Use extreme care when using the high-priority class, because a high-priority class CPU-bound
///    application can use nearly all available cycles. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>IDLE_PRIORITY_CLASS</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> Process whose threads run
///    only when the system is idle and are preempted by the threads of any process running in a higher priority class.
///    An example is a screen saver. The idle priority class is inherited by child processes. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>NORMAL_PRIORITY_CLASS</b></dt> <dt>0x00000020</dt> </dl> </td> <td width="60%"> Process
///    with no special scheduling needs. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>REALTIME_PRIORITY_CLASS</b></dt>
///    <dt>0x00000100</dt> </dl> </td> <td width="60%"> Process that has the highest possible priority. The threads of a
///    real-time priority class process preempt the threads of all other processes, including operating system processes
///    performing important tasks. For example, a real-time process that executes for more than a very brief interval
///    can cause disk caches not to flush or cause the mouse to be unresponsive. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetPriorityClass(HANDLE hProcess);

///Sets the minimum size of the stack associated with the calling thread or fiber that will be available during any
///stack overflow exceptions. This is useful for handling stack overflow exceptions; the application can safely use the
///specified number of bytes during exception handling.
///Params:
///    StackSizeInBytes = The size of the stack, in bytes. On return, this value is set to the size of the previous stack, in bytes. If
///                       this parameter is 0 (zero), the function succeeds and the parameter contains the size of the current stack. If
///                       the specified size is less than the current size, the function succeeds but ignores this request. Therefore, you
///                       cannot use this function to reduce the size of the stack. This value cannot be larger than the reserved stack
///                       size.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetThreadStackGuarantee(uint* StackSizeInBytes);

///Retrieves the process identifier of the specified process.
///Params:
///    Process = A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION
///              access right. For more information, see Process Security and Access Rights. <b>Windows Server 2003 and Windows
///              XP: </b>The handle must have the PROCESS_QUERY_INFORMATION access right.
///Returns:
///    If the function succeeds, the return value is the process identifier. If the function fails, the return value is
///    zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetProcessId(HANDLE Process);

///Retrieves the thread identifier of the specified thread.
///Params:
///    Thread = A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION
///             access right. For more information about access rights, see Thread Security and Access Rights. <b>Windows Server
///             2003: </b>The handle must have the THREAD_QUERY_INFORMATION access right.
///Returns:
///    If the function fails, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetThreadId(HANDLE Thread);

///Flushes the write queue of each processor that is running a thread of the current process.
@DllImport("KERNEL32")
void FlushProcessWriteBuffers();

///Retrieves the process identifier of the process associated with the specified thread.
///Params:
///    Thread = A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION
///             access right. For more information, see Thread Security and Access Rights. <b>Windows Server 2003: </b>The handle
///             must have the THREAD_QUERY_INFORMATION access right.
///Returns:
///    If the function succeeds, the return value is the process identifier of the process associated with the specified
///    thread. If the function fails, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetProcessIdOfThread(HANDLE Thread);

///Initializes the specified list of attributes for process and thread creation.
///Params:
///    lpAttributeList = The attribute list. This parameter can be NULL to determine the buffer size required to support the specified
///                      number of attributes.
///    dwAttributeCount = The count of attributes to be added to the list.
///    dwFlags = This parameter is reserved and must be zero.
///    lpSize = If <i>lpAttributeList</i> is not NULL, this parameter specifies the size in bytes of the <i>lpAttributeList</i>
///             buffer on input. On output, this parameter receives the size in bytes of the initialized attribute list. If
///             <i>lpAttributeList</i> is NULL, this parameter receives the required buffer size in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL InitializeProcThreadAttributeList(ptrdiff_t lpAttributeList, uint dwAttributeCount, uint dwFlags, 
                                       size_t* lpSize);

///Deletes the specified list of attributes for process and thread creation.
///Params:
///    lpAttributeList = The attribute list. This list is created by the InitializeProcThreadAttributeList function.
@DllImport("KERNEL32")
void DeleteProcThreadAttributeList(ptrdiff_t lpAttributeList);

///Updates the specified attribute in a list of attributes for process and thread creation.
///Params:
///    lpAttributeList = A pointer to an attribute list created by the InitializeProcThreadAttributeList function.
///    dwFlags = This parameter is reserved and must be zero.
///    Attribute = The attribute key to update in the attribute list. This parameter can be one of the following values. <table>
///                <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY"></a><a id="proc_thread_attribute_group_affinity"></a><dl>
///                <dt><b>PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY</b></dt> </dl> </td> <td width="60%"> The <i>lpValue</i> parameter is
///                a pointer to a GROUP_AFFINITY structure that specifies the processor group affinity for the new thread.
///                <b>Windows Server 2008 and Windows Vista: </b>This value is not supported until Windows 7 and Windows Server 2008
///                R2. </td> </tr> <tr> <td width="40%"><a id="PROC_THREAD_ATTRIBUTE_HANDLE_LIST"></a><a
///                id="proc_thread_attribute_handle_list"></a><dl> <dt><b>PROC_THREAD_ATTRIBUTE_HANDLE_LIST</b></dt> </dl> </td> <td
///                width="60%"> The <i>lpValue</i> parameter is a pointer to a list of handles to be inherited by the child process.
///                These handles must be created as inheritable handles and must not include pseudo handles such as those returned
///                by the GetCurrentProcess or GetCurrentThread function. <div class="alert"><b>Note</b> if you use this attribute,
///                pass in a value of TRUE for the <i>bInheritHandles</i> parameter of the CreateProcess function.</div> <div>
///                </div> </td> </tr> <tr> <td width="40%"><a id="PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR"></a><a
///                id="proc_thread_attribute_ideal_processor"></a><dl> <dt><b>PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR</b></dt> </dl>
///                </td> <td width="60%"> The <i>lpValue</i> parameter is a pointer to a PROCESSOR_NUMBER structure that specifies
///                the ideal processor for the new thread. <b>Windows Server 2008 and Windows Vista: </b>This value is not supported
///                until Windows 7 and Windows Server 2008 R2. </td> </tr> <tr> <td width="40%"><a
///                id="PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY"></a><a id="proc_thread_attribute_mitigation_policy"></a><dl>
///                <dt><b>PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY</b></dt> </dl> </td> <td width="60%"> The <i>lpValue</i> parameter
///                is a pointer to a <b>DWORD</b> or <b>DWORD64</b> that specifies the exploit mitigation policy for the child
///                process. Starting in Windows 10, version 1703, this parameter can also be a pointer to a two-element
///                <b>DWORD64</b> array. The specified policy overrides the policies set for the application and the system and
///                cannot be changed after the child process starts running. <b>Windows Server 2008 and Windows Vista: </b>This
///                value is not supported until Windows 7 and Windows Server 2008 R2. The <b>DWORD</b> or <b>DWORD64</b> pointed to
///                by <i>lpValue</i> can be one or more of the values listed in the remarks. </td> </tr> <tr> <td width="40%"><a
///                id="PROC_THREAD_ATTRIBUTE_PARENT_PROCESS"></a><a id="proc_thread_attribute_parent_process"></a><dl>
///                <dt><b>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</b></dt> </dl> </td> <td width="60%"> The <i>lpValue</i> parameter is
///                a pointer to a handle to a process to use instead of the calling process as the parent for the process being
///                created. The process to use must have the <b>PROCESS_CREATE_PROCESS</b> access right. Attributes inherited from
///                the specified process include handles, the device map, processor affinity, priority, quotas, the process token,
///                and job object. (Note that some attributes such as the debug port will come from the creating process, not the
///                process specified by this handle.) </td> </tr> <tr> <td width="40%"><a
///                id="PROC_THREAD_ATTRIBUTE_PREFERRED_NODE"></a><a id="proc_thread_attribute_preferred_node"></a><dl>
///                <dt><b>PROC_THREAD_ATTRIBUTE_PREFERRED_NODE</b></dt> </dl> </td> <td width="60%"> The <i>lpValue</i> parameter is
///                a pointer to the node number of the preferred NUMA node for the new process. <b>Windows Server 2008 and Windows
///                Vista: </b>This value is not supported until Windows 7 and Windows Server 2008 R2. </td> </tr> <tr> <td
///                width="40%"><a id="PROC_THREAD_ATTRIBUTE_UMS_THREAD"></a><a id="proc_thread_attribute_ums_thread"></a><dl>
///                <dt><b>PROC_THREAD_ATTRIBUTE_UMS_THREAD</b></dt> </dl> </td> <td width="60%"> The <i>lpValue</i> parameter is a
///                pointer to a UMS_CREATE_THREAD_ATTRIBUTES structure that specifies a user-mode scheduling (UMS) thread context
///                and a UMS completion list to associate with the thread. After the UMS thread is created, the system queues it to
///                the specified completion list. The UMS thread runs only when an application's UMS scheduler retrieves the UMS
///                thread from the completion list and selects it to run. For more information, see User-Mode Scheduling. <b>Windows
///                Server 2008 and Windows Vista: </b>This value is not supported until Windows 7 and Windows Server 2008 R2. </td>
///                </tr> <tr> <td width="40%"><a id="PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES"></a><a
///                id="proc_thread_attribute_security_capabilities"></a><dl>
///                <dt><b>PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES</b></dt> </dl> </td> <td width="60%"> The <i>lpValue</i>
///                parameter is a pointer to a SECURITY_CAPABILITIES structure that defines the security capabilities of an app
///                container. If this attribute is set the new process will be created as an AppContainer process. <b>Windows 7,
///                Windows Server 2008 R2, Windows Server 2008 and Windows Vista: </b>This value is not supported until Windows 8
///                and Windows Server 2012. </td> </tr> <tr> <td width="40%"><a id="PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL"></a><a
///                id="proc_thread_attribute_protection_level"></a><dl> <dt><b>PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL</b></dt> </dl>
///                </td> <td width="60%"> The <i>lpValue</i> parameter is a pointer to a <b>DWORD</b> value of
///                <b>PROTECTION_LEVEL_SAME</b>. This specifies the protection level of the child process to be the same as the
///                protection level of its parent process. </td> </tr> <tr> <td width="40%"><a
///                id="PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY"></a><a id="proc_thread_attribute_child_process_policy"></a><dl>
///                <dt><b>PROC_THREAD_ATTRIBUTE_CHILD_PROCESS_POLICY</b></dt> </dl> </td> <td width="60%"> The <i>lpValue</i>
///                parameter is a pointer to a <b>DWORD</b> or <b>DWORD64</b> value that specifies the child process policy. The
///                policy specifies whether to allow a child process to be created. For information on the possible values for the
///                <b>DWORD</b> or <b>DWORD64</b> to which <i>lpValue</i> points, see Remarks. </td> </tr> <tr> <td width="40%"><a
///                id="PROC_THREAD_ATTRIBUTE_DESKTOP_APP_POLICY"></a><a id="proc_thread_attribute_desktop_app_policy"></a><dl>
///                <dt><b>PROC_THREAD_ATTRIBUTE_DESKTOP_APP_POLICY</b></dt> </dl> </td> <td width="60%"> This attribute is relevant
///                only to win32 applications that have been converted to UWP packages by using the Desktop Bridge. The
///                <i>lpValue</i> parameter is a pointer to a <b>DWORD</b> value that specifies the desktop app policy. The policy
///                specifies whether descendant processes should continue to run in the desktop environment. For information about
///                the possible values for the <b>DWORD</b> to which <i>lpValue</i> points, see Remarks. </td> </tr> </table>
///    lpValue = A pointer to the attribute value. This value should persist until the attribute is destroyed using the
///              DeleteProcThreadAttributeList function.
///    cbSize = The size of the attribute value specified by the <i>lpValue</i> parameter.
///    lpPreviousValue = This parameter is reserved and must be NULL.
///    lpReturnSize = This parameter is reserved and must be NULL.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL UpdateProcThreadAttribute(ptrdiff_t lpAttributeList, uint dwFlags, size_t Attribute, void* lpValue, 
                               size_t cbSize, void* lpPreviousValue, size_t* lpReturnSize);

///Sets the affinity update mode of the specified process.
///Params:
///    hProcess = A handle to the process. This handle must be returned by the GetCurrentProcess function.
///    dwFlags = The affinity update mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Disables dynamic update
///              of the process affinity by the system. </td> </tr> <tr> <td width="40%"><a
///              id="PROCESS_AFFINITY_ENABLE_AUTO_UPDATE"></a><a id="process_affinity_enable_auto_update"></a><dl>
///              <dt><b>PROCESS_AFFINITY_ENABLE_AUTO_UPDATE</b></dt> <dt>0x00000001UL</dt> </dl> </td> <td width="60%"> Enables
///              dynamic update of the process affinity by the system. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, uint dwFlags);

///Retrieves the affinity update mode of the specified process.
///Params:
///    hProcess = A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION
///               access right. For more information, see Process Security and Access Rights.
///    lpdwFlags = The affinity update mode. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Dynamic update of the
///                process affinity by the system is disabled. </td> </tr> <tr> <td width="40%"><a
///                id="PROCESS_AFFINITY_ENABLE_AUTO_UPDATE"></a><a id="process_affinity_enable_auto_update"></a><dl>
///                <dt><b>PROCESS_AFFINITY_ENABLE_AUTO_UPDATE</b></dt> <dt>0x00000001UL</dt> </dl> </td> <td width="60%"> Dynamic
///                update of the process affinity by the system is enabled. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, uint* lpdwFlags);

///Creates a thread that runs in the virtual address space of another process and optionally specifies extended
///attributes such as processor group affinity.
///Params:
///    hProcess = A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD,
///               PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights. In Windows
///               10, version 1607, your code must obtain these access rights for the new handle. However, starting in Windows 10,
///               version 1703, if the new handle is entitled to these access rights, the system obtains them for you. For more
///               information, see Process Security and Access Rights.
///    lpThreadAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and
///                         determines whether child processes can inherit the returned handle. If <i>lpThreadAttributes</i> is NULL, the
///                         thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in
///                         the default security descriptor for a thread come from the primary token of the creator.
///    dwStackSize = The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0
///                  (zero), the new thread uses the default size for the executable. For more information, see Thread Stack Size.
///    lpStartAddress = A pointer to the application-defined function of type <b>LPTHREAD_START_ROUTINE</b> to be executed by the thread
///                     and represents the starting address of the thread in the remote process. The function must exist in the remote
///                     process. For more information, see ThreadProc.
///    lpParameter = A pointer to a variable to be passed to the thread function pointed to by <i>lpStartAddress</i>. This parameter
///                  can be NULL.
///    dwCreationFlags = The flags that control the creation of the thread. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                      width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The thread runs immediately after creation. </td> </tr>
///                      <tr> <td width="40%"><a id="CREATE_SUSPENDED"></a><a id="create_suspended"></a><dl>
///                      <dt><b>CREATE_SUSPENDED</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> The thread is created in a
///                      suspended state and does not run until the ResumeThread function is called. </td> </tr> <tr> <td width="40%"><a
///                      id="STACK_SIZE_PARAM_IS_A_RESERVATION"></a><a id="stack_size_param_is_a_reservation"></a><dl>
///                      <dt><b>STACK_SIZE_PARAM_IS_A_RESERVATION</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> The
///                      <i>dwStackSize</i> parameter specifies the initial reserve size of the stack. If this flag is not specified,
///                      <i>dwStackSize</i> specifies the commit size. </td> </tr> </table>
///    lpAttributeList = An attribute list that contains additional parameters for the new thread. This list is created by the
///                      InitializeProcThreadAttributeList function.
///    lpThreadId = A pointer to a variable that receives the thread identifier. If this parameter is NULL, the thread identifier is
///                 not returned.
///Returns:
///    If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value
///    is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateRemoteThreadEx(HANDLE hProcess, SECURITY_ATTRIBUTES* lpThreadAttributes, size_t dwStackSize, 
                            LPTHREAD_START_ROUTINE lpStartAddress, void* lpParameter, uint dwCreationFlags, 
                            ptrdiff_t lpAttributeList, uint* lpThreadId);

///Retrieves the boundaries of the stack that was allocated by the system for the current thread.
///Params:
///    LowLimit = A pointer variable that receives the lower boundary of the current thread stack.
///    HighLimit = A pointer variable that receives the upper boundary of the current thread stack.
@DllImport("KERNEL32")
void GetCurrentThreadStackLimits(uint* LowLimit, uint* HighLimit);

///Retrieves mitigation policy settings for the calling process.
///Params:
///    hProcess = A handle to the process. This handle must have the PROCESS_QUERY_INFORMATION access right. For more information,
///               see Process Security and Access Rights.
///    MitigationPolicy = The mitigation policy to retrieve. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                       <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ProcessDEPPolicy"></a><a id="processdeppolicy"></a><a
///                       id="PROCESSDEPPOLICY"></a><dl> <dt><b>ProcessDEPPolicy</b></dt> </dl> </td> <td width="60%"> The data execution
///                       prevention (DEP) policy of the process. The <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_DEP_POLICY
///                       structure that specifies the DEP policy flags. </td> </tr> <tr> <td width="40%"><a id="ProcessASLRPolicy"></a><a
///                       id="processaslrpolicy"></a><a id="PROCESSASLRPOLICY"></a><dl> <dt><b>ProcessASLRPolicy</b></dt> </dl> </td> <td
///                       width="60%"> The Address Space Layout Randomization (ASLR) policy of the process. The <i>lpBuffer</i> parameter
///                       points to a PROCESS_MITIGATION_ASLR_POLICY structure that specifies the ASLR policy flags. </td> </tr> <tr> <td
///                       width="40%"><a id="ProcessDynamicCodePolicy"></a><a id="processdynamiccodepolicy"></a><a
///                       id="PROCESSDYNAMICCODEPOLICY"></a><dl> <dt><b>ProcessDynamicCodePolicy</b></dt> </dl> </td> <td width="60%"> The
///                       dynamic code policy of the process. When turned on, the process cannot generate dynamic code or modify existing
///                       executable code. The <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_DYNAMIC_CODE_POLICY structure that
///                       specifies the dynamic code policy flags. </td> </tr> <tr> <td width="40%"><a
///                       id="ProcessStrictHandleCheckPolicy"></a><a id="processstricthandlecheckpolicy"></a><a
///                       id="PROCESSSTRICTHANDLECHECKPOLICY"></a><dl> <dt><b>ProcessStrictHandleCheckPolicy</b></dt> </dl> </td> <td
///                       width="60%"> The process will receive a fatal error if it manipulates a handle that is not valid. The
///                       <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY structure that specifies the
///                       handle check policy flags. </td> </tr> <tr> <td width="40%"><a id="ProcessSystemCallDisablePolicy"></a><a
///                       id="processsystemcalldisablepolicy"></a><a id="PROCESSSYSTEMCALLDISABLEPOLICY"></a><dl>
///                       <dt><b>ProcessSystemCallDisablePolicy</b></dt> </dl> </td> <td width="60%"> Disables the ability to use
///                       NTUser/GDI functions at the lowest layer. The <i>lpBuffer</i> parameter points to a
///                       PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY structure that specifies the system call disable policy flags.
///                       </td> </tr> <tr> <td width="40%"><a id="ProcessMitigationOptionsMask"></a><a
///                       id="processmitigationoptionsmask"></a><a id="PROCESSMITIGATIONOPTIONSMASK"></a><dl>
///                       <dt><b>ProcessMitigationOptionsMask</b></dt> </dl> </td> <td width="60%"> Returns the mask of valid bits for all
///                       the mitigation options on the system. An application can set many mitigation options without querying the
///                       operating system for mitigation options by combining bitwise with the mask to exclude all non-supported bits at
///                       once. The <i>lpBuffer</i> parameter points to a <b>ULONG64</b> bit vector for the mask, or a two-element array of
///                       <b>ULONG64</b> bit vectors. </td> </tr> <tr> <td width="40%"><a id="ProcessExtensionPointDisablePolicy"></a><a
///                       id="processextensionpointdisablepolicy"></a><a id="PROCESSEXTENSIONPOINTDISABLEPOLICY"></a><dl>
///                       <dt><b>ProcessExtensionPointDisablePolicy</b></dt> </dl> </td> <td width="60%"> Prevents certain built-in third
///                       party extension points from being enabled, preventing legacy extension point DLLs from being loaded into the
///                       process. The <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY structure
///                       that specifies the extension point disable policy flags. </td> </tr> <tr> <td width="40%"><a
///                       id="ProcessControlFlowGuardPolicy"></a><a id="processcontrolflowguardpolicy"></a><a
///                       id="PROCESSCONTROLFLOWGUARDPOLICY"></a><dl> <dt><b>ProcessControlFlowGuardPolicy</b></dt> </dl> </td> <td
///                       width="60%"> The Control Flow Guard (CFG) policy of the process. The <i>lpBuffer</i> parameter points to a
///                       PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY structure that specifies the CFG policy flags. </td> </tr> <tr> <td
///                       width="40%"><a id="ProcessSignaturePolicy"></a><a id="processsignaturepolicy"></a><a
///                       id="PROCESSSIGNATUREPOLICY"></a><dl> <dt><b>ProcessSignaturePolicy</b></dt> </dl> </td> <td width="60%"> The
///                       policy of a process that can restrict image loading to those images that are either signed by Microsoft, by the
///                       Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs (WHQL). he
///                       <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY structure that specifies the
///                       signature policy flags. </td> </tr> <tr> <td width="40%"><a id="ProcessFontDisablePolicy"></a><a
///                       id="processfontdisablepolicy"></a><a id="PROCESSFONTDISABLEPOLICY"></a><dl>
///                       <dt><b>ProcessFontDisablePolicy</b></dt> </dl> </td> <td width="60%"> The policy regarding font loading for the
///                       process. When turned on, the process cannot load non-system fonts. The <i>lpBuffer</i> parameter points to a
///                       PROCESS_MITIGATION_FONT_DISABLE_POLICY structure that specifies the policy flags for font loading. </td> </tr>
///                       <tr> <td width="40%"><a id="ProcessImageLoadPolicy"></a><a id="processimageloadpolicy"></a><a
///                       id="PROCESSIMAGELOADPOLICY"></a><dl> <dt><b>ProcessImageLoadPolicy</b></dt> </dl> </td> <td width="60%"> The
///                       policy regarding image loading for the process, which determines the types of executable images that are allowed
///                       to be mapped into the process. When turned on, images cannot be loaded from some locations, such a remote devices
///                       or files that have the low mandatory label. The <i>lpBuffer</i> parameter points to a
///                       PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that specifies the policy flags for image loading. </td> </tr>
///                       <tr> <td width="40%"><a id="ProcessSideChannelIsolationPolicy"></a><a
///                       id="processsidechannelisolationpolicy"></a><a id="PROCESSSIDECHANNELISOLATIONPOLICY"></a><dl>
///                       <dt><b>ProcessSideChannelIsolationPolicy</b></dt> </dl> </td> <td width="60%"> Windows 10, version 1809 and
///                       above: The policy regarding isolation of side channels for the specified process. The <i>lpBuffer</i> parameter
///                       points to a PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY structure that specifies the policy flags for side
///                       channel isolation. </td> </tr> <tr> <td width="40%"><a id="ProcessUserShadowStackPolicy"></a><a
///                       id="processusershadowstackpolicy"></a><a id="PROCESSUSERSHADOWSTACKPOLICY"></a><dl>
///                       <dt><b>ProcessUserShadowStackPolicy</b></dt> </dl> </td> <td width="60%"> Windows 10, version 2004 and above: The
///                       policy regarding user-mode Hardware-enforced Stack Protection for the specified process. The <i>lpBuffer</i>
///                       parameter points to a PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY structure that specifies the policy flags for
///                       user-mode Hardware-enforced Stack Protection. </td> </tr> </table>
///    lpBuffer = If the <i>MitigationPolicy</i> parameter is <b>ProcessDEPPolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_DEP_POLICY structure that receives the DEP policy flags. If the <i>MitigationPolicy</i>
///               parameter is <b>ProcessASLRPolicy</b>, this parameter points to a PROCESS_MITIGATION_ASLR_POLICY structure that
///               receives the ASLR policy flags. If the <i>MitigationPolicy</i> parameter is <b>ProcessDynamicCodePolicy</b>, this
///               parameter points to a PROCESS_MITIGATION_DYNAMIC_CODE_POLICY structure that receives the dynamic code policy
///               flags. If the <i>MitigationPolicy</i> parameter is <b>ProcessStrictHandleCheckPolicy</b>, this parameter points
///               to a PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY structure that specifies the handle check policy flags. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessSystemCallDisablePolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY structure that specifies the system call disable policy flags. If
///               the <i>MitigationPolicy</i> parameter is <b>ProcessMitigationOptionsMask</b>, this parameter points to a
///               <b>ULONG64</b> bit vector for the mask or a two-element array of <b>ULONG64</b> bit vectors. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessExtensionPointDisablePolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY structure that specifies the extension point disable policy
///               flags. If the <i>MitigationPolicy</i> parameter is <b>ProcessControlFlowGuardPolicy</b>, this parameter points to
///               a PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY structure that specifies the CFG policy flags. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessSignaturePolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY structure that receives the signature policy flags. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessFontDisablePolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_FONT_DISABLE_POLICY structure that receives the policy flags for font loading. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that receives the policy flags for image loading. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessUserShadowStackPolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY structure that receives the policy flags for user-mode
///               Hardware-enforced Stack Protection.
///    dwLength = The size of <i>lpBuffer</i>, in bytes.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve
///    error values defined for this function, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, void* lpBuffer, 
                                size_t dwLength);

///Sets a mitigation policy for the calling process. Mitigation policies enable a process to harden itself against
///various types of attacks.
///Params:
///    MitigationPolicy = The mitigation policy to apply. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                       <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ProcessDEPPolicy"></a><a id="processdeppolicy"></a><a
///                       id="PROCESSDEPPOLICY"></a><dl> <dt><b>ProcessDEPPolicy</b></dt> </dl> </td> <td width="60%"> The data execution
///                       prevention (DEP) policy of the process. The <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_DEP_POLICY
///                       structure that specifies the DEP policy flags. </td> </tr> <tr> <td width="40%"><a id="ProcessASLRPolicy"></a><a
///                       id="processaslrpolicy"></a><a id="PROCESSASLRPOLICY"></a><dl> <dt><b>ProcessASLRPolicy</b></dt> </dl> </td> <td
///                       width="60%"> The Address Space Layout Randomization (ASLR) policy of the process. The <i>lpBuffer</i> parameter
///                       points to a PROCESS_MITIGATION_ASLR_POLICY structure that specifies the ASLR policy flags. </td> </tr> <tr> <td
///                       width="40%"><a id="ProcessDynamicCodePolicy"></a><a id="processdynamiccodepolicy"></a><a
///                       id="PROCESSDYNAMICCODEPOLICY"></a><dl> <dt><b>ProcessDynamicCodePolicy</b></dt> </dl> </td> <td width="60%"> The
///                       dynamic code policy of the process. When turned on, the process cannot generate dynamic code or modify existing
///                       executable code. The <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_DYNAMIC_CODE_POLICY structure that
///                       specifies the dynamic code policy flags. </td> </tr> <tr> <td width="40%"><a
///                       id="ProcessStrictHandleCheckPolicy"></a><a id="processstricthandlecheckpolicy"></a><a
///                       id="PROCESSSTRICTHANDLECHECKPOLICY"></a><dl> <dt><b>ProcessStrictHandleCheckPolicy</b></dt> </dl> </td> <td
///                       width="60%"> The process will receive a fatal error if it manipulates a handle that is not valid. The
///                       <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY structure that specifies the
///                       handle check policy flags. </td> </tr> <tr> <td width="40%"><a id="ProcessSystemCallDisablePolicy"></a><a
///                       id="processsystemcalldisablepolicy"></a><a id="PROCESSSYSTEMCALLDISABLEPOLICY"></a><dl>
///                       <dt><b>ProcessSystemCallDisablePolicy</b></dt> </dl> </td> <td width="60%"> Disables the ability to use
///                       NTUser/GDI functions at the lowest layer. The <i>lpBuffer</i> parameter points to a
///                       PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY structure that specifies the system call disable policy flags.
///                       </td> </tr> <tr> <td width="40%"><a id="ProcessMitigationOptionsMask"></a><a
///                       id="processmitigationoptionsmask"></a><a id="PROCESSMITIGATIONOPTIONSMASK"></a><dl>
///                       <dt><b>ProcessMitigationOptionsMask</b></dt> </dl> </td> <td width="60%"> Returns the mask of valid bits for all
///                       the mitigation options on the system. An application can set many mitigation options without querying the
///                       operating system for mitigation options by combining bitwise with the mask to exclude all non-supported bits at
///                       once. The <i>lpBuffer</i> parameter points to a <b>ULONG64</b> bit vector for the mask, or to accommodate more
///                       than 64 bits, a two-element array of <b>ULONG64</b> bit vectors. </td> </tr> <tr> <td width="40%"><a
///                       id="ProcessExtensionPointDisablePolicy"></a><a id="processextensionpointdisablepolicy"></a><a
///                       id="PROCESSEXTENSIONPOINTDISABLEPOLICY"></a><dl> <dt><b>ProcessExtensionPointDisablePolicy</b></dt> </dl> </td>
///                       <td width="60%"> The <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
///                       structure that specifies the extension point disable policy flags. </td> </tr> <tr> <td width="40%"><a
///                       id="ProcessControlFlowGuardPolicy"></a><a id="processcontrolflowguardpolicy"></a><a
///                       id="PROCESSCONTROLFLOWGUARDPOLICY"></a><dl> <dt><b>ProcessControlFlowGuardPolicy</b></dt> </dl> </td> <td
///                       width="60%"> The Control Flow Guard (CFG) policy of the process. The <i>lpBuffer</i> parameter points to a
///                       PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY structure that specifies the CFG policy flags. <div
///                       class="alert"><b>Note</b> This value is not currently supported.</div> <div> </div> </td> </tr> <tr> <td
///                       width="40%"><a id="ProcessSignaturePolicy"></a><a id="processsignaturepolicy"></a><a
///                       id="PROCESSSIGNATUREPOLICY"></a><dl> <dt><b>ProcessSignaturePolicy</b></dt> </dl> </td> <td width="60%"> The
///                       policy of a process that can restrict image loading to those images that are either signed by Microsoft, by the
///                       Windows Store, or by Microsoft, the Windows Store and the Windows Hardware Quality Labs (WHQL). he
///                       <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY structure that specifies the
///                       signature policy flags. </td> </tr> <tr> <td width="40%"><a id="ProcessFontDisablePolicy"></a><a
///                       id="processfontdisablepolicy"></a><a id="PROCESSFONTDISABLEPOLICY"></a><dl>
///                       <dt><b>ProcessFontDisablePolicy</b></dt> </dl> </td> <td width="60%"> The policy regarding font loading for the
///                       process. When turned on, the process cannot load non-system fonts. The <i>lpBuffer</i> parameter points to a
///                       PROCESS_MITIGATION_FONT_DISABLE_POLICY structure that specifies the policy flags for font loading. </td> </tr>
///                       <tr> <td width="40%"><a id="ProcessImageLoadPolicy"></a><a id="processimageloadpolicy"></a><a
///                       id="PROCESSIMAGELOADPOLICY"></a><dl> <dt><b>ProcessImageLoadPolicy</b></dt> </dl> </td> <td width="60%"> The
///                       policy regarding image loading for the process, which determines the types of executable images that are allowed
///                       to be mapped into the process. When turned on, images cannot be loaded from some locations, such a remote devices
///                       or files that have the low mandatory label. The <i>lpBuffer</i> parameter points to a
///                       PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that specifies the policy flags for image loading. </td> </tr>
///                       <tr> <td width="40%"><a id="ProcessUserShadowStackPolicy"></a><a id="processusershadowstackpolicy"></a><a
///                       id="PROCESSUSERSHADOWSTACKPOLICY"></a><dl> <dt><b>ProcessUserShadowStackPolicy</b></dt> </dl> </td> <td
///                       width="60%"> Windows 10, version 2004 and above: The policy regarding user-mode Hardware-enforced Stack
///                       Protection for the process. The <i>lpBuffer</i> parameter points to a PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY
///                       structure that specifies the policy flags for user-mode Hardware-enforced Stack Protection. </td> </tr> </table>
///    lpBuffer = If the <i>MitigationPolicy</i> parameter is <b>ProcessDEPPolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_DEP_POLICY structure that specifies the DEP policy flags. If the <i>MitigationPolicy</i>
///               parameter is <b>ProcessASLRPolicy</b>, this parameter points to a PROCESS_MITIGATION_ASLR_POLICY structure that
///               specifies the ASLR policy flags. If the <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this
///               parameter points to a PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that receives the policy flags for image
///               loading. If the <i>MitigationPolicy</i> parameter is <b>ProcessStrictHandleCheckPolicy</b>, this parameter points
///               to a PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY structure that specifies the handle check policy flags. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessSystemCallDisablePolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY structure that specifies the system call disable policy flags. If
///               the <i>MitigationPolicy</i> parameter is <b>ProcessMitigationOptionsMask</b>, this parameter points to a
///               <b>ULONG64</b> bit vector for the mask, or to accommodate more than 64 bits, a two-element array of
///               <b>ULONG64</b> bit vectors. If the <i>MitigationPolicy</i> parameter is
///               <b>ProcessExtensionPointDisablePolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY structure that specifies the extension point disable policy
///               flags. If the <i>MitigationPolicy</i> parameter is <b>ProcessControlFlowGuardPolicy</b>, this parameter points to
///               a PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY structure that specifies the CFG policy flags. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessSignaturePolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY structure that specifies the signature policy flags. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessFontDisablePolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_FONT_DISABLE_POLICY structure that specifies the policy flags for font loading. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessImageLoadPolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_IMAGE_LOAD_POLICY structure that specifies the policy flags for image loading. If the
///               <i>MitigationPolicy</i> parameter is <b>ProcessUserShadowStackPolicy</b>, this parameter points to a
///               PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY structure that specifies the policy flags for user-mode
///               Hardware-enforced Stack Protection.
///    dwLength = The size of <i>lpBuffer</i>, in bytes.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve
///    error values defined for this function, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, void* lpBuffer, size_t dwLength);

///Retrieves timing information for the specified thread.
///Params:
///    hThread = A handle to the thread whose timing information is sought. The handle must have the
///              <b>THREAD_QUERY_INFORMATION</b> or <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information,
///              see Thread Security and Access Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the
///              <b>THREAD_QUERY_INFORMATION</b> access right.
///    lpCreationTime = A pointer to a FILETIME structure that receives the creation time of the thread.
///    lpExitTime = A pointer to a FILETIME structure that receives the exit time of the thread. If the thread has not exited, the
///                 content of this structure is undefined.
///    lpKernelTime = A pointer to a FILETIME structure that receives the amount of time that the thread has executed in kernel mode.
///    lpUserTime = A pointer to a FILETIME structure that receives the amount of time that the thread has executed in user mode.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetThreadTimes(HANDLE hThread, FILETIME* lpCreationTime, FILETIME* lpExitTime, FILETIME* lpKernelTime, 
                    FILETIME* lpUserTime);

///Opens an existing local process object.
///Params:
///    dwDesiredAccess = The access to the process object. This access right is checked against the security descriptor for the process.
///                      This parameter can be one or more of the process access rights. If the caller has enabled the SeDebugPrivilege
///                      privilege, the requested access is granted regardless of the contents of the security descriptor.
///    bInheritHandle = If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not
///                     inherit this handle.
///    dwProcessId = The identifier of the local process to be opened. If the specified process is the System Idle Process
///                  (0x00000000), the function fails and the last error code is `ERROR_INVALID_PARAMETER`. If the specified process
///                  is the System process or one of the Client Server Run-Time Subsystem (CSRSS) processes, this function fails and
///                  the last error code is `ERROR_ACCESS_DENIED` because their access restrictions prevent user-level code from
///                  opening them. If you are using GetCurrentProcessId as an argument to this function, consider using
///                  GetCurrentProcess instead of OpenProcess, for improved performance.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified process. If the function fails, the
///    return value is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenProcess(PROCESS_ACCESS_RIGHTS dwDesiredAccess, BOOL bInheritHandle, uint dwProcessId);

///Retrieves the number of open handles that belong to the specified process.
///Params:
///    hProcess = A handle to the process whose handle count is being requested. The handle must have the PROCESS_QUERY_INFORMATION
///               or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights.
///               <b>Windows Server 2003 and Windows XP: </b>The handle must have the PROCESS_QUERY_INFORMATION access right.
///    pdwHandleCount = A pointer to a variable that receives the number of open handles that belong to the specified process.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessHandleCount(HANDLE hProcess, uint* pdwHandleCount);

///Retrieves the number of the processor the current thread was running on during the call to this function.
///Returns:
///    The function returns the current processor number.
///    
@DllImport("KERNEL32")
uint GetCurrentProcessorNumber();

///Sets the ideal processor for the specified thread and optionally retrieves the previous ideal processor.
///Params:
///    hThread = A handle to the thread for which to set the ideal processor. This handle must have been created with the
///              THREAD_SET_INFORMATION access right. For more information, see Thread Security and Access Rights.
///    lpIdealProcessor = A pointer to a PROCESSOR_NUMBER structure that specifies the processor number of the desired ideal processor.
///    lpPreviousIdealProcessor = A pointer to a PROCESSOR_NUMBER structure to receive the previous ideal processor. This parameter can point to
///                               the same memory location as the <i>lpIdealProcessor</i> parameter. This parameter can be NULL if the previous
///                               ideal processor is not required.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, it returns zero. To get extended
///    error information, use GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetThreadIdealProcessorEx(HANDLE hThread, PROCESSOR_NUMBER* lpIdealProcessor, 
                               PROCESSOR_NUMBER* lpPreviousIdealProcessor);

///Retrieves the processor number of the ideal processor for the specified thread.
///Params:
///    hThread = A handle to the thread for which to retrieve the ideal processor. This handle must have been created with the
///              THREAD_QUERY_LIMITED_INFORMATION access right. For more information, see Thread Security and Access Rights.
///    lpIdealProcessor = Points to PROCESSOR_NUMBER structure to receive the number of the ideal processor.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, it returns zero. To get extended
///    error information, use GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetThreadIdealProcessorEx(HANDLE hThread, PROCESSOR_NUMBER* lpIdealProcessor);

///Retrieves the processor group and number of the logical processor in which the calling thread is running.
///Params:
///    ProcNumber = A pointer to a PROCESSOR_NUMBER structure that receives the processor group to which the logical processor is
///                 assigned and the number of the logical processor within its group.
///Returns:
///    If the function succeeds, the <i>ProcNumber</i> parameter contains the group and processor number of the
///    processor on which the calling thread is running.
///    
@DllImport("KERNEL32")
void GetCurrentProcessorNumberEx(PROCESSOR_NUMBER* ProcNumber);

///Retrieves the priority boost control state of the specified process.
///Params:
///    hProcess = A handle to the process. This handle must have the <b>PROCESS_QUERY_INFORMATION</b> or
///               <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see Process Security and Access
///               Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b>
///               access right.
///    pDisablePriorityBoost = A pointer to a variable that receives the priority boost control state. A value of TRUE indicates that dynamic
///                            boosting is disabled. A value of FALSE indicates normal behavior.
///Returns:
///    If the function succeeds, the return value is nonzero. In that case, the variable pointed to by the
///    <i>pDisablePriorityBoost</i> parameter receives the priority boost control state. If the function fails, the
///    return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessPriorityBoost(HANDLE hProcess, BOOL* pDisablePriorityBoost);

///Disables or enables the ability of the system to temporarily boost the priority of the threads of the specified
///process.
///Params:
///    hProcess = A handle to the process. This handle must have the PROCESS_SET_INFORMATION access right. For more information,
///               see Process Security and Access Rights.
///    bDisablePriorityBoost = If this parameter is TRUE, dynamic boosting is disabled. If the parameter is FALSE, dynamic boosting is enabled.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost);

///Determines whether a specified thread has any I/O requests pending.
///Params:
///    hThread = A handle to the thread in question. This handle must have been created with the THREAD_QUERY_INFORMATION access
///              right. For more information, see Thread Security and Access Rights.
///    lpIOIsPending = A pointer to a variable which the function sets to TRUE if the specified thread has one or more I/O requests
///                    pending, or to FALSE otherwise.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetThreadIOPendingFlag(HANDLE hThread, BOOL* lpIOIsPending);

///Retrieves information about the specified thread.
///Params:
///    hThread = A handle to the thread. The handle must have THREAD_QUERY_INFORMATION access rights. For more information, see
///              Thread Security and Access Rights.
///    ThreadInformationClass = The class of information to retrieve. The only supported values are <b>ThreadMemoryPriority</b> and
///                             <b>ThreadPowerThrottling</b>.
///    ThreadInformation = Pointer to a structure to receive the type of information specified by the <i>ThreadInformationClass</i>
///                        parameter. If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must
///                        point to a <b>MEMORY_PRIORITY_INFORMATION</b> structure. If the <i>ThreadInformationClass</i> parameter is
///                        <b>ThreadPowerThrottling</b>, this parameter must point to a <b>THREAD_POWER_THROTTLING_STATE</b> structure.
///    ThreadInformationSize = The size in bytes of the structure specified by the <i>ThreadInformation</i> parameter. If the
///                            <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must be
///                            <code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>. If the <i>ThreadInformationClass</i> parameter is
///                            <b>ThreadPowerThrottling</b>, this parameter must be <code>sizeof(THREAD_POWER_THROTTLING_STATE)</code>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, void* ThreadInformation, 
                          uint ThreadInformationSize);

///Sets information for the specified thread.
///Params:
///    hThread = A handle to the thread. The handle must have THREAD_SET_INFORMATION access right. For more information, see
///              Thread Security and Access Rights.
///    ThreadInformationClass = The class of information to set. The only supported values are <b>ThreadMemoryPriority</b> and
///                             <b>ThreadPowerThrottling</b>.
///    ThreadInformation = Pointer to a structure that contains the type of information specified by the <i>ThreadInformationClass</i>
///                        parameter. If the <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must
///                        point to a <b>MEMORY_PRIORITY_INFORMATION</b> structure. If the <i>ThreadInformationClass</i> parameter is
///                        <b>ThreadPowerThrottling</b>, this parameter must point to a <b>THREAD_POWER_THROTTLING_STATE</b> structure.
///    ThreadInformationSize = The size in bytes of the structure specified by the <i>ThreadInformation</i> parameter. If the
///                            <i>ThreadInformationClass</i> parameter is <b>ThreadMemoryPriority</b>, this parameter must be
///                            <code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>. If the <i>ThreadInformationClass</i> parameter is
///                            <b>ThreadPowerThrottling</b>, this parameter must be <code>sizeof(THREAD_POWER_THROTTLING_STATE)</code>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, void* ThreadInformation, 
                          uint ThreadInformationSize);

///Determines whether the specified process is considered critical.
///Params:
///    hProcess = A handle to the process to query. The process must have been opened with <b>PROCESS_QUERY_LIMITED_INFORMATION</b>
///               access.
///    Critical = A pointer to the <b>BOOL</b> value this function will use to indicate whether the process is considered critical.
///Returns:
///    This routine returns FALSE on failure. Any other value indicates success. Call GetLastError to query for the
///    specific error reason on failure.
///    
@DllImport("KERNEL32")
BOOL IsProcessCritical(HANDLE hProcess, BOOL* Critical);

///Sets a protected policy. This function is for use primarily by Windows, and not designed for external use.
///Params:
///    PolicyGuid = The globally-unique identifier of the policy to set.
///    PolicyValue = The value to set the policy to.
///    OldPolicyValue = Optionally receives the original value that was associated with the supplied policy.
///Returns:
///    True if the function succeeds; otherwise, false. To retrieve error values for this function, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetProtectedPolicy(GUID* PolicyGuid, size_t PolicyValue, uint* OldPolicyValue);

///Queries the value associated with a protected policy.
///Params:
///    PolicyGuid = The globally-unique identifier of the policy to query.
///    PolicyValue = Receives the value that the supplied policy is set to.
///Returns:
///    True if the function succeeds; otherwise, false.
///    
@DllImport("KERNEL32")
BOOL QueryProtectedPolicy(GUID* PolicyGuid, uint* PolicyValue);

///Sets a preferred processor for a thread. The system schedules threads on their preferred processors whenever
///possible. On a system with more than 64 processors, this function sets the preferred processor to a logical processor
///in the processor group to which the calling thread is assigned. Use the SetThreadIdealProcessorEx function to specify
///a processor group and preferred processor.
///Params:
///    hThread = A handle to the thread whose preferred processor is to be set. The handle must have the THREAD_SET_INFORMATION
///              access right. For more information, see Thread Security and Access Rights.
///    dwIdealProcessor = The number of the preferred processor for the thread. This value is zero-based. If this parameter is
///                       MAXIMUM_PROCESSORS, the function returns the current ideal processor without changing it.
///Returns:
///    If the function succeeds, the return value is the previous preferred processor. If the function fails, the return
///    value is (DWORD) – 1. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint SetThreadIdealProcessor(HANDLE hThread, uint dwIdealProcessor);

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] Sets information for the specified process.
///Params:
///    hProcess = A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more
///               information, see Process Security and Access Rights.
///    ProcessInformationClass = A member of the [PROCESS_INFORMATION_CLASS](./ne-processthreadsapi-process_information_class.md) enumeration
///                              specifying the kind of information to set.
///    ProcessInformation = Pointer to an object that contains the type of information specified by the <i>ProcessInformationClass</i>
///                         parameter. If the <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must
///                         point to a MEMORY_PRIORITY_INFORMATION structure. If the <i>ProcessInformationClass</i> parameter is
///                         <b>ProcessPowerThrottling</b>, this parameter must point to a PROCESS_POWER_THROTTLING_STATE structure. If the
///                         <i>ProcessInformationClass</i> parameter is <b>ProcessLeapSecondInfo</b>, this parameter must point to a
///                         PROCESS_LEAP_SECOND_INFO structure.
///    ProcessInformationSize = The size in bytes of the structure specified by the <i>ProcessInformation</i> parameter. If the
///                             <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must be
///                             <code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>. If the <i>ProcessInformationClass</i> parameter is
///                             <b>ProcessPowerThrottling</b>, this parameter must be <code>sizeof(PROCESS_POWER_THROTTLING_STATE)</code>. If the
///                             <i>ProcessInformationClass</i> parameter is <b>ProcessLeapSecondInfo</b>, this parameter must be
///                             <code>sizeof(PROCESS_LEAP_SECOND_INFO)</code>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, 
                           void* ProcessInformation, uint ProcessInformationSize);

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] Retrieves information about the specified process.
///Params:
///    hProcess = A handle to the process. This handle must have the <b>PROCESS_SET_INFORMATION</b> access right. For more
///               information, see Process Security and Access Rights.
///    ProcessInformationClass = A member of the [PROCESS_INFORMATION_CLASS](./ne-processthreadsapi-process_information_class.md) enumeration
///                              specifying the kind of information to retrieve.
///    ProcessInformation = Pointer to an object to receive the type of information specified by the <i>ProcessInformationClass</i>
///                         parameter. If the <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must
///                         point to a MEMORY_PRIORITY_INFORMATION structure. If the <i>ProcessInformationClass</i> parameter is
///                         <b>ProcessPowerThrottling</b>, this parameter must point to a PROCESS_POWER_THROTTLING_STATE structure. If the
///                         <i>ProcessInformationClass</i> parameter is <b>ProcessProtectionLevelInfo</b>, this parameter must point to a
///                         PROCESS_PROTECTION_LEVEL_INFORMATION structure. If the <i>ProcessInformationClass</i> parameter is
///                         <b>ProcessLeapSecondInfo</b>, this parameter must point to a PROCESS_LEAP_SECOND_INFO structure. If the
///                         <i>ProcessInformationClass</i> parameter is <b>ProcessAppMemoryInfo</b>, this parameter must point to a
///                         APP_MEMORY_INFORMATION structure.
///    ProcessInformationSize = The size in bytes of the structure specified by the <i>ProcessInformation</i> parameter. If the
///                             <i>ProcessInformationClass</i> parameter is <b>ProcessMemoryPriority</b>, this parameter must be
///                             <code>sizeof(MEMORY_PRIORITY_INFORMATION)</code>. If the <i>ProcessInformationClass</i> parameter is
///                             <b>ProcessPowerThrottling</b>, this parameter must be <code>sizeof(PROCESS_POWER_THROTTLING_STATE)</code>. If the
///                             <i>ProcessInformationClass</i> parameter is <b>ProcessProtectionLevelInfo</b>, this parameter must be
///                             <code>sizeof(PROCESS_PROTECTION_LEVEL_INFORMATION)</code>. If the <i>ProcessInformationClass</i> parameter is
///                             <b>ProcessLeapSecondInfo</b>, this parameter must be <code>sizeof(PROCESS_LEAP_SECOND_INFO)</code>. If the
///                             <i>ProcessInformationClass</i> parameter is <b>ProcessAppMemoryInfo</b>, this parameter must be
///                             <code>sizeof(APP_MEMORY_INFORMATION)</code>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, 
                           void* ProcessInformation, uint ProcessInformationSize);

///Creates a new process and its primary thread. The new process runs in the security context of the user represented by
///the specified token. Typically, the process that calls the <b>CreateProcessAsUser</b> function must have the
///<b>SE_INCREASE_QUOTA_NAME</b> privilege and may require the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege if the token
///is not assignable. If this function fails with <b>ERROR_PRIVILEGE_NOT_HELD</b> (1314), use the
///CreateProcessWithLogonW function instead. <b>CreateProcessWithLogonW</b> requires no special privileges, but the
///specified user account must be allowed to log on interactively. Generally, it is best to use
///<b>CreateProcessWithLogonW</b> to create a process with alternate credentials.
///Params:
///    hToken = A handle to the primary token that represents a user. The handle must have the <b>TOKEN_QUERY</b>,
///             <b>TOKEN_DUPLICATE</b>, and <b>TOKEN_ASSIGN_PRIMARY</b> access rights. For more information, see Access Rights
///             for Access-Token Objects. The user represented by the token must have read and execute access to the application
///             specified by the <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter. To get a primary token that
///             represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx
///             function to convert an impersonation token into a primary token. This allows a server application that is
///             impersonating a client to create a process that has the security context of the client. If <i>hToken</i> is a
///             restricted version of the caller's primary token, the <b>SE_ASSIGNPRIMARYTOKEN_NAME</b> privilege is not
///             required. If the necessary privileges are not already enabled, <b>CreateProcessAsUser</b> enables them for the
///             duration of the call. For more information, see Running with Special Privileges. <b>Terminal Services: </b>The
///             process is run in the session specified in the token. By default, this is the same session that called LogonUser.
///             To change the session, use the SetTokenInformation function.
///    lpApplicationName = The name of the module to be executed. This module can be a Windows-based application. It can be some other type
///                        of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer. The
///                        string can specify the full path and file name of the module to execute or it can specify a partial name. In the
///                        case of a partial name, the function uses the current drive and current directory to complete the specification.
///                        The function will not use the search path. This parameter must include the file name extension; no default
///                        extension is assumed. The <i>lpApplicationName</i> parameter can be <b>NULL</b>. In that case, the module name
///                        must be the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file
///                        name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin;
///                        otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name".
///                        This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the
///                        following order: <b>c:\program.exe</b> <b>c:\program files\sub.exe</b> <b>c:\program files\sub
///                        dir\program.exe</b> <b>c:\program files\sub dir\program name.exe</b> If the executable module is a 16-bit
///                        application, <i>lpApplicationName</i> should be <b>NULL</b>, and the string pointed to by <i>lpCommandLine</i>
///                        should specify the executable module as well as its arguments. By default, all 16-bit Windows-based applications
///                        created by <b>CreateProcessAsUser</b> are run in a separate VDM (equivalent to <b>CREATE_SEPARATE_WOW_VDM</b> in
///                        CreateProcess).
///    lpCommandLine = The command line to be executed. The maximum length of this string is 32K characters. If <i>lpApplicationName</i>
///                    is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to <b>MAX_PATH</b> characters. The
///                    Unicode version of this function, <b>CreateProcessAsUserW</b>, can modify the contents of this string. Therefore,
///                    this parameter cannot be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If
///                    this parameter is a constant string, the function may cause an access violation. The <i>lpCommandLine</i>
///                    parameter can be <b>NULL</b>. In that case, the function uses the string pointed to by <i>lpApplicationName</i>
///                    as the command line. If both <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>,
///                    *<i>lpApplicationName</i> specifies the module to execute, and *<i>lpCommandLine</i> specifies the command line.
///                    The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can
///                    use the <i>argc</i> and <i>argv</i> arguments to parse the command line. Because <i>argv</i>[0] is the module
///                    name, C programmers generally repeat the module name as the first token in the command line. If
///                    <i>lpApplicationName</i> is <b>NULL</b>, the first white space–delimited token of the command line specifies
///                    the module name. If you are using a long file name that contains a space, use quoted strings to indicate where
///                    the file name ends and the arguments begin (see the explanation for the <i>lpApplicationName</i> parameter). If
///                    the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com,
///                    this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if
///                    the file name contains a path, .exe is not appended. If the file name does not contain a directory path, the
///                    system searches for the executable file in the following sequence: <ol> <li>The directory from which the
///                    application loaded.</li> <li>The current directory for the parent process.</li> <li>The 32-bit Windows system
///                    directory. Use the GetSystemDirectory function to get the path of this directory. </li> <li>The 16-bit Windows
///                    system directory. There is no function that obtains the path of this directory, but it is searched. </li> <li>The
///                    Windows directory. Use the GetWindowsDirectory function to get the path of this directory.</li> <li>The
///                    directories that are listed in the PATH environment variable. Note that this function does not search the
///                    per-application path specified by the <b>App Paths</b> registry key. To include this per-application path in the
///                    search sequence, use the ShellExecute function.</li> </ol> The system adds a null character to the command line
///                    string to separate the file name from the arguments. This divides the original string into two strings for
///                    internal processing.
///    lpProcessAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new process object and
///                          determines whether child processes can inherit the returned handle to the process. If <i>lpProcessAttributes</i>
///                          is <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the process gets a default security descriptor and
///                          the handle cannot be inherited. The default security descriptor is that of the user referenced in the
///                          <i>hToken</i> parameter. This security descriptor may not allow access for the caller, in which case the process
///                          may not be opened again after it is run. The process handle is valid and will continue to have full access
///                          rights.
///    lpThreadAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread object and
///                         determines whether child processes can inherit the returned handle to the thread. If <i>lpThreadAttributes</i> is
///                         <b>NULL</b> or <b>lpSecurityDescriptor</b> is <b>NULL</b>, the thread gets a default security descriptor and the
///                         handle cannot be inherited. The default security descriptor is that of the user referenced in the <i>hToken</i>
///                         parameter. This security descriptor may not allow access for the caller.
///    bInheritHandles = If this parameter is <b>TRUE</b>, each inheritable handle in the calling process is inherited by the new process.
///                      If the parameter is <b>FALSE</b>, the handles are not inherited. Note that inherited handles have the same value
///                      and access rights as the original handles. For additional discussion of inheritable handles, see Remarks.
///                      <b>Terminal Services: </b>You cannot inherit handles across sessions. Additionally, if this parameter is
///                      <b>TRUE</b>, you must create the process in the same session as the caller. <b>Protected Process Light (PPL)
///                      processes: </b>The generic handle inheritance is blocked when a PPL process creates a non-PPL process since
///                      PROCESS_DUP_HANDLE is not allowed from a non-PPL process to a PPL process. See Process Security and Access Rights
///    dwCreationFlags = The flags that control the priority class and the creation of the process. For a list of values, see Process
///                      Creation Flags. This parameter also controls the new process's priority class, which is used to determine the
///                      scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the
///                      priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless the
///                      priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>. In
///                      this case, the child process receives the default priority class of the calling process. If the dwCreationFlags
///                      parameter has a value of 0: - The process inherits both the error mode of the caller and the parent's console. -
///                      The environment block for the new process is assumed to contain ANSI characters (see *lpEnvironment* parameter
///                      for additional information). - A 16-bit Windows-based application runs in a shared Virtual DOS machine (VDM).
///    lpEnvironment = A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses the
///                    environment of the calling process. An environment block consists of a null-terminated block of null-terminated
///                    strings. Each string is in the following form: <i>name</i>=<i>value</i>\0 Because the equal sign is used as a
///                    separator, it must not be used in the name of an environment variable. An environment block can contain either
///                    Unicode or ANSI characters. If the environment block pointed to by <i>lpEnvironment</i> contains Unicode
///                    characters, be sure that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is
///                    <b>NULL</b> and the environment block of the parent process contains Unicode characters, you must also ensure
///                    that <i>dwCreationFlags</i> includes <b>CREATE_UNICODE_ENVIRONMENT</b>. The ANSI version of this function,
///                    <b>CreateProcessAsUserA</b> fails if the total size of the environment block for the process exceeds 32,767
///                    characters. Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one
///                    more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last
///                    string, two more to terminate the block. <b>Windows Server 2003 and Windows XP: </b>If the size of the combined
///                    user and system environment variable exceeds 8192 bytes, the process created by <b>CreateProcessAsUser</b> no
///                    longer runs with the environment block passed to the function by the parent process. Instead, the child process
///                    runs with the environment block returned by the CreateEnvironmentBlock function. To retrieve a copy of the
///                    environment block for a given user, use the CreateEnvironmentBlock function.
///    lpCurrentDirectory = The full path to the current directory for the process. The string can also specify a UNC path. If this parameter
///                         is NULL, the new process will have the same current drive and directory as the calling process. (This feature is
///                         provided primarily for shells that need to start an application and specify its initial drive and working
///                         directory.)
///    lpStartupInfo = A pointer to a STARTUPINFO or STARTUPINFOEX structure. The user must have full access to both the specified
///                    window station and desktop. If you want the process to be interactive, specify winsta0\default. If the
///                    <b>lpDesktop</b> member is NULL, the new process inherits the desktop and window station of its parent process.
///                    If this member is an empty string, "", the new process connects to a window station using the rules described in
///                    Process Connection to a Window Station. To set extended attributes, use a STARTUPINFOEX structure and specify
///                    <b>EXTENDED_STARTUPINFO_PRESENT</b> in the <i>dwCreationFlags</i> parameter. Handles in STARTUPINFO or
///                    STARTUPINFOEX must be closed with CloseHandle when they are no longer needed. <div class="alert"><b>Important</b>
///                    The caller is responsible for ensuring that the standard handle fields in STARTUPINFO contain valid handle
///                    values. These fields are copied unchanged to the child process without validation, even when the <b>dwFlags</b>
///                    member specifies <b>STARTF_USESTDHANDLES</b>. Incorrect values can cause the child process to misbehave or crash.
///                    Use the Application Verifier runtime verification tool to detect invalid handles. </div> <div> </div>
///    lpProcessInformation = A pointer to a PROCESS_INFORMATION structure that receives identification information about the new process.
///                           Handles in PROCESS_INFORMATION must be closed with CloseHandle when they are no longer needed.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Note that the function returns before the process has finished
///    initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the
///    termination status of a process, call GetExitCodeProcess.
///    
@DllImport("ADVAPI32")
BOOL CreateProcessAsUserA(HANDLE hToken, const(PSTR) lpApplicationName, PSTR lpCommandLine, 
                          SECURITY_ATTRIBUTES* lpProcessAttributes, SECURITY_ATTRIBUTES* lpThreadAttributes, 
                          BOOL bInheritHandles, uint dwCreationFlags, void* lpEnvironment, 
                          const(PSTR) lpCurrentDirectory, STARTUPINFOA* lpStartupInfo, 
                          PROCESS_INFORMATION* lpProcessInformation);

///Retrieves the shutdown parameters for the currently calling process.
///Params:
///    lpdwLevel = A pointer to a variable that receives the shutdown priority level. Higher levels shut down first. System level
///                shutdown orders are reserved for system components. Higher numbers shut down first. Following are the level
///                conventions. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>000-0FF</dt> </dl>
///                </td> <td width="60%"> System reserved last shutdown range. </td> </tr> <tr> <td width="40%"> <dl>
///                <dt>100-1FF</dt> </dl> </td> <td width="60%"> Application reserved last shutdown range. </td> </tr> <tr> <td
///                width="40%"> <dl> <dt>200-2FF</dt> </dl> </td> <td width="60%"> Application reserved "in between" shutdown range.
///                </td> </tr> <tr> <td width="40%"> <dl> <dt>300-3FF</dt> </dl> </td> <td width="60%"> Application reserved first
///                shutdown range. </td> </tr> <tr> <td width="40%"> <dl> <dt>400-4FF</dt> </dl> </td> <td width="60%"> System
///                reserved first shutdown range. </td> </tr> </table> All processes start at shutdown level 0x280.
///    lpdwFlags = A pointer to a variable that receives the shutdown flags. This parameter can be the following value. <table> <tr>
///                <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SHUTDOWN_NORETRY"></a><a
///                id="shutdown_noretry"></a><dl> <dt><b>SHUTDOWN_NORETRY</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%">
///                If this process takes longer than the specified timeout to shut down, do not display a retry dialog box for the
///                user. Instead, just cause the process to directly exit. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessShutdownParameters(uint* lpdwLevel, uint* lpdwFlags);

///Assigns a description to a thread.
///Params:
///    hThread = A handle for the thread for which you want to set the description. The handle must have
///              THREAD_SET_LIMITED_INFORMATION access.
///    lpThreadDescription = A Unicode string that specifies the description of the thread.
///Returns:
///    If the function succeeds, the return value is the **HRESULT** that denotes a successful operation. If the
///    function fails, the return value is an **HRESULT** that denotes the error.
///    
@DllImport("KERNEL32")
HRESULT SetThreadDescription(HANDLE hThread, const(PWSTR) lpThreadDescription);

///Retrieves the description that was assigned to a thread by calling
///[SetThreadDescription](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreaddescription).
///Params:
///    hThread = A handle to the thread for which to retrieve the description. The handle must have
///              THREAD_QUERY_LIMITED_INFORMATION access.
///    ppszThreadDescription = A Unicode string that contains the description of the thread.
///Returns:
///    If the function succeeds, the return value is the <b>HRESULT</b> that denotes a successful operation. If the
///    function fails, the return value is an <b>HRESULT</b> that denotes the error.
///    
@DllImport("KERNEL32")
HRESULT GetThreadDescription(HANDLE hThread, PWSTR* ppszThreadDescription);

///Retrieves information about the system's current usage of both physical and virtual memory.
///Params:
///    lpBuffer = A pointer to a MEMORYSTATUSEX structure that receives information about current memory availability.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GlobalMemoryStatusEx(MEMORYSTATUSEX* lpBuffer);

///Retrieves information about logical processors and related hardware. To retrieve information about logical processors
///and related hardware, including processor groups, use the GetLogicalProcessorInformationEx function.
///Params:
///    Buffer = A pointer to a buffer that receives an array of SYSTEM_LOGICAL_PROCESSOR_INFORMATION structures. If the function
///             fails, the contents of this buffer are undefined.
///    ReturnedLength = On input, specifies the length of the buffer pointed to by <i>Buffer</i>, in bytes. If the buffer is large enough
///                     to contain all of the data, this function succeeds and <i>ReturnLength</i> is set to the number of bytes
///                     returned. If the buffer is not large enough to contain all of the data, the function fails, GetLastError returns
///                     ERROR_INSUFFICIENT_BUFFER, and <i>ReturnLength</i> is set to the buffer length required to contain all of the
///                     data. If the function fails with an error other than ERROR_INSUFFICIENT_BUFFER, the value of <i>ReturnLength</i>
///                     is undefined.
///Returns:
///    If the function succeeds, the return value is TRUE and at least one SYSTEM_LOGICAL_PROCESSOR_INFORMATION
///    structure is written to the output buffer. If the function fails, the return value is FALSE. To get extended
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetLogicalProcessorInformation(SYSTEM_LOGICAL_PROCESSOR_INFORMATION* Buffer, uint* ReturnedLength);

///Retrieves information about the relationships of logical processors and related hardware.
///Params:
///    RelationshipType = The type of relationship to retrieve. This parameter can be one of the following LOGICAL_PROCESSOR_RELATIONSHIP
///                       values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="RelationCache"></a><a
///                       id="relationcache"></a><a id="RELATIONCACHE"></a><dl> <dt><b>RelationCache</b></dt> <dt>2</dt> </dl> </td> <td
///                       width="60%"> Retrieves information about logical processors that share a cache. </td> </tr> <tr> <td
///                       width="40%"><a id="RelationNumaNode"></a><a id="relationnumanode"></a><a id="RELATIONNUMANODE"></a><dl>
///                       <dt><b>RelationNumaNode</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Retrieves information about logical
///                       processors that are part of the same NUMA node. </td> </tr> <tr> <td width="40%"><a
///                       id="RelationProcessorCore"></a><a id="relationprocessorcore"></a><a id="RELATIONPROCESSORCORE"></a><dl>
///                       <dt><b>RelationProcessorCore</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Retrieves information about logical
///                       processors that share a single processor core. </td> </tr> <tr> <td width="40%"><a
///                       id="RelationProcessorPackage"></a><a id="relationprocessorpackage"></a><a id="RELATIONPROCESSORPACKAGE"></a><dl>
///                       <dt><b>RelationProcessorPackage</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Retrieves information about
///                       logical processors that share a physical package. </td> </tr> <tr> <td width="40%"><a id="RelationGroup"></a><a
///                       id="relationgroup"></a><a id="RELATIONGROUP"></a><dl> <dt><b>RelationGroup</b></dt> <dt>4</dt> </dl> </td> <td
///                       width="60%"> Retrieves information about logical processors that share a processor group. </td> </tr> <tr> <td
///                       width="40%"><a id="RelationAll"></a><a id="relationall"></a><a id="RELATIONALL"></a><dl>
///                       <dt><b>RelationAll</b></dt> <dt>0xffff</dt> </dl> </td> <td width="60%"> Retrieves information about logical
///                       processors for all relationship types (cache, NUMA node, processor core, physical package, and processor group).
///                       </td> </tr> </table>
///    Buffer = A pointer to a buffer that receives an array of SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX structures. If the
///             function fails, the contents of this buffer are undefined.
///    ReturnedLength = On input, specifies the length of the buffer pointed to by <i>Buffer</i>, in bytes. If the buffer is large enough
///                     to contain all of the data, this function succeeds and <i>ReturnedLength</i> is set to the number of bytes
///                     returned. If the buffer is not large enough to contain all of the data, the function fails, GetLastError returns
///                     ERROR_INSUFFICIENT_BUFFER, and <i>ReturnedLength</i> is set to the buffer length required to contain all of the
///                     data. If the function fails with an error other than ERROR_INSUFFICIENT_BUFFER, the value of
///                     <i>ReturnedLength</i> is undefined.
///Returns:
///    If the function succeeds, the return value is TRUE and at least one SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
///    structure is written to the output buffer. If the function fails, the return value is FALSE. To get extended
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, 
                                      SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX* Buffer, uint* ReturnedLength);

///Retrieves the amount of RAM that is physically installed on the computer.
///Params:
///    TotalMemoryInKilobytes = A pointer to a variable that receives the amount of physically installed RAM, in kilobytes.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b> and sets the <i>TotalMemoryInKilobytes</i> parameter to a
///    nonzero value. If the function fails, it returns <b>FALSE</b> and does not modify the
///    <i>TotalMemoryInKilobytes</i> parameter. To get extended error information, use the GetLastError function. Common
///    errors are listed in the following table. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> The
///    <i>TotalMemoryInKilobytes</i> parameter is <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_DATA</b></dt> </dl> </td> <td width="60%"> The System Management BIOS (SMBIOS) data is
///    malformed. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL GetPhysicallyInstalledSystemMemory(ulong* TotalMemoryInKilobytes);

///Retrieves the cycle time each processor in the specified processor group spent executing deferred procedure calls
///(DPCs) and interrupt service routines (ISRs) since the processor became active.
///Params:
///    Group = The number of the processor group for which to retrieve the cycle time.
///    Buffer = A pointer to a buffer to receive a SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION structure for each processor in the
///             group. On output, the DWORD64 <b>CycleTime</b> member of this structure is set to the cycle time for one
///             processor.
///    ReturnedLength = The size of the buffer, in bytes. When the function returns, this parameter contains the number of bytes written
///                     to <i>Buffer</i>. If the buffer is too small for the data, the function fails with ERROR_INSUFFICIENT_BUFFER and
///                     sets the <i>ReturnedLength</i> parameter to the required buffer size.
///Returns:
///    If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.
///    To get extended error information, use GetLastError. If the error value is ERROR_INSUFFICIENT_BUFFER, the
///    <i>ReturnedLength</i> parameter contains the required buffer size.
///    
@DllImport("KERNEL32")
BOOL GetProcessorSystemCycleTime(ushort Group, SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION* Buffer, 
                                 uint* ReturnedLength);

///Retrieves the cycle time for the specified thread.
///Params:
///    ThreadHandle = A handle to the thread. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION
///                   access right. For more information, see Process Security and Access Rights.
///    CycleTime = The number of CPU clock cycles used by the thread. This value includes cycles spent in both user mode and kernel
///                mode.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryThreadCycleTime(HANDLE ThreadHandle, ulong* CycleTime);

///Retrieves the sum of the cycle time of all threads of the specified process.
///Params:
///    ProcessHandle = A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION
///                    access right. For more information, see Process Security and Access Rights.
///    CycleTime = The number of CPU clock cycles used by the threads of the process. This value includes cycles spent in both user
///                mode and kernel mode.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryProcessCycleTime(HANDLE ProcessHandle, ulong* CycleTime);

///Retrieves the cycle time for the idle thread of each processor in the system. On a system with more than 64
///processors, this function retrieves the cycle time for the idle thread of each processor in the processor group to
///which the calling thread is assigned. Use the QueryIdleProcessorCycleTimeEx function to retrieve the cycle time for
///the idle thread on each logical processor for a specific processor group.
///Params:
///    BufferLength = On input, specifies the size of the <i>ProcessorIdleCycleTime</i> buffer, in bytes. This buffer is expected to be
///                   8 times the number of processors in the group. On output, specifies the number of elements written to the buffer.
///                   If the buffer size is not sufficient, the function fails and this parameter receives the required length of the
///                   buffer.
///    ProcessorIdleCycleTime = The number of CPU clock cycles used by each idle thread. This buffer must be 8 times the number of processors in
///                             the system in size.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryIdleProcessorCycleTime(uint* BufferLength, ulong* ProcessorIdleCycleTime);

///Retrieves the accumulated cycle time for the idle thread on each logical processor in the specified processor group.
///Params:
///    Group = The number of the processor group for which to retrieve the cycle time.
///    BufferLength = On input, specifies the size of the <i>ProcessorIdleCycleTime</i> buffer, in bytes. This buffer is expected to be
///                   8 times the number of processors in the group. On output, specifies the number of elements written to the buffer.
///                   If the buffer size is not sufficient, the function fails and this parameter receives the required length of the
///                   buffer.
///    ProcessorIdleCycleTime = The number of CPU clock cycles used by each idle thread. If this parameter is NULL, the function updates the
///                             <i>BufferLength</i> parameter with the required length.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, use GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryIdleProcessorCycleTimeEx(ushort Group, uint* BufferLength, ulong* ProcessorIdleCycleTime);

///Allocates the specified number of bytes from the heap. <div class="alert"><b>Note</b> The global functions have
///greater overhead and provide fewer features than other memory management functions. New applications should use the
///heap functions unless documentation states that a global function should be used. For more information, see Global
///and Local Functions.</div><div> </div>
///Params:
///    uFlags = The memory allocation attributes. If zero is specified, the default is <b>GMEM_FIXED</b>. This parameter can be
///             one or more of the following values, except for the incompatible combinations that are specifically noted.
///             <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="GHND"></a><a id="ghnd"></a><dl>
///             <dt><b>GHND</b></dt> <dt>0x0042</dt> </dl> </td> <td width="60%"> Combines <b>GMEM_MOVEABLE</b> and
///             <b>GMEM_ZEROINIT</b>. </td> </tr> <tr> <td width="40%"><a id="GMEM_FIXED"></a><a id="gmem_fixed"></a><dl>
///             <dt><b>GMEM_FIXED</b></dt> <dt>0x0000</dt> </dl> </td> <td width="60%"> Allocates fixed memory. The return value
///             is a pointer. </td> </tr> <tr> <td width="40%"><a id="GMEM_MOVEABLE"></a><a id="gmem_moveable"></a><dl>
///             <dt><b>GMEM_MOVEABLE</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Allocates movable memory. Memory
///             blocks are never moved in physical memory, but they can be moved within the default heap. The return value is a
///             handle to the memory object. To translate the handle into a pointer, use the GlobalLock function. This value
///             cannot be combined with <b>GMEM_FIXED</b>. </td> </tr> <tr> <td width="40%"><a id="GMEM_ZEROINIT"></a><a
///             id="gmem_zeroinit"></a><dl> <dt><b>GMEM_ZEROINIT</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%">
///             Initializes memory contents to zero. </td> </tr> <tr> <td width="40%"><a id="GPTR"></a><a id="gptr"></a><dl>
///             <dt><b>GPTR</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%"> Combines <b>GMEM_FIXED</b> and
///             <b>GMEM_ZEROINIT</b>. </td> </tr> </table> The following values are obsolete, but are provided for compatibility
///             with 16-bit Windows. They are ignored.<dl> <dd><b>GMEM_DDESHARE</b></dd> <dd><b>GMEM_DISCARDABLE</b></dd>
///             <dd><b>GMEM_LOWER</b></dd> <dd><b>GMEM_NOCOMPACT</b></dd> <dd><b>GMEM_NODISCARD</b></dd>
///             <dd><b>GMEM_NOT_BANKED</b></dd> <dd><b>GMEM_NOTIFY</b></dd> <dd><b>GMEM_SHARE</b></dd> </dl>
///    dwBytes = The number of bytes to allocate. If this parameter is zero and the <i>uFlags</i> parameter specifies
///              <b>GMEM_MOVEABLE</b>, the function returns a handle to a memory object that is marked as discarded.
///Returns:
///    If the function succeeds, the return value is a handle to the newly allocated memory object. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t GlobalAlloc(uint uFlags, size_t dwBytes);

///Changes the size or attributes of a specified global memory object. The size can increase or decrease. <div
///class="alert"><b>Note</b> The global functions have greater overhead and provide fewer features than other memory
///management functions. New applications should use the heap functions unless documentation states that a global
///function should be used. For more information, see Global and Local Functions. </div><div> </div>
///Params:
///    hMem = A handle to the global memory object to be reallocated. This handle is returned by either the GlobalAlloc or
///           <b>GlobalReAlloc</b> function.
///    dwBytes = The new size of the memory block, in bytes. If <i>uFlags</i> specifies <b>GMEM_MODIFY</b>, this parameter is
///              ignored.
///    uFlags = The reallocation options. If <b>GMEM_MODIFY</b> is specified, the function modifies the attributes of the memory
///             object only (the <i>dwBytes</i> parameter is ignored.) Otherwise, the function reallocates the memory object. You
///             can optionally combine <b>GMEM_MODIFY</b> with the following value. <table> <tr> <th>Value</th> <th>Meaning</th>
///             </tr> <tr> <td width="40%"><a id="GMEM_MOVEABLE"></a><a id="gmem_moveable"></a><dl> <dt><b>GMEM_MOVEABLE</b></dt>
///             <dt>0x0002</dt> </dl> </td> <td width="60%"> Allocates movable memory. If the memory is a locked
///             <b>GMEM_MOVEABLE</b> memory block or a <b>GMEM_FIXED</b> memory block and this flag is not specified, the memory
///             can only be reallocated in place. </td> </tr> </table> If this parameter does not specify <b>GMEM_MODIFY</b>, you
///             can use the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="GMEM_ZEROINIT"></a><a id="gmem_zeroinit"></a><dl> <dt><b>GMEM_ZEROINIT</b></dt> <dt>0x0040</dt> </dl> </td>
///             <td width="60%"> Causes the additional memory contents to be initialized to zero if the memory object is growing
///             in size. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to the reallocated memory object. If the function fails,
///    the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t GlobalReAlloc(ptrdiff_t hMem, size_t dwBytes, uint uFlags);

///Retrieves the current size of the specified global memory object, in bytes. <div class="alert"><b>Note</b> The global
///functions have greater overhead and provide fewer features than other memory management functions. New applications
///should use the heap functions unless documentation states that a global function should be used. For more
///information, see Global and Local Functions. </div><div> </div>
///Params:
///    hMem = A handle to the global memory object. This handle is returned by either the GlobalAlloc or GlobalReAlloc
///           function.
///Returns:
///    If the function succeeds, the return value is the size of the specified global memory object, in bytes. If the
///    specified handle is not valid or if the object has been discarded, the return value is zero. To get extended
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
size_t GlobalSize(ptrdiff_t hMem);

///Decrements the lock count associated with a memory object that was allocated with <b>GMEM_MOVEABLE</b>. This function
///has no effect on memory objects allocated with <b>GMEM_FIXED</b>. <div class="alert"><b>Note</b> The global functions
///have greater overhead and provide fewer features than other memory management functions. New applications should use
///the heap functions unless documentation states that a global function should be used. For more information, see
///Global and Local Functions. </div><div> </div>
///Params:
///    hMem = A handle to the global memory object. This handle is returned by either the GlobalAlloc or GlobalReAlloc
///           function.
///Returns:
///    If the memory object is still locked after decrementing the lock count, the return value is a nonzero value. If
///    the memory object is unlocked after decrementing the lock count, the function returns zero and GetLastError
///    returns <b>NO_ERROR</b>. If the function fails, the return value is zero and GetLastError returns a value other
///    than <b>NO_ERROR</b>.
///    
@DllImport("KERNEL32")
BOOL GlobalUnlock(ptrdiff_t hMem);

///Locks a global memory object and returns a pointer to the first byte of the object's memory block. <div
///class="alert"><b>Note</b> The global functions have greater overhead and provide fewer features than other memory
///management functions. New applications should use the heap functions unless documentation states that a global
///function should be used. For more information, see Global and Local Functions. </div><div> </div>
///Params:
///    hMem = A handle to the global memory object. This handle is returned by either the GlobalAlloc or GlobalReAlloc
///           function.
///Returns:
///    If the function succeeds, the return value is a pointer to the first byte of the memory block. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* GlobalLock(ptrdiff_t hMem);

///Retrieves information about the specified global memory object. <div class="alert"><b>Note</b> This function is
///provided only for compatibility with 16-bit versions of Windows. New applications should use the heap functions. For
///more information, see Remarks. </div><div> </div>
///Params:
///    hMem = A handle to the global memory object. This handle is returned by either the GlobalAlloc or GlobalReAlloc
///           function.
///Returns:
///    If the function succeeds, the return value specifies the allocation values and the lock count for the memory
///    object. If the function fails, the return value is <b>GMEM_INVALID_HANDLE</b>, indicating that the global handle
///    is not valid. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GlobalFlags(ptrdiff_t hMem);

///Retrieves the handle associated with the specified pointer to a global memory block. <div class="alert"><b>Note</b>
///The global functions have greater overhead and provide fewer features than other memory management functions. New
///applications should use the heap functions unless documentation states that a global function should be used. For
///more information, see Global and Local Functions. </div><div> </div>
///Params:
///    pMem = A pointer to the first byte of the global memory block. This pointer is returned by the GlobalLock function.
///Returns:
///    If the function succeeds, the return value is a handle to the specified global memory object. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t GlobalHandle(const(void)* pMem);

///Frees the specified global memory object and invalidates its handle. <div class="alert"><b>Note</b> The global
///functions have greater overhead and provide fewer features than other memory management functions. New applications
///should use the heap functions unless documentation states that a global function should be used. For more
///information, see Global and Local Functions. </div><div> </div>
///Params:
///    hMem = A handle to the global memory object. This handle is returned by either the GlobalAlloc or GlobalReAlloc
///           function. It is not safe to free memory allocated with LocalAlloc.
///Returns:
///    If the function succeeds, the return value is <b>NULL</b>. If the function fails, the return value is equal to a
///    handle to the global memory object. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t GlobalFree(ptrdiff_t hMem);

///<p class="CCE_Message">[<b>GlobalMemoryStatus</b> can return incorrect information. Use the GlobalMemoryStatusEx
///function instead.] Retrieves information about the system's current usage of both physical and virtual memory.
///Params:
///    lpBuffer = A pointer to a MEMORYSTATUS structure. The <b>GlobalMemoryStatus</b> function stores information about current
///               memory availability into this structure.
@DllImport("KERNEL32")
void GlobalMemoryStatus(MEMORYSTATUS* lpBuffer);

///Allocates the specified number of bytes from the heap. <div class="alert"><b>Note</b> The local functions have
///greater overhead and provide fewer features than other memory management functions. New applications should use the
///heap functions unless documentation states that a local function should be used. For more information, see Global and
///Local Functions.</div><div> </div>
///Params:
///    uFlags = The memory allocation attributes. The default is the <b>LMEM_FIXED</b> value. This parameter can be one or more
///             of the following values, except for the incompatible combinations that are specifically noted. <table> <tr>
///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LHND"></a><a id="lhnd"></a><dl>
///             <dt><b>LHND</b></dt> <dt>0x0042</dt> </dl> </td> <td width="60%"> Combines <b>LMEM_MOVEABLE</b> and
///             <b>LMEM_ZEROINIT</b>. </td> </tr> <tr> <td width="40%"><a id="LMEM_FIXED"></a><a id="lmem_fixed"></a><dl>
///             <dt><b>LMEM_FIXED</b></dt> <dt>0x0000</dt> </dl> </td> <td width="60%"> Allocates fixed memory. The return value
///             is a pointer to the memory object. </td> </tr> <tr> <td width="40%"><a id="LMEM_MOVEABLE"></a><a
///             id="lmem_moveable"></a><dl> <dt><b>LMEM_MOVEABLE</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Allocates
///             movable memory. Memory blocks are never moved in physical memory, but they can be moved within the default heap.
///             The return value is a handle to the memory object. To translate the handle to a pointer, use the LocalLock
///             function. This value cannot be combined with <b>LMEM_FIXED</b>. </td> </tr> <tr> <td width="40%"><a
///             id="LMEM_ZEROINIT"></a><a id="lmem_zeroinit"></a><dl> <dt><b>LMEM_ZEROINIT</b></dt> <dt>0x0040</dt> </dl> </td>
///             <td width="60%"> Initializes memory contents to zero. </td> </tr> <tr> <td width="40%"><a id="LPTR"></a><a
///             id="lptr"></a><dl> <dt><b>LPTR</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%"> Combines <b>LMEM_FIXED</b>
///             and <b>LMEM_ZEROINIT</b>. </td> </tr> <tr> <td width="40%"><a id="NONZEROLHND"></a><a id="nonzerolhnd"></a><dl>
///             <dt><b>NONZEROLHND</b></dt> </dl> </td> <td width="60%"> Same as <b>LMEM_MOVEABLE</b>. </td> </tr> <tr> <td
///             width="40%"><a id="NONZEROLPTR"></a><a id="nonzerolptr"></a><dl> <dt><b>NONZEROLPTR</b></dt> </dl> </td> <td
///             width="60%"> Same as <b>LMEM_FIXED</b>. </td> </tr> </table> The following values are obsolete, but are provided
///             for compatibility with 16-bit Windows. They are ignored.<dl> <dd><b>LMEM_DISCARDABLE</b></dd>
///             <dd><b>LMEM_NOCOMPACT</b></dd> <dd><b>LMEM_NODISCARD</b></dd> </dl>
///    uBytes = The number of bytes to allocate. If this parameter is zero and the <i>uFlags</i> parameter specifies
///             <b>LMEM_MOVEABLE</b>, the function returns a handle to a memory object that is marked as discarded.
///Returns:
///    If the function succeeds, the return value is a handle to the newly allocated memory object. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t LocalAlloc(uint uFlags, size_t uBytes);

///Changes the size or the attributes of a specified local memory object. The size can increase or decrease. <div
///class="alert"><b>Note</b> The local functions have greater overhead and provide fewer features than other memory
///management functions. New applications should use the heap functions unless documentation states that a local
///function should be used. For more information, see Global and Local Functions.</div><div> </div>
///Params:
///    hMem = A handle to the local memory object to be reallocated. This handle is returned by either the LocalAlloc or
///           <b>LocalReAlloc</b> function.
///    uBytes = The new size of the memory block, in bytes. If <i>uFlags</i> specifies <b>LMEM_MODIFY</b>, this parameter is
///             ignored.
///    uFlags = The reallocation options. If <b>LMEM_MODIFY</b> is specified, the function modifies the attributes of the memory
///             object only (the <i>uBytes</i> parameter is ignored.) Otherwise, the function reallocates the memory object. You
///             can optionally combine <b>LMEM_MODIFY</b> with the following value. <table> <tr> <th>Value</th> <th>Meaning</th>
///             </tr> <tr> <td width="40%"><a id="LMEM_MOVEABLE"></a><a id="lmem_moveable"></a><dl> <dt><b>LMEM_MOVEABLE</b></dt>
///             <dt>0x0002</dt> </dl> </td> <td width="60%"> Allocates fixed or movable memory. If the memory is a locked
///             <b>LMEM_MOVEABLE</b> memory block or a <b>LMEM_FIXED</b> memory block and this flag is not specified, the memory
///             can only be reallocated in place. </td> </tr> </table> If this parameter does not specify <b>LMEM_MODIFY</b>, you
///             can use the following value. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="LMEM_ZEROINIT"></a><a id="lmem_zeroinit"></a><dl> <dt><b>LMEM_ZEROINIT</b></dt> <dt>0x0040</dt> </dl> </td>
///             <td width="60%"> Causes the additional memory contents to be initialized to zero if the memory object is growing
///             in size. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to the reallocated memory object. If the function fails,
///    the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t LocalReAlloc(ptrdiff_t hMem, size_t uBytes, uint uFlags);

///Locks a local memory object and returns a pointer to the first byte of the object's memory block. <div
///class="alert"><b>Note</b> The local functions have greater overhead and provide fewer features than other memory
///management functions. New applications should use the heap functions unless documentation states that a local
///function should be used. For more information, see Global and Local Functions.</div><div> </div>
///Params:
///    hMem = A handle to the local memory object. This handle is returned by either the LocalAlloc or LocalReAlloc function.
///Returns:
///    If the function succeeds, the return value is a pointer to the first byte of the memory block. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* LocalLock(ptrdiff_t hMem);

///Retrieves the handle associated with the specified pointer to a local memory object. <div class="alert"><b>Note</b>
///The local functions have greater overhead and provide fewer features than other memory management functions. New
///applications should use the heap functions unless documentation states that a local function should be used. For more
///information, see Global and Local Functions.</div><div> </div>
///Params:
///    pMem = A pointer to the first byte of the local memory object. This pointer is returned by the LocalLock function.
///Returns:
///    If the function succeeds, the return value is a handle to the specified local memory object. If the function
///    fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t LocalHandle(const(void)* pMem);

///Decrements the lock count associated with a memory object that was allocated with <b>LMEM_MOVEABLE</b>. This function
///has no effect on memory objects allocated with <b>LMEM_FIXED</b>. <div class="alert"><b>Note</b> The local functions
///have greater overhead and provide fewer features than other memory management functions. New applications should use
///the heap functions unless documentation states that a local function should be used. For more information, see Global
///and Local Functions.</div><div> </div>
///Params:
///    hMem = A handle to the local memory object. This handle is returned by either the LocalAlloc or LocalReAlloc function.
///Returns:
///    If the memory object is still locked after decrementing the lock count, the return value is nonzero. If the
///    memory object is unlocked after decrementing the lock count, the function returns zero and GetLastError returns
///    <b>NO_ERROR</b>. If the function fails, the return value is zero and GetLastError returns a value other than
///    <b>NO_ERROR</b>.
///    
@DllImport("KERNEL32")
BOOL LocalUnlock(ptrdiff_t hMem);

///Retrieves the current size of the specified local memory object, in bytes. <div class="alert"><b>Note</b> The local
///functions have greater overhead and provide fewer features than other memory management functions. New applications
///should use the heap functions unless documentation states that a local function should be used. For more information,
///see Global and Local Functions.</div><div> </div>
///Params:
///    hMem = A handle to the local memory object. This handle is returned by the LocalAlloc, LocalReAlloc, or LocalHandle
///           function.
///Returns:
///    If the function succeeds, the return value is the size of the specified local memory object, in bytes. If the
///    specified handle is not valid or if the object has been discarded, the return value is zero. To get extended
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
size_t LocalSize(ptrdiff_t hMem);

///Retrieves information about the specified local memory object. <div class="alert"><b>Note</b> This function is
///provided only for compatibility with 16-bit versions of Windows. New applications should use the heap functions. For
///more information, see Remarks.</div><div> </div>
///Params:
///    hMem = A handle to the local memory object. This handle is returned by either the LocalAlloc or LocalReAlloc function.
///Returns:
///    If the function succeeds, the return value specifies the allocation values and the lock count for the memory
///    object. If the function fails, the return value is <b>LMEM_INVALID_HANDLE</b>, indicating that the local handle
///    is not valid. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint LocalFlags(ptrdiff_t hMem);

///Frees the specified local memory object and invalidates its handle. <div class="alert"><b>Note</b> The local
///functions have greater overhead and provide fewer features than other memory management functions. New applications
///should use the heap functions unless documentation states that a local function should be used. For more information,
///see Global and Local Functions.</div><div> </div>
///Params:
///    hMem = A handle to the local memory object. This handle is returned by either the LocalAlloc or LocalReAlloc function.
///           It is not safe to free memory allocated with GlobalAlloc.
///Returns:
///    If the function succeeds, the return value is <b>NULL</b>. If the function fails, the return value is equal to a
///    handle to the local memory object. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t LocalFree(ptrdiff_t hMem);

///Retrieves the process affinity mask for the specified process and the system affinity mask for the system.
///Params:
///    hProcess = A handle to the process whose affinity mask is desired. This handle must have the
///               <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information,
///               see Process Security and Access Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the
///               <b>PROCESS_QUERY_INFORMATION</b> access right.
///    lpProcessAffinityMask = A pointer to a variable that receives the affinity mask for the specified process.
///    lpSystemAffinityMask = A pointer to a variable that receives the affinity mask for the system.
///Returns:
///    If the function succeeds, the return value is nonzero and the function sets the variables pointed to by
///    <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> to the appropriate affinity masks. On a system with
///    more than 64 processors, if the threads of the calling process are in a single processor group, the function sets
///    the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i> to the process affinity
///    mask and the processor mask of active logical processors for that group. If the calling process contains threads
///    in multiple groups, the function returns zero for both affinity masks. If the function fails, the return value is
///    zero, and the values of the variables pointed to by <i>lpProcessAffinityMask</i> and <i>lpSystemAffinityMask</i>
///    are undefined. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessAffinityMask(HANDLE hProcess, size_t* lpProcessAffinityMask, size_t* lpSystemAffinityMask);

///Sets a processor affinity mask for the threads of the specified process.
///Params:
///    hProcess = A handle to the process whose affinity mask is to be set. This handle must have the
///               <b>PROCESS_SET_INFORMATION</b> access right. For more information, see Process Security and Access Rights.
///    dwProcessAffinityMask = The affinity mask for the threads of the process. On a system with more than 64 processors, the affinity mask
///                            must specify processors in a single processor group.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the process affinity mask requests a processor that is not
///    configured in the system, the last error code is <b>ERROR_INVALID_PARAMETER</b>. On a system with more than 64
///    processors, if the calling process contains threads in more than one processor group, the last error code is
///    <b>ERROR_INVALID_PARAMETER</b>.
///    
@DllImport("KERNEL32")
BOOL SetProcessAffinityMask(HANDLE hProcess, size_t dwProcessAffinityMask);

///Retrieves accounting information for all I/O operations performed by the specified process.
///Params:
///    hProcess = A handle to the process. The handle must have the <b>PROCESS_QUERY_INFORMATION</b> or
///               <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information, see Process Security and Access
///               Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the <b>PROCESS_QUERY_INFORMATION</b>
///               access right.
///    lpIoCounters = A pointer to an IO_COUNTERS structure that receives the I/O accounting information for the process.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessIoCounters(HANDLE hProcess, IO_COUNTERS* lpIoCounters);

///Retrieves the minimum and maximum working set sizes of the specified process.
///Params:
///    hProcess = A handle to the process whose working set sizes will be obtained. The handle must have the
///               <b>PROCESS_QUERY_INFORMATION</b> or <b>PROCESS_QUERY_LIMITED_INFORMATION</b> access right. For more information,
///               see Process Security and Access Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the
///               <b>PROCESS_QUERY_INFORMATION</b> access right.
///    lpMinimumWorkingSetSize = A pointer to a variable that receives the minimum working set size of the specified process, in bytes. The
///                              virtual memory manager attempts to keep at least this much memory resident in the process whenever the process is
///                              active.
///    lpMaximumWorkingSetSize = A pointer to a variable that receives the maximum working set size of the specified process, in bytes. The
///                              virtual memory manager attempts to keep no more than this much memory resident in the process whenever the
///                              process is active when memory is in short supply.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessWorkingSetSize(HANDLE hProcess, size_t* lpMinimumWorkingSetSize, size_t* lpMaximumWorkingSetSize);

///Sets the minimum and maximum working set sizes for the specified process.
///Params:
///    hProcess = A handle to the process whose working set sizes is to be set. The handle must have the <b>PROCESS_SET_QUOTA</b>
///               access right. For more information, see Process Security and Access Rights.
///    dwMinimumWorkingSetSize = The minimum working set size for the process, in bytes. The virtual memory manager attempts to keep at least this
///                              much memory resident in the process whenever the process is active. This parameter must be greater than zero but
///                              less than or equal to the maximum working set size. The default size is 50 pages (for example, this is 204,800
///                              bytes on systems with a 4K page size). If the value is greater than zero but less than 20 pages, the minimum
///                              value is set to 20 pages. If both <i>dwMinimumWorkingSetSize</i> and <i>dwMaximumWorkingSetSize</i> have the
///                              value (<b>SIZE_T</b>)–1, the function removes as many pages as possible from the working set of the specified
///                              process.
///    dwMaximumWorkingSetSize = The maximum working set size for the process, in bytes. The virtual memory manager attempts to keep no more than
///                              this much memory resident in the process whenever the process is active and available memory is low. This
///                              parameter must be greater than or equal to 13 pages (for example, 53,248 on systems with a 4K page size), and
///                              less than the system-wide maximum (number of available pages minus 512 pages). The default size is 345 pages (for
///                              example, this is 1,413,120 bytes on systems with a 4K page size). If both <i>dwMinimumWorkingSetSize</i> and
///                              <i>dwMaximumWorkingSetSize</i> have the value (<b>SIZE_T</b>)–1, the function removes as many pages as possible
///                              from the working set of the specified process.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Call
///    GetLastError to obtain extended error information.
///    
@DllImport("KERNEL32")
BOOL SetProcessWorkingSetSize(HANDLE hProcess, size_t dwMinimumWorkingSetSize, size_t dwMaximumWorkingSetSize);

///Schedules a fiber. The function must be called on a fiber.
///Params:
///    lpFiber = The address of the fiber to be scheduled.
@DllImport("KERNEL32")
void SwitchToFiber(void* lpFiber);

///Deletes an existing fiber.
///Params:
///    lpFiber = The address of the fiber to be deleted.
@DllImport("KERNEL32")
void DeleteFiber(void* lpFiber);

///Converts the current fiber into a thread.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL ConvertFiberToThread();

///Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address,
///typically the fiber function. This function does not schedule the fiber.
///Params:
///    dwStackCommitSize = The initial commit size of the stack, in bytes. If this parameter is zero, the new fiber uses the default commit
///                        stack size for the executable. For more information, see Thread Stack Size.
///    dwStackReserveSize = The initial reserve size of the stack, in bytes. If this parameter is zero, the new fiber uses the default
///                         reserved stack size for the executable. For more information, see Thread Stack Size.
///    dwFlags = If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a
///              fiber uses floating-point arithmetic. If this parameter is <b>FIBER_FLAG_FLOAT_SWITCH</b>, the floating-point
///              state is switched for the fiber. <b>Windows XP: </b>The <b>FIBER_FLAG_FLOAT_SWITCH</b> flag is not supported.
///    lpStartAddress = A pointer to the application-defined function to be executed by the fiber and represents the starting address of
///                     the fiber. Execution of the newly created fiber does not begin until another fiber calls the SwitchToFiber
///                     function with this address. For more information on the fiber callback function, see FiberProc.
///    lpParameter = A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the GetFiberData
///                  macro.
///Returns:
///    If the function succeeds, the return value is the address of the fiber. If the function fails, the return value
///    is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* CreateFiberEx(size_t dwStackCommitSize, size_t dwStackReserveSize, uint dwFlags, 
                    LPFIBER_START_ROUTINE lpStartAddress, void* lpParameter);

///Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other
///fibers.
///Params:
///    lpParameter = A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the GetFiberData
///                  macro.
///    dwFlags = If this parameter is zero, the floating-point state on x86 systems is not switched and data can be corrupted if a
///              fiber uses floating-point arithmetic. If this parameter is FIBER_FLAG_FLOAT_SWITCH, the floating-point state is
///              switched for the fiber.
///Returns:
///    If the function succeeds, the return value is the address of the fiber. If the function fails, the return value
///    is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* ConvertThreadToFiberEx(void* lpParameter, uint dwFlags);

///Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address,
///typically the fiber function. This function does not schedule the fiber. To specify both a commit and reserve stack
///size, use the CreateFiberEx function.
///Params:
///    dwStackSize = The initial committed size of the stack, in bytes. If this parameter is zero, the new fiber uses the default
///                  commit stack size for the executable. For more information, see Thread Stack Size.
///    lpStartAddress = A pointer to the application-defined function to be executed by the fiber and represents the starting address of
///                     the fiber. Execution of the newly created fiber does not begin until another fiber calls the SwitchToFiber
///                     function with this address. For more information of the fiber callback function, see FiberProc.
///    lpParameter = A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the GetFiberData
///                  macro.
///Returns:
///    If the function succeeds, the return value is the address of the fiber. If the function fails, the return value
///    is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* CreateFiber(size_t dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, void* lpParameter);

///Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other
///fibers.
///Params:
///    lpParameter = A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the GetFiberData
///                  macro.
///Returns:
///    If the function succeeds, the return value is the address of the fiber. If the function fails, the return value
///    is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* ConvertThreadToFiber(void* lpParameter);

///Creates a user-mode scheduling (UMS) completion list.
///Params:
///    UmsCompletionList = A <b>PUMS_COMPLETION_LIST</b> variable. On output, this parameter receives a pointer to an empty UMS completion
///                        list.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Possible error values include the following. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory is available to create the
///    completion list. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL CreateUmsCompletionList(void** UmsCompletionList);

///Retrieves user-mode scheduling (UMS) worker threads from the specified UMS completion list.
///Params:
///    UmsCompletionList = A pointer to the completion list from which to retrieve worker threads.
///    WaitTimeOut = The time-out interval for the retrieval operation, in milliseconds. The function returns if the interval elapses,
///                  even if no worker threads are queued to the completion list. If the <i>WaitTimeOut</i> parameter is zero, the
///                  completion list is checked for available worker threads without waiting for worker threads to become available.
///                  If the <i>WaitTimeOut</i> parameter is INFINITE, the function's time-out interval never elapses. This is not
///                  recommended, however, because it causes the function to block until one or more worker threads become available.
///    UmsThreadList = A pointer to a UMS_CONTEXT variable. On output, this parameter receives a pointer to the first UMS thread context
///                    in a list of UMS thread contexts. If no worker threads are available before the time-out specified by the
///                    <i>WaitTimeOut</i> parameter, this parameter is set to NULL.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Possible error values include the following. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_TIMEOUT</b></dt> </dl>
///    </td> <td width="60%"> No threads became available before the specified time-out interval elapsed. </td> </tr>
///    </table>
///    
@DllImport("KERNEL32")
BOOL DequeueUmsCompletionListItems(void* UmsCompletionList, uint WaitTimeOut, void** UmsThreadList);

///Retrieves a handle to the event associated with the specified user-mode scheduling (UMS) completion list.
///Params:
///    UmsCompletionList = A pointer to a UMS completion list. The CreateUmsCompletionList function provides this pointer.
///    UmsCompletionEvent = A pointer to a HANDLE variable. On output, the <i>UmsCompletionEvent</i> parameter is set to a handle to the
///                         event associated with the specified completion list.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetUmsCompletionListEvent(void* UmsCompletionList, HANDLE* UmsCompletionEvent);

///Runs the specified UMS worker thread.
///Params:
///    UmsThread = A pointer to the UMS thread context of the worker thread to run.
///Returns:
///    If the function succeeds, it does not return a value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Possible error codes include the following. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_RETRY</b></dt> </dl>
///    </td> <td width="60%"> The specified UMS worker thread is temporarily locked by the system. The caller can retry
///    the operation. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL ExecuteUmsThread(void* UmsThread);

///Yields control to the user-mode scheduling (UMS) scheduler thread on which the calling UMS worker thread is running.
///Params:
///    SchedulerParam = A parameter to pass to the scheduler thread's UmsSchedulerProc function.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL UmsThreadYield(void* SchedulerParam);

///Deletes the specified user-mode scheduling (UMS) completion list. The list must be empty.
///Params:
///    UmsCompletionList = A pointer to the UMS completion list to be deleted. The CreateUmsCompletionList function provides this pointer.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteUmsCompletionList(void* UmsCompletionList);

///Returns the user-mode scheduling (UMS) thread context of the calling UMS thread.
///Returns:
///    The function returns a pointer to the UMS thread context of the calling thread. If calling thread is not a UMS
///    thread, the function returns NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* GetCurrentUmsThread();

///Returns the next user-mode scheduling (UMS) thread context in a list of thread contexts.
///Params:
///    UmsContext = A pointer to a UMS context in a list of thread contexts. This list is retrieved by the
///                 DequeueUmsCompletionListItems function.
///Returns:
///    If the function succeeds, it returns a pointer to the next thread context in the list. If there is no thread
///    context after the context specified by the <i>UmsContext</i> parameter, the function returns NULL. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
void* GetNextUmsListItem(void* UmsContext);

///Retrieves information about the specified user-mode scheduling (UMS) worker thread.
///Params:
///    UmsThread = A pointer to a UMS thread context.
///    UmsThreadInfoClass = A UMS_THREAD_INFO_CLASS value that specifies the kind of information to retrieve.
///    UmsThreadInformation = A pointer to a buffer to receive the specified information. The required size of this buffer depends on the
///                           specified information class. If the information class is <b>UmsThreadContext</b> or <b>UmsThreadTeb</b>, the
///                           buffer must be <code>sizeof(PVOID)</code>. If the information class is <b>UmsThreadIsSuspended</b> or
///                           <b>UmsThreadIsTerminated</b>, the buffer must be <code>sizeof(BOOLEAN)</code>.
///    UmsThreadInformationLength = The size of the <i>UmsThreadInformation</i> buffer, in bytes.
///    ReturnLength = A pointer to a ULONG variable. On output, this parameter receives the number of bytes written to the
///                   <i>UmsThreadInformation</i> buffer.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Possible error values include the following. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INFO_LENGTH_MISMATCH</b></dt> </dl> </td> <td width="60%"> The buffer is too small for the requested
///    information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_INFO_CLASS</b></dt> </dl> </td> <td
///    width="60%"> The specified information class is not supported. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL QueryUmsThreadInformation(void* UmsThread, RTL_UMS_THREAD_INFO_CLASS UmsThreadInfoClass, 
                               void* UmsThreadInformation, uint UmsThreadInformationLength, uint* ReturnLength);

///Sets application-specific context information for the specified user-mode scheduling (UMS) worker thread.
///Params:
///    UmsThread = A pointer to a UMS thread context.
///    UmsThreadInfoClass = A UMS_THREAD_INFO_CLASS value that specifies the kind of information to set. This parameter must be
///                         <b>UmsThreadUserContext</b>.
///    UmsThreadInformation = A pointer to a buffer that contains the information to set.
///    UmsThreadInformationLength = The size of the <i>UmsThreadInformation</i> buffer, in bytes.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Possible error values include the following. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INFO_LENGTH_MISMATCH</b></dt> </dl> </td> <td width="60%"> The buffer size does not match the
///    required size for the specified information class. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INVALID_INFO_CLASS</b></dt> </dl> </td> <td width="60%"> The <i>UmsThreadInfoClass</i> parameter
///    specifies an information class that is not supported. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL SetUmsThreadInformation(void* UmsThread, RTL_UMS_THREAD_INFO_CLASS UmsThreadInfoClass, 
                             void* UmsThreadInformation, uint UmsThreadInformationLength);

///Deletes the specified user-mode scheduling (UMS) thread context. The thread must be terminated.
///Params:
///    UmsThread = A pointer to the UMS thread context to be deleted. The CreateUmsThreadContext function provides this pointer.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteUmsThreadContext(void* UmsThread);

///Creates a user-mode scheduling (UMS) thread context to represent a UMS worker thread.
///Params:
///    lpUmsThread = A PUMS_CONTEXT variable. On output, this parameter receives a pointer to a UMS thread context.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Possible error values include the following. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough memory is available to create the
///    UMS thread context. </td> </tr> </table>
///    
@DllImport("KERNEL32")
BOOL CreateUmsThreadContext(void** lpUmsThread);

///Converts the calling thread into a user-mode scheduling (UMS) scheduler thread.
///Params:
///    SchedulerStartupInfo = A pointer to a UMS_SCHEDULER_STARTUP_INFO structure that specifies UMS attributes for the thread, including a
///                           completion list and a UmsSchedulerProc entry point function.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL EnterUmsSchedulingMode(UMS_SCHEDULER_STARTUP_INFO* SchedulerStartupInfo);

///Queries whether the specified thread is a UMS scheduler thread, a UMS worker thread, or a non-UMS thread.
///Params:
///    ThreadHandle = A handle to a thread. The thread handle must have the THREAD_QUERY_INFORMATION access right. For more
///                   information, see Thread Security and Access Rights.
///    SystemThreadInfo = A pointer to an initialized UMS_SYSTEM_THREAD_INFORMATION structure that specifies the kind of thread for the
///                       query.
///Returns:
///    Returns TRUE if the specified thread matches the kind of thread specified by the <i>SystemThreadInfo</i>
///    parameter. Otherwise, the function returns FALSE.
///    
@DllImport("KERNEL32")
BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, UMS_SYSTEM_THREAD_INFORMATION* SystemThreadInfo);

///Sets a processor affinity mask for the specified thread.
///Params:
///    hThread = A handle to the thread whose affinity mask is to be set. This handle must have the <b>THREAD_SET_INFORMATION</b>
///              or <b>THREAD_SET_LIMITED_INFORMATION</b> access right and the <b>THREAD_QUERY_INFORMATION</b> or
///              <b>THREAD_QUERY_LIMITED_INFORMATION</b> access right. For more information, see Thread Security and Access
///              Rights. <b>Windows Server 2003 and Windows XP: </b>The handle must have the <b>THREAD_SET_INFORMATION</b> and
///              <b>THREAD_QUERY_INFORMATION</b> access rights.
///    dwThreadAffinityMask = The affinity mask for the thread. On a system with more than 64 processors, the affinity mask must specify
///                           processors in the thread's current processor group.
///Returns:
///    If the function succeeds, the return value is the thread's previous affinity mask. If the function fails, the
///    return value is zero. To get extended error information, call GetLastError. If the thread affinity mask requests
///    a processor that is not selected for the process affinity mask, the last error code is
///    <b>ERROR_INVALID_PARAMETER</b>.
///    
@DllImport("KERNEL32")
size_t SetThreadAffinityMask(HANDLE hThread, size_t dwThreadAffinityMask);

///Changes data execution prevention (DEP) and DEP-ATL thunk emulation settings for a 32-bit process.
///Params:
///    dwFlags = A <b>DWORD</b> that can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///              </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> If the DEP system policy is OptIn or
///              OptOut and DEP is enabled for the process, setting <i>dwFlags</i> to 0 disables DEP for the process. </td> </tr>
///              <tr> <td width="40%"><a id="PROCESS_DEP_ENABLE"></a><a id="process_dep_enable"></a><dl>
///              <dt><b>PROCESS_DEP_ENABLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Enables DEP permanently on
///              the current process. After DEP has been enabled for the process by setting <b>PROCESS_DEP_ENABLE</b>, it cannot
///              be disabled for the life of the process. </td> </tr> <tr> <td width="40%"><a
///              id="PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION"></a><a id="process_dep_disable_atl_thunk_emulation"></a><dl>
///              <dt><b>PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Disables
///              DEP-ATL thunk emulation for the current process, which prevents the system from intercepting NX faults that
///              originate from the Active Template Library (ATL) thunk layer. For more information, see the Remarks section. This
///              flag can be specified only with <b>PROCESS_DEP_ENABLE</b>. </td> </tr> </table>
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve
///    error values defined for this function, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetProcessDEPPolicy(uint dwFlags);

///Gets the data execution prevention (DEP) and DEP-ATL thunk emulation settings for the specified 32-bit
///process.<b>Windows XP with SP3: </b>Gets the DEP and DEP-ATL thunk emulation settings for the current process.
///Params:
///    hProcess = A handle to the process. <b>PROCESS_QUERY_INFORMATION</b> privilege is required to get the DEP policy of a
///               process. <b>Windows XP with SP3: </b>The <i>hProcess</i> parameter is ignored.
///    lpFlags = A <b>DWORD</b> that receives one or more of the following flags. <table> <tr> <th>Value</th> <th>Meaning</th>
///              </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> DEP is disabled for the specified
///              process. </td> </tr> <tr> <td width="40%"><a id="PROCESS_DEP_ENABLE"></a><a id="process_dep_enable"></a><dl>
///              <dt><b>PROCESS_DEP_ENABLE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> DEP is enabled for the
///              specified process. </td> </tr> <tr> <td width="40%"><a id="PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION"></a><a
///              id="process_dep_disable_atl_thunk_emulation"></a><dl> <dt><b>PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION</b></dt>
///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> DEP-ATL thunk emulation is disabled for the specified process.
///              For information about DEP-ATL thunk emulation, see SetProcessDEPPolicy. </td> </tr> </table>
///    lpPermanent = <b>TRUE</b> if DEP is enabled or disabled permanently for the specified process; otherwise <b>FALSE</b>. If
///                  <i>lpPermanent</i> is <b>TRUE</b>, the current DEP setting persists for the life of the process and cannot be
///                  changed by calling SetProcessDEPPolicy.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>. To retrieve
///    error values defined for this function, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetProcessDEPPolicy(HANDLE hProcess, uint* lpFlags, BOOL* lpPermanent);

///<p class="CCE_Message">[<b>RequestWakeupLatency</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions.] Has no effect and returns
///<b>STATUS_NOT_SUPPORTED</b>. This function is provided only for compatibility with earlier versions of Windows.
///<b>Windows Server 2008 and Windows Vista: </b>Has no effect and always returns success.
///Params:
///    latency = The latency requirement for the time is takes to wake the computer. This parameter can be one of the following
///              values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LT_LOWEST_LATENCY"></a><a
///              id="lt_lowest_latency"></a><dl> <dt><b>LT_LOWEST_LATENCY</b></dt> <dt>1</dt> </dl> </td> <td width="60%">
///              PowerSystemSleeping1 state (equivalent to ACPI state S0 and APM state Working). </td> </tr> <tr> <td
///              width="40%"><a id="LT_DONT_CARE"></a><a id="lt_dont_care"></a><dl> <dt><b>LT_DONT_CARE</b></dt> <dt>0</dt> </dl>
///              </td> <td width="60%"> Any latency (default). </td> </tr> </table>
///Returns:
///    The return value is nonzero.
///    
@DllImport("KERNEL32")
BOOL RequestWakeupLatency(LATENCY_TIME latency);

///Determines the current state of the computer.
///Returns:
///    If the system was restored to the working state automatically and the user is not active, the function returns
///    <b>TRUE</b>. Otherwise, the function returns <b>FALSE</b>.
///    
@DllImport("KERNEL32")
BOOL IsSystemResumeAutomatic();

///Enables an application to inform the system that it is in use, thereby preventing the system from entering sleep or
///turning off the display while the application is running.
///Params:
///    esFlags = The thread's execution requirements. This parameter can be one or more of the following values. <table> <tr>
///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="ES_AWAYMODE_REQUIRED"></a><a
///              id="es_awaymode_required"></a><dl> <dt><b>ES_AWAYMODE_REQUIRED</b></dt> <dt>0x00000040</dt> </dl> </td> <td
///              width="60%"> Enables away mode. This value must be specified with <b>ES_CONTINUOUS</b>. Away mode should be used
///              only by media-recording and media-distribution applications that must perform critical background processing on
///              desktop computers while the computer appears to be sleeping. See Remarks. </td> </tr> <tr> <td width="40%"><a
///              id="ES_CONTINUOUS"></a><a id="es_continuous"></a><dl> <dt><b>ES_CONTINUOUS</b></dt> <dt>0x80000000</dt> </dl>
///              </td> <td width="60%"> Informs the system that the state being set should remain in effect until the next call
///              that uses <b>ES_CONTINUOUS</b> and one of the other state flags is cleared. </td> </tr> <tr> <td width="40%"><a
///              id="ES_DISPLAY_REQUIRED"></a><a id="es_display_required"></a><dl> <dt><b>ES_DISPLAY_REQUIRED</b></dt>
///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> Forces the display to be on by resetting the display idle timer.
///              </td> </tr> <tr> <td width="40%"><a id="ES_SYSTEM_REQUIRED"></a><a id="es_system_required"></a><dl>
///              <dt><b>ES_SYSTEM_REQUIRED</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Forces the system to be in
///              the working state by resetting the system idle timer. </td> </tr> <tr> <td width="40%"><a
///              id="ES_USER_PRESENT"></a><a id="es_user_present"></a><dl> <dt><b>ES_USER_PRESENT</b></dt> <dt>0x00000004</dt>
///              </dl> </td> <td width="60%"> This value is not supported. If <b>ES_USER_PRESENT</b> is combined with other
///              <i>esFlags</i> values, the call will fail and none of the specified states will be set. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is the previous thread execution state. If the function fails, the
///    return value is <b>NULL</b>.
///    
@DllImport("KERNEL32")
uint SetThreadExecutionState(uint esFlags);

///Creates a new power request object.
///Params:
///    Context = Points to a REASON_CONTEXT structure that contains information about the power request.
///Returns:
///    If the function succeeds, the return value is a handle to the power request object. If the function fails, the
///    return value is INVALID_HANDLE_VALUE. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE PowerCreateRequest(REASON_CONTEXT* Context);

///Increments the count of power requests of the specified type for a power request object.
///Params:
///    PowerRequest = A handle to a power request object.
///    RequestType = The power request type to be incremented. This parameter can be one of the following values.
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, it returns zero. To get extended
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);

///Decrements the count of power requests of the specified type for a power request object.
///Params:
///    PowerRequest = A handle to a power request object.
///    RequestType = The power request type to be decremented. This parameter can be one of the following values. <table> <tr>
///                  <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PowerRequestDisplayRequired"></a><a
///                  id="powerrequestdisplayrequired"></a><a id="POWERREQUESTDISPLAYREQUIRED"></a><dl>
///                  <dt><b>PowerRequestDisplayRequired</b></dt> </dl> </td> <td width="60%"> The display remains on even if there is
///                  no user input for an extended period of time. </td> </tr> <tr> <td width="40%"><a
///                  id="PowerRequestSystemRequired"></a><a id="powerrequestsystemrequired"></a><a
///                  id="POWERREQUESTSYSTEMREQUIRED"></a><dl> <dt><b>PowerRequestSystemRequired</b></dt> </dl> </td> <td width="60%">
///                  The system continues to run instead of entering sleep after a period of user inactivity. </td> </tr> <tr> <td
///                  width="40%"><a id="PowerRequestAwayModeRequired"></a><a id="powerrequestawaymoderequired"></a><a
///                  id="POWERREQUESTAWAYMODEREQUIRED"></a><dl> <dt><b>PowerRequestAwayModeRequired</b></dt> </dl> </td> <td
///                  width="60%"> The system enters away mode instead of sleep. In away mode, the system continues to run but turns
///                  off audio and video to give the appearance of sleep. </td> </tr> <tr> <td width="40%"><a
///                  id="PowerRequestExecutionRequired"></a><a id="powerrequestexecutionrequired"></a><a
///                  id="POWERREQUESTEXECUTIONREQUIRED"></a><dl> <dt><b>PowerRequestExecutionRequired</b></dt> </dl> </td> <td
///                  width="60%"> The calling process continues to run instead of being suspended or terminated by process lifetime
///                  management mechanisms. When and how long the process is allowed to run depends on the operating system and power
///                  policy settings. When a <b>PowerRequestExecutionRequired</b> request is active, it implies
///                  <b>PowerRequestSystemRequired</b>. The <b>PowerRequestExecutionRequired</b> request type can be used only by
///                  applications. Services cannot use this request type. <b>Windows 7 and Windows Server 2008 R2: </b>This request
///                  type is supported starting with Windows 8 and Windows Server 2012. </td> </tr> </table>
///Returns:
///    If the function succeeds, it returns a nonzero value. If the function fails, it returns zero. To get extended
///    error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);

///Sets the specified event object to the signaled state and then resets it to the nonsignaled state after releasing the
///appropriate number of waiting threads. <div class="alert"><b>Note</b> This function is unreliable and should not be
///used. It exists mainly for backward compatibility. For more information, see Remarks.</div><div> </div>
///Params:
///    hEvent = A handle to the event object. The CreateEvent or OpenEvent function returns this handle. The handle must have the
///             EVENT_MODIFY_STATE access right. For more information, see Synchronization Object Security and Access Rights.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL PulseEvent(HANDLE hEvent);

///Retrieves the current power state of the specified device. This function cannot be used to query the power state of a
///display device.
///Params:
///    hDevice = A handle to an object on the device, such as a file or socket, or a handle to the device itself.
///    pfOn = A pointer to the variable that receives the power state. This value is <b>TRUE</b> if the device is in the
///           working state. Otherwise, it is <b>FALSE</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.
///    
@DllImport("KERNEL32")
BOOL GetDevicePowerState(HANDLE hDevice, BOOL* pfOn);

///Loads and executes an application or creates a new instance of an existing application. <div
///class="alert"><b>Note</b> This function is provided only for compatibility with 16-bit versions of Windows.
///Applications should use the CreateProcess function.</div><div> </div>
///Params:
///    lpModuleName = The file name of the application to be run. When specifying a path, be sure to use backslashes (\\), not forward
///                   slashes (/). If the <i>lpModuleName</i> parameter does not contain a directory path, the system searches for the
///                   executable file in this order: <ol> <li>The directory from which the application loaded.</li> <li>The current
///                   directory.</li> <li>The system directory. Use the GetSystemDirectory function to get the path of this directory.
///                   </li> <li> The 16-bit system directory. There is no function that obtains the path of this directory, but it is
///                   searched. The name of this directory is System.</li> <li>The Windows directory. Use the GetWindowsDirectory
///                   function to get the path of this directory.</li> <li>The directories that are listed in the PATH environment
///                   variable.</li> </ol>
///    lpParameterBlock = A pointer to an application-defined <b>LOADPARMS32</b> structure that defines the new application's parameter
///                       block. Set all unused members to NULL, except for <b>lpCmdLine</b>, which must point to a null-terminated string
///                       if it is not used. For more information, see Remarks.
///Returns:
///    If the function succeeds, the return value is greater than 31. If the function fails, the return value is an
///    error value, which may be one of the following values. <table> <tr> <th>Return code/value</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The system is out
///    of memory or resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_FORMAT</b></dt> <dt>11L</dt>
///    </dl> </td> <td width="60%"> The .exe file is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILE_NOT_FOUND</b></dt> <dt>2L</dt> </dl> </td> <td width="60%"> The specified file was not found.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt> <dt>3L</dt> </dl> </td> <td
///    width="60%"> The specified path was not found. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint LoadModule(const(PSTR) lpModuleName, void* lpParameterBlock);

///Runs the specified application. <div class="alert"><b>Note</b> This function is provided only for compatibility with
///16-bit Windows. Applications should use the CreateProcess function.</div><div> </div>
///Params:
///    lpCmdLine = The command line (file name plus optional parameters) for the application to be executed. If the name of the
///                executable file in the <i>lpCmdLine</i> parameter does not contain a directory path, the system searches for the
///                executable file in this sequence: <ol> <li>The directory from which the application loaded.</li> <li>The current
///                directory.</li> <li>The Windows system directory. The GetSystemDirectory function retrieves the path of this
///                directory.</li> <li>The Windows directory. The GetWindowsDirectory function retrieves the path of this
///                directory.</li> <li>The directories listed in the PATH environment variable.</li> </ol>
///    uCmdShow = The display options. For a list of the acceptable values, see the description of the <i>nCmdShow</i> parameter of
///               the ShowWindow function.
///Returns:
///    If the function succeeds, the return value is greater than 31. If the function fails, the return value is one of
///    the following error values. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The system is out of memory or resources. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_BAD_FORMAT</b></dt> </dl> </td> <td width="60%"> The .exe file is
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_FILE_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
///    The specified file was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
///    </dl> </td> <td width="60%"> The specified path was not found. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint WinExec(const(PSTR) lpCmdLine, uint uCmdShow);

///Restores character transmission for a specified communications device and places the transmission line in a nonbreak
///state.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL ClearCommBreak(HANDLE hFile);

///Retrieves information about a communications error and reports the current status of a communications device. The
///function is called when a communications error occurs, and it clears the device's error flag to enable additional
///input and output (I/O) operations.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    lpErrors = A pointer to a variable that receives a mask indicating the type of error. This parameter can be one or more of
///               the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///               id="CE_BREAK"></a><a id="ce_break"></a><dl> <dt><b>CE_BREAK</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%">
///               The hardware detected a break condition. </td> </tr> <tr> <td width="40%"><a id="CE_FRAME"></a><a
///               id="ce_frame"></a><dl> <dt><b>CE_FRAME</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> The hardware
///               detected a framing error. </td> </tr> <tr> <td width="40%"><a id="CE_OVERRUN"></a><a id="ce_overrun"></a><dl>
///               <dt><b>CE_OVERRUN</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> A character-buffer overrun has occurred.
///               The next character is lost. </td> </tr> <tr> <td width="40%"><a id="CE_RXOVER"></a><a id="ce_rxover"></a><dl>
///               <dt><b>CE_RXOVER</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> An input buffer overflow has occurred.
///               There is either no room in the input buffer, or a character was received after the end-of-file (EOF) character.
///               </td> </tr> <tr> <td width="40%"><a id="CE_RXPARITY"></a><a id="ce_rxparity"></a><dl> <dt><b>CE_RXPARITY</b></dt>
///               <dt>0x0004</dt> </dl> </td> <td width="60%"> The hardware detected a parity error. </td> </tr> </table> The
///               following values are not supported:
///    lpStat = A pointer to a COMSTAT structure in which the device's status information is returned. If this parameter is
///             <b>NULL</b>, no status information is returned.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL ClearCommError(HANDLE hFile, uint* lpErrors, COMSTAT* lpStat);

///Initializes the communications parameters for a specified communications device.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    dwInQueue = The recommended size of the device's internal input buffer, in bytes.
///    dwOutQueue = The recommended size of the device's internal output buffer, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetupComm(HANDLE hFile, uint dwInQueue, uint dwOutQueue);

///Directs the specified communications device to perform an extended function.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    dwFunc = The extended function to be performed. This parameter can be one of the following values. <table> <tr>
///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="CLRBREAK"></a><a id="clrbreak"></a><dl>
///             <dt><b>CLRBREAK</b></dt> <dt>9</dt> </dl> </td> <td width="60%"> Restores character transmission and places the
///             transmission line in a nonbreak state. The CLRBREAK extended function code is identical to the ClearCommBreak
///             function. </td> </tr> <tr> <td width="40%"><a id="CLRDTR"></a><a id="clrdtr"></a><dl> <dt><b>CLRDTR</b></dt>
///             <dt>6</dt> </dl> </td> <td width="60%"> Clears the DTR (data-terminal-ready) signal. </td> </tr> <tr> <td
///             width="40%"><a id="CLRRTS"></a><a id="clrrts"></a><dl> <dt><b>CLRRTS</b></dt> <dt>4</dt> </dl> </td> <td
///             width="60%"> Clears the RTS (request-to-send) signal. </td> </tr> <tr> <td width="40%"><a id="SETBREAK"></a><a
///             id="setbreak"></a><dl> <dt><b>SETBREAK</b></dt> <dt>8</dt> </dl> </td> <td width="60%"> Suspends character
///             transmission and places the transmission line in a break state until the ClearCommBreak function is called (or
///             <b>EscapeCommFunction</b> is called with the CLRBREAK extended function code). The SETBREAK extended function
///             code is identical to the SetCommBreak function. Note that this extended function does not flush data that has not
///             been transmitted. </td> </tr> <tr> <td width="40%"><a id="SETDTR"></a><a id="setdtr"></a><dl>
///             <dt><b>SETDTR</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Sends the DTR (data-terminal-ready) signal. </td>
///             </tr> <tr> <td width="40%"><a id="SETRTS"></a><a id="setrts"></a><dl> <dt><b>SETRTS</b></dt> <dt>3</dt> </dl>
///             </td> <td width="60%"> Sends the RTS (request-to-send) signal. </td> </tr> <tr> <td width="40%"><a
///             id="SETXOFF"></a><a id="setxoff"></a><dl> <dt><b>SETXOFF</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Causes
///             transmission to act as if an XOFF character has been received. </td> </tr> <tr> <td width="40%"><a
///             id="SETXON"></a><a id="setxon"></a><dl> <dt><b>SETXON</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> Causes
///             transmission to act as if an XON character has been received. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL EscapeCommFunction(HANDLE hFile, uint dwFunc);

///Retrieves the current configuration of a communications device. To retrieve the default configuration settings from
///the device manager, use the GetDefaultCommConfig function.
///Params:
///    hCommDev = A handle to the open communications device. The CreateFile function returns this handle.
///    lpCC = A pointer to a buffer that receives a COMMCONFIG structure.
///    lpdwSize = The size, in bytes, of the buffer pointed to by <i>lpCC</i>. When the function returns, the variable contains the
///               number of bytes copied if the function succeeds, or the number of bytes required if the buffer was too small.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, use the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL GetCommConfig(HANDLE hCommDev, COMMCONFIG* lpCC, uint* lpdwSize);

///Retrieves the value of the event mask for a specified communications device.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    lpEvtMask = A pointer to the variable that receives a mask of events that are currently enabled. This parameter can be one or
///                more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                id="EV_BREAK"></a><a id="ev_break"></a><dl> <dt><b>EV_BREAK</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%">
///                A break was detected on input. </td> </tr> <tr> <td width="40%"><a id="EV_CTS"></a><a id="ev_cts"></a><dl>
///                <dt><b>EV_CTS</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> The CTS (clear-to-send) signal changed state.
///                </td> </tr> <tr> <td width="40%"><a id="EV_DSR"></a><a id="ev_dsr"></a><dl> <dt><b>EV_DSR</b></dt>
///                <dt>0x0010</dt> </dl> </td> <td width="60%"> The DSR (data-set-ready) signal changed state. </td> </tr> <tr> <td
///                width="40%"><a id="EV_ERR"></a><a id="ev_err"></a><dl> <dt><b>EV_ERR</b></dt> <dt>0x0080</dt> </dl> </td> <td
///                width="60%"> A line-status error occurred. Line-status errors are <b>CE_FRAME</b>, <b>CE_OVERRUN</b>, and
///                <b>CE_RXPARITY</b>. </td> </tr> <tr> <td width="40%"><a id="EV_EVENT1"></a><a id="ev_event1"></a><dl>
///                <dt><b>EV_EVENT1</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> An event of the first provider-specific
///                type occurred. </td> </tr> <tr> <td width="40%"><a id="EV_EVENT2"></a><a id="ev_event2"></a><dl>
///                <dt><b>EV_EVENT2</b></dt> <dt>0x1000</dt> </dl> </td> <td width="60%"> An event of the second provider-specific
///                type occurred. </td> </tr> <tr> <td width="40%"><a id="EV_PERR"></a><a id="ev_perr"></a><dl>
///                <dt><b>EV_PERR</b></dt> <dt>0x0200</dt> </dl> </td> <td width="60%"> A printer error occurred. </td> </tr> <tr>
///                <td width="40%"><a id="EV_RING"></a><a id="ev_ring"></a><dl> <dt><b>EV_RING</b></dt> <dt>0x0100</dt> </dl> </td>
///                <td width="60%"> A ring indicator was detected. </td> </tr> <tr> <td width="40%"><a id="EV_RLSD"></a><a
///                id="ev_rlsd"></a><dl> <dt><b>EV_RLSD</b></dt> <dt>0x0020</dt> </dl> </td> <td width="60%"> The RLSD
///                (receive-line-signal-detect) signal changed state. </td> </tr> <tr> <td width="40%"><a id="EV_RX80FULL"></a><a
///                id="ev_rx80full"></a><dl> <dt><b>EV_RX80FULL</b></dt> <dt>0x0400</dt> </dl> </td> <td width="60%"> The receive
///                buffer is 80 percent full. </td> </tr> <tr> <td width="40%"><a id="EV_RXCHAR"></a><a id="ev_rxchar"></a><dl>
///                <dt><b>EV_RXCHAR</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> A character was received and placed in the
///                input buffer. </td> </tr> <tr> <td width="40%"><a id="EV_RXFLAG"></a><a id="ev_rxflag"></a><dl>
///                <dt><b>EV_RXFLAG</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> The event character was received and
///                placed in the input buffer. The event character is specified in the device's DCB structure, which is applied to a
///                serial port by using the SetCommState function. </td> </tr> <tr> <td width="40%"><a id="EV_TXEMPTY"></a><a
///                id="ev_txempty"></a><dl> <dt><b>EV_TXEMPTY</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> The last
///                character in the output buffer was sent. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetCommMask(HANDLE hFile, uint* lpEvtMask);

///Retrieves information about the communications properties for a specified communications device.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    lpCommProp = A pointer to a COMMPROP structure in which the communications properties information is returned. This
///                 information can be used in subsequent calls to the SetCommState, SetCommTimeouts, or SetupComm function to
///                 configure the communications device.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetCommProperties(HANDLE hFile, COMMPROP* lpCommProp);

///Retrieves the modem control-register values.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    lpModemStat = A pointer to a variable that receives the current state of the modem control-register values. This parameter can
///                  be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                  width="40%"><a id="MS_CTS_ON"></a><a id="ms_cts_on"></a><dl> <dt><b>MS_CTS_ON</b></dt> <dt>0x0010</dt> </dl>
///                  </td> <td width="60%"> The CTS (clear-to-send) signal is on. </td> </tr> <tr> <td width="40%"><a
///                  id="MS_DSR_ON"></a><a id="ms_dsr_on"></a><dl> <dt><b>MS_DSR_ON</b></dt> <dt>0x0020</dt> </dl> </td> <td
///                  width="60%"> The DSR (data-set-ready) signal is on. </td> </tr> <tr> <td width="40%"><a id="MS_RING_ON"></a><a
///                  id="ms_ring_on"></a><dl> <dt><b>MS_RING_ON</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%"> The ring
///                  indicator signal is on. </td> </tr> <tr> <td width="40%"><a id="MS_RLSD_ON"></a><a id="ms_rlsd_on"></a><dl>
///                  <dt><b>MS_RLSD_ON</b></dt> <dt>0x0080</dt> </dl> </td> <td width="60%"> The RLSD (receive-line-signal-detect)
///                  signal is on. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetCommModemStatus(HANDLE hFile, uint* lpModemStat);

///Retrieves the current control settings for a specified communications device.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    lpDCB = A pointer to a DCB structure that receives the control settings information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetCommState(HANDLE hFile, DCB* lpDCB);

///Retrieves the time-out parameters for all read and write operations on a specified communications device.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    lpCommTimeouts = A pointer to a COMMTIMEOUTS structure in which the time-out information is returned.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetCommTimeouts(HANDLE hFile, COMMTIMEOUTS* lpCommTimeouts);

///Discards all characters from the output or input buffer of a specified communications resource. It can also terminate
///pending read or write operations on the resource.
///Params:
///    hFile = A handle to the communications resource. The CreateFile function returns this handle.
///    dwFlags = This parameter can be one or more of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///              <tr> <td width="40%"><a id="PURGE_RXABORT"></a><a id="purge_rxabort"></a><dl> <dt><b>PURGE_RXABORT</b></dt>
///              <dt>0x0002</dt> </dl> </td> <td width="60%"> Terminates all outstanding overlapped read operations and returns
///              immediately, even if the read operations have not been completed. </td> </tr> <tr> <td width="40%"><a
///              id="PURGE_RXCLEAR"></a><a id="purge_rxclear"></a><dl> <dt><b>PURGE_RXCLEAR</b></dt> <dt>0x0008</dt> </dl> </td>
///              <td width="60%"> Clears the input buffer (if the device driver has one). </td> </tr> <tr> <td width="40%"><a
///              id="PURGE_TXABORT"></a><a id="purge_txabort"></a><dl> <dt><b>PURGE_TXABORT</b></dt> <dt>0x0001</dt> </dl> </td>
///              <td width="60%"> Terminates all outstanding overlapped write operations and returns immediately, even if the
///              write operations have not been completed. </td> </tr> <tr> <td width="40%"><a id="PURGE_TXCLEAR"></a><a
///              id="purge_txclear"></a><dl> <dt><b>PURGE_TXCLEAR</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Clears the
///              output buffer (if the device driver has one). </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL PurgeComm(HANDLE hFile, uint dwFlags);

///Suspends character transmission for a specified communications device and places the transmission line in a break
///state until the ClearCommBreak function is called.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetCommBreak(HANDLE hFile);

///Sets the current configuration of a communications device.
///Params:
///    hCommDev = A handle to the open communications device. The CreateFile function returns this handle.
///    lpCC = A pointer to a COMMCONFIG structure.
///    dwSize = The size of the structure pointed to by <i>lpCC</i>, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetCommConfig(HANDLE hCommDev, COMMCONFIG* lpCC, uint dwSize);

///Specifies a set of events to be monitored for a communications device.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    dwEvtMask = The events to be enabled. A value of zero disables all events. This parameter can be one or more of the following
///                values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="EV_BREAK"></a><a
///                id="ev_break"></a><dl> <dt><b>EV_BREAK</b></dt> <dt>0x0040</dt> </dl> </td> <td width="60%"> A break was detected
///                on input. </td> </tr> <tr> <td width="40%"><a id="EV_CTS"></a><a id="ev_cts"></a><dl> <dt><b>EV_CTS</b></dt>
///                <dt>0x0008</dt> </dl> </td> <td width="60%"> The CTS (clear-to-send) signal changed state. </td> </tr> <tr> <td
///                width="40%"><a id="EV_DSR"></a><a id="ev_dsr"></a><dl> <dt><b>EV_DSR</b></dt> <dt>0x0010</dt> </dl> </td> <td
///                width="60%"> The DSR (data-set-ready) signal changed state. </td> </tr> <tr> <td width="40%"><a
///                id="EV_ERR"></a><a id="ev_err"></a><dl> <dt><b>EV_ERR</b></dt> <dt>0x0080</dt> </dl> </td> <td width="60%"> A
///                line-status error occurred. Line-status errors are <b>CE_FRAME</b>, <b>CE_OVERRUN</b>, and <b>CE_RXPARITY</b>.
///                </td> </tr> <tr> <td width="40%"><a id="EV_RING"></a><a id="ev_ring"></a><dl> <dt><b>EV_RING</b></dt>
///                <dt>0x0100</dt> </dl> </td> <td width="60%"> A ring indicator was detected. </td> </tr> <tr> <td width="40%"><a
///                id="EV_RLSD"></a><a id="ev_rlsd"></a><dl> <dt><b>EV_RLSD</b></dt> <dt>0x0020</dt> </dl> </td> <td width="60%">
///                The RLSD (receive-line-signal-detect) signal changed state. </td> </tr> <tr> <td width="40%"><a
///                id="EV_RXCHAR"></a><a id="ev_rxchar"></a><dl> <dt><b>EV_RXCHAR</b></dt> <dt>0x0001</dt> </dl> </td> <td
///                width="60%"> A character was received and placed in the input buffer. </td> </tr> <tr> <td width="40%"><a
///                id="EV_RXFLAG"></a><a id="ev_rxflag"></a><dl> <dt><b>EV_RXFLAG</b></dt> <dt>0x0002</dt> </dl> </td> <td
///                width="60%"> The event character was received and placed in the input buffer. The event character is specified in
///                the device's DCB structure, which is applied to a serial port by using the SetCommState function. </td> </tr>
///                <tr> <td width="40%"><a id="EV_TXEMPTY"></a><a id="ev_txempty"></a><dl> <dt><b>EV_TXEMPTY</b></dt>
///                <dt>0x0004</dt> </dl> </td> <td width="60%"> The last character in the output buffer was sent. </td> </tr>
///                </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetCommMask(HANDLE hFile, uint dwEvtMask);

///Configures a communications device according to the specifications in a device-control block (a DCB structure). The
///function reinitializes all hardware and control settings, but it does not empty output or input queues.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    lpDCB = A pointer to a DCB structure that contains the configuration information for the specified communications device.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetCommState(HANDLE hFile, DCB* lpDCB);

///Sets the time-out parameters for all read and write operations on a specified communications device.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    lpCommTimeouts = A pointer to a COMMTIMEOUTS structure that contains the new time-out values.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetCommTimeouts(HANDLE hFile, COMMTIMEOUTS* lpCommTimeouts);

///Transmits a specified character ahead of any pending data in the output buffer of the specified communications
///device.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    cChar = The character to be transmitted.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL TransmitCommChar(HANDLE hFile, byte cChar);

///Waits for an event to occur for a specified communications device. The set of events that are monitored by this
///function is contained in the event mask associated with the device handle.
///Params:
///    hFile = A handle to the communications device. The CreateFile function returns this handle.
///    lpEvtMask = A pointer to a variable that receives a mask indicating the type of event that occurred. If an error occurs, the
///                value is zero; otherwise, it is one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                <tr> <td width="40%"><a id="EV_BREAK"></a><a id="ev_break"></a><dl> <dt><b>EV_BREAK</b></dt> <dt>0x0040</dt>
///                </dl> </td> <td width="60%"> A break was detected on input. </td> </tr> <tr> <td width="40%"><a
///                id="EV_CTS"></a><a id="ev_cts"></a><dl> <dt><b>EV_CTS</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> The
///                CTS (clear-to-send) signal changed state. </td> </tr> <tr> <td width="40%"><a id="EV_DSR"></a><a
///                id="ev_dsr"></a><dl> <dt><b>EV_DSR</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> The DSR (data-set-ready)
///                signal changed state. </td> </tr> <tr> <td width="40%"><a id="EV_ERR"></a><a id="ev_err"></a><dl>
///                <dt><b>EV_ERR</b></dt> <dt>0x0080</dt> </dl> </td> <td width="60%"> A line-status error occurred. Line-status
///                errors are <b>CE_FRAME</b>, <b>CE_OVERRUN</b>, and <b>CE_RXPARITY</b>. </td> </tr> <tr> <td width="40%"><a
///                id="EV_RING"></a><a id="ev_ring"></a><dl> <dt><b>EV_RING</b></dt> <dt>0x0100</dt> </dl> </td> <td width="60%"> A
///                ring indicator was detected. </td> </tr> <tr> <td width="40%"><a id="EV_RLSD"></a><a id="ev_rlsd"></a><dl>
///                <dt><b>EV_RLSD</b></dt> <dt>0x0020</dt> </dl> </td> <td width="60%"> The RLSD (receive-line-signal-detect) signal
///                changed state. </td> </tr> <tr> <td width="40%"><a id="EV_RXCHAR"></a><a id="ev_rxchar"></a><dl>
///                <dt><b>EV_RXCHAR</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> A character was received and placed in the
///                input buffer. </td> </tr> <tr> <td width="40%"><a id="EV_RXFLAG"></a><a id="ev_rxflag"></a><dl>
///                <dt><b>EV_RXFLAG</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> The event character was received and
///                placed in the input buffer. The event character is specified in the device's DCB structure, which is applied to a
///                serial port by using the SetCommState function. </td> </tr> <tr> <td width="40%"><a id="EV_TXEMPTY"></a><a
///                id="ev_txempty"></a><dl> <dt><b>EV_TXEMPTY</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> The last
///                character in the output buffer was sent. </td> </tr> </table>
///    lpOverlapped = A pointer to an OVERLAPPED structure. This structure is required if <i>hFile</i> was opened with
///                   <b>FILE_FLAG_OVERLAPPED</b>. If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b>, the <i>lpOverlapped</i>
///                   parameter must not be <b>NULL</b>. It must point to a valid OVERLAPPED structure. If <i>hFile</i> was opened with
///                   <b>FILE_FLAG_OVERLAPPED</b> and <i>lpOverlapped</i> is <b>NULL</b>, the function can incorrectly report that the
///                   operation is complete. If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b> and <i>lpOverlapped</i> is not
///                   <b>NULL</b>, <b>WaitCommEvent</b> is performed as an overlapped operation. In this case, the OVERLAPPED structure
///                   must contain a handle to a manual-reset event object (created by using the CreateEvent function). If <i>hFile</i>
///                   was not opened with <b>FILE_FLAG_OVERLAPPED</b>, <b>WaitCommEvent</b> does not return until one of the specified
///                   events or an error occurs.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL WaitCommEvent(HANDLE hFile, uint* lpEvtMask, OVERLAPPED* lpOverlapped);

///Attempts to open a communication device.
///Params:
///    uPortNumber = A one-based port number for the communication device to open.
///    dwDesiredAccess = The requested access to the device. For more information about requested access, see CreateFile and Creating and
///                      Opening Files.
///    dwFlagsAndAttributes = The requested flags and attributes to the device. <div class="alert"><b>Note</b> <p class="note">For this
///                           function, only values of <b>FILE_FLAG_OVERLAPPED</b> or 0x0 are expected for this parameter. </div> <div> </div>
///                           <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a
///                           id="file_flag_overlapped"></a><dl> <dt><b>FILE_FLAG_OVERLAPPED</b></dt> <dt>0x40000000</dt> </dl> </td> <td
///                           width="60%"> The file or device is being opened or created for asynchronous I/O. </td> </tr> </table>
///Returns:
///    If the function succeeds, the function returns a valid <b>HANDLE</b>. Use CloseHandle to close that handle. If an
///    error occurs, the function returns <b>INVALID_HANDLE_VALUE</b>.
///    
@DllImport("api-ms-win-core-comm-l1-1-1")
HANDLE OpenCommPort(uint uPortNumber, uint dwDesiredAccess, uint dwFlagsAndAttributes);

///Gets an array that contains the well-formed COM ports. This function obtains the COM port numbers from the
///<b>HKLM\Hardware\DeviceMap\SERIALCOMM</b> registry key and then writes them to a caller-supplied array. If the array
///is too small, the function gets the necessary size. <div class="alert"><b>Note</b> If new entries are added to the
///registry key, the necessary size can change between API calls.</div><div> </div>
///Params:
///    lpPortNumbers = An array for the port numbers.
///    uPortNumbersCount = The length of the array in the <i>lpPortNumbers</i> parameter.
///    puPortNumbersFound = The number of port numbers written to the <i>lpPortNumbers</i> or the length of the array required for the port
///                         numbers.
@DllImport("api-ms-win-core-comm-l1-1-2")
uint GetCommPorts(uint* lpPortNumbers, uint uPortNumbersCount, uint* puPortNumbersFound);

///The <b>SetTapePosition</b> function sets the tape position on the specified device.
///Params:
///    hDevice = Handle to the device on which to set the tape position. This handle is created by using the CreateFile function.
///    dwPositionMethod = Type of positioning to perform. This parameter must be one of the following values. <table> <tr> <th>Value</th>
///                       <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_ABSOLUTE_BLOCK"></a><a id="tape_absolute_block"></a><dl>
///                       <dt><b>TAPE_ABSOLUTE_BLOCK</b></dt> <dt>1L</dt> </dl> </td> <td width="60%"> Moves the tape to the
///                       device-specific block address specified by the <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> parameters. The
///                       <i>dwPartition</i> parameter is ignored. </td> </tr> <tr> <td width="40%"><a id="TAPE_LOGICAL_BLOCK"></a><a
///                       id="tape_logical_block"></a><dl> <dt><b>TAPE_LOGICAL_BLOCK</b></dt> <dt>2L</dt> </dl> </td> <td width="60%">
///                       Moves the tape to the block address specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the partition
///                       specified by <i>dwPartition</i>. </td> </tr> <tr> <td width="40%"><a id="TAPE_REWIND"></a><a
///                       id="tape_rewind"></a><dl> <dt><b>TAPE_REWIND</b></dt> <dt>0L</dt> </dl> </td> <td width="60%"> Moves the tape to
///                       the beginning of the current partition. The <i>dwPartition</i>, <i>dwOffsetLow</i>, and <i>dwOffsetHigh</i>
///                       parameters are ignored. </td> </tr> <tr> <td width="40%"><a id="TAPE_SPACE_END_OF_DATA"></a><a
///                       id="tape_space_end_of_data"></a><dl> <dt><b>TAPE_SPACE_END_OF_DATA</b></dt> <dt>4L</dt> </dl> </td> <td
///                       width="60%"> Moves the tape to the end of the data on the partition specified by <i>dwPartition</i>. </td> </tr>
///                       <tr> <td width="40%"><a id="TAPE_SPACE_FILEMARKS"></a><a id="tape_space_filemarks"></a><dl>
///                       <dt><b>TAPE_SPACE_FILEMARKS</b></dt> <dt>6L</dt> </dl> </td> <td width="60%"> Moves the tape forward (or
///                       backward) the number of filemarks specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the current
///                       partition. The <i>dwPartition</i> parameter is ignored. </td> </tr> <tr> <td width="40%"><a
///                       id="TAPE_SPACE_RELATIVE_BLOCKS"></a><a id="tape_space_relative_blocks"></a><dl>
///                       <dt><b>TAPE_SPACE_RELATIVE_BLOCKS</b></dt> <dt>5L</dt> </dl> </td> <td width="60%"> Moves the tape forward (or
///                       backward) the number of blocks specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the current partition.
///                       The <i>dwPartition</i> parameter is ignored. </td> </tr> <tr> <td width="40%"><a
///                       id="TAPE_SPACE_SEQUENTIAL_FMKS"></a><a id="tape_space_sequential_fmks"></a><dl>
///                       <dt><b>TAPE_SPACE_SEQUENTIAL_FMKS</b></dt> <dt>7L</dt> </dl> </td> <td width="60%"> Moves the tape forward (or
///                       backward) to the first occurrence of n filemarks in the current partition, where n is the number specified by
///                       <i>dwOffsetLow</i> and <i>dwOffsetHigh</i>. The <i>dwPartition</i> parameter is ignored. </td> </tr> <tr> <td
///                       width="40%"><a id="TAPE_SPACE_SEQUENTIAL_SMKS"></a><a id="tape_space_sequential_smks"></a><dl>
///                       <dt><b>TAPE_SPACE_SEQUENTIAL_SMKS</b></dt> <dt>9L</dt> </dl> </td> <td width="60%"> Moves the tape forward (or
///                       backward) to the first occurrence of n setmarks in the current partition, where n is the number specified by
///                       <i>dwOffsetLow</i> and <i>dwOffsetHigh</i>. The <i>dwPartition</i> parameter is ignored. </td> </tr> <tr> <td
///                       width="40%"><a id="TAPE_SPACE_SETMARKS"></a><a id="tape_space_setmarks"></a><dl>
///                       <dt><b>TAPE_SPACE_SETMARKS</b></dt> <dt>8L</dt> </dl> </td> <td width="60%"> Moves the tape forward (or backward)
///                       the number of setmarks specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> in the current partition. The
///                       <i>dwPartition</i> parameter is ignored. </td> </tr> </table>
///    dwPartition = Partition to position within. If <i>dwPartition</i> is zero, the current partition is used. Partitions are
///                  numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last.
///    dwOffsetLow = Low-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i>
///                  parameter.
///    dwOffsetHigh = High-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i>
///                   parameter. If the high-order bits are not required, this parameter should be zero.
///    bImmediate = Indicates whether to return as soon as the move operation begins. If this parameter is <b>TRUE</b>, the function
///                 returns immediately; if <b>FALSE</b>, the function does not return until the move operation has been completed.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function fails, it can return one of the following
///    error codes. <table> <tr> <th>Error</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt> <dt>1102L</dt> </dl> </td> <td width="60%"> An attempt to access data
///    before the beginning-of-medium marker failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUS_RESET</b></dt> <dt>1111L</dt> </dl> </td> <td width="60%"> A reset condition was detected on the
///    bus. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt> <dt>1107L</dt> </dl>
///    </td> <td width="60%"> The partition information could not be found when a tape was being loaded. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_END_OF_MEDIA</b></dt> <dt>1100L</dt> </dl> </td> <td width="60%"> The
///    end-of-tape marker was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILEMARK_DETECTED</b></dt> <dt>1101L</dt> </dl> </td> <td width="60%"> A filemark was reached during
///    an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt> <dt>1106L</dt>
///    </dl> </td> <td width="60%"> The block size is incorrect on a new tape in a multivolume partition. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_MEDIA_CHANGED</b></dt> <dt>1110L</dt> </dl> </td> <td width="60%"> The
///    tape that was in the drive has been replaced or removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_DATA_DETECTED</b></dt> <dt>1104L</dt> </dl> </td> <td width="60%"> The end-of-data marker was
///    reached during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
///    <dt>1112L</dt> </dl> </td> <td width="60%"> There is no media in the drive. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> <dt>50L</dt> </dl> </td> <td width="60%"> The tape driver does not
///    support a requested function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PARTITION_FAILURE</b></dt>
///    <dt>1105L</dt> </dl> </td> <td width="60%"> The tape could not be partitioned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SETMARK_DETECTED</b></dt> <dt>1103L</dt> </dl> </td> <td width="60%"> A setmark was reached
///    during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
///    <dt>1108L</dt> </dl> </td> <td width="60%"> An attempt to lock the ejection mechanism failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt> <dt>1109L</dt> </dl> </td> <td width="60%"> An
///    attempt to unload the tape failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WRITE_PROTECT</b></dt>
///    <dt>19L</dt> </dl> </td> <td width="60%"> The media is write protected. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint SetTapePosition(HANDLE hDevice, uint dwPositionMethod, uint dwPartition, uint dwOffsetLow, uint dwOffsetHigh, 
                     BOOL bImmediate);

///The <b>GetTapePosition</b> function retrieves the current address of the tape, in logical or absolute blocks.
///Params:
///    hDevice = Handle to the device on which to get the tape position. This handle is created by using CreateFile.
///    dwPositionType = Type of address to obtain. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                     <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_ABSOLUTE_POSITION"></a><a
///                     id="tape_absolute_position"></a><dl> <dt><b>TAPE_ABSOLUTE_POSITION</b></dt> <dt>0L</dt> </dl> </td> <td
///                     width="60%"> The <i>lpdwOffsetLow</i> and <i>lpdwOffsetHigh</i> parameters receive the device-specific block
///                     address. The <i>dwPartition</i> parameter receives zero. </td> </tr> <tr> <td width="40%"><a
///                     id="TAPE_LOGICAL_POSITION"></a><a id="tape_logical_position"></a><dl> <dt><b>TAPE_LOGICAL_POSITION</b></dt>
///                     <dt>1L</dt> </dl> </td> <td width="60%"> The <i>lpdwOffsetLow</i> and <i>lpdwOffsetHigh</i> parameters receive
///                     the logical block address. The <i>dwPartition</i> parameter receives the logical tape partition. </td> </tr>
///                     </table>
///    lpdwPartition = Pointer to a variable that receives the number of the current tape partition. Partitions are numbered logically
///                    from 1 through n, where 1 is the first partition on the tape and n is the last. When a device-specific block
///                    address is retrieved, or if the device supports only one partition, this parameter receives zero.
///    lpdwOffsetLow = Pointer to a variable that receives the low-order bits of the current tape position.
///    lpdwOffsetHigh = Pointer to a variable that receives the high-order bits of the current tape position. This parameter can be
///                     <b>NULL</b> if the high-order bits are not required.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function fails, it can return one of the following
///    error codes. <table> <tr> <th>Error code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt> <dt>1102L</dt> </dl> </td> <td width="60%"> An attempt to access data
///    before the beginning-of-medium marker failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUS_RESET</b></dt> <dt>1111L</dt> </dl> </td> <td width="60%"> A reset condition was detected on the
///    bus. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt> <dt>1107L</dt> </dl>
///    </td> <td width="60%"> The partition information could not be found when a tape was being loaded. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_END_OF_MEDIA</b></dt> <dt>1100L</dt> </dl> </td> <td width="60%"> The
///    end-of-tape marker was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILEMARK_DETECTED</b></dt> <dt>1101L</dt> </dl> </td> <td width="60%"> A filemark was reached during
///    an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt> <dt>1106L</dt>
///    </dl> </td> <td width="60%"> The block size is incorrect on a new tape in a multivolume partition. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_MEDIA_CHANGED</b></dt> <dt>1110L</dt> </dl> </td> <td width="60%"> The
///    tape that was in the drive has been replaced or removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_DATA_DETECTED</b></dt> <dt>1104L</dt> </dl> </td> <td width="60%"> The end-of-data marker was
///    reached during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
///    <dt>1112L</dt> </dl> </td> <td width="60%"> There is no media in the drive. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> <dt>50L</dt> </dl> </td> <td width="60%"> The tape driver does not
///    support a requested function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PARTITION_FAILURE</b></dt>
///    <dt>1105L</dt> </dl> </td> <td width="60%"> The tape could not be partitioned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SETMARK_DETECTED</b></dt> <dt>1103L</dt> </dl> </td> <td width="60%"> A setmark was reached
///    during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
///    <dt>1108L</dt> </dl> </td> <td width="60%"> An attempt to lock the ejection mechanism failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt> <dt>1109L</dt> </dl> </td> <td width="60%"> An
///    attempt to unload the tape failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WRITE_PROTECT</b></dt>
///    <dt>19L</dt> </dl> </td> <td width="60%"> The media is write protected. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetTapePosition(HANDLE hDevice, uint dwPositionType, uint* lpdwPartition, uint* lpdwOffsetLow, 
                     uint* lpdwOffsetHigh);

///The <b>PrepareTape</b> function prepares the tape to be accessed or removed.
///Params:
///    hDevice = Handle to the device preparing the tape. This handle is created by using the CreateFile function.
///    dwOperation = Tape device preparation. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_FORMAT"></a><a id="tape_format"></a><dl>
///                  <dt><b>TAPE_FORMAT</b></dt> <dt>5L</dt> </dl> </td> <td width="60%"> Performs a low-level format of the tape.
///                  Currently, only the QIC117 device supports this feature. </td> </tr> <tr> <td width="40%"><a
///                  id="TAPE_LOAD"></a><a id="tape_load"></a><dl> <dt><b>TAPE_LOAD</b></dt> <dt>0L</dt> </dl> </td> <td width="60%">
///                  Loads the tape and moves the tape to the beginning. </td> </tr> <tr> <td width="40%"><a id="TAPE_LOCK"></a><a
///                  id="tape_lock"></a><dl> <dt><b>TAPE_LOCK</b></dt> <dt>3L</dt> </dl> </td> <td width="60%"> Locks the tape
///                  ejection mechanism so that the tape is not ejected accidentally. </td> </tr> <tr> <td width="40%"><a
///                  id="TAPE_TENSION"></a><a id="tape_tension"></a><dl> <dt><b>TAPE_TENSION</b></dt> <dt>2L</dt> </dl> </td> <td
///                  width="60%"> Adjusts the tension by moving the tape to the end of the tape and back to the beginning. This option
///                  is not supported by all devices. This value is ignored if it is not supported. </td> </tr> <tr> <td
///                  width="40%"><a id="TAPE_UNLOAD"></a><a id="tape_unload"></a><dl> <dt><b>TAPE_UNLOAD</b></dt> <dt>1L</dt> </dl>
///                  </td> <td width="60%"> Moves the tape to the beginning for removal from the device. After a successful unload
///                  operation, the device returns errors to applications that attempt to access the tape, until the tape is loaded
///                  again. </td> </tr> <tr> <td width="40%"><a id="TAPE_UNLOCK"></a><a id="tape_unlock"></a><dl>
///                  <dt><b>TAPE_UNLOCK</b></dt> <dt>4L</dt> </dl> </td> <td width="60%"> Unlocks the tape ejection mechanism. </td>
///                  </tr> </table>
///    bImmediate = If this parameter is <b>TRUE</b>, the function returns immediately. If it is <b>FALSE</b>, the function does not
///                 return until the operation has been completed.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function fails, it can return one of the following
///    error codes. <table> <tr> <th>Error</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt> <dt>1102L</dt> </dl> </td> <td width="60%"> An attempt to access data
///    before the beginning-of-medium marker failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUS_RESET</b></dt> <dt>1111L</dt> </dl> </td> <td width="60%"> A reset condition was detected on the
///    bus. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt> <dt>1107L</dt> </dl>
///    </td> <td width="60%"> The partition information could not be found when a tape was being loaded. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_END_OF_MEDIA</b></dt> <dt>1100L</dt> </dl> </td> <td width="60%"> The
///    end-of-tape marker was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILEMARK_DETECTED</b></dt> <dt>1101L</dt> </dl> </td> <td width="60%"> A filemark was reached during
///    an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt> <dt>1106L</dt>
///    </dl> </td> <td width="60%"> The block size is incorrect on a new tape in a multivolume partition. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_MEDIA_CHANGED</b></dt> <dt>1110L</dt> </dl> </td> <td width="60%"> The
///    tape that was in the drive has been replaced or removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_DATA_DETECTED</b></dt> <dt>1104L</dt> </dl> </td> <td width="60%"> The end-of-data marker was
///    reached during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
///    <dt>1112L</dt> </dl> </td> <td width="60%"> There is no media in the drive. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> <dt>50L</dt> </dl> </td> <td width="60%"> The tape driver does not
///    support a requested function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PARTITION_FAILURE</b></dt>
///    <dt>1105L</dt> </dl> </td> <td width="60%"> The tape could not be partitioned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SETMARK_DETECTED</b></dt> <dt>1103L</dt> </dl> </td> <td width="60%"> A setmark was reached
///    during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
///    <dt>1108L</dt> </dl> </td> <td width="60%"> An attempt to lock the ejection mechanism failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt> <dt>1109L</dt> </dl> </td> <td width="60%"> An
///    attempt to unload the tape failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WRITE_PROTECT</b></dt>
///    <dt>19L</dt> </dl> </td> <td width="60%"> The media is write protected. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint PrepareTape(HANDLE hDevice, uint dwOperation, BOOL bImmediate);

///The <b>EraseTape</b> function erases all or part of a tape.
///Params:
///    hDevice = Handle to the device where the tape is to be erased. This handle is created by using the CreateFile function.
///    dwEraseType = Erasing technique. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_ERASE_LONG"></a><a id="tape_erase_long"></a><dl>
///                  <dt><b>TAPE_ERASE_LONG</b></dt> <dt>1L</dt> </dl> </td> <td width="60%"> Erases the tape from the current
///                  position to the end of the current partition. </td> </tr> <tr> <td width="40%"><a id="TAPE_ERASE_SHORT"></a><a
///                  id="tape_erase_short"></a><dl> <dt><b>TAPE_ERASE_SHORT</b></dt> <dt>0L</dt> </dl> </td> <td width="60%"> Writes
///                  an erase gap or end-of-data marker at the current position. </td> </tr> </table>
///    bImmediate = If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not
///                 return until the erase operation has been completed.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function fails, it can return one of the following
///    error codes. <table> <tr> <th>Error code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt> <dt>1102L</dt> </dl> </td> <td width="60%"> An attempt to access data
///    before the beginning-of-medium marker failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUS_RESET</b></dt> <dt>1111L</dt> </dl> </td> <td width="60%"> A reset condition was detected on the
///    bus. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt> <dt>1107L</dt> </dl>
///    </td> <td width="60%"> The partition information could not be found when a tape was being loaded. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_END_OF_MEDIA</b></dt> <dt>1100L</dt> </dl> </td> <td width="60%"> The
///    end-of-tape marker was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILEMARK_DETECTED</b></dt> <dt>1101L</dt> </dl> </td> <td width="60%"> A filemark was reached during
///    an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt> <dt>1106L</dt>
///    </dl> </td> <td width="60%"> The block size is incorrect on a new tape in a multivolume partition. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_MEDIA_CHANGED</b></dt> <dt>1110L</dt> </dl> </td> <td width="60%"> The
///    tape that was in the drive has been replaced or removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_DATA_DETECTED</b></dt> <dt>1104L</dt> </dl> </td> <td width="60%"> The end-of-data marker was
///    reached during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
///    <dt>1112L</dt> </dl> </td> <td width="60%"> There is no media in the drive. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> <dt>50L</dt> </dl> </td> <td width="60%"> The tape driver does not
///    support a requested function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PARTITION_FAILURE</b></dt>
///    <dt>1105L</dt> </dl> </td> <td width="60%"> The tape could not be partitioned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SETMARK_DETECTED</b></dt> <dt>1103L</dt> </dl> </td> <td width="60%"> A setmark was reached
///    during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
///    <dt>1108L</dt> </dl> </td> <td width="60%"> An attempt to lock the ejection mechanism failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt> <dt>1109L</dt> </dl> </td> <td width="60%"> An
///    attempt to unload the tape failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WRITE_PROTECT</b></dt>
///    <dt>19L</dt> </dl> </td> <td width="60%"> The media is write protected. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint EraseTape(HANDLE hDevice, uint dwEraseType, BOOL bImmediate);

///The <b>CreateTapePartition</b> function reformats a tape.
///Params:
///    hDevice = Handle to the device where the new partition is to be created. This handle is created by using the CreateFile
///              function.
///    dwPartitionMethod = Type of partition to create. To determine what type of partitions your device supports, see the documentation for
///                        your hardware. This parameter can have one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///                        </tr> <tr> <td width="40%"><a id="TAPE_FIXED_PARTITIONS"></a><a id="tape_fixed_partitions"></a><dl>
///                        <dt><b>TAPE_FIXED_PARTITIONS</b></dt> <dt>0L</dt> </dl> </td> <td width="60%"> Partitions the tape based on the
///                        device's default definition of partitions. The <i>dwCount</i> and <i>dwSize</i> parameters are ignored. </td>
///                        </tr> <tr> <td width="40%"><a id="TAPE_INITIATOR_PARTITIONS"></a><a id="tape_initiator_partitions"></a><dl>
///                        <dt><b>TAPE_INITIATOR_PARTITIONS</b></dt> <dt>2L</dt> </dl> </td> <td width="60%"> Partitions the tape into the
///                        number and size of partitions specified by <i>dwCount</i> and <i>dwSize</i>, respectively, except for the last
///                        partition. The size of the last partition is the remainder of the tape. </td> </tr> <tr> <td width="40%"><a
///                        id="TAPE_SELECT_PARTITIONS"></a><a id="tape_select_partitions"></a><dl> <dt><b>TAPE_SELECT_PARTITIONS</b></dt>
///                        <dt>1L</dt> </dl> </td> <td width="60%"> Partitions the tape into the number of partitions specified by
///                        <i>dwCount</i>. The <i>dwSize</i> parameter is ignored. The size of the partitions is determined by the device's
///                        default partition size. For more specific information, see the documentation for your tape device. </td> </tr>
///                        </table>
///    dwCount = Number of partitions to create. The GetTapeParameters function provides the maximum number of partitions a tape
///              can support.
///    dwSize = Size of each partition, in megabytes. This value is ignored if the <i>dwPartitionMethod</i> parameter is
///             <b>TAPE_SELECT_PARTITIONS</b>.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function fails, it can return one of the following
///    error codes. <table> <tr> <th>Error</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt> <dt>1102L</dt> </dl> </td> <td width="60%"> An attempt to access data
///    before the beginning-of-medium marker failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUS_RESET</b></dt> <dt>1111L</dt> </dl> </td> <td width="60%"> A reset condition was detected on the
///    bus. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_END_OF_MEDIA</b></dt> <dt>1100L</dt> </dl> </td> <td
///    width="60%"> The end-of-tape marker was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILEMARK_DETECTED</b></dt> <dt>1101L</dt> </dl> </td> <td width="60%"> A filemark was reached during
///    an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SETMARK_DETECTED</b></dt> <dt>1103L</dt> </dl>
///    </td> <td width="60%"> A setmark was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_DATA_DETECTED</b></dt> <dt>1104L</dt> </dl> </td> <td width="60%"> The end-of-data marker was
///    reached during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PARTITION_FAILURE</b></dt>
///    <dt>1105L</dt> </dl> </td> <td width="60%"> The tape could not be partitioned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt> <dt>1106L</dt> </dl> </td> <td width="60%"> The block size is
///    incorrect on a new tape in a multivolume partition. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt> <dt>1107L</dt> </dl> </td> <td width="60%"> The partition
///    information could not be found when a tape was being loaded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_MEDIA_CHANGED</b></dt> <dt>1110L</dt> </dl> </td> <td width="60%"> The tape that was in the drive
///    has been replaced or removed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
///    <dt>1112L</dt> </dl> </td> <td width="60%"> There is no media in the drive. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> <dt>50L</dt> </dl> </td> <td width="60%"> The tape driver does not
///    support a requested function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
///    <dt>1108L</dt> </dl> </td> <td width="60%"> An attempt to lock the ejection mechanism failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt> <dt>1109L</dt> </dl> </td> <td width="60%"> An
///    attempt to unload the tape failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WRITE_PROTECT</b></dt>
///    <dt>19L</dt> </dl> </td> <td width="60%"> The media is write protected. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint CreateTapePartition(HANDLE hDevice, uint dwPartitionMethod, uint dwCount, uint dwSize);

///The <b>WriteTapemark</b> function writes a specified number of filemarks, setmarks, short filemarks, or long
///filemarks to a tape device. These tapemarks divide a tape partition into smaller areas.
///Params:
///    hDevice = Handle to the device on which to write tapemarks. This handle is created by using the CreateFile function.
///    dwTapemarkType = Type of tapemarks to write. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///                     <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TAPE_FILEMARKS"></a><a id="tape_filemarks"></a><dl>
///                     <dt><b>TAPE_FILEMARKS</b></dt> <dt>1L</dt> </dl> </td> <td width="60%"> Writes the number of filemarks specified
///                     by the <i>dwTapemarkCount</i> parameter. </td> </tr> <tr> <td width="40%"><a id="TAPE_LONG_FILEMARKS"></a><a
///                     id="tape_long_filemarks"></a><dl> <dt><b>TAPE_LONG_FILEMARKS</b></dt> <dt>3L</dt> </dl> </td> <td width="60%">
///                     Writes the number of long filemarks specified by <i>dwTapemarkCount</i>. </td> </tr> <tr> <td width="40%"><a
///                     id="TAPE_SETMARKS"></a><a id="tape_setmarks"></a><dl> <dt><b>TAPE_SETMARKS</b></dt> <dt>0L</dt> </dl> </td> <td
///                     width="60%"> Writes the number of setmarks specified by <i>dwTapemarkCount</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="TAPE_SHORT_FILEMARKS"></a><a id="tape_short_filemarks"></a><dl>
///                     <dt><b>TAPE_SHORT_FILEMARKS</b></dt> <dt>2L</dt> </dl> </td> <td width="60%"> Writes the number of short
///                     filemarks specified by <i>dwTapemarkCount</i>. </td> </tr> </table>
///    dwTapemarkCount = Number of tapemarks to write.
///    bImmediate = If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not
///                 return until the operation has been completed.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function fails, it can return one of the following
///    error codes. <table> <tr> <th>Error</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt> <dt>1102L</dt> </dl> </td> <td width="60%"> An attempt to access data
///    before the beginning-of-medium marker failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUS_RESET</b></dt> <dt>1111L</dt> </dl> </td> <td width="60%"> A reset condition was detected on the
///    bus. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt> <dt>1107L</dt> </dl>
///    </td> <td width="60%"> The partition information could not be found when a tape was being loaded. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_END_OF_MEDIA</b></dt> <dt>1100L</dt> </dl> </td> <td width="60%"> The
///    end-of-tape marker was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILEMARK_DETECTED</b></dt> <dt>1101L</dt> </dl> </td> <td width="60%"> A filemark was reached during
///    an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt> <dt>1106L</dt>
///    </dl> </td> <td width="60%"> The block size is incorrect on a new tape in a multivolume partition. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_MEDIA_CHANGED</b></dt> <dt>1110L</dt> </dl> </td> <td width="60%"> The
///    tape that was in the drive has been replaced or removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_DATA_DETECTED</b></dt> <dt>1104L</dt> </dl> </td> <td width="60%"> The end-of-data marker was
///    reached during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
///    <dt>1112L</dt> </dl> </td> <td width="60%"> There is no media in the drive. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> <dt>50L</dt> </dl> </td> <td width="60%"> The tape driver does not
///    support a requested function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PARTITION_FAILURE</b></dt>
///    <dt>1105L</dt> </dl> </td> <td width="60%"> The tape could not be partitioned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SETMARK_DETECTED</b></dt> <dt>1103L</dt> </dl> </td> <td width="60%"> A setmark was reached
///    during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
///    <dt>1108L</dt> </dl> </td> <td width="60%"> An attempt to lock the ejection mechanism failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt> <dt>1109L</dt> </dl> </td> <td width="60%"> An
///    attempt to unload the tape failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WRITE_PROTECT</b></dt>
///    <dt>19L</dt> </dl> </td> <td width="60%"> The media is write protected. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint WriteTapemark(HANDLE hDevice, uint dwTapemarkType, uint dwTapemarkCount, BOOL bImmediate);

///The <b>GetTapeStatus</b> function determines whether the tape device is ready to process tape commands.
///Params:
///    hDevice = Handle to the device for which to get the device status. This handle is created by using the CreateFile function.
///Returns:
///    If the tape device is ready to accept appropriate tape-access commands without returning errors, the return value
///    is NO_ERROR. If the function fails, it can return one of the following error codes. <table> <tr> <th>Error
///    code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
///    <dt>1102L</dt> </dl> </td> <td width="60%"> An attempt to access data before the beginning-of-medium marker
///    failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_BUS_RESET</b></dt> <dt>1111L</dt> </dl> </td> <td
///    width="60%"> A reset condition was detected on the bus. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt> <dt>1107L</dt> </dl> </td> <td width="60%"> The partition
///    information could not be found when a tape was being loaded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_DEVICE_REQUIRES_CLEANING</b></dt> <dt>1165L</dt> </dl> </td> <td width="60%"> The tape drive is
///    capable of reporting that it requires cleaning, and reports that it does require cleaning. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_END_OF_MEDIA</b></dt> <dt>1100L</dt> </dl> </td> <td width="60%"> The end-of-tape
///    marker was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILEMARK_DETECTED</b></dt> <dt>1101L</dt> </dl> </td> <td width="60%"> A filemark was reached during
///    an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt> <dt>1106L</dt>
///    </dl> </td> <td width="60%"> The block size is incorrect on a new tape in a multivolume partition. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_MEDIA_CHANGED</b></dt> <dt>1110L</dt> </dl> </td> <td width="60%"> The
///    tape that was in the drive has been replaced or removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_DATA_DETECTED</b></dt> <dt>1104L</dt> </dl> </td> <td width="60%"> The end-of-data marker was
///    reached during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
///    <dt>1112L</dt> </dl> </td> <td width="60%"> There is no media in the drive. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> <dt>50L</dt> </dl> </td> <td width="60%"> The tape driver does not
///    support a requested function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PARTITION_FAILURE</b></dt>
///    <dt>1105L</dt> </dl> </td> <td width="60%"> The tape could not be partitioned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SETMARK_DETECTED</b></dt> <dt>1103L</dt> </dl> </td> <td width="60%"> A setmark was reached
///    during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
///    <dt>1108L</dt> </dl> </td> <td width="60%"> An attempt to lock the ejection mechanism failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt> <dt>1109L</dt> </dl> </td> <td width="60%"> An
///    attempt to unload the tape failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WRITE_PROTECT</b></dt>
///    <dt>19L</dt> </dl> </td> <td width="60%"> The media is write protected. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetTapeStatus(HANDLE hDevice);

///The <b>GetTapeParameters</b> function retrieves information that describes the tape or the tape drive.
///Params:
///    hDevice = Handle to the device about which information is sought. This handle is created by using the CreateFile function.
///    dwOperation = Type of information requested. This parameter must be one of the following values. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="GET_TAPE_DRIVE_INFORMATION"></a><a
///                  id="get_tape_drive_information"></a><dl> <dt><b>GET_TAPE_DRIVE_INFORMATION</b></dt> <dt>1</dt> </dl> </td> <td
///                  width="60%"> Retrieves information about the tape device. </td> </tr> <tr> <td width="40%"><a
///                  id="GET_TAPE_MEDIA_INFORMATION"></a><a id="get_tape_media_information"></a><dl>
///                  <dt><b>GET_TAPE_MEDIA_INFORMATION</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Retrieves information about
///                  the tape in the tape device. </td> </tr> </table>
///    lpdwSize = Pointer to a variable that receives the size, in bytes, of the buffer specified by the <i>lpTapeInformation</i>
///               parameter. If the buffer is too small, this parameter receives the required size.
///    lpTapeInformation = Pointer to a structure that contains the requested information. If the <i>dwOperation</i> parameter is
///                        <b>GET_TAPE_MEDIA_INFORMATION</b>, <i>lpTapeInformation</i> points to a TAPE_GET_MEDIA_PARAMETERS structure. If
///                        <i>dwOperation</i> is <b>GET_TAPE_DRIVE_INFORMATION</b>, <i>lpTapeInformation</i> points to a
///                        TAPE_GET_DRIVE_PARAMETERS structure.
///Returns:
///    If the function succeeds, the return value is <b>NO_ERROR</b>. If the function fails, it can return one of the
///    following error codes. <table> <tr> <th>Error code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt> <dt>1102L</dt> </dl> </td> <td width="60%"> An attempt to access data
///    before the beginning-of-medium marker failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUS_RESET</b></dt> <dt>1111L</dt> </dl> </td> <td width="60%"> A reset condition was detected on the
///    bus. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt> <dt>1107L</dt> </dl>
///    </td> <td width="60%"> The partition information could not be found when a tape was being loaded. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_END_OF_MEDIA</b></dt> <dt>1100L</dt> </dl> </td> <td width="60%"> The
///    end-of-tape marker was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILEMARK_DETECTED</b></dt> <dt>1101L</dt> </dl> </td> <td width="60%"> A filemark was reached during
///    an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt> <dt>1106L</dt>
///    </dl> </td> <td width="60%"> The block size is incorrect on a new tape in a multivolume partition. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_MEDIA_CHANGED</b></dt> <dt>1110L</dt> </dl> </td> <td width="60%"> The
///    tape that was in the drive has been replaced or removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_DATA_DETECTED</b></dt> <dt>1104L</dt> </dl> </td> <td width="60%"> The end-of-data marker was
///    reached during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
///    <dt>1112L</dt> </dl> </td> <td width="60%"> There is no media in the drive. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> <dt>50L</dt> </dl> </td> <td width="60%"> The tape driver does not
///    support a requested function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PARTITION_FAILURE</b></dt>
///    <dt>1105L</dt> </dl> </td> <td width="60%"> The tape could not be partitioned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SETMARK_DETECTED</b></dt> <dt>1103L</dt> </dl> </td> <td width="60%"> A setmark was reached
///    during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
///    <dt>1108L</dt> </dl> </td> <td width="60%"> An attempt to lock the ejection mechanism failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt> <dt>1109L</dt> </dl> </td> <td width="60%"> An
///    attempt to unload the tape failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WRITE_PROTECT</b></dt>
///    <dt>19L</dt> </dl> </td> <td width="60%"> The media is write protected. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint GetTapeParameters(HANDLE hDevice, uint dwOperation, uint* lpdwSize, void* lpTapeInformation);

///The <b>SetTapeParameters</b> function either specifies the block size of a tape or configures the tape device.
///Params:
///    hDevice = Handle to the device for which to set configuration information. This handle is created by using the CreateFile
///              function.
///    dwOperation = Type of information to set. This parameter must be one of the following values. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SET_TAPE_DRIVE_INFORMATION"></a><a
///                  id="set_tape_drive_information"></a><dl> <dt><b>SET_TAPE_DRIVE_INFORMATION</b></dt> <dt>1L</dt> </dl> </td> <td
///                  width="60%"> Sets the device-specific information specified by <i>lpTapeInformation</i>. </td> </tr> <tr> <td
///                  width="40%"><a id="SET_TAPE_MEDIA_INFORMATION"></a><a id="set_tape_media_information"></a><dl>
///                  <dt><b>SET_TAPE_MEDIA_INFORMATION</b></dt> <dt>0L</dt> </dl> </td> <td width="60%"> Sets the tape-specific
///                  information specified by the <i>lpTapeInformation</i> parameter. </td> </tr> </table>
///    lpTapeInformation = Pointer to a structure that contains the information to set. If the <i>dwOperation</i> parameter is
///                        SET_TAPE_MEDIA_INFORMATION, <i>lpTapeInformation</i> points to a TAPE_SET_MEDIA_PARAMETERS structure. If
///                        <i>dwOperation</i> is SET_TAPE_DRIVE_INFORMATION, <i>lpTapeInformation</i> points to a TAPE_SET_DRIVE_PARAMETERS
///                        structure.
///Returns:
///    If the function succeeds, the return value is NO_ERROR. If the function fails, it can return one of the following
///    error codes. <table> <tr> <th>Error</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt> <dt>1102L</dt> </dl> </td> <td width="60%"> An attempt to access data
///    before the beginning-of-medium marker failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_BUS_RESET</b></dt> <dt>1111L</dt> </dl> </td> <td width="60%"> A reset condition was detected on the
///    bus. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt> <dt>1107L</dt> </dl>
///    </td> <td width="60%"> The partition information could not be found when a tape was being loaded. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_END_OF_MEDIA</b></dt> <dt>1100L</dt> </dl> </td> <td width="60%"> The
///    end-of-tape marker was reached during an operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_FILEMARK_DETECTED</b></dt> <dt>1101L</dt> </dl> </td> <td width="60%"> A filemark was reached during
///    an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt> <dt>1106L</dt>
///    </dl> </td> <td width="60%"> The block size is incorrect on a new tape in a multivolume partition. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>ERROR_MEDIA_CHANGED</b></dt> <dt>1110L</dt> </dl> </td> <td width="60%"> The
///    tape that was in the drive has been replaced or removed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_NO_DATA_DETECTED</b></dt> <dt>1104L</dt> </dl> </td> <td width="60%"> The end-of-data marker was
///    reached during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
///    <dt>1112L</dt> </dl> </td> <td width="60%"> There is no media in the drive. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_NOT_SUPPORTED</b></dt> <dt>50L</dt> </dl> </td> <td width="60%"> The tape driver does not
///    support a requested function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_PARTITION_FAILURE</b></dt>
///    <dt>1105L</dt> </dl> </td> <td width="60%"> The tape could not be partitioned. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_SETMARK_DETECTED</b></dt> <dt>1103L</dt> </dl> </td> <td width="60%"> A setmark was reached
///    during an operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
///    <dt>1108L</dt> </dl> </td> <td width="60%"> An attempt to lock the ejection mechanism failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt> <dt>1109L</dt> </dl> </td> <td width="60%"> An
///    attempt to unload the tape failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_WRITE_PROTECT</b></dt>
///    <dt>19L</dt> </dl> </td> <td width="60%"> The media is write protected. </td> </tr> </table>
///    
@DllImport("KERNEL32")
uint SetTapeParameters(HANDLE hDevice, uint dwOperation, void* lpTapeInformation);

///Gets the data execution prevention (DEP) policy setting for the system.
///Returns:
///    This function returns a value of type <b>DEP_SYSTEM_POLICY_TYPE</b>, which can be one of the following values.
///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>AlwaysOff</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> DEP is disabled for all parts of the system,
///    regardless of hardware support for DEP. The processor runs in PAE mode with 32-bit versions of Windows unless PAE
///    is disabled in the boot configuration data. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>AlwaysOn</b></dt>
///    <dt>1</dt> </dl> </td> <td width="60%"> DEP is enabled for all parts of the system. All processes always run with
///    DEP enabled. DEP cannot be explicitly disabled for selected applications. System compatibility fixes are ignored.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OptIn</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> On systems
///    with processors that are capable of hardware-enforced DEP, DEP is automatically enabled only for operating system
///    components. This is the default setting for client versions of Windows. DEP can be explicitly enabled for
///    selected applications or the current process. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>OptOut</b></dt>
///    <dt>3</dt> </dl> </td> <td width="60%"> DEP is automatically enabled for operating system components and all
///    processes. This is the default setting for Windows Server versions. DEP can be explicitly disabled for selected
///    applications or the current process. System compatibility fixes for DEP are in effect. </td> </tr> </table>
///    
@DllImport("KERNEL32")
DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy();

///Creates a mailslot with the specified name and returns a handle that a mailslot server can use to perform operations
///on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the
///specified name already exists.
///Params:
///    lpName = The name of the mailslot. This name must have the following form: \\\\.\mailslot\\[<i>path</i>]<i>name</i> The
///             name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes.
///             For example, both \\\\.\mailslot\example_mailslot_name and \\\\.\mailslot\abc\def\ghi are valid names.
///    nMaxMessageSize = The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message
///                      can be of any size, set this value to zero.
///    lReadTimeout = The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in
///                   milliseconds. The following values have special meanings. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                   <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Returns immediately if no message is present. (The
///                   system does not treat an immediate return as an error.) </td> </tr> <tr> <td width="40%"><a
///                   id="MAILSLOT_WAIT_FOREVER"></a><a id="mailslot_wait_forever"></a><dl> <dt><b>MAILSLOT_WAIT_FOREVER</b></dt>
///                   <dt>((DWORD)-1)</dt> </dl> </td> <td width="60%"> Waits forever for a message. </td> </tr> </table> This time-out
///                   value applies to all subsequent read operations and all inherited mailslot handles.
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure. The <b>bInheritHandle</b> member of the structure determines
///                           whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>,
///                           the handle cannot be inherited.
///Returns:
///    If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations.
///    The handle returned by this function is asynchronous, or overlapped. If the function fails, the return value is
///    <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateMailslotA(const(PSTR) lpName, uint nMaxMessageSize, uint lReadTimeout, 
                       SECURITY_ATTRIBUTES* lpSecurityAttributes);

///Creates a mailslot with the specified name and returns a handle that a mailslot server can use to perform operations
///on the mailslot. The mailslot is local to the computer that creates it. An error occurs if a mailslot with the
///specified name already exists.
///Params:
///    lpName = The name of the mailslot. This name must have the following form: \\\\.\mailslot\\[<i>path</i>]<i>name</i> The
///             name field must be unique. The name may include multiple levels of pseudo directories separated by backslashes.
///             For example, both \\\\.\mailslot\example_mailslot_name and \\\\.\mailslot\abc\def\ghi are valid names.
///    nMaxMessageSize = The maximum size of a single message that can be written to the mailslot, in bytes. To specify that the message
///                      can be of any size, set this value to zero.
///    lReadTimeout = The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in
///                   milliseconds. The following values have special meanings. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                   <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Returns immediately if no message is present. (The
///                   system does not treat an immediate return as an error.) </td> </tr> <tr> <td width="40%"><a
///                   id="MAILSLOT_WAIT_FOREVER"></a><a id="mailslot_wait_forever"></a><dl> <dt><b>MAILSLOT_WAIT_FOREVER</b></dt>
///                   <dt>((DWORD)-1)</dt> </dl> </td> <td width="60%"> Waits forever for a message. </td> </tr> </table> This time-out
///                   value applies to all subsequent read operations and all inherited mailslot handles.
///    lpSecurityAttributes = A pointer to a SECURITY_ATTRIBUTES structure. The <b>bInheritHandle</b> member of the structure determines
///                           whether the returned handle can be inherited by child processes. If <i>lpSecurityAttributes</i> is <b>NULL</b>,
///                           the handle cannot be inherited.
///Returns:
///    If the function succeeds, the return value is a handle to the mailslot, for use in server mailslot operations.
///    The handle returned by this function is asynchronous, or overlapped. If the function fails, the return value is
///    <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateMailslotW(const(PWSTR) lpName, uint nMaxMessageSize, uint lReadTimeout, 
                       SECURITY_ATTRIBUTES* lpSecurityAttributes);

///Retrieves information about the specified mailslot.
///Params:
///    hMailslot = A handle to a mailslot. The CreateMailslot function must create this handle.
///    lpMaxMessageSize = The maximum message size, in bytes, allowed for this mailslot. This value can be greater than or equal to the
///                       value specified in the <i>cbMaxMsg</i> parameter of the CreateMailslot function that created the mailslot. This
///                       parameter can be <b>NULL</b>.
///    lpNextSize = The size of the next message, in bytes. The following value has special meaning. <table> <tr> <th>Value</th>
///                 <th>Meaning</th> </tr> <tr> <td width="40%"><a id="MAILSLOT_NO_MESSAGE"></a><a id="mailslot_no_message"></a><dl>
///                 <dt><b>MAILSLOT_NO_MESSAGE</b></dt> <dt>((DWORD)-1)</dt> </dl> </td> <td width="60%"> There is no next message.
///                 </td> </tr> </table> This parameter can be <b>NULL</b>.
///    lpMessageCount = The total number of messages waiting to be read, when the function returns. This parameter can be <b>NULL</b>.
///    lpReadTimeout = The amount of time, in milliseconds, a read operation can wait for a message to be written to the mailslot before
///                    a time-out occurs. This parameter is filled in when the function returns. This parameter can be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetMailslotInfo(HANDLE hMailslot, uint* lpMaxMessageSize, uint* lpNextSize, uint* lpMessageCount, 
                     uint* lpReadTimeout);

///Sets the time-out value used by the specified mailslot for a read operation.
///Params:
///    hMailslot = A handle to a mailslot. The CreateMailslot function must create this handle.
///    lReadTimeout = The time a read operation can wait for a message to be written to the mailslot before a time-out occurs, in
///                   milliseconds. The following values have special meanings. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                   <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> Returns immediately if no message is present. (The
///                   system does not treat an immediate return as an error.) </td> </tr> <tr> <td width="40%"><a
///                   id="MAILSLOT_WAIT_FOREVER"></a><a id="mailslot_wait_forever"></a><dl> <dt><b>MAILSLOT_WAIT_FOREVER</b></dt>
///                   <dt>((DWORD)-1)</dt> </dl> </td> <td width="60%"> Waits forever for a message. </td> </tr> </table> This time-out
///                   value applies to all subsequent read operations and to all inherited mailslot handles.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetMailslotInfo(HANDLE hMailslot, uint lReadTimeout);

///Signals one object and waits on another object as a single operation.
///Params:
///    hObjectToSignal = A handle to the object to be signaled. This object can be a semaphore, a mutex, or an event. If the handle is a
///                      semaphore, the <b>SEMAPHORE_MODIFY_STATE</b> access right is required. If the handle is an event, the
///                      <b>EVENT_MODIFY_STATE</b> access right is required. If the handle is a mutex and the caller does not own the
///                      mutex, the function fails with <b>ERROR_NOT_OWNER</b>.
///    hObjectToWaitOn = A handle to the object to wait on. The <b>SYNCHRONIZE</b> access right is required; for more information, see
///                      Synchronization Object Security and Access Rights. For a list of the object types whose handles you can specify,
///                      see the Remarks section.
///    dwMilliseconds = The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state
///                     is nonsignaled and no completion or asynchronous procedure call (APC) objects are queued. If
///                     <i>dwMilliseconds</i> is zero, the function tests the object's state, checks for queued completion routines or
///                     APCs, and returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval
///                     never elapses.
///    bAlertable = If this parameter is <b>TRUE</b>, the function returns when the system queues an I/O completion routine or APC
///                 function, and the thread calls the function. If <b>FALSE</b>, the function does not return, and the thread does
///                 not call the completion routine or APC function. A completion routine is queued when the function call that
///                 queued the APC has completed. This function returns and the completion routine is called only if
///                 <i>bAlertable</i> is <b>TRUE</b>, and the calling thread is the thread that queued the APC.
///Returns:
///    If the function succeeds, the return value indicates the event that caused the function to return. It can be one
///    of the following values. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WAIT_ABANDONED</b></dt> <dt>0x00000080L</dt> </dl> </td> <td width="60%"> The specified object is a
///    mutex object that was not released by the thread that owned the mutex object before the owning thread terminated.
///    Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled. If the mutex
///    was protecting persistent state information, you should check it for consistency. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WAIT_IO_COMPLETION</b></dt> <dt>0x000000C0L</dt> </dl> </td> <td width="60%"> The wait
///    was ended by one or more user-mode asynchronous procedure calls (APC) queued to the thread. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WAIT_OBJECT_0</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The state of
///    the specified object is signaled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_TIMEOUT</b></dt>
///    <dt>0x00000102L</dt> </dl> </td> <td width="60%"> The time-out interval elapsed, and the object's state is
///    nonsignaled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WAIT_FAILED</b></dt> <dt>(<b>DWORD</b>)0xFFFFFFFF</dt>
///    </dl> </td> <td width="60%"> The function has failed. To get extended error information, call GetLastError. </td>
///    </tr> </table>
///    
@DllImport("KERNEL32")
uint SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, uint dwMilliseconds, BOOL bAlertable);

///The <b>BackupRead</b> function can be used to back up a file or directory, including the security information. The
///function reads data associated with a specified file or directory into a buffer, which can then be written to the
///backup medium using the WriteFile function.
///Params:
///    hFile = Handle to the file or directory to be backed up. To obtain the handle, call the CreateFile function. The SACLs
///            are not read unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. For more
///            information, see [File security and access rights](/windows/win32/fileio/file-security-and-access-rights). The
///            handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set
///            when CreateFile is called. This function does not validate that the handle it receives is synchronous, so it does
///            not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can
///            result in subtle errors that are very difficult to debug. The <b>BackupRead</b> function may fail if
///            <b>CreateFile</b> was called with the flag <b>FILE_FLAG_NO_BUFFERING</b>. In this case, the GetLastError function
///            returns the value <b>ERROR_INVALID_PARAMETER</b>.
///    lpBuffer = Pointer to a buffer that receives the data.
///    nNumberOfBytesToRead = Length of the buffer, in bytes. The buffer size must be greater than the size of a WIN32_STREAM_ID structure.
///    lpNumberOfBytesRead = Pointer to a variable that receives the number of bytes read. If the function returns a nonzero value, and the
///                          variable pointed to by <i>lpNumberOfBytesRead</i> is zero, then all the data associated with the file handle has
///                          been read.
///    bAbort = Indicates whether you have finished using <b>BackupRead</b> on the handle. While you are backing up the file,
///             specify this parameter as <b>FALSE</b>. Once you are done using <b>BackupRead</b>, you must call
///             <b>BackupRead</b> one more time specifying <b>TRUE</b> for this parameter and passing the appropriate
///             <i>lpContext</i>. <i>lpContext</i> must be passed when <i>bAbort</i> is <b>TRUE</b>; all other parameters are
///             ignored.
///    bProcessSecurity = Indicates whether the function will restore the access-control list (ACL) data for the file or directory. If
///                       <i>bProcessSecurity</i> is <b>TRUE</b>, the ACL data will be backed up.
///    lpContext = Pointer to a variable that receives a pointer to an internal data structure used by <b>BackupRead</b> to maintain
///                context information during a backup operation. You must set the variable pointed to by <i>lpContext</i> to
///                <b>NULL</b> before the first call to <b>BackupRead</b> for the specified file or directory. The function
///                allocates memory for the data structure, and then sets the variable to point to that structure. You must not
///                change <i>lpContext</i> or the variable that it points to between calls to <b>BackupRead</b>. To release the
///                memory used by the data structure, call <b>BackupRead</b> with the <i>bAbort</i> parameter set to <b>TRUE</b>
///                when the backup operation is complete.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero,
///    indicating that an I/O error occurred. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL BackupRead(HANDLE hFile, ubyte* lpBuffer, uint nNumberOfBytesToRead, uint* lpNumberOfBytesRead, BOOL bAbort, 
                BOOL bProcessSecurity, void** lpContext);

///The <b>BackupSeek</b> function seeks forward in a data stream initially accessed by using the BackupRead or
///BackupWrite function.
///Params:
///    hFile = Handle to the file or directory. This handle is created by using the CreateFile function. The handle must be
///            synchronous (nonoverlapped). This means that the FILE_FLAG_OVERLAPPED flag must not be set when CreateFile is
///            called. This function does not validate that the handle it receives is synchronous, so it does not return an
///            error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle
///            errors that are very difficult to debug.
///    dwLowBytesToSeek = Low-order part of the number of bytes to seek.
///    dwHighBytesToSeek = High-order part of the number of bytes to seek.
///    lpdwLowByteSeeked = Pointer to a variable that receives the low-order bits of the number of bytes the function actually seeks.
///    lpdwHighByteSeeked = Pointer to a variable that receives the high-order bits of the number of bytes the function actually seeks.
///    lpContext = Pointer to an internal data structure used by the function. This structure must be the same structure that was
///                initialized by the BackupRead or BackupWrite function. An application must not touch the contents of this
///                structure.
///Returns:
///    If the function could seek the requested amount, the function returns a nonzero value. If the function could not
///    seek the requested amount, the function returns zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL BackupSeek(HANDLE hFile, uint dwLowBytesToSeek, uint dwHighBytesToSeek, uint* lpdwLowByteSeeked, 
                uint* lpdwHighByteSeeked, void** lpContext);

///The <b>BackupWrite</b> function can be used to restore a file or directory that was backed up using BackupRead. Use
///the ReadFile function to get a stream of data from the backup medium, then use <b>BackupWrite</b> to write the data
///to the specified file or directory.
///Params:
///    hFile = Handle to the file or directory to be restored. To obtain the handle, call the CreateFile function. The SACLs are
///            not restored unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. To ensure
///            that the integrity ACEs are restored correctly, the file handle must also have been created with the
///            <b>WRITE_OWNER</b> access right. For more information, see [File security and access
///            rights](/windows/win32/fileio/file-security-and-access-rights). The handle must be synchronous (nonoverlapped).
///            This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when CreateFile is called. This function
///            does not validate that the handle it receives is synchronous, so it does not return an error code for a
///            synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are
///            very difficult to debug. The <b>BackupWrite</b> function may fail if CreateFile was called with the flag
///            <b>FILE_FLAG_NO_BUFFERING</b>. In this case, the GetLastError function returns the value
///            <b>ERROR_INVALID_PARAMETER</b>.
///    lpBuffer = Pointer to a buffer that the function writes data from.
///    nNumberOfBytesToWrite = Size of the buffer, in bytes. The buffer size must be greater than the size of a WIN32_STREAM_ID structure.
///    lpNumberOfBytesWritten = Pointer to a variable that receives the number of bytes written.
///    bAbort = Indicates whether you have finished using <b>BackupWrite</b> on the handle. While you are restoring the file,
///             specify this parameter as <b>FALSE</b>. After you are done using <b>BackupWrite</b>, you must call
///             <b>BackupWrite</b> one more time specifying <b>TRUE</b> for this parameter and passing the appropriate
///             <i>lpContext</i>. <i>lpContext</i> must be passed when <i>bAbort</i> is <b>TRUE</b>; all other parameters are
///             ignored.
///    bProcessSecurity = Specifies whether the function will restore the access-control list (ACL) data for the file or directory. If
///                       <i>bProcessSecurity</i> is <b>TRUE</b>, you need to specify <b>WRITE_OWNER</b> and <b>WRITE_DAC</b> access when
///                       opening the file or directory handle. If the handle does not have those access rights, the operating system
///                       denies access to the ACL data, and ACL data restoration will not occur.
///    lpContext = Pointer to a variable that receives a pointer to an internal data structure used by <b>BackupWrite</b> to
///                maintain context information during a restore operation. You must set the variable pointed to by <i>lpContext</i>
///                to <b>NULL</b> before the first call to <b>BackupWrite</b> for the specified file or directory. The function
///                allocates memory for the data structure, and then sets the variable to point to that structure. You must not
///                change <i>lpContext</i> or the variable that it points to between calls to <b>BackupWrite</b>. To release the
///                memory used by the data structure, call <b>BackupWrite</b> with the <i>bAbort</i> parameter set to <b>TRUE</b>
///                when the restore operation is complete.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero,
///    indicating that an I/O error occurred. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL BackupWrite(HANDLE hFile, ubyte* lpBuffer, uint nNumberOfBytesToWrite, uint* lpNumberOfBytesWritten, 
                 BOOL bAbort, BOOL bProcessSecurity, void** lpContext);

///Creates or opens a named or unnamed semaphore object. To specify an access mask for the object, use the
///[CreateSemaphoreEx](/windows/win32/api/winbase/nf-winbase-createsemaphoreexa) function.
///Params:
///    lpSemaphoreAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the handle cannot be inherited by
///                            child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security descriptor for the
///                            new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security descriptor. The ACLs in
///                            the default security descriptor for a semaphore come from the primary or impersonation token of the creator.
///    lInitialCount = The initial count for the semaphore object. This value must be greater than or equal to zero and less than or
///                    equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and
///                    nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was
///                    waiting for the semaphore. The count is increased by a specified amount by calling the ReleaseSemaphore function.
///    lMaximumCount = The maximum count for the semaphore object. This value must be greater than zero.
///    lpName = The name of the semaphore object. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case
///             sensitive. If <i>lpName</i> matches the name of an existing named semaphore object, this function requests the
///             <b>SEMAPHORE_ALL_ACCESS</b> access right. In this case, the <i>lInitialCount</i> and <i>lMaximumCount</i>
///             parameters are ignored because they have already been set by the creating process. If the
///             <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>, it determines whether the handle can be inherited, but
///             its security-descriptor member is ignored. If <i>lpName</i> is <b>NULL</b>, the semaphore object is created
///             without a name. If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or
///             file-mapping object, the function fails and the GetLastError function returns <b>ERROR_INVALID_HANDLE</b>. This
///             occurs because these objects share the same namespace. The name can have a "Global\" or "Local\" prefix to
///             explicitly create the object in the global or session namespace. The remainder of the name can contain any
///             character except the backslash character (\\). For more information, see Kernel Object Namespaces. Fast user
///             switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines
///             outlined for Terminal Services so that applications can support multiple users. The object can be created in a
///             private namespace. For more information, see Object Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object
///    existed before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateSemaphoreA(SECURITY_ATTRIBUTES* lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, 
                        const(PSTR) lpName);

///Creates or opens a named or unnamed semaphore object and returns a handle to the object.
///Params:
///    lpSemaphoreAttributes = A pointer to a SECURITY_ATTRIBUTES structure. If this parameter is <b>NULL</b>, the semaphore handle cannot be
///                            inherited by child processes. The <b>lpSecurityDescriptor</b> member of the structure specifies a security
///                            descriptor for the new semaphore. If this parameter is <b>NULL</b>, the semaphore gets a default security
///                            descriptor. The ACLs in the default security descriptor for a semaphore come from the primary or impersonation
///                            token of the creator.
///    lInitialCount = The initial count for the semaphore object. This value must be greater than or equal to zero and less than or
///                    equal to <i>lMaximumCount</i>. The state of a semaphore is signaled when its count is greater than zero and
///                    nonsignaled when it is zero. The count is decreased by one whenever a wait function releases a thread that was
///                    waiting for the semaphore. The count is increased by a specified amount by calling the ReleaseSemaphore function.
///    lMaximumCount = The maximum count for the semaphore object. This value must be greater than zero.
///    lpName = A pointer to a null-terminated string specifying the name of the semaphore object. The name is limited to
///             <b>MAX_PATH</b> characters. Name comparison is case sensitive. If <i>lpName</i> matches the name of an existing
///             named semaphore object, the <i>lInitialCount</i> and <i>lMaximumCount</i> parameters are ignored because they
///             have already been set by the creating process. If the <i>lpSemaphoreAttributes</i> parameter is not <b>NULL</b>,
///             it determines whether the handle can be inherited. If <i>lpName</i> is <b>NULL</b>, the semaphore object is
///             created without a name. If <i>lpName</i> matches the name of an existing event, mutex, waitable timer, job, or
///             file-mapping object, the function fails and the GetLastError function returns <b>ERROR_INVALID_HANDLE</b>. This
///             occurs because these objects share the same namespace. The name can have a "Global\" or "Local\" prefix to
///             explicitly create the object in the global or session namespace. The remainder of the name can contain any
///             character except the backslash character (\\). For more information, see Kernel Object Namespaces. Fast user
///             switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines
///             outlined for Terminal Services so that applications can support multiple users. The object can be created in a
///             private namespace. For more information, see Object Namespaces.
///    dwFlags = This parameter is reserved and must be 0.
///    dwDesiredAccess = The access mask for the semaphore object. For a list of access rights, see Synchronization Object Security and
///                      Access Rights.
///Returns:
///    If the function succeeds, the return value is a handle to the semaphore object. If the named semaphore object
///    existed before the function call, the function returns a handle to the existing object and GetLastError returns
///    <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value is <b>NULL</b>. To get extended error
///    information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateSemaphoreExA(SECURITY_ATTRIBUTES* lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, 
                          const(PSTR) lpName, uint dwFlags, uint dwDesiredAccess);

///Creates or opens a named or unnamed file mapping object for a specified file. To specify the NUMA node for the
///physical memory, see CreateFileMappingNuma.
///Params:
///    hFile = A handle to the file from which to create a file mapping object. The file must be opened with access rights that
///            are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but
///            it is recommended that files you intend to map be opened for exclusive access. For more information, see File
///            Security and Access Rights. If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify
///            a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In
///            this scenario, <b>CreateFileMapping</b> creates a file mapping object of a specified size that is backed by the
///            system paging file instead of by a file in the file system.
///    lpFileMappingAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether a returned handle can be inherited by child
///                              processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a
///                              security descriptor for a new file mapping object. If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle
///                              cannot be inherited and the file mapping object gets a default security descriptor. The access control lists
///                              (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token
///                              of the creator. For more information, see File Mapping Security and Access Rights.
///    flProtect = Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with
///                this protection. This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="PAGE_EXECUTE_READ"></a><a id="page_execute_read"></a><dl>
///                <dt><b>PAGE_EXECUTE_READ</b></dt> <dt>0x20</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, or execute access. The file handle specified by the <i>hFile</i> parameter must be
///                created with the <b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights. <b>Windows Server 2003 and Windows
///                XP: </b>This value is not available until Windows XP with SP2 and Windows Server 2003 with SP1. </td> </tr> <tr>
///                <td width="40%"><a id="PAGE_EXECUTE_READWRITE"></a><a id="page_execute_readwrite"></a><dl>
///                <dt><b>PAGE_EXECUTE_READWRITE</b></dt> <dt>0x40</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, read/write, or execute access. The file handle that the <i>hFile</i> parameter
///                specifies must be created with the <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and <b>GENERIC_EXECUTE</b> access
///                rights. <b>Windows Server 2003 and Windows XP: </b>This value is not available until Windows XP with SP2 and
///                Windows Server 2003 with SP1. </td> </tr> <tr> <td width="40%"><a id="PAGE_EXECUTE_WRITECOPY"></a><a
///                id="page_execute_writecopy"></a><dl> <dt><b>PAGE_EXECUTE_WRITECOPY</b></dt> <dt>0x80</dt> </dl> </td> <td
///                width="60%"> Allows views to be mapped for read-only, copy-on-write, or execute access. This value is equivalent
///                to <b>PAGE_EXECUTE_READ</b>. The file handle that the <i>hFile</i> parameter specifies must be created with the
///                <b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights. <b>Windows Vista: </b>This value is not available
///                until Windows Vista with SP1. <b>Windows Server 2003 and Windows XP: </b>This value is not supported. </td> </tr>
///                <tr> <td width="40%"><a id="PAGE_READONLY"></a><a id="page_readonly"></a><dl> <dt><b>PAGE_READONLY</b></dt>
///                <dt>0x02</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only or copy-on-write access. An
///                attempt to write to a specific region results in an access violation. The file handle that the <i>hFile</i>
///                parameter specifies must be created with the <b>GENERIC_READ</b> access right. </td> </tr> <tr> <td
///                width="40%"><a id="PAGE_READWRITE"></a><a id="page_readwrite"></a><dl> <dt><b>PAGE_READWRITE</b></dt>
///                <dt>0x04</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only, copy-on-write, or read/write
///                access. The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b>
///                and <b>GENERIC_WRITE</b> access rights. </td> </tr> <tr> <td width="40%"><a id="PAGE_WRITECOPY"></a><a
///                id="page_writecopy"></a><dl> <dt><b>PAGE_WRITECOPY</b></dt> <dt>0x08</dt> </dl> </td> <td width="60%"> Allows
///                views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>. The
///                file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.
///                </td> </tr> </table> An application can specify one or more of the following attributes for the file mapping
///                object by combining them with one of the preceding page protection values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SEC_COMMIT"></a><a id="sec_commit"></a><dl>
///                <dt><b>SEC_COMMIT</b></dt> <dt>0x8000000</dt> </dl> </td> <td width="60%"> If the file mapping object is backed
///                by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that
///                when a view of the file is mapped into a process address space, the entire range of pages is committed rather
///                than reserved. The system must have enough committable pages to hold the entire mapping. Otherwise,
///                <b>CreateFileMapping</b> fails. This attribute has no effect for file mapping objects that are backed by
///                executable image files or data files (the <i>hfile</i> parameter is a handle to a file). <b>SEC_COMMIT</b> cannot
///                be combined with <b>SEC_RESERVE</b>. If no attribute is specified, <b>SEC_COMMIT</b> is assumed. </td> </tr> <tr>
///                <td width="40%"><a id="SEC_IMAGE"></a><a id="sec_image"></a><dl> <dt><b>SEC_IMAGE</b></dt> <dt>0x1000000</dt>
///                </dl> </td> <td width="60%"> Specifies that the file that the <i>hFile</i> parameter specifies is an executable
///                image file. The <b>SEC_IMAGE</b> attribute must be combined with a page protection value such as
///                <b>PAGE_READONLY</b>. However, this page protection value has no effect on views of the executable image file.
///                Page protection for views of an executable image file is determined by the executable file itself. No other
///                attributes are valid with <b>SEC_IMAGE</b>. </td> </tr> <tr> <td width="40%"><a id="SEC_IMAGE_NO_EXECUTE"></a><a
///                id="sec_image_no_execute"></a><dl> <dt><b>SEC_IMAGE_NO_EXECUTE</b></dt> <dt>0x11000000</dt> </dl> </td> <td
///                width="60%"> Specifies that the file that the <i>hFile</i> parameter specifies is an executable image file that
///                will not be executed and the loaded image file will have no forced integrity checks run. Additionally, mapping a
///                view of a file mapping object created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver
///                callbacks registered using the PsSetLoadImageNotifyRoutine kernel API. The <b>SEC_IMAGE_NO_EXECUTE</b> attribute
///                must be combined with the <b>PAGE_READONLY</b> page protection value. No other attributes are valid with
///                <b>SEC_IMAGE_NO_EXECUTE</b>. <b>Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows
///                Server 2003 and Windows XP: </b>This value is not supported before Windows Server 2012 and Windows 8. </td> </tr>
///                <tr> <td width="40%"><a id="SEC_LARGE_PAGES"></a><a id="sec_large_pages"></a><dl> <dt><b>SEC_LARGE_PAGES</b></dt>
///                <dt>0x80000000</dt> </dl> </td> <td width="60%"> Enables large pages to be used for file mapping objects that are
///                backed by the operating system paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>). This
///                attribute is not supported for file mapping objects that are backed by executable image files or data files (the
///                <i>hFile</i> parameter is a handle to an executable image or data file). The maximum size of the file mapping
///                object must be a multiple of the minimum size of a large page returned by the GetLargePageMinimum function. If it
///                is not, <b>CreateFileMapping</b> fails. When mapping a view of a file mapping object created with
///                <b>SEC_LARGE_PAGES</b>, the base address and view size must also be multiples of the minimum large page size.
///                <b>SEC_LARGE_PAGES</b> requires the SeLockMemoryPrivilege privilege to be enabled in the caller's token. If
///                <b>SEC_LARGE_PAGES</b> is specified, <b>SEC_COMMIT</b> must also be specified. <b>Windows Server 2003: </b>This
///                value is not supported until Windows Server 2003 with SP1. <b>Windows XP: </b>This value is not supported. </td>
///                </tr> <tr> <td width="40%"><a id="SEC_NOCACHE"></a><a id="sec_nocache"></a><dl> <dt><b>SEC_NOCACHE</b></dt>
///                <dt>0x10000000</dt> </dl> </td> <td width="60%"> Sets all pages to be non-cachable. Applications should not use
///                this attribute except when explicitly required for a device. Using the interlocked functions with memory that is
///                mapped with <b>SEC_NOCACHE</b> can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.
///                <b>SEC_NOCACHE</b> requires either the <b>SEC_RESERVE</b> or <b>SEC_COMMIT</b> attribute to be set. </td> </tr>
///                <tr> <td width="40%"><a id="SEC_RESERVE"></a><a id="sec_reserve"></a><dl> <dt><b>SEC_RESERVE</b></dt>
///                <dt>0x4000000</dt> </dl> </td> <td width="60%"> If the file mapping object is backed by the operating system
///                paging file (the <i>hfile</i> parameter is <b>INVALID_HANDLE_VALUE</b>), specifies that when a view of the file
///                is mapped into a process address space, the entire range of pages is reserved for later use by the process rather
///                than committed. Reserved pages can be committed in subsequent calls to the VirtualAlloc function. After the pages
///                are committed, they cannot be freed or decommitted with the VirtualFree function. This attribute has no effect
///                for file mapping objects that are backed by executable image files or data files (the <i>hfile</i> parameter is a
///                handle to a file). <b>SEC_RESERVE</b> cannot be combined with <b>SEC_COMMIT</b>. </td> </tr> <tr> <td
///                width="40%"><a id="SEC_WRITECOMBINE"></a><a id="sec_writecombine"></a><dl> <dt><b>SEC_WRITECOMBINE</b></dt>
///                <dt>0x40000000</dt> </dl> </td> <td width="60%"> Sets all pages to be write-combined. Applications should not use
///                this attribute except when explicitly required for a device. Using the interlocked functions with memory that is
///                mapped with <b>SEC_WRITECOMBINE</b> can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception.
///                <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or <b>SEC_COMMIT</b> attribute to be set.
///                <b>Windows Server 2003 and Windows XP: </b>This flag is not supported until Windows Vista. </td> </tr> </table>
///    dwMaximumSizeHigh = The high-order <b>DWORD</b> of the maximum size of the file mapping object.
///    dwMaximumSizeLow = The low-order <b>DWORD</b> of the maximum size of the file mapping object. If this parameter and
///                       <i>dwMaximumSizeHigh</i> are 0 (zero), the maximum size of the file mapping object is equal to the current size
///                       of the file that <i>hFile</i> identifies. An attempt to map a file with a length of 0 (zero) fails with an error
///                       code of <b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of 0 (zero) and reject those
///                       files.
///    lpName = The name of the file mapping object. If this parameter matches the name of an existing mapping object, the
///             function requests access to the object with the protection that <i>flProtect</i> specifies. If this parameter is
///             <b>NULL</b>, the file mapping object is created without a name. If <i>lpName</i> matches the name of an existing
///             event, semaphore, mutex, waitable timer, or job object, the function fails, and the GetLastError function returns
///             <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The name can have a
///             "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). Creating a file mapping object in the
///             global namespace from a session other than session zero requires the SeCreateGlobalPrivilege privilege. For more
///             information, see Kernel Object Namespaces. Fast user switching is implemented by using Terminal Services
///             sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so
///             on. Kernel object names must follow the guidelines that are outlined for Terminal Services so that applications
///             can support multiple users.
///Returns:
///    If the function succeeds, the return value is a handle to the newly created file mapping object. If the object
///    exists before the function call, the function returns a handle to the existing object (with its current size, not
///    the specified size), and GetLastErrorreturns <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateFileMappingA(HANDLE hFile, SECURITY_ATTRIBUTES* lpFileMappingAttributes, PAGE_TYPE flProtect, 
                          uint dwMaximumSizeHigh, uint dwMaximumSizeLow, const(PSTR) lpName);

///Creates or opens a named or unnamed file mapping object for a specified file and specifies the NUMA node for the
///physical memory.
///Params:
///    hFile = A handle to the file from which to create a file mapping object. The file must be opened with access rights that
///            are compatible with the protection flags that the <i>flProtect</i> parameter specifies. It is not required, but
///            it is recommended that files you intend to map be opened for exclusive access. For more information, see File
///            Security and Access Rights. If <i>hFile</i> is <b>INVALID_HANDLE_VALUE</b>, the calling process must also specify
///            a size for the file mapping object in the <i>dwMaximumSizeHigh</i> and <i>dwMaximumSizeLow</i> parameters. In
///            this scenario, <b>CreateFileMappingNuma</b> creates a file mapping object of a specified size that is backed by
///            the system paging file instead of by a file in the file system.
///    lpFileMappingAttributes = A pointer to a SECURITY_ATTRIBUTES structure that determines whether a returned handle can be inherited by child
///                              processes. The <b>lpSecurityDescriptor</b> member of the <b>SECURITY_ATTRIBUTES</b> structure specifies a
///                              security descriptor for a new file mapping object. If <i>lpFileMappingAttributes</i> is <b>NULL</b>, the handle
///                              cannot be inherited and the file mapping object gets a default security descriptor. The access control lists
///                              (ACL) in the default security descriptor for a file mapping object come from the primary or impersonation token
///                              of the creator. For more information, see File Mapping Security and Access Rights.
///    flProtect = Specifies the page protection of the file mapping object. All mapped views of the object must be compatible with
///                this protection. This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th>
///                </tr> <tr> <td width="40%"><a id="PAGE_EXECUTE_READ"></a><a id="page_execute_read"></a><dl>
///                <dt><b>PAGE_EXECUTE_READ</b></dt> <dt>0x20</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, or execute access. The file handle that the <i>hFile</i> parameter specifies must be
///                created with the <b>GENERIC_READ</b> and <b>GENERIC_EXECUTE</b> access rights. </td> </tr> <tr> <td
///                width="40%"><a id="PAGE_EXECUTE_READWRITE"></a><a id="page_execute_readwrite"></a><dl>
///                <dt><b>PAGE_EXECUTE_READWRITE</b></dt> <dt>0x40</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, read/write or execute access. The file handle that the <i>hFile</i> parameter specifies
///                must be created with the <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, and <b>GENERIC_EXECUTE</b> access rights.
///                </td> </tr> <tr> <td width="40%"><a id="PAGE_EXECUTE_WRITECOPY"></a><a id="page_execute_writecopy"></a><dl>
///                <dt><b>PAGE_EXECUTE_WRITECOPY</b></dt> <dt>0x80</dt> </dl> </td> <td width="60%"> Allows views to be mapped for
///                read-only, copy-on-write, or execute access. This value is equivalent to <b>PAGE_EXECUTE_READ</b>. The file
///                handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> and
///                <b>GENERIC_EXECUTE</b> access rights. <b>Windows Vista: </b>This value is not available until Windows Vista with
///                SP1. </td> </tr> <tr> <td width="40%"><a id="PAGE_READONLY"></a><a id="page_readonly"></a><dl>
///                <dt><b>PAGE_READONLY</b></dt> <dt>0x02</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only
///                or copy-on-write access. An attempt to write to a specific region results in an access violation. The file handle
///                that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right. </td> </tr>
///                <tr> <td width="40%"><a id="PAGE_READWRITE"></a><a id="page_readwrite"></a><dl> <dt><b>PAGE_READWRITE</b></dt>
///                <dt>0x04</dt> </dl> </td> <td width="60%"> Allows views to be mapped for read-only, copy-on-write, or read/write
///                access. The file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b>
///                and <b>GENERIC_WRITE</b> access rights. </td> </tr> <tr> <td width="40%"><a id="PAGE_WRITECOPY"></a><a
///                id="page_writecopy"></a><dl> <dt><b>PAGE_WRITECOPY</b></dt> <dt>0x08</dt> </dl> </td> <td width="60%"> Allows
///                views to be mapped for read-only or copy-on-write access. This value is equivalent to <b>PAGE_READONLY</b>. The
///                file handle that the <i>hFile</i> parameter specifies must be created with the <b>GENERIC_READ</b> access right.
///                </td> </tr> </table> An application can specify one or more of the following attributes for the file mapping
///                object by combining them with one of the preceding page protection values. <table> <tr> <th>Value</th>
///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SEC_COMMIT"></a><a id="sec_commit"></a><dl>
///                <dt><b>SEC_COMMIT</b></dt> <dt>0x8000000</dt> </dl> </td> <td width="60%"> Allocates physical storage in memory
///                or the paging file for all pages. This is the default setting. </td> </tr> <tr> <td width="40%"><a
///                id="SEC_IMAGE"></a><a id="sec_image"></a><dl> <dt><b>SEC_IMAGE</b></dt> <dt>0x1000000</dt> </dl> </td> <td
///                width="60%"> Sets the file that is specified to be an executable image file. The <b>SEC_IMAGE</b> attribute must
///                be combined with a page protection value such as <b>PAGE_READONLY</b>. However, this page protection value has no
///                effect on views of the executable image file. Page protection for views of an executable image file is determined
///                by the executable file itself. No other attributes are valid with <b>SEC_IMAGE</b>. </td> </tr> <tr> <td
///                width="40%"><a id="SEC_IMAGE_NO_EXECUTE"></a><a id="sec_image_no_execute"></a><dl>
///                <dt><b>SEC_IMAGE_NO_EXECUTE</b></dt> <dt>0x11000000</dt> </dl> </td> <td width="60%"> Specifies that the file
///                that the <i>hFile</i> parameter specifies is an executable image file that will not be executed and the loaded
///                image file will have no forced integrity checks run. Additionally, mapping a view of a file mapping object
///                created with the <b>SEC_IMAGE_NO_EXECUTE</b> attribute will not invoke driver callbacks registered using the
///                PsSetLoadImageNotifyRoutine kernel API. The <b>SEC_IMAGE_NO_EXECUTE</b> attribute must be combined with the
///                <b>PAGE_READONLY</b> page protection value. No other attributes are valid with <b>SEC_IMAGE_NO_EXECUTE</b>.
///                <b>Windows Server 2008 R2, Windows 7, Windows Server 2008 and Windows Vista: </b>This value is not supported
///                before Windows Server 2012 and Windows 8. </td> </tr> <tr> <td width="40%"><a id="SEC_LARGE_PAGES"></a><a
///                id="sec_large_pages"></a><dl> <dt><b>SEC_LARGE_PAGES</b></dt> <dt>0x80000000</dt> </dl> </td> <td width="60%">
///                Enables large pages to be used when mapping images or backing from the pagefile, but not when mapping data for
///                regular files. Be sure to specify the maximum size of the file mapping object as the minimum size of a large page
///                reported by the GetLargePageMinimum function and to enable the SeLockMemoryPrivilege privilege. </td> </tr> <tr>
///                <td width="40%"><a id="SEC_NOCACHE"></a><a id="sec_nocache"></a><dl> <dt><b>SEC_NOCACHE</b></dt>
///                <dt>0x10000000</dt> </dl> </td> <td width="60%"> Sets all pages to noncachable. Applications should not use this
///                flag except when explicitly required for a device. Using the interlocked functions with memory mapped with
///                <b>SEC_NOCACHE</b> can result in an <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception. <b>SEC_NOCACHE</b> requires
///                either <b>SEC_RESERVE</b> or <b>SEC_COMMIT</b> to be set. </td> </tr> <tr> <td width="40%"><a
///                id="SEC_RESERVE"></a><a id="sec_reserve"></a><dl> <dt><b>SEC_RESERVE</b></dt> <dt>0x4000000</dt> </dl> </td> <td
///                width="60%"> Reserves all pages without allocating physical storage. The reserved range of pages cannot be used
///                by any other allocation operations until the range of pages is released. Reserved pages can be identified in
///                subsequent calls to the VirtualAllocExNuma function. This attribute is valid only if the <i>hFile</i> parameter
///                is <b>INVALID_HANDLE_VALUE</b> (that is, a file mapping object that is backed by the system paging file). </td>
///                </tr> <tr> <td width="40%"><a id="SEC_WRITECOMBINE"></a><a id="sec_writecombine"></a><dl>
///                <dt><b>SEC_WRITECOMBINE</b></dt> <dt>0x40000000</dt> </dl> </td> <td width="60%"> Sets all pages to be
///                write-combined. Applications should not use this attribute except when explicitly required for a device. Using
///                the interlocked functions with memory that is mapped with <b>SEC_WRITECOMBINE</b> can result in an
///                <b>EXCEPTION_ILLEGAL_INSTRUCTION</b> exception. <b>SEC_WRITECOMBINE</b> requires either the <b>SEC_RESERVE</b> or
///                <b>SEC_COMMIT</b> attribute to be set. </td> </tr> </table>
///    dwMaximumSizeHigh = The high-order <b>DWORD</b> of the maximum size of the file mapping object.
///    dwMaximumSizeLow = The low-order <b>DWORD</b> of the maximum size of the file mapping object. If this parameter and the
///                       <i>dwMaximumSizeHigh</i> parameter are 0 (zero), the maximum size of the file mapping object is equal to the
///                       current size of the file that the <i>hFile</i> parameter identifies. An attempt to map a file with a length of 0
///                       (zero) fails with an error code of <b>ERROR_FILE_INVALID</b>. Applications should test for files with a length of
///                       0 (zero) and reject those files.
///    lpName = The name of the file mapping object. If this parameter matches the name of an existing file mapping object, the
///             function requests access to the object with the protection that the <i>flProtect</i> parameter specifies. If this
///             parameter is <b>NULL</b>, the file mapping object is created without a name. If the <i>lpName</i> parameter
///             matches the name of an existing event, semaphore, mutex, waitable timer, or job object, the function fails and
///             the GetLastError function returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same
///             namespace. The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or
///             session namespace. The remainder of the name can contain any character except the backslash character (\\).
///             Creating a file mapping object in the global namespace requires the SeCreateGlobalPrivilege privilege. For more
///             information, see Kernel Object Namespaces. Fast user switching is implemented by using Terminal Services
///             sessions. The first user to log on uses session 0 (zero), the next user to log on uses session 1 (one), and so
///             on. Kernel object names must follow the guidelines so that applications can support multiple users.
///    nndPreferred = The NUMA node where the physical memory should reside. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                   <td width="40%"><a id="NUMA_NO_PREFERRED_NODE"></a><a id="numa_no_preferred_node"></a><dl>
///                   <dt><b>NUMA_NO_PREFERRED_NODE</b></dt> <dt>0xffffffff</dt> </dl> </td> <td width="60%"> No NUMA node is
///                   preferred. This is the same as calling the CreateFileMapping function. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is a handle to the file mapping object. If the object exists before
///    the function call, the function returns a handle to the existing object (with its current size, not the specified
///    size) and the GetLastErrorfunction returns <b>ERROR_ALREADY_EXISTS</b>. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
HANDLE CreateFileMappingNumaA(HANDLE hFile, SECURITY_ATTRIBUTES* lpFileMappingAttributes, uint flProtect, 
                              uint dwMaximumSizeHigh, uint dwMaximumSizeLow, const(PSTR) lpName, uint nndPreferred);

///Opens a named file mapping object.
///Params:
///    dwDesiredAccess = The access to the file mapping object. This access is checked against any security descriptor on the target file
///                      mapping object. For a list of values, see File Mapping Security and Access Rights.
///    bInheritHandle = If this parameter is <b>TRUE</b>, a process created by the CreateProcess function can inherit the handle;
///                     otherwise, the handle cannot be inherited.
///    lpName = The name of the file mapping object to be opened. If there is an open handle to a file mapping object by this
///             name and the security descriptor on the mapping object does not conflict with the <i>dwDesiredAccess</i>
///             parameter, the open operation succeeds. The name can have a "Global\\" or "Local\\" prefix to explicitly open an
///             object in the global or session namespace. The remainder of the name can contain any character except the
///             backslash character (\\). For more information, see Kernel Object Namespaces. Fast user switching is implemented
///             using Terminal Services sessions. The first user to log on uses session 0, the next user to log on uses session
///             1, and so on. Kernel object names must follow the guidelines outlined for Terminal Services so that applications
///             can support multiple users.
///Returns:
///    If the function succeeds, the return value is an open handle to the specified file mapping object. If the
///    function fails, the return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenFileMappingA(uint dwDesiredAccess, BOOL bInheritHandle, const(PSTR) lpName);

///Loads the specified packaged module and its dependencies into the address space of the calling process.
///Params:
///    lpwLibFileName = The file name of the packaged module to load. The module can be a library module (a .dll file) or an executable
///                     module (an .exe file). If this parameter specifies a module name without a path and the file name extension is
///                     omitted, the function appends the default library extension .dll to the module name. To prevent the function from
///                     appending .dll to the module name, include a trailing point character (.) in the module name string. If this
///                     parameter specifies a path, the function searches that path for the module. The path cannot be an absolute path
///                     or a relative path that contains ".." in the path. When specifying a path, be sure to use backslashes (\\), not
///                     forward slashes (/). For more information about paths, see Naming Files, Paths, and Namespaces. If the specified
///                     module is already loaded in the process, the function returns a handle to the loaded module. The module must have
///                     been originally loaded from the package dependency graph of the process. If loading the specified module causes
///                     the system to load other associated modules, the function first searches loaded modules, then it searches the
///                     package dependency graph of the process. For more information, see Remarks.
///    Reserved = This parameter is reserved. It must be 0.
///Returns:
///    If the function succeeds, the return value is a handle to the loaded module. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
ptrdiff_t LoadPackagedLibrary(const(PWSTR) lpwLibFileName, uint Reserved);

///Retrieves the full name of the executable image for the specified process.
///Params:
///    hProcess = A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or
///               PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights.
///    dwFlags = This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The name should use the Win32 path format. </td> </tr>
///              <tr> <td width="40%"><a id="PROCESS_NAME_NATIVE"></a><a id="process_name_native"></a><dl>
///              <dt><b>PROCESS_NAME_NATIVE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The name should use the
///              native system path format. </td> </tr> </table>
///    lpExeName = The path to the executable image. If the function succeeds, this string is null-terminated.
///    lpdwSize = On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of
///               characters written to the buffer, not including the null-terminating character.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryFullProcessImageNameA(HANDLE hProcess, uint dwFlags, PSTR lpExeName, uint* lpdwSize);

///Retrieves the full name of the executable image for the specified process.
///Params:
///    hProcess = A handle to the process. This handle must be created with the PROCESS_QUERY_INFORMATION or
///               PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights.
///    dwFlags = This parameter can be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The name should use the Win32 path format. </td> </tr>
///              <tr> <td width="40%"><a id="PROCESS_NAME_NATIVE"></a><a id="process_name_native"></a><dl>
///              <dt><b>PROCESS_NAME_NATIVE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The name should use the
///              native system path format. </td> </tr> </table>
///    lpExeName = The path to the executable image. If the function succeeds, this string is null-terminated.
///    lpdwSize = On input, specifies the size of the <i>lpExeName</i> buffer, in characters. On success, receives the number of
///               characters written to the buffer, not including the null-terminating character.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL QueryFullProcessImageNameW(HANDLE hProcess, uint dwFlags, PWSTR lpExeName, uint* lpdwSize);

///Adds a directory to the search path used to locate DLLs for the application.
///Params:
///    lpPathName = The directory to be added to the search path. If this parameter is an empty string (""), the call removes the
///                 current directory from the default DLL search order. If this parameter is NULL, the function restores the default
///                 search order.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetDllDirectoryA(const(PSTR) lpPathName);

///Adds a directory to the search path used to locate DLLs for the application.
///Params:
///    lpPathName = The directory to be added to the search path. If this parameter is an empty string (""), the call removes the
///                 current directory from the default DLL search order. If this parameter is NULL, the function restores the default
///                 search order.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetDllDirectoryW(const(PWSTR) lpPathName);

///Retrieves the application-specific portion of the search path used to locate DLLs for the application.
///Params:
///    nBufferLength = The size of the output buffer, in characters.
///    lpBuffer = A pointer to a buffer that receives the application-specific portion of the search path.
///Returns:
///    If the function succeeds, the return value is the length of the string copied to <i>lpBuffer</i>, in characters,
///    not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, it
///    specifies the size of the buffer required for the path. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetDllDirectoryA(uint nBufferLength, PSTR lpBuffer);

///Retrieves the application-specific portion of the search path used to locate DLLs for the application.
///Params:
///    nBufferLength = The size of the output buffer, in characters.
///    lpBuffer = A pointer to a buffer that receives the application-specific portion of the search path.
///Returns:
///    If the function succeeds, the return value is the length of the string copied to <i>lpBuffer</i>, in characters,
///    not including the terminating null character. If the return value is greater than <i>nBufferLength</i>, it
///    specifies the size of the buffer required for the path. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
uint GetDllDirectoryW(uint nBufferLength, PWSTR lpBuffer);

///Retrieves information about a specified named pipe. The information returned can vary during the lifetime of an
///instance of the named pipe.
///Params:
///    hNamedPipe = A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ access for a
///                 read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a write-only
///                 pipe. This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.
///    lpState = A pointer to a variable that indicates the current state of the handle. This parameter can be <b>NULL</b> if this
///              information is not needed. Either or both of the following values can be specified. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td width="40%"><a id="PIPE_NOWAIT"></a><a id="pipe_nowait"></a><dl>
///              <dt><b>PIPE_NOWAIT</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> The pipe handle is in nonblocking
///              mode. If this flag is not specified, the pipe handle is in blocking mode. </td> </tr> <tr> <td width="40%"><a
///              id="PIPE_READMODE_MESSAGE"></a><a id="pipe_readmode_message"></a><dl> <dt><b>PIPE_READMODE_MESSAGE</b></dt>
///              <dt>0x00000002</dt> </dl> </td> <td width="60%"> The pipe handle is in message-read mode. If this flag is not
///              specified, the pipe handle is in byte-read mode. </td> </tr> </table>
///    lpCurInstances = A pointer to a variable that receives the number of current pipe instances. This parameter can be <b>NULL</b> if
///                     this information is not required.
///    lpMaxCollectionCount = A pointer to a variable that receives the maximum number of bytes to be collected on the client's computer before
///                           transmission to the server. This parameter must be <b>NULL</b> if the specified pipe handle is to the server end
///                           of a named pipe or if client and server processes are on the same computer. This parameter can be <b>NULL</b> if
///                           this information is not required.
///    lpCollectDataTimeout = A pointer to a variable that receives the maximum time, in milliseconds, that can pass before a remote named pipe
///                           transfers information over the network. This parameter must be <b>NULL</b> if the specified pipe handle is to the
///                           server end of a named pipe or if client and server processes are on the same computer. This parameter can be
///                           <b>NULL</b> if this information is not required.
///    lpUserName = A pointer to a buffer that receives the user name string associated with the client application. The server can
///                 only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access. This parameter
///                 must be <b>NULL</b> if the specified pipe handle is to the client end of a named pipe. This parameter can be
///                 <b>NULL</b> if this information is not required.
///    nMaxUserNameSize = The size of the buffer specified by the <i>lpUserName</i> parameter, in <b>TCHARs</b>. This parameter is ignored
///                       if <i>lpUserName</i> is <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, uint* lpState, uint* lpCurInstances, uint* lpMaxCollectionCount, 
                              uint* lpCollectDataTimeout, PSTR lpUserName, uint nMaxUserNameSize);

///Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads from the
///pipe, and then closes the pipe.
///Params:
///    lpNamedPipeName = The pipe name.
///    lpInBuffer = The data to be written to the pipe.
///    nInBufferSize = The size of the write buffer, in bytes.
///    lpOutBuffer = A pointer to the buffer that receives the data read from the pipe.
///    nOutBufferSize = The size of the read buffer, in bytes.
///    lpBytesRead = A pointer to a variable that receives the number of bytes read from the pipe.
///    nTimeOut = The number of milliseconds to wait for the named pipe to be available. In addition to numeric values, the
///               following special values can be specified. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///               width="40%"><a id="NMPWAIT_NOWAIT"></a><a id="nmpwait_nowait"></a><dl> <dt><b>NMPWAIT_NOWAIT</b></dt>
///               <dt>0x00000001</dt> </dl> </td> <td width="60%"> Does not wait for the named pipe. If the named pipe is not
///               available, the function returns an error. </td> </tr> <tr> <td width="40%"><a id="NMPWAIT_WAIT_FOREVER"></a><a
///               id="nmpwait_wait_forever"></a><dl> <dt><b>NMPWAIT_WAIT_FOREVER</b></dt> <dt>0xffffffff</dt> </dl> </td> <td
///               width="60%"> Waits indefinitely. </td> </tr> <tr> <td width="40%"><a id="NMPWAIT_USE_DEFAULT_WAIT"></a><a
///               id="nmpwait_use_default_wait"></a><dl> <dt><b>NMPWAIT_USE_DEFAULT_WAIT</b></dt> <dt>0x00000000</dt> </dl> </td>
///               <td width="60%"> Uses the default time-out specified in a call to the CreateNamedPipe function. </td> </tr>
///               </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. If the message written to the pipe by the server process is longer
///    than <i>nOutBufferSize</i>, <b>CallNamedPipe</b> returns <b>FALSE</b>, and GetLastError returns ERROR_MORE_DATA.
///    The remainder of the message is discarded, because <b>CallNamedPipe</b> closes the handle to the pipe before
///    returning.
///    
@DllImport("KERNEL32")
BOOL CallNamedPipeA(const(PSTR) lpNamedPipeName, void* lpInBuffer, uint nInBufferSize, void* lpOutBuffer, 
                    uint nOutBufferSize, uint* lpBytesRead, uint nTimeOut);

///Retrieves the client computer name for the specified named pipe.
///Params:
///    Pipe = A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe function.
///    ClientComputerName = The computer name.
///    ClientComputerNameLength = The size of the <i>ClientComputerName</i> buffer, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, PSTR ClientComputerName, uint ClientComputerNameLength);

///Retrieves the client process identifier for the specified named pipe.
///Params:
///    Pipe = A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe function.
///    ClientProcessId = The process identifier.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL GetNamedPipeClientProcessId(HANDLE Pipe, uint* ClientProcessId);

///Retrieves the client session identifier for the specified named pipe.
///Params:
///    Pipe = A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe function.
///    ClientSessionId = The session identifier.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL GetNamedPipeClientSessionId(HANDLE Pipe, uint* ClientSessionId);

///Retrieves the server process identifier for the specified named pipe.
///Params:
///    Pipe = A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe function.
///    ServerProcessId = The process identifier.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL GetNamedPipeServerProcessId(HANDLE Pipe, uint* ServerProcessId);

///Retrieves the server session identifier for the specified named pipe.
///Params:
///    Pipe = A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe function.
///    ServerSessionId = The session identifier.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL GetNamedPipeServerSessionId(HANDLE Pipe, uint* ServerSessionId);

///Clears the specified event log, and optionally saves the current copy of the log to a backup file.
///Params:
///    hEventLog = A handle to the event log to be cleared. The OpenEventLog function returns this handle.
///    lpBackupFileName = The absolute or relative path of the backup file. If this file already exists, the function fails. If the
///                       <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The <b>ClearEventLog</b> function can fail if the event log is
///    empty or the backup file already exists.
///    
@DllImport("ADVAPI32")
BOOL ClearEventLogA(HANDLE hEventLog, const(PSTR) lpBackupFileName);

///Clears the specified event log, and optionally saves the current copy of the log to a backup file.
///Params:
///    hEventLog = A handle to the event log to be cleared. The OpenEventLog function returns this handle.
///    lpBackupFileName = The absolute or relative path of the backup file. If this file already exists, the function fails. If the
///                       <i>lpBackupFileName</i> parameter is <b>NULL</b>, the event log is not backed up.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. The <b>ClearEventLog</b> function can fail if the event log is
///    empty or the backup file already exists.
///    
@DllImport("ADVAPI32")
BOOL ClearEventLogW(HANDLE hEventLog, const(PWSTR) lpBackupFileName);

///Saves the specified event log to a backup file. The function does not clear the event log.
///Params:
///    hEventLog = A handle to the open event log. The OpenEventLog function returns this handle.
///    lpBackupFileName = The absolute or relative path of the backup file.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL BackupEventLogA(HANDLE hEventLog, const(PSTR) lpBackupFileName);

///Saves the specified event log to a backup file. The function does not clear the event log.
///Params:
///    hEventLog = A handle to the open event log. The OpenEventLog function returns this handle.
///    lpBackupFileName = The absolute or relative path of the backup file.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL BackupEventLogW(HANDLE hEventLog, const(PWSTR) lpBackupFileName);

///Closes the specified event log.
///Params:
///    hEventLog = A handle to the event log to be closed. The OpenEventLog or OpenBackupEventLog function returns this handle.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL CloseEventLog(HANDLE hEventLog);

///Closes the specified event log.
///Params:
///    hEventLog = A handle to the event log. The RegisterEventSource function returns this handle.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL DeregisterEventSource(HANDLE hEventLog);

///Enables an application to receive notification when an event is written to the specified event log. When the event is
///written to the log, the specified event object is set to the signaled state.
///Params:
///    hEventLog = A handle to an event log. The OpenEventLog function returns this handle.
///    hEvent = A handle to a manual-reset or auto-reset event object. Use the CreateEvent function to create the event object.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent);

///Retrieves the number of records in the specified event log.
///Params:
///    hEventLog = A handle to the open event log. The OpenEventLog or OpenBackupEventLog function returns this handle.
///    NumberOfRecords = A pointer to a variable that receives the number of records in the specified event log.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, uint* NumberOfRecords);

///Retrieves the absolute record number of the oldest record in the specified event log.
///Params:
///    hEventLog = A handle to the open event log. The OpenEventLog or OpenBackupEventLog function returns this handle.
///    OldestRecord = A pointer to a variable that receives the absolute record number of the oldest record in the specified event log.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL GetOldestEventLogRecord(HANDLE hEventLog, uint* OldestRecord);

///Opens a handle to the specified event log.
///Params:
///    lpUNCServerName = The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this
///                      parameter is <b>NULL</b>, the local computer is used.
///    lpSourceName = The name of the log. If you specify a custom log and it cannot be found, the event logging service opens the
///                   <b>Application</b> log; however, there will be no associated message or category string file.
///Returns:
///    If the function succeeds, the return value is the handle to an event log. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
EventLogHandle OpenEventLogA(const(PSTR) lpUNCServerName, const(PSTR) lpSourceName);

///Opens a handle to the specified event log.
///Params:
///    lpUNCServerName = The Universal Naming Convention (UNC) name of the remote server on which the event log is to be opened. If this
///                      parameter is <b>NULL</b>, the local computer is used.
///    lpSourceName = The name of the log. If you specify a custom log and it cannot be found, the event logging service opens the
///                   <b>Application</b> log; however, there will be no associated message or category string file.
///Returns:
///    If the function succeeds, the return value is the handle to an event log. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
EventLogHandle OpenEventLogW(const(PWSTR) lpUNCServerName, const(PWSTR) lpSourceName);

///Retrieves a registered handle to the specified event log.
///Params:
///    lpUNCServerName = The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If
///                      this parameter is <b>NULL</b>, the local computer is used.
///    lpSourceName = The name of the event source whose handle is to be retrieved. The source name must be a subkey of a log under the
///                   <b>Eventlog</b> registry key. Note that the <b>Security</b> log is for system use only. <div
///                   class="alert"><b>Note</b> This string must not contain characters prohibited in XML Attributes, with the
///                   exception of XML Escape sequences such as <b>&amp;lt &amp;gl</b>.</div> <div> </div>
///Returns:
///    If the function succeeds, the return value is a handle to the event log. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call GetLastError. The function returns
///    <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.
///    
@DllImport("ADVAPI32")
EventSourceHandle RegisterEventSourceA(const(PSTR) lpUNCServerName, const(PSTR) lpSourceName);

///Retrieves a registered handle to the specified event log.
///Params:
///    lpUNCServerName = The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If
///                      this parameter is <b>NULL</b>, the local computer is used.
///    lpSourceName = The name of the event source whose handle is to be retrieved. The source name must be a subkey of a log under the
///                   <b>Eventlog</b> registry key. Note that the <b>Security</b> log is for system use only. <div
///                   class="alert"><b>Note</b> This string must not contain characters prohibited in XML Attributes, with the
///                   exception of XML Escape sequences such as <b>&amp;lt;</b> or <b>&amp;gt;</b>.</div> <div> </div>
///Returns:
///    If the function succeeds, the return value is a handle to the event log. If the function fails, the return value
///    is <b>NULL</b>. To get extended error information, call GetLastError. The function returns
///    <b>ERROR_ACCESS_DENIED</b> if <i>lpSourceName</i> specifies the <b>Security</b> event log.
///    
@DllImport("ADVAPI32")
HANDLE RegisterEventSourceW(const(PWSTR) lpUNCServerName, const(PWSTR) lpSourceName);

///Opens a handle to a backup event log created by the BackupEventLog function.
///Params:
///    lpUNCServerName = The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If
///                      this parameter is <b>NULL</b>, the local computer is used.
///    lpFileName = The full path of the backup file.
///Returns:
///    If the function succeeds, the return value is a handle to the backup event log. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
EventLogHandle OpenBackupEventLogA(const(PSTR) lpUNCServerName, const(PSTR) lpFileName);

///Opens a handle to a backup event log created by the BackupEventLog function.
///Params:
///    lpUNCServerName = The Universal Naming Convention (UNC) name of the remote server on which this operation is to be performed. If
///                      this parameter is <b>NULL</b>, the local computer is used.
///    lpFileName = The full path of the backup file.
///Returns:
///    If the function succeeds, the return value is a handle to the backup event log. If the function fails, the return
///    value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
EventLogHandle OpenBackupEventLogW(const(PWSTR) lpUNCServerName, const(PWSTR) lpFileName);

///Reads the specified number of entries from the specified event log. The function can be used to read log entries in
///chronological or reverse chronological order.
///Params:
///    hEventLog = A handle to the event log to be read. The OpenEventLog function returns this handle.
///    dwReadFlags = Use the following flag values to indicate how to read the log file. This parameter must include one of the
///                  following values (the flags are mutually exclusive). <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                  width="40%"><a id="EVENTLOG_SEEK_READ"></a><a id="eventlog_seek_read"></a><dl> <dt><b>EVENTLOG_SEEK_READ</b></dt>
///                  <dt>0x0002</dt> </dl> </td> <td width="60%"> Begin reading from the record specified in the <i>dwRecordOffset</i>
///                  parameter. This option may not work with large log files if the function cannot determine the log file's size.
///                  For details, see Knowledge Base article, 177199. </td> </tr> <tr> <td width="40%"><a
///                  id="EVENTLOG_SEQUENTIAL_READ"></a><a id="eventlog_sequential_read"></a><dl>
///                  <dt><b>EVENTLOG_SEQUENTIAL_READ</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Read the records
///                  sequentially. If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags
///                  determines which record is read first. </td> </tr> </table> You must specify one of the following flags to
///                  indicate the direction for successive read operations (the flags are mutually exclusive). <table> <tr>
///                  <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="EVENTLOG_FORWARDS_READ"></a><a
///                  id="eventlog_forwards_read"></a><dl> <dt><b>EVENTLOG_FORWARDS_READ</b></dt> <dt>0x0004</dt> </dl> </td> <td
///                  width="60%"> The log is read in chronological order (oldest to newest). The default. </td> </tr> <tr> <td
///                  width="40%"><a id="EVENTLOG_BACKWARDS_READ"></a><a id="eventlog_backwards_read"></a><dl>
///                  <dt><b>EVENTLOG_BACKWARDS_READ</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> The log is read in reverse
///                  chronological order (newest to oldest). </td> </tr> </table>
///    dwRecordOffset = The record number of the log-entry at which the read operation should start. This parameter is ignored unless
///                     <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.
///    lpBuffer = An application-allocated buffer that will receive one or more EVENTLOGRECORD structures. This parameter cannot be
///               <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero. The maximum size of this buffer is
///               0x7ffff bytes.
///    nNumberOfBytesToRead = The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the
///                           buffer; the function will not return partial entries.
///    pnBytesRead = A pointer to a variable that receives the number of bytes read by the function.
///    pnMinNumberOfBytesNeeded = A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only
///                               if this function returns zero and GetLastError returns <b>ERROR_INSUFFICIENT_BUFFER</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL ReadEventLogA(HANDLE hEventLog, uint dwReadFlags, uint dwRecordOffset, void* lpBuffer, 
                   uint nNumberOfBytesToRead, uint* pnBytesRead, uint* pnMinNumberOfBytesNeeded);

///Reads the specified number of entries from the specified event log. The function can be used to read log entries in
///chronological or reverse chronological order.
///Params:
///    hEventLog = A handle to the event log to be read. The OpenEventLog function returns this handle.
///    dwReadFlags = Use the following flag values to indicate how to read the log file. This parameter must include one of the
///                  following values (the flags are mutually exclusive). <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                  width="40%"><a id="EVENTLOG_SEEK_READ"></a><a id="eventlog_seek_read"></a><dl> <dt><b>EVENTLOG_SEEK_READ</b></dt>
///                  <dt>0x0002</dt> </dl> </td> <td width="60%"> Begin reading from the record specified in the <i>dwRecordOffset</i>
///                  parameter. This option may not work with large log files if the function cannot determine the log file's size.
///                  For details, see Knowledge Base article, 177199. </td> </tr> <tr> <td width="40%"><a
///                  id="EVENTLOG_SEQUENTIAL_READ"></a><a id="eventlog_sequential_read"></a><dl>
///                  <dt><b>EVENTLOG_SEQUENTIAL_READ</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Read the records
///                  sequentially. If this is the first read operation, the EVENTLOG_FORWARDS_READ EVENTLOG_BACKWARDS_READ flags
///                  determines which record is read first. </td> </tr> </table> You must specify one of the following flags to
///                  indicate the direction for successive read operations (the flags are mutually exclusive). <table> <tr>
///                  <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="EVENTLOG_FORWARDS_READ"></a><a
///                  id="eventlog_forwards_read"></a><dl> <dt><b>EVENTLOG_FORWARDS_READ</b></dt> <dt>0x0004</dt> </dl> </td> <td
///                  width="60%"> The log is read in chronological order (oldest to newest). The default. </td> </tr> <tr> <td
///                  width="40%"><a id="EVENTLOG_BACKWARDS_READ"></a><a id="eventlog_backwards_read"></a><dl>
///                  <dt><b>EVENTLOG_BACKWARDS_READ</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> The log is read in reverse
///                  chronological order (newest to oldest). </td> </tr> </table>
///    dwRecordOffset = The record number of the log-entry at which the read operation should start. This parameter is ignored unless
///                     <i>dwReadFlags</i> includes the <b>EVENTLOG_SEEK_READ</b> flag.
///    lpBuffer = An application-allocated buffer that will receive one or more EVENTLOGRECORD structures. This parameter cannot be
///               <b>NULL</b>, even if the <i>nNumberOfBytesToRead</i> parameter is zero. The maximum size of this buffer is
///               0x7ffff bytes.
///    nNumberOfBytesToRead = The size of the <i>lpBuffer</i> buffer, in bytes. This function will read as many log entries as will fit in the
///                           buffer; the function will not return partial entries.
///    pnBytesRead = A pointer to a variable that receives the number of bytes read by the function.
///    pnMinNumberOfBytesNeeded = A pointer to a variable that receives the required size of the <i>lpBuffer</i> buffer. This value is valid only
///                               this function returns zero and GetLastError returns <b>ERROR_INSUFFICIENT_BUFFER</b>.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL ReadEventLogW(HANDLE hEventLog, uint dwReadFlags, uint dwRecordOffset, void* lpBuffer, 
                   uint nNumberOfBytesToRead, uint* pnBytesRead, uint* pnMinNumberOfBytesNeeded);

///Writes an entry at the end of the specified event log.
///Params:
///    hEventLog = A handle to the event log. The RegisterEventSource function returns this handle. As of Windows XP with SP2, this
///                parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the
///                AuthzReportSecurityEvent function.
///    wType = The type of event to be logged. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="EVENTLOG_SUCCESS"></a><a id="eventlog_success"></a><dl>
///            <dt><b>EVENTLOG_SUCCESS</b></dt> <dt>0x0000</dt> </dl> </td> <td width="60%"> Information event </td> </tr> <tr>
///            <td width="40%"><a id="EVENTLOG_AUDIT_FAILURE"></a><a id="eventlog_audit_failure"></a><dl>
///            <dt><b>EVENTLOG_AUDIT_FAILURE</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> Failure Audit event </td>
///            </tr> <tr> <td width="40%"><a id="EVENTLOG_AUDIT_SUCCESS"></a><a id="eventlog_audit_success"></a><dl>
///            <dt><b>EVENTLOG_AUDIT_SUCCESS</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> Success Audit event </td>
///            </tr> <tr> <td width="40%"><a id="EVENTLOG_ERROR_TYPE"></a><a id="eventlog_error_type"></a><dl>
///            <dt><b>EVENTLOG_ERROR_TYPE</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Error event </td> </tr> <tr> <td
///            width="40%"><a id="EVENTLOG_INFORMATION_TYPE"></a><a id="eventlog_information_type"></a><dl>
///            <dt><b>EVENTLOG_INFORMATION_TYPE</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Information event </td>
///            </tr> <tr> <td width="40%"><a id="EVENTLOG_WARNING_TYPE"></a><a id="eventlog_warning_type"></a><dl>
///            <dt><b>EVENTLOG_WARNING_TYPE</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Warning event </td> </tr>
///            </table> For more information about event types, see Event Types.
///    wCategory = The event category. This is source-specific information; the category can have any value. For more information,
///                see Event Categories.
///    dwEventID = The event identifier. The event identifier specifies the entry in the message file associated with the event
///                source. For more information, see Event Identifiers.
///    lpUserSid = A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier
///                is not required.
///    wNumStrings = The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates
///                  that no strings are present.
///    dwDataSize = The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no
///                 event-specific data is present.
///    lpStrings = A pointer to a buffer containing an array of null-terminated strings that are merged into the message before
///                Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if
///                <i>wNumStrings</i> is zero. Each string is limited to 31,839 characters. <b>Prior to Windows Vista: </b>Each
///                string is limited to 32K characters.
///    lpRawData = A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even
///                if the <i>dwDataSize</i> parameter is zero.
///Returns:
///    If the function succeeds, the return value is nonzero, indicating that the entry was written to the log. If the
///    function fails, the return value is zero. To get extended error information, call GetLastError, which returns one
///    of the following extended error codes. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One of the parameters is
///    not valid. This error is returned on Windows Server 2003 if the message data to be logged is too large. This
///    error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than
///    261,991 (0x3ff67). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory resources are available to complete the operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>RPC_S_INVALID_BOUND</b></dt> </dl> </td> <td width="60%"> The array bounds are invalid.
///    This error is returned if the message data to be logged is too large. On Windows Vista and later, this error is
///    returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000). </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>RPC_X_BAD_STUB_DATA</b></dt> </dl> </td> <td width="60%"> The stub received bad data. This error is
///    returned on Windows XP if the message data to be logged is too large. This error is returned by the RPC server on
///    Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff). </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> Use FormatMessage to obtain the message
///    string for the returned error. </td> </tr> </table>
///    
@DllImport("ADVAPI32")
BOOL ReportEventA(HANDLE hEventLog, ushort wType, ushort wCategory, uint dwEventID, void* lpUserSid, 
                  ushort wNumStrings, uint dwDataSize, PSTR* lpStrings, void* lpRawData);

///Writes an entry at the end of the specified event log.
///Params:
///    hEventLog = A handle to the event log. The RegisterEventSource function returns this handle. As of Windows XP with SP2, this
///                parameter cannot be a handle to the <b>Security</b> log. To write an event to the <b>Security</b> log, use the
///                AuthzReportSecurityEvent function.
///    wType = The type of event to be logged. This parameter can be one of the following values. <table> <tr> <th>Value</th>
///            <th>Meaning</th> </tr> <tr> <td width="40%"><a id="EVENTLOG_SUCCESS"></a><a id="eventlog_success"></a><dl>
///            <dt><b>EVENTLOG_SUCCESS</b></dt> <dt>0x0000</dt> </dl> </td> <td width="60%"> Information event </td> </tr> <tr>
///            <td width="40%"><a id="EVENTLOG_AUDIT_FAILURE"></a><a id="eventlog_audit_failure"></a><dl>
///            <dt><b>EVENTLOG_AUDIT_FAILURE</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%"> Failure Audit event </td>
///            </tr> <tr> <td width="40%"><a id="EVENTLOG_AUDIT_SUCCESS"></a><a id="eventlog_audit_success"></a><dl>
///            <dt><b>EVENTLOG_AUDIT_SUCCESS</b></dt> <dt>0x0008</dt> </dl> </td> <td width="60%"> Success Audit event </td>
///            </tr> <tr> <td width="40%"><a id="EVENTLOG_ERROR_TYPE"></a><a id="eventlog_error_type"></a><dl>
///            <dt><b>EVENTLOG_ERROR_TYPE</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Error event </td> </tr> <tr> <td
///            width="40%"><a id="EVENTLOG_INFORMATION_TYPE"></a><a id="eventlog_information_type"></a><dl>
///            <dt><b>EVENTLOG_INFORMATION_TYPE</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Information event </td>
///            </tr> <tr> <td width="40%"><a id="EVENTLOG_WARNING_TYPE"></a><a id="eventlog_warning_type"></a><dl>
///            <dt><b>EVENTLOG_WARNING_TYPE</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Warning event </td> </tr>
///            </table> For more information about event types, see Event Types.
///    wCategory = The event category. This is source-specific information; the category can have any value. For more information,
///                see Event Categories.
///    dwEventID = The event identifier. The event identifier specifies the entry in the message file associated with the event
///                source. For more information, see Event Identifiers.
///    lpUserSid = A pointer to the current user's security identifier. This parameter can be <b>NULL</b> if the security identifier
///                is not required.
///    wNumStrings = The number of insert strings in the array pointed to by the <i>lpStrings</i> parameter. A value of zero indicates
///                  that no strings are present.
///    dwDataSize = The number of bytes of event-specific raw (binary) data to write to the log. If this parameter is zero, no
///                 event-specific data is present.
///    lpStrings = A pointer to a buffer containing an array of null-terminated strings that are merged into the message before
///                Event Viewer displays the string to the user. This parameter must be a valid pointer (or <b>NULL</b>), even if
///                <i>wNumStrings</i> is zero. Each string is limited to 31,839 characters. <b>Prior to Windows Vista: </b>Each
///                string is limited to 32K characters.
///    lpRawData = A pointer to the buffer containing the binary data. This parameter must be a valid pointer (or <b>NULL</b>), even
///                if the <i>dwDataSize</i> parameter is zero.
///Returns:
///    If the function succeeds, the return value is nonzero, indicating that the entry was written to the log. If the
///    function fails, the return value is zero. To get extended error information, call GetLastError, which returns one
///    of the following extended error codes. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> One of the parameters is
///    not valid. This error is returned on Windows Server 2003 if the message data to be logged is too large. This
///    error is returned by the RPC server on Windows Server 2003 if the <i>dwDataSize</i> parameter is larger than
///    261,991 (0x3ff67). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> Insufficient memory resources are available to complete the operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>RPC_S_INVALID_BOUND</b></dt> </dl> </td> <td width="60%"> The array bounds are invalid.
///    This error is returned if the message data to be logged is too large. On Windows Vista and later, this error is
///    returned if the <i>dwDataSize</i> parameter is larger than 61,440 (0xf000). </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>RPC_X_BAD_STUB_DATA</b></dt> </dl> </td> <td width="60%"> The stub received bad data. This error is
///    returned on Windows XP if the message data to be logged is too large. This error is returned by the RPC server on
///    Windows XP, if the <i>dwDataSize</i> parameter is larger than 262,143 (0x3ffff). </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>Other</b></dt> </dl> </td> <td width="60%"> Use FormatMessage to obtain the message
///    string for the returned error. </td> </tr> </table>
///    
@DllImport("ADVAPI32")
BOOL ReportEventW(HANDLE hEventLog, ushort wType, ushort wCategory, uint dwEventID, void* lpUserSid, 
                  ushort wNumStrings, uint dwDataSize, PWSTR* lpStrings, void* lpRawData);

///Retrieves information about the specified event log.
///Params:
///    hEventLog = A handle to the event log. The OpenEventLog or RegisterEventSource function returns this handle.
///    dwInfoLevel = The level of event log information to return. This parameter can be the following value. <table> <tr>
///                  <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="EVENTLOG_FULL_INFO"></a><a
///                  id="eventlog_full_info"></a><dl> <dt><b>EVENTLOG_FULL_INFO</b></dt> </dl> </td> <td width="60%"> Indicate whether
///                  the specified log is full. The <i>lpBuffer</i> parameter will contain an EVENTLOG_FULL_INFORMATION structure.
///                  </td> </tr> </table>
///    lpBuffer = An application-allocated buffer that receives the event log information. The format of this data depends on the
///               value of the <i>dwInfoLevel</i> parameter.
///    cbBufSize = The size of the <i>lpBuffer</i> buffer, in bytes.
///    pcbBytesNeeded = The function sets this parameter to the required buffer size for the requested information, regardless of whether
///                     the function succeeds. Use this value if the function fails with <b>ERROR_INSUFFICIENT_BUFFER</b> to allocate a
///                     buffer of the correct size.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL GetEventLogInformation(HANDLE hEventLog, uint dwInfoLevel, void* lpBuffer, uint cbBufSize, 
                            uint* pcbBytesNeeded);

///Maps a view of a file mapping into the address space of a calling process and specifies the NUMA node for the
///physical memory.
///Params:
///    hFileMappingObject = A handle to a file mapping object. The CreateFileMappingNuma and OpenFileMapping functions return this handle.
///    dwDesiredAccess = The type of access to a file mapping object, which determines the page protection of the pages. This parameter
///                      can be one of the following values, or a bitwise OR combination of multiple values where appropriate. <table>
///                      <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="FILE_MAP_ALL_ACCESS"></a><a
///                      id="file_map_all_access"></a><dl> <dt><b>FILE_MAP_ALL_ACCESS</b></dt> </dl> </td> <td width="60%"> A read/write
///                      view of the file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or
///                      <b>PAGE_EXECUTE_READWRITE</b> protection. When used with <b>MapViewOfFileExNuma</b>, <b>FILE_MAP_ALL_ACCESS</b>
///                      is equivalent to <b>FILE_MAP_WRITE</b>. </td> </tr> <tr> <td width="40%"><a id="FILE_MAP_READ"></a><a
///                      id="file_map_read"></a><dl> <dt><b>FILE_MAP_READ</b></dt> </dl> </td> <td width="60%"> A read-only view of the
///                      file is mapped. An attempt to write to the file view results in an access violation. The file mapping object must
///                      have been created with <b>PAGE_READONLY</b>, <b>PAGE_READWRITE</b>, <b>PAGE_EXECUTE_READ</b>, or
///                      <b>PAGE_EXECUTE_READWRITE</b> protection. </td> </tr> <tr> <td width="40%"><a id="FILE_MAP_WRITE"></a><a
///                      id="file_map_write"></a><dl> <dt><b>FILE_MAP_WRITE</b></dt> </dl> </td> <td width="60%"> A read/write view of the
///                      file is mapped. The file mapping object must have been created with <b>PAGE_READWRITE</b> or
///                      <b>PAGE_EXECUTE_READWRITE</b> protection. When used with <b>MapViewOfFileExNuma</b>, <code>(FILE_MAP_WRITE |
///                      FILE_MAP_READ)</code> is equivalent to <b>FILE_MAP_WRITE</b>. </td> </tr> </table> Using bitwise OR, you can
///                      combine the values above with these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                      width="40%"><a id="FILE_MAP_COPY"></a><a id="file_map_copy"></a><dl> <dt><b>FILE_MAP_COPY</b></dt> </dl> </td>
///                      <td width="60%"> A copy-on-write view of the file is mapped. The file mapping object must have been created with
///                      <b>PAGE_READONLY</b>, <b>PAGE_READ_EXECUTE</b>, <b>PAGE_WRITECOPY</b>, <b>PAGE_EXECUTE_WRITECOPY</b>,
///                      <b>PAGE_READWRITE</b>, or <b>PAGE_EXECUTE_READWRITE</b> protection. When a process writes to a copy-on-write
///                      page, the system copies the original page to a new page that is private to the process. The new page is backed by
///                      the paging file. The protection of the new page changes from copy-on-write to read/write. When copy-on-write
///                      access is specified, the system and process commit charge taken is for the entire view because the calling
///                      process can potentially write to every page in the view, making all pages private. The contents of the new page
///                      are never written back to the original file and are lost when the view is unmapped. </td> </tr> <tr> <td
///                      width="40%"><a id="FILE_MAP_EXECUTE"></a><a id="file_map_execute"></a><dl> <dt><b>FILE_MAP_EXECUTE</b></dt> </dl>
///                      </td> <td width="60%"> An executable view of the file is mapped (mapped memory can be run as code). The file
///                      mapping object must have been created with <b>PAGE_EXECUTE_READ</b>, <b>PAGE_EXECUTE_WRITECOPY</b>, or
///                      <b>PAGE_EXECUTE_READWRITE</b> protection. </td> </tr> <tr> <td width="40%"><a id="FILE_MAP_LARGE_PAGES"></a><a
///                      id="file_map_large_pages"></a><dl> <dt><b>FILE_MAP_LARGE_PAGES</b></dt> </dl> </td> <td width="60%"> Starting
///                      with Windows 10, version 1703, this flag specifies that the view should be mapped using large page support. The
///                      size of the view must be a multiple of the size of a large page reported by the GetLargePageMinimum function, and
///                      the file-mapping object must have been created using the <b>SEC_LARGE_PAGES</b> option. If you provide a non-null
///                      value for <i>lpBaseAddress</i>, then the value must be a multiple of <b>GetLargePageMinimum</b>. </td> </tr> <tr>
///                      <td width="40%"><a id="FILE_MAP_TARGETS_INVALID"></a><a id="file_map_targets_invalid"></a><dl>
///                      <dt><b>FILE_MAP_TARGETS_INVALID</b></dt> </dl> </td> <td width="60%"> Sets all the locations in the mapped file
///                      as invalid targets for Control Flow Guard (CFG). This flag is similar to <b>PAGE_TARGETS_INVALID</b>. Use this
///                      flag in combination with the execute access right <b>FILE_MAP_EXECUTE</b>. Any indirect call to locations in
///                      those pages will fail CFG checks, and the process will be terminated. The default behavior for executable pages
///                      allocated is to be marked valid call targets for CFG. </td> </tr> </table> For file-mapping objects created with
///                      the <b>SEC_IMAGE</b> attribute, the <i>dwDesiredAccess</i> parameter has no effect, and should be set to any
///                      valid value such as <b>FILE_MAP_READ</b>. For more information about access to file mapping objects, see File
///                      Mapping Security and Access Rights.
///    dwFileOffsetHigh = The high-order <b>DWORD</b> of the file offset where the view is to begin.
///    dwFileOffsetLow = The low-order <b>DWORD</b> of the file offset where the view is to begin. The combination of the high and low
///                      offsets must specify an offset within the file mapping. They must also match the memory allocation granularity of
///                      the system. That is, the offset must be a multiple of the allocation granularity. To obtain the memory allocation
///                      granularity of the system, use the GetSystemInfo function, which fills in the members of a SYSTEM_INFO structure.
///    dwNumberOfBytesToMap = The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size specified by
///                           CreateFileMapping. If this parameter is 0 (zero), the mapping extends from the specified offset to the end of the
///                           file mapping.
///    lpBaseAddress = A pointer to the memory address in the calling process address space where mapping begins. This must be a
///                    multiple of the system's memory allocation granularity, or the function fails. To determine the memory allocation
///                    granularity of the system, use the GetSystemInfo function. If there is not enough address space at the specified
///                    address, the function fails. If the <i>lpBaseAddress</i> parameter is <b>NULL</b>, the operating system chooses
///                    the mapping address. While it is possible to specify an address that is safe now (not used by the operating
///                    system), there is no guarantee that the address will remain safe over time. Therefore, it is better to let the
///                    operating system choose the address. In this case, you would not store pointers in the memory mapped file; you
///                    would store offsets from the base of the file mapping so that the mapping can be used at any address.
///    nndPreferred = The NUMA node where the physical memory should reside. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                   <td width="40%"><a id="NUMA_NO_PREFERRED_NODE"></a><a id="numa_no_preferred_node"></a><dl>
///                   <dt><b>NUMA_NO_PREFERRED_NODE</b></dt> <dt>0xffffffff</dt> </dl> </td> <td width="60%"> No NUMA node is
///                   preferred. This is the same as calling the MapViewOfFileEx function. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is the starting address of the mapped view. If the function fails, the
///    return value is <b>NULL</b>. To get extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
void* MapViewOfFileExNuma(HANDLE hFileMappingObject, uint dwDesiredAccess, uint dwFileOffsetHigh, 
                          uint dwFileOffsetLow, size_t dwNumberOfBytesToMap, void* lpBaseAddress, uint nndPreferred);

///Verifies that the calling process has read access to the specified range of memory. <div
///class="alert"><b>Important</b> This function is obsolete and should not be used. Despite its name, it does not
///guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks
///on this page.</div><div> </div>
///Params:
///    lp = A pointer to the first byte of the memory block.
///    ucb = The size of the memory block, in bytes. If this parameter is zero, the return value is zero.
///Returns:
///    If the calling process has read access to all bytes in the specified memory range, the return value is zero. If
///    the calling process does not have read access to all bytes in the specified memory range, the return value is
///    nonzero. If the application is compiled as a debugging version, and the process does not have read access to all
///    bytes in the specified memory range, the function causes an assertion and breaks into the debugger. Leaving the
///    debugger, the function continues as usual, and returns a nonzero value. This behavior is by design, as a
///    debugging aid.
///    
@DllImport("KERNEL32")
BOOL IsBadReadPtr(const(void)* lp, size_t ucb);

///Verifies that the calling process has write access to the specified range of memory. <div
///class="alert"><b>Important</b> This function is obsolete and should not be used. Despite its name, it does not
///guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks
///on this page.</div><div> </div>
///Params:
///    lp = A pointer to the first byte of the memory block.
///    ucb = The size of the memory block, in bytes. If this parameter is zero, the return value is zero.
///Returns:
///    If the calling process has write access to all bytes in the specified memory range, the return value is zero. If
///    the calling process does not have write access to all bytes in the specified memory range, the return value is
///    nonzero. If the application is run under a debugger and the process does not have write access to all bytes in
///    the specified memory range, the function causes a first chance STATUS_ACCESS_VIOLATION exception. The debugger
///    can be configured to break for this condition. After resuming process execution in the debugger, the function
///    continues as usual and returns a nonzero value This behavior is by design and serves as a debugging aid.
///    
@DllImport("KERNEL32")
BOOL IsBadWritePtr(void* lp, size_t ucb);

///Determines whether the calling process has read access to the memory at the specified address. <div
///class="alert"><b>Important</b> This function is obsolete and should not be used. Despite its name, it does not
///guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks
///on this page.</div><div> </div>
///Params:
///    lpfn = A pointer to a memory address.
///Returns:
///    If the calling process has read access to the specified memory, the return value is zero. If the calling process
///    does not have read access to the specified memory, the return value is nonzero. To get extended error
///    information, call GetLastError. If the application is compiled as a debugging version, and the process does not
///    have read access to the specified memory location, the function causes an assertion and breaks into the debugger.
///    Leaving the debugger, the function continues as usual, and returns a nonzero value. This behavior is by design,
///    as a debugging aid.
///    
@DllImport("KERNEL32")
BOOL IsBadCodePtr(FARPROC lpfn);

///Verifies that the calling process has read access to the specified range of memory. <div
///class="alert"><b>Important</b> This function is obsolete and should not be used. Despite its name, it does not
///guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks
///on this page.</div><div> </div>
///Params:
///    lpsz = A pointer to a null-terminated string, either Unicode or ASCII.
///    ucchMax = The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the
///              string's terminating null character or up to the number of characters specified by this parameter, whichever is
///              smaller. If this parameter is zero, the return value is zero.
///Returns:
///    If the calling process has read access to all characters up to the string's terminating null character or up to
///    the number of characters specified by <i>ucchMax</i>, the return value is zero. If the calling process does not
///    have read access to all characters up to the string's terminating null character or up to the number of
///    characters specified by <i>ucchMax</i>, the return value is nonzero. If the application is compiled as a
///    debugging version, and the process does not have read access to the entire memory range specified, the function
///    causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and
///    returns a nonzero value This behavior is by design, as a debugging aid.
///    
@DllImport("KERNEL32")
BOOL IsBadStringPtrA(const(PSTR) lpsz, size_t ucchMax);

///Verifies that the calling process has read access to the specified range of memory. <div
///class="alert"><b>Important</b> This function is obsolete and should not be used. Despite its name, it does not
///guarantee that the pointer is valid or that the memory pointed to is safe to use. For more information, see Remarks
///on this page.</div><div> </div>
///Params:
///    lpsz = A pointer to a null-terminated string, either Unicode or ASCII.
///    ucchMax = The maximum size of the string, in <b>TCHARs</b>. The function checks for read access in all characters up to the
///              string's terminating null character or up to the number of characters specified by this parameter, whichever is
///              smaller. If this parameter is zero, the return value is zero.
///Returns:
///    If the calling process has read access to all characters up to the string's terminating null character or up to
///    the number of characters specified by <i>ucchMax</i>, the return value is zero. If the calling process does not
///    have read access to all characters up to the string's terminating null character or up to the number of
///    characters specified by <i>ucchMax</i>, the return value is nonzero. If the application is compiled as a
///    debugging version, and the process does not have read access to the entire memory range specified, the function
///    causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and
///    returns a nonzero value This behavior is by design, as a debugging aid.
///    
@DllImport("KERNEL32")
BOOL IsBadStringPtrW(const(PWSTR) lpsz, size_t ucchMax);

///Fills a specified DCB structure with values specified in a device-control string. The device-control string uses the
///syntax of the <b>mode</b> command.
///Params:
///    lpDef = The device-control information. The function takes this string, parses it, and then sets appropriate values in
///            the DCB structure pointed to by <i>lpDCB</i>. The string must have the same form as the <b>mode</b> command's
///            command-line arguments:
///            COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]
///            The device name is optional, but it must specify a valid device if used. For example, the following string
///            specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit: <code>baud=1200 parity=N data=8
///            stop=1</code>
///    lpDCB = A pointer to a DCB structure that receives the information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL BuildCommDCBA(const(PSTR) lpDef, DCB* lpDCB);

///Fills a specified DCB structure with values specified in a device-control string. The device-control string uses the
///syntax of the <b>mode</b> command.
///Params:
///    lpDef = The device-control information. The function takes this string, parses it, and then sets appropriate values in
///            the DCB structure pointed to by <i>lpDCB</i>. The string must have the same form as the <b>mode</b> command's
///            command-line arguments:
///            COM<i>x</i>[:][baud=<i>b</i>][parity=<i>p</i>][data=<i>d</i>][stop=<i>s</i>][to={on|off}][xon={on|off}][odsr={on|off}][octs={on|off}][dtr={on|off|hs}][rts={on|off|hs|tg}][idsr={on|off}]
///            The device name is optional, but it must specify a valid device if used. For example, the following string
///            specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit: <code>baud=1200 parity=N data=8
///            stop=1</code>
///    lpDCB = A pointer to a DCB structure that receives the information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL BuildCommDCBW(const(PWSTR) lpDef, DCB* lpDCB);

///Translates a device-definition string into appropriate device-control block codes and places them into a device
///control block. The function can also set up time-out values, including the possibility of no time-outs, for a device;
///the function's behavior in this regard depends on the contents of the device-definition string.
///Params:
///    lpDef = The device-control information. The function takes this string, parses it, and then sets appropriate values in
///            the DCB structure pointed to by <i>lpDCB</i>. The string must have the same form as the <b>mode</b> command's
///            command-line arguments:
///            <b>COM</b><i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]
///            The "baud" substring can be any of the values listed, which are in pairs. The two-digit values are the first two
///            digits of the associated values that they represent. For example, 11 represents 110 baud, 19 represents 19,200
///            baud. The "parity" substring indicates how the parity bit is used to detect transmission errors. The values
///            represent "none", "even", "odd", "mark", and "space". For more information, see the Mode command reference in
///            TechNet. For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:
///            <code>baud=1200 parity=N data=8 stop=1</code>
///    lpDCB = A pointer to a DCB structure that receives information from the device-control information string pointed to by
///            <i>lpDef</i>. This <b>DCB</b> structure defines the control settings for a communications device.
///    lpCommTimeouts = A pointer to a COMMTIMEOUTS structure that receives time-out information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL BuildCommDCBAndTimeoutsA(const(PSTR) lpDef, DCB* lpDCB, COMMTIMEOUTS* lpCommTimeouts);

///Translates a device-definition string into appropriate device-control block codes and places them into a device
///control block. The function can also set up time-out values, including the possibility of no time-outs, for a device;
///the function's behavior in this regard depends on the contents of the device-definition string.
///Params:
///    lpDef = The device-control information. The function takes this string, parses it, and then sets appropriate values in
///            the DCB structure pointed to by <i>lpDCB</i>. The string must have the same form as the <b>mode</b> command's
///            command-line arguments:
///            <b>COM</b><i>x</i>[<b>:</b>][<b>baud=</b>{<b>11</b>|<b>110</b>|<b>15</b>|<b>150</b>|<b>30</b>|<b>300</b>|<b>60</b>|<b>600</b>|<b>12</b>|<b>1200</b>|<b>24</b>|<b>2400</b>|<b>48</b>|<b>4800</b>|<b>96</b>|<b>9600</b>|<b>19</b>|<b>19200</b>}][<b>parity=</b>{<b>n</b>|<b>e</b>|<b>o</b>|<b>m</b>|<b>s</b>}][<b>data=</b>{<b>5</b>|<b>6</b>|<b>7</b>|<b>8</b>}][<b>stop=</b>{<b>1</b>|<b>1.5</b>|<b>2</b>}][<b>to=</b>{<b>on</b>|<b>off</b>}][<b>xon=</b>{<b>on</b>|<b>off</b>}][<b>odsr=</b>{<b>on</b>|<b>off</b>}][<b>octs=</b>{<b>on</b>|<b>off</b>}][<b>dtr=</b>{<b>on</b>|<b>off</b>|<b>hs</b>}][<b>rts=</b>{<b>on</b>|<b>off</b>|<b>hs</b>|<b>tg</b>}][<b>idsr=</b>{<b>on</b>|<b>off</b>}]
///            The "baud" substring can be any of the values listed, which are in pairs. The two-digit values are the first two
///            digits of the associated values that they represent. For example, 11 represents 110 baud, 19 represents 19,200
///            baud. The "parity" substring indicates how the parity bit is used to detect transmission errors. The values
///            represent "none", "even", "odd", "mark", and "space". For more information, see the Mode command reference in
///            TechNet. For example, the following string specifies a baud rate of 1200, no parity, 8 data bits, and 1 stop bit:
///            <code>baud=1200 parity=N data=8 stop=1</code>
///    lpDCB = A pointer to a DCB structure that receives information from the device-control information string pointed to by
///            <i>lpDef</i>. This <b>DCB</b> structure defines the control settings for a communications device.
///    lpCommTimeouts = A pointer to a COMMTIMEOUTS structure that receives time-out information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL BuildCommDCBAndTimeoutsW(const(PWSTR) lpDef, DCB* lpDCB, COMMTIMEOUTS* lpCommTimeouts);

///Displays a driver-supplied configuration dialog box.
///Params:
///    lpszName = The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial
///               ports and LPT1 through LPT9 are parallel ports.
///    hWnd = A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be
///           <b>NULL</b> if the dialog box is to have no owner.
///    lpCC = A pointer to a COMMCONFIG structure. This structure contains initial settings for the dialog box before the call,
///           and changed values after the call.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL CommConfigDialogA(const(PSTR) lpszName, HWND hWnd, COMMCONFIG* lpCC);

///Displays a driver-supplied configuration dialog box.
///Params:
///    lpszName = The name of the device for which a dialog box should be displayed. For example, COM1 through COM9 are serial
///               ports and LPT1 through LPT9 are parallel ports.
///    hWnd = A handle to the window that owns the dialog box. This parameter can be any valid window handle, or it should be
///           <b>NULL</b> if the dialog box is to have no owner.
///    lpCC = A pointer to a COMMCONFIG structure. This structure contains initial settings for the dialog box before the call,
///           and changed values after the call.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL CommConfigDialogW(const(PWSTR) lpszName, HWND hWnd, COMMCONFIG* lpCC);

///Retrieves the default configuration for the specified communications device.
///Params:
///    lpszName = The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.
///    lpCC = A pointer to a buffer that receives a COMMCONFIG structure.
///    lpdwSize = A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return,
///               the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the
///               buffer was too small.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, use the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL GetDefaultCommConfigA(const(PSTR) lpszName, COMMCONFIG* lpCC, uint* lpdwSize);

///Retrieves the default configuration for the specified communications device.
///Params:
///    lpszName = The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.
///    lpCC = A pointer to a buffer that receives a COMMCONFIG structure.
///    lpdwSize = A pointer to a variable that specifies the size of the buffer pointed to by <i>lpCC</i>, in bytes. Upon return,
///               the variable contains the number of bytes copied if the function succeeds, or the number of bytes required if the
///               buffer was too small.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, use the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL GetDefaultCommConfigW(const(PWSTR) lpszName, COMMCONFIG* lpCC, uint* lpdwSize);

///Sets the default configuration for a communications device.
///Params:
///    lpszName = The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.
///    lpCC = A pointer to a COMMCONFIG structure.
///    dwSize = The size of the structure pointed to by <i>lpCC</i>, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetDefaultCommConfigA(const(PSTR) lpszName, COMMCONFIG* lpCC, uint dwSize);

///Sets the default configuration for a communications device.
///Params:
///    lpszName = The name of the device. For example, COM1 through COM9 are serial ports and LPT1 through LPT9 are parallel ports.
///    lpCC = A pointer to a COMMCONFIG structure.
///    dwSize = The size of the structure pointed to by <i>lpCC</i>, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetDefaultCommConfigW(const(PWSTR) lpszName, COMMCONFIG* lpCC, uint dwSize);

///Creates a new process and its primary thread. Then the new process runs the specified executable file in the security
///context of the specified credentials (user, domain, and password). It can optionally load the user profile for a
///specified user. This function is similar to the CreateProcessAsUser and CreateProcessWithTokenW functions, except
///that the caller does not need to call the LogonUser function to authenticate the user and get a token.
///Params:
///    lpUsername = The name of the user. This is the name of the user account to log on to. If you use the UPN format,
///                 <i>user</i>@<i>DNS_domain_name</i>, the <i>lpDomain</i> parameter must be NULL. The user account must have the
///                 Log On Locally permission on the local computer. This permission is granted to all users on workstations and
///                 servers, but only to administrators on domain controllers.
///    lpDomain = The name of the domain or server whose account database contains the <i>lpUsername</i> account. If this parameter
///               is NULL, the user name must be specified in UPN format.
///    lpPassword = The clear-text password for the <i>lpUsername</i> account.
///    dwLogonFlags = The logon option. This parameter can be 0 (zero) or one of the following values. <table> <tr> <th>Value</th>
///                   <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LOGON_WITH_PROFILE"></a><a id="logon_with_profile"></a><dl>
///                   <dt><b>LOGON_WITH_PROFILE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Log on, then load the user
///                   profile in the <b>HKEY_USERS</b> registry key. The function returns after the profile is loaded. Loading the
///                   profile can be time-consuming, so it is best to use this value only if you must access the information in the
///                   <b>HKEY_CURRENT_USER</b> registry key. <b>Windows Server 2003: </b>The profile is unloaded after the new process
///                   is terminated, whether or not it has created child processes. <b>Windows XP: </b>The profile is unloaded after
///                   the new process and all child processes it has created are terminated. </td> </tr> <tr> <td width="40%"><a
///                   id="LOGON_NETCREDENTIALS_ONLY"></a><a id="logon_netcredentials_only"></a><dl>
///                   <dt><b>LOGON_NETCREDENTIALS_ONLY</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Log on, but use the
///                   specified credentials on the network only. The new process uses the same token as the caller, but the system
///                   creates a new logon session within LSA, and the process uses the specified credentials as the default
///                   credentials. This value can be used to create a process that uses a different set of credentials locally than it
///                   does remotely. This is useful in inter-domain scenarios where there is no trust relationship. The system does not
///                   validate the specified credentials. Therefore, the process can start, but it may not have access to network
///                   resources. </td> </tr> </table>
///    lpApplicationName = The name of the module to be executed. This module can be a Windows-based application. It can be some other type
///                        of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer. The
///                        string can specify the full path and file name of the module to execute or it can specify a partial name. If it
///                        is a partial name, the function uses the current drive and current directory to complete the specification. The
///                        function does not use the search path. This parameter must include the file name extension; no default extension
///                        is assumed. The <i>lpApplicationName</i> parameter can be NULL, and the module name must be the first white
///                        space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name that contains a
///                        space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name
///                        is ambiguous. For example, the following string can be interpreted in different ways: "c:\program files\sub
///                        dir\program name" The system tries to interpret the possibilities in the following order:<ol>
///                        <li><b>c:\program.exe</b> files\sub dir\program name</li> <li><b>c:\program files\sub.exe</b> dir\program
///                        name</li> <li><b>c:\program files\sub dir\program.exe</b> name</li> <li><b>c:\program files\sub dir\program
///                        name.exe</b></li> </ol> If the executable module is a 16-bit application, <i>lpApplicationName</i> should be
///                        NULL, and the string pointed to by <i>lpCommandLine</i> should specify the executable module and its arguments.
///    lpCommandLine = The command line to be executed. The maximum length of this string is 1024 characters. If
///                    <i>lpApplicationName</i> is <b>NULL</b>, the module name portion of <i>lpCommandLine</i> is limited to
///                    <b>MAX_PATH</b> characters. The function can modify the contents of this string. Therefore, this parameter cannot
///                    be a pointer to read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a
///                    constant string, the function may cause an access violation. The <i>lpCommandLine</i> parameter can be
///                    <b>NULL</b>, and the function uses the string pointed to by <i>lpApplicationName</i> as the command line. If both
///                    <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-<b>NULL</b>, *<i>lpApplicationName</i> specifies the
///                    module to execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use GetCommandLine
///                    to retrieve the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i>
///                    arguments to parse the command line. Because <i>argv[0]</i> is the module name, C programmers typically repeat
///                    the module name as the first token in the command line. If <i>lpApplicationName</i> is <b>NULL</b>, the first
///                    white space–delimited token of the command line specifies the module name. If you are using a long file name
///                    that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the
///                    explanation for the <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is
///                    appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the
///                    file name ends in a period with no extension, or if the file name contains a path, .exe is not appended. If the
///                    file name does not contain a directory path, the system searches for the executable file in the following
///                    sequence: <ol> <li>The directory from which the application loaded.</li> <li>The current directory for the parent
///                    process.</li> <li>The 32-bit Windows system directory. Use the GetSystemDirectory function to get the path of
///                    this directory.</li> <li>The 16-bit Windows system directory. There is no function that obtains the path of this
///                    directory, but it is searched.</li> <li>The Windows directory. Use the GetWindowsDirectory function to get the
///                    path of this directory.</li> <li>The directories that are listed in the PATH environment variable. Note that this
///                    function does not search the per-application path specified by the <b>App Paths</b> registry key. To include this
///                    per-application path in the search sequence, use the ShellExecute function.</li> </ol> The system adds a null
///                    character to the command line string to separate the file name from the arguments. This divides the original
///                    string into two strings for internal processing.
///    dwCreationFlags = The flags that control how the process is created. The <b>CREATE_DEFAULT_ERROR_MODE</b>,
///                      <b>CREATE_NEW_CONSOLE</b>, and <b>CREATE_NEW_PROCESS_GROUP</b> flags are enabled by default. For a list of
///                      values, see Process Creation Flags. This parameter also controls the new process's priority class, which is used
///                      to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If
///                      none of the priority class flags is specified, the priority class defaults to <b>NORMAL_PRIORITY_CLASS</b> unless
///                      the priority class of the creating process is <b>IDLE_PRIORITY_CLASS</b> or <b>BELOW_NORMAL_PRIORITY_CLASS</b>.
///                      In this case, the child process receives the default priority class of the calling process. If the
///                      dwCreationFlags parameter has a value of 0: - The process inherits both the error mode of the caller and the
///                      parent's console. - The environment block for the new process is assumed to contain ANSI characters (see
///                      *lpEnvironment* parameter for additional information). - A 16-bit Windows-based application runs in a shared
///                      Virtual DOS machine (VDM).
///    lpEnvironment = A pointer to an environment block for the new process. If this parameter is <b>NULL</b>, the new process uses an
///                    environment created from the profile of the user specified by <i>lpUsername</i>. An environment block consists of
///                    a null-terminated block of null-terminated strings. Each string is in the following form:
///                    <i>name</i>=<i>value</i> Because the equal sign (=) is used as a separator, it must not be used in the name of an
///                    environment variable. An environment block can contain Unicode or ANSI characters. If the environment block
///                    pointed to by <i>lpEnvironment</i> contains Unicode characters, ensure that <i>dwCreationFlags</i> includes
///                    <b>CREATE_UNICODE_ENVIRONMENT</b>. If this parameter is NULL and the environment block of the parent process
///                    contains Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes
///                    <b>CREATE_UNICODE_ENVIRONMENT</b>. An ANSI environment block is terminated by two 0 (zero) bytes: one for the
///                    last string and one more to terminate the block. A Unicode environment block is terminated by four zero bytes:
///                    two for the last string and two more to terminate the block. To retrieve a copy of the environment block for a
///                    specific user, use the CreateEnvironmentBlock function.
///    lpCurrentDirectory = The full path to the current directory for the process. The string can also specify a UNC path. If this parameter
///                         is <b>NULL</b>, the new process has the same current drive and directory as the calling process. This feature is
///                         provided primarily for shells that need to start an application, and specify its initial drive and working
///                         directory.
///    lpStartupInfo = A pointer to a STARTUPINFO structure. The application must add permission for the specified user account to the
///                    specified window station and desktop, even for WinSta0\Default. If the <b>lpDesktop</b> member is <b>NULL</b> or
///                    an empty string, the new process inherits the desktop and window station of its parent process. The application
///                    must add permission for the specified user account to the inherited window station and desktop. <b>Windows XP:
///                    </b><b>CreateProcessWithLogonW</b> adds permission for the specified user account to the inherited window station
///                    and desktop. Handles in STARTUPINFO must be closed with CloseHandle when they are no longer needed. <div
///                    class="alert"><b>Important</b> If the <b>dwFlags</b> member of the STARTUPINFO structure specifies
///                    <b>STARTF_USESTDHANDLES</b>, the standard handle fields are copied unchanged to the child process without
///                    validation. The caller is responsible for ensuring that these fields contain valid handle values. Incorrect
///                    values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool
///                    to detect invalid handles. </div> <div> </div>
///    lpProcessInformation = A pointer to a PROCESS_INFORMATION structure that receives identification information for the new process,
///                           including a handle to the process. Handles in PROCESS_INFORMATION must be closed with the CloseHandle function
///                           when they are not needed.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
///    get extended error information, call GetLastError. Note that the function returns before the process has finished
///    initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the
///    termination status of a process, call GetExitCodeProcess.
///    
@DllImport("ADVAPI32")
BOOL CreateProcessWithLogonW(const(PWSTR) lpUsername, const(PWSTR) lpDomain, const(PWSTR) lpPassword, 
                             uint dwLogonFlags, const(PWSTR) lpApplicationName, PWSTR lpCommandLine, 
                             uint dwCreationFlags, void* lpEnvironment, const(PWSTR) lpCurrentDirectory, 
                             STARTUPINFOW* lpStartupInfo, PROCESS_INFORMATION* lpProcessInformation);

///Creates a new process and its primary thread. The new process runs in the security context of the specified token. It
///can optionally load the user profile for the specified user. The process that calls <b>CreateProcessWithTokenW</b>
///must have the SE_IMPERSONATE_NAME privilege. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the
///CreateProcessAsUser or CreateProcessWithLogonW function instead. Typically, the process that calls
///<b>CreateProcessAsUser</b> must have the SE_INCREASE_QUOTA_NAME privilege and may require the
///SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. <b>CreateProcessWithLogonW</b> requires no
///special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to
///use <b>CreateProcessWithLogonW</b> to create a process with alternate credentials.
///Params:
///    hToken = A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and
///             TOKEN_ASSIGN_PRIMARY access rights. For more information, see Access Rights for Access-Token Objects. The user
///             represented by the token must have read and execute access to the application specified by the
///             <i>lpApplicationName</i> or the <i>lpCommandLine</i> parameter. To get a primary token that represents the
///             specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx function to convert
///             an impersonation token into a primary token. This allows a server application that is impersonating a client to
///             create a process that has the security context of the client. <b>Terminal Services: </b>The process is run in the
///             session specified in the token. By default, this is the same session that called LogonUser. To change the
///             session, use the SetTokenInformation function.
///    dwLogonFlags = The logon option. This parameter can be zero or one of the following values. <table> <tr> <th>Value</th>
///                   <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LOGON_WITH_PROFILE"></a><a id="logon_with_profile"></a><dl>
///                   <dt><b>LOGON_WITH_PROFILE</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Log on, then load the user's
///                   profile in the <b>HKEY_USERS</b> registry key. The function returns after the profile has been loaded. Loading
///                   the profile can be time-consuming, so it is best to use this value only if you must access the information in the
///                   <b>HKEY_CURRENT_USER</b> registry key. <b>Windows Server 2003: </b>The profile is unloaded after the new process
///                   has been terminated, regardless of whether it has created child processes. </td> </tr> <tr> <td width="40%"><a
///                   id="LOGON_NETCREDENTIALS_ONLY"></a><a id="logon_netcredentials_only"></a><dl>
///                   <dt><b>LOGON_NETCREDENTIALS_ONLY</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Log on, but use the
///                   specified credentials on the network only. The new process uses the same token as the caller, but the system
///                   creates a new logon session within LSA, and the process uses the specified credentials as the default
///                   credentials. This value can be used to create a process that uses a different set of credentials locally than it
///                   does remotely. This is useful in inter-domain scenarios where there is no trust relationship. The system does not
///                   validate the specified credentials. Therefore, the process can start, but it may not have access to network
///                   resources. </td> </tr> </table>
///    lpApplicationName = The name of the module to be executed. This module can be a Windows-based application. It can be some other type
///                        of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer. The
///                        string can specify the full path and file name of the module to execute or it can specify a partial name. In the
///                        case of a partial name, the function uses the current drive and current directory to complete the specification.
///                        The function will not use the search path. This parameter must include the file name extension; no default
///                        extension is assumed. The <i>lpApplicationName</i> parameter can be NULL. In that case, the module name must be
///                        the first white space–delimited token in the <i>lpCommandLine</i> string. If you are using a long file name
///                        that contains a space, use quoted strings to indicate where the file name ends and the arguments begin;
///                        otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name".
///                        This string can be interpreted in a number of ways. The system tries to interpret the possibilities in the
///                        following order: <b>c:\program.exe</b> <b>c:\program files\sub.exe</b> <b>c:\program files\sub
///                        dir\program.exe</b> <b>c:\program files\sub dir\program name.exe</b> If the executable module is a 16-bit
///                        application, <i>lpApplicationName</i> should be NULL, and the string pointed to by <i>lpCommandLine</i> should
///                        specify the executable module as well as its arguments.
///    lpCommandLine = The command line to be executed. The maximum length of this string is 1024 characters. If
///                    <i>lpApplicationName</i> is NULL, the module name portion of <i>lpCommandLine</i> is limited to MAX_PATH
///                    characters. The function can modify the contents of this string. Therefore, this parameter cannot be a pointer to
///                    read-only memory (such as a <b>const</b> variable or a literal string). If this parameter is a constant string,
///                    the function may cause an access violation. The <i>lpCommandLine</i> parameter can be NULL. In that case, the
///                    function uses the string pointed to by <i>lpApplicationName</i> as the command line. If both
///                    <i>lpApplicationName</i> and <i>lpCommandLine</i> are non-NULL, *<i>lpApplicationName</i> specifies the module to
///                    execute, and *<i>lpCommandLine</i> specifies the command line. The new process can use GetCommandLine to retrieve
///                    the entire command line. Console processes written in C can use the <i>argc</i> and <i>argv</i> arguments to
///                    parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the
///                    first token in the command line. If <i>lpApplicationName</i> is NULL, the first white space–delimited token of
///                    the command line specifies the module name. If you are using a long file name that contains a space, use quoted
///                    strings to indicate where the file name ends and the arguments begin (see the explanation for the
///                    <i>lpApplicationName</i> parameter). If the file name does not contain an extension, .exe is appended. Therefore,
///                    if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a
///                    period (.) with no extension, or if the file name contains a path, .exe is not appended. If the file name does
///                    not contain a directory path, the system searches for the executable file in the following sequence: <ol> <li>The
///                    directory from which the application loaded.</li> <li>The current directory for the parent process.</li> <li>The
///                    32-bit Windows system directory. Use the GetSystemDirectory function to get the path of this directory.</li>
///                    <li>The 16-bit Windows system directory. There is no function that obtains the path of this directory, but it is
///                    searched.</li> <li>The Windows directory. Use the GetWindowsDirectory function to get the path of this
///                    directory.</li> <li>The directories that are listed in the PATH environment variable. Note that this function
///                    does not search the per-application path specified by the <b>App Paths</b> registry key. To include this
///                    per-application path in the search sequence, use the ShellExecute function.</li> </ol> The system adds a null
///                    character to the command line string to separate the file name from the arguments. This divides the original
///                    string into two strings for internal processing.
///    dwCreationFlags = The flags that control how the process is created. The CREATE_DEFAULT_ERROR_MODE, CREATE_NEW_CONSOLE, and
///                      CREATE_NEW_PROCESS_GROUP flags are enabled by default. For a list of values, see Process Creation Flags. This
///                      parameter also controls the new process's priority class, which is used to determine the scheduling priorities of
///                      the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is
///                      specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process
///                      is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default
///                      priority class of the calling process. If the dwCreationFlags parameter has a value of 0: - The process inherits
///                      both the error mode of the caller and the parent's console. - The environment block for the new process is
///                      assumed to contain ANSI characters (see *lpEnvironment* parameter for additional information). - A 16-bit
///                      Windows-based application runs in a shared Virtual DOS machine (VDM).
///    lpEnvironment = A pointer to an environment block for the new process. If this parameter is NULL, the new process uses an
///                    environment created from the profile of the user specified by <i>lpUsername</i>. An environment block consists of
///                    a null-terminated block of null-terminated strings. Each string is in the following form:
///                    <i>name</i>=<i>value</i> Because the equal sign (=) is used as a separator, it must not be used in the name of an
///                    environment variable. An environment block can contain Unicode or ANSI characters. If the environment block
///                    pointed to by <i>lpEnvironment</i> contains Unicode characters, be sure that <i>dwCreationFlags</i> includes
///                    CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains
///                    Unicode characters, you must also ensure that <i>dwCreationFlags</i> includes CREATE_UNICODE_ENVIRONMENT. An ANSI
///                    environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A
///                    Unicode environment block is terminated by four zero bytes: two for the last string and two more to terminate the
///                    block. To retrieve a copy of the environment block for a specific user, use the CreateEnvironmentBlock function.
///    lpCurrentDirectory = The full path to the current directory for the process. The string can also specify a UNC path. If this parameter
///                         is NULL, the new process will have the same current drive and directory as the calling process. (This feature is
///                         provided primarily for shells that need to start an application and specify its initial drive and working
///                         directory.)
///    lpStartupInfo = A pointer to a STARTUPINFO or STARTUPINFOEX structure. If the <b>lpDesktop</b> member is NULL or an empty string,
///                    the new process inherits the desktop and window station of its parent process. The function adds permission for
///                    the specified user account to the inherited window station and desktop. Otherwise, if this member specifies a
///                    desktop, it is the responsibility of the application to add permission for the specified user account to the
///                    specified window station and desktop, even for WinSta0\Default. Handles in STARTUPINFO or STARTUPINFOEX must be
///                    closed with CloseHandle when they are no longer needed. <div class="alert"><b>Important</b> If the <b>dwFlags</b>
///                    member of the STARTUPINFO structure specifies <b>STARTF_USESTDHANDLES</b>, the standard handle fields are copied
///                    unchanged to the child process without validation. The caller is responsible for ensuring that these fields
///                    contain valid handle values. Incorrect values can cause the child process to misbehave or crash. Use the
///                    Application Verifier runtime verification tool to detect invalid handles. </div> <div> </div>
///    lpProcessInformation = A pointer to a PROCESS_INFORMATION structure that receives identification information for the new process,
///                           including a handle to the process. Handles in PROCESS_INFORMATION must be closed with the CloseHandle function
///                           when they are no longer needed.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError. Note that the function returns before the process has finished
///    initialization. If a required DLL cannot be located or fails to initialize, the process is terminated. To get the
///    termination status of a process, call GetExitCodeProcess.
///    
@DllImport("ADVAPI32")
BOOL CreateProcessWithTokenW(HANDLE hToken, uint dwLogonFlags, const(PWSTR) lpApplicationName, PWSTR lpCommandLine, 
                             uint dwCreationFlags, void* lpEnvironment, const(PWSTR) lpCurrentDirectory, 
                             STARTUPINFOW* lpStartupInfo, PROCESS_INFORMATION* lpProcessInformation);

///Directs a wait thread in the thread pool to wait on the object. The wait thread queues the specified callback
///function to the thread pool when one of the following occurs: <ul> <li>The specified object is in the signaled
///state.</li> <li>The time-out interval elapses.</li> </ul>
///Params:
///    phNewWaitObject = A pointer to a variable that receives a wait handle on return. Note that a wait handle cannot be used in
///                      functions that require an object handle, such as CloseHandle.
///    hObject = A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks
///              section. If this handle is closed while the wait is still pending, the function's behavior is undefined. The
///              handles must have the <b>SYNCHRONIZE</b> access right. For more information, see Standard Access Rights.
///    Callback = A pointer to the application-defined function of type <b>WAITORTIMERCALLBACK</b> to be executed when
///               <i>hObject</i> is in the signaled state, or <i>dwMilliseconds</i> elapses. For more information, see
///               WaitOrTimerCallback.
///    Context = A single value that is passed to the callback function.
///    dwMilliseconds = The time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state
///                     is nonsignaled. If <i>dwMilliseconds</i> is zero, the function tests the object's state and returns immediately.
///                     If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function's time-out interval never elapses.
///    dwFlags = This parameter can be one or more of the following values. For information about using these values with objects
///              that remain signaled, see the Remarks section. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"><a id="WT_EXECUTEDEFAULT"></a><a id="wt_executedefault"></a><dl> <dt><b>WT_EXECUTEDEFAULT</b></dt>
///              <dt>0x00000000</dt> </dl> </td> <td width="60%"> By default, the callback function is queued to a non-I/O worker
///              thread. </td> </tr> <tr> <td width="40%"><a id="WT_EXECUTEINIOTHREAD"></a><a id="wt_executeiniothread"></a><dl>
///              <dt><b>WT_EXECUTEINIOTHREAD</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> This flag is not used.
///              <b>Windows Server 2003 and Windows XP: </b>The callback function is queued to an I/O worker thread. This flag
///              should be used if the function should be executed in a thread that waits in an alertable state. I/O worker
///              threads were removed starting with Windows Vista and Windows Server 2008. </td> </tr> <tr> <td width="40%"><a
///              id="WT_EXECUTEINPERSISTENTTHREAD"></a><a id="wt_executeinpersistentthread"></a><dl>
///              <dt><b>WT_EXECUTEINPERSISTENTTHREAD</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> The callback
///              function is queued to a thread that never terminates. It does not guarantee that the same thread is used each
///              time. This flag should be used only for short tasks or it could affect other wait operations. This flag must be
///              set if the thread calls functions that use APCs. For more information, see Asynchronous Procedure Calls. Note
///              that currently no worker thread is truly persistent, although no worker thread will terminate if there are any
///              pending I/O requests. </td> </tr> <tr> <td width="40%"><a id="WT_EXECUTEINWAITTHREAD"></a><a
///              id="wt_executeinwaitthread"></a><dl> <dt><b>WT_EXECUTEINWAITTHREAD</b></dt> <dt>0x00000004</dt> </dl> </td> <td
///              width="60%"> The callback function is invoked by the wait thread itself. This flag should be used only for short
///              tasks or it could affect other wait operations. Deadlocks can occur if some other thread acquires an exclusive
///              lock and calls the UnregisterWait or UnregisterWaitEx function while the callback function is trying to acquire
///              the same lock. </td> </tr> <tr> <td width="40%"><a id="WT_EXECUTELONGFUNCTION"></a><a
///              id="wt_executelongfunction"></a><dl> <dt><b>WT_EXECUTELONGFUNCTION</b></dt> <dt>0x00000010</dt> </dl> </td> <td
///              width="60%"> The callback function can perform a long wait. This flag helps the system to decide if it should
///              create a new thread. </td> </tr> <tr> <td width="40%"><a id="WT_EXECUTEONLYONCE"></a><a
///              id="wt_executeonlyonce"></a><dl> <dt><b>WT_EXECUTEONLYONCE</b></dt> <dt>0x00000008</dt> </dl> </td> <td
///              width="60%"> The thread will no longer wait on the handle after the callback function has been called once.
///              Otherwise, the timer is reset every time the wait operation completes until the wait operation is canceled. </td>
///              </tr> <tr> <td width="40%"><a id="WT_TRANSFER_IMPERSONATION"></a><a id="wt_transfer_impersonation"></a><dl>
///              <dt><b>WT_TRANSFER_IMPERSONATION</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Callback functions
///              will use the current access token, whether it is a process or impersonation token. If this flag is not specified,
///              callback functions execute only with the process token. <b>Windows XP: </b>This flag is not supported until
///              Windows XP with SP2 and Windows Server 2003. </td> </tr> </table>
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL RegisterWaitForSingleObject(HANDLE* phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, 
                                 void* Context, uint dwMilliseconds, uint dwFlags);

///Cancels a registered wait operation issued by the RegisterWaitForSingleObject function. To use a completion event,
///call the UnregisterWaitEx function.
///Params:
///    WaitHandle = The wait handle. This handle is returned by the RegisterWaitForSingleObject function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL UnregisterWait(HANDLE WaitHandle);

///Associates the I/O completion port owned by the thread pool with the specified file handle. On completion of an I/O
///request involving this file, a non-I/O worker thread will execute the specified callback function.
///Params:
///    FileHandle = A handle to the file opened for overlapped I/O completion. This handle is returned by the CreateFile function,
///                 with the <b>FILE_FLAG_OVERLAPPED</b> flag.
///    Function = A pointer to the callback function to be executed in a non-I/O worker thread when the I/O operation is complete.
///               This callback function must not call the TerminateThread function. For more information about the completion
///               routine, see FileIOCompletionRoutine.
///    Flags = This parameter must be zero.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call the GetLastError function. The value returned is an <b>NTSTATUS</b> error code.
///    To retrieve the corresponding system error code, use the RtlNtStatusToDosError function.
///    
@DllImport("KERNEL32")
BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, uint Flags);

///Deletes a timer queue. Any pending timers in the queue are canceled and deleted. <div class="alert"><b>Note</b> This
///function is obsolete and has been replaced by the DeleteTimerQueueEx function.</div><div> </div>
///Params:
///    TimerQueue = A handle to the timer queue. This handle is returned by the CreateTimerQueue function.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL DeleteTimerQueue(HANDLE TimerQueue);

///Creates a boundary descriptor.
///Params:
///    Name = The name of the boundary descriptor.
///    Flags = This parameter is reserved for future use.
///Returns:
///    If the function succeeds, the return value is a handle to the boundary descriptor. If the function fails, the
///    return value is <b>NULL</b>. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BoundaryDescriptorHandle CreateBoundaryDescriptorA(const(PSTR) Name, uint Flags);

///Adds a new required security identifier (SID) to the specified boundary descriptor.
///Params:
///    BoundaryDescriptor = A handle to the boundary descriptor. The CreateBoundaryDescriptor function returns this handle.
///    IntegrityLabel = A pointer to a SID structure that represents the mandatory integrity level for the namespace. Use one of the
///                     following RID values to create the SID: <b>SECURITY_MANDATORY_UNTRUSTED_RID</b> <b>SECURITY_MANDATORY_LOW_RID</b>
///                     <b>SECURITY_MANDATORY_MEDIUM_RID</b> <b>SECURITY_MANDATORY_SYSTEM_RID</b>
///                     <b>SECURITY_MANDATORY_PROTECTED_PROCESS_RID</b> For more information, see Well-Known SIDs.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE* BoundaryDescriptor, void* IntegrityLabel);

///<p class="CCE_Message">[<b>SetSystemPowerState</b> is available for use in the operating systems specified in the
///Requirements section. It may be altered or unavailable in subsequent versions. Applications written for Windows Vista
///and later should use SetSuspendState instead.] Suspends the system by shutting power down. Depending on the
///<i>ForceFlag</i> parameter, the function either suspends operation immediately or requests permission from all
///applications and device drivers before doing so.
///Params:
///    fSuspend = If this parameter is <b>TRUE</b>, the system is suspended. If the parameter is <b>FALSE</b>, the system
///               hibernates.
///    fForce = This parameter has no effect.
///Returns:
///    If power has been suspended and subsequently restored, the return value is nonzero. If the system was not
///    suspended, the return value is zero. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce);

///Retrieves the power status of the system. The status indicates whether the system is running on AC or DC power,
///whether the battery is currently charging, how much battery life remains, and if battery saver is on or off.
///Params:
///    lpSystemPowerStatus = A pointer to a SYSTEM_POWER_STATUS structure that receives status information.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetSystemPowerStatus(SYSTEM_POWER_STATUS* lpSystemPowerStatus);

///Maps previously allocated physical memory pages at a specified address in an Address Windowing Extensions (AWE)
///region. <b>64-bit Windows on Itanium-based systems: </b>Due to the difference in page sizes,
///<b>MapUserPhysicalPagesScatter</b> is not supported for 32-bit applications.
///Params:
///    VirtualAddresses = A pointer to an array of starting addresses of the regions of memory to remap. Each entry in
///                       <i>VirtualAddresses</i> must be within the address range that the VirtualAlloc function returns when the Address
///                       Windowing Extensions (AWE) region is allocated. The value in <i>NumberOfPages</i> indicates the size of the
///                       array. Entries can be from multiple Address Windowing Extensions (AWE) regions.
///    NumberOfPages = The size of the physical memory and virtual address space for which to establish translations, in pages. The
///                    array at <i>VirtualAddresses</i> specifies the virtual address range.
///    PageArray = A pointer to an array of values that indicates how each corresponding page in <i>VirtualAddresses</i> should be
///                treated. A 0 (zero) indicates that the corresponding entry in <i>VirtualAddresses</i> should be unmapped, and any
///                nonzero value that it has should be mapped. If this parameter is <b>NULL</b>, then every address in the
///                <i>VirtualAddresses</i> array is unmapped. The value in <i>NumberOfPages</i> indicates the size of the array.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is
///    <b>FALSE</b>, and the function does not map or unmap—partial or otherwise. To get extended error information,
///    call GetLastError.
///    
@DllImport("KERNEL32")
BOOL MapUserPhysicalPagesScatter(void** VirtualAddresses, size_t NumberOfPages, uint* PageArray);

///Creates or opens a job object.
///Params:
///    lpJobAttributes = A pointer to a SECURITY_ATTRIBUTES structure that specifies the security descriptor for the job object and
///                      determines whether child processes can inherit the returned handle. If <i>lpJobAttributes</i> is <b>NULL</b>, the
///                      job object gets a default security descriptor and the handle cannot be inherited. The ACLs in the default
///                      security descriptor for a job object come from the primary or impersonation token of the creator.
///    lpName = The name of the job. The name is limited to <b>MAX_PATH</b> characters. Name comparison is case-sensitive. If
///             <i>lpName</i> is <b>NULL</b>, the job is created without a name. If <i>lpName</i> matches the name of an existing
///             event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the GetLastError function
///             returns <b>ERROR_INVALID_HANDLE</b>. This occurs because these objects share the same namespace. The object can
///             be created in a private namespace. For more information, see Object Namespaces. <b>Terminal Services: </b>The
///             name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace.
///             The remainder of the name can contain any character except the backslash character (\\). For more information,
///             see Kernel Object Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the job object. The handle has the
///    <b>JOB_OBJECT_ALL_ACCESS</b> access right. If the object existed before the function call, the function returns a
///    handle to the existing job object and GetLastError returns <b>ERROR_ALREADY_EXISTS</b>. If the function fails,
///    the return value is NULL. To get extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
HANDLE CreateJobObjectA(SECURITY_ATTRIBUTES* lpJobAttributes, const(PSTR) lpName);

///Opens an existing job object.
///Params:
///    dwDesiredAccess = The access to the job object. This parameter can be one or more of the job object access rights. This access
///                      right is checked against any security descriptor for the object.
///    bInheritHandle = If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not
///                     inherit this handle.
///    lpName = The name of the job to be opened. Name comparisons are case sensitive. This function can open objects in a
///             private namespace. For more information, see Object Namespaces. <b>Terminal Services: </b>The name can have a
///             "Global\" or "Local\" prefix to explicitly open the object in the global or session namespace. The remainder of
///             the name can contain any character except the backslash character (\\). For more information, see Kernel Object
///             Namespaces.
///Returns:
///    If the function succeeds, the return value is a handle to the job. The handle provides the requested access to
///    the job. If the function fails, the return value is <b>NULL</b>. To get extended error information, call
///    GetLastError.
///    
@DllImport("KERNEL32")
HANDLE OpenJobObjectA(uint dwDesiredAccess, BOOL bInheritHandle, const(PSTR) lpName);

///Returns the number of active processor groups in the system.
///Returns:
///    If the function succeeds, the return value is the number of active processor groups in the system. If the
///    function fails, the return value is zero.
///    
@DllImport("KERNEL32")
ushort GetActiveProcessorGroupCount();

///Returns the maximum number of processor groups that the system can have.
///Returns:
///    If the function succeeds, the return value is the maximum number of processor groups that the system can have. If
///    the function fails, the return value is zero.
///    
@DllImport("KERNEL32")
ushort GetMaximumProcessorGroupCount();

///Returns the number of active processors in a processor group or in the system.
///Params:
///    GroupNumber = The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the number of active
///                  processors in the system.
///Returns:
///    If the function succeeds, the return value is the number of active processors in the specified group. If the
///    function fails, the return value is zero. To get extended error information, use GetLastError.
///    
@DllImport("KERNEL32")
uint GetActiveProcessorCount(ushort GroupNumber);

///Returns the maximum number of logical processors that a processor group or the system can have.
///Params:
///    GroupNumber = The processor group number. If this parameter is ALL_PROCESSOR_GROUPS, the function returns the maximum number of
///                  processors that the system can have.
///Returns:
///    If the function succeeds, the return value is the maximum number of processors that the specified group can have.
///    If the function fails, the return value is zero. To get extended error information, use GetLastError.
///    
@DllImport("KERNEL32")
uint GetMaximumProcessorCount(ushort GroupNumber);

///Retrieves the node number for the specified processor. Use the GetNumaProcessorNodeEx function to specify a processor
///group and retrieve the node number as a <b>USHORT</b> value.
///Params:
///    Processor = The processor number. On a system with more than 64 logical processors, the processor number is relative to the
///                processor group that contains the processor on which the calling thread is running.
///    NodeNumber = The node number. If the processor does not exist, this parameter is 0xFF.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNumaProcessorNode(ubyte Processor, ubyte* NodeNumber);

///Retrieves the NUMA node associated with the file or I/O device represented by the specified file handle.
///Params:
///    hFile = A handle to a file or I/O device. Examples of I/O devices include files, file streams, volumes, physical disks,
///            and sockets. For more information, see the CreateFile function.
///    NodeNumber = A pointer to a variable to receive the number of the NUMA node associated with the specified file handle.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, use GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, ushort* NodeNumber);

///Retrieves the node number as a <b>USHORT</b> value for the specified logical processor.
///Params:
///    Processor = A pointer to a PROCESSOR_NUMBER structure that represents the logical processor and the processor group to which
///                it is assigned.
///    NodeNumber = A pointer to a variable to receive the node number. If the specified processor does not exist, this parameter is
///                 set to MAXUSHORT.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNumaProcessorNodeEx(PROCESSOR_NUMBER* Processor, ushort* NodeNumber);

///Retrieves the processor mask for the specified node. Use the GetNumaNodeProcessorMaskEx function to retrieve the
///processor mask for a node in any processor group.
///Params:
///    Node = The number of the node.
///    ProcessorMask = The processor mask for the node. A processor mask is a bit vector in which each bit represents a processor and
///                    whether it is in the node. If the node has no processors configured, the processor mask is zero. On systems with
///                    more than 64 processors, this parameter is set to the processor mask for the node only if the node is in the same
///                    processor group as the calling thread. Otherwise, the parameter is set to zero.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNumaNodeProcessorMask(ubyte Node, ulong* ProcessorMask);

///Retrieves the amount of memory available in the specified node. Use the GetNumaAvailableMemoryNodeEx function to
///specify the node as a <b>USHORT</b> value.
///Params:
///    Node = The number of the node.
///    AvailableBytes = The amount of available memory for the node, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNumaAvailableMemoryNode(ubyte Node, ulong* AvailableBytes);

///Retrieves the amount of memory that is available in a node specified as a <b>USHORT</b> value.
///Params:
///    Node = The number of the node.
///    AvailableBytes = The amount of available memory for the node, in bytes.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNumaAvailableMemoryNodeEx(ushort Node, ulong* AvailableBytes);

///Retrieves the NUMA node number that corresponds to the specified proximity domain identifier. Use the
///GetNumaProximityNodeEx function to retrieve the node number as a <b>USHORT</b> value.
///Params:
///    ProximityId = The proximity domain identifier of the node.
///    NodeNumber = The node number. If the processor does not exist, this parameter is 0xFF.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("KERNEL32")
BOOL GetNumaProximityNode(uint ProximityId, ubyte* NodeNumber);

///Registers a callback function to be called when a secured memory range is freed or its protections are changed.
///Params:
///    pfnCallBack = A pointer to the application-defined SecureMemoryCacheCallback function to register.
///Returns:
///    If the function succeeds, it registers the callback function and returns <b>TRUE</b>. If the function fails, it
///    returns <b>FALSE</b>. To get extended error information, call the GetLastError function.
///    
@DllImport("KERNEL32")
BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);

///Unregisters a callback function that was previously registered with the AddSecureMemoryCacheCallback function.
///Params:
///    pfnCallBack = A pointer to the application-defined SecureMemoryCacheCallback function to remove.
///Returns:
///    If the function succeeds, it returns <b>TRUE</b>. If the function fails, it returns <b>FALSE</b>.
///    
@DllImport("KERNEL32")
BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);

///Initiates a shutdown and optional restart of the specified computer. To record a reason for the shutdown in the event
///log, call the InitiateSystemShutdownEx function.
///Params:
///    lpMachineName = The network name of the computer to be shut down. If <i>lpMachineName</i> is <b>NULL</b> or an empty string, the
///                    function shuts down the local computer.
///    lpMessage = The message to be displayed in the shutdown dialog box. This parameter can be <b>NULL</b> if no message is
///                required. <b>Windows Server 2003 and Windows XP: </b>This string is also stored as a comment in the event log
///                entry. <b>Windows Server 2003 and Windows XP with SP1: </b>The string is limited to 3072 <b>TCHARs</b>.
///    dwTimeout = The length of time that the shutdown dialog box should be displayed, in seconds. While this dialog box is
///                displayed, the shutdown can be stopped by the AbortSystemShutdown function. If <i>dwTimeout</i> is not zero,
///                <b>InitiateSystemShutdown</b> displays a dialog box on the specified computer. The dialog box displays the name
///                of the user who called the function, displays the message specified by the <i>lpMessage</i> parameter, and
///                prompts the user to log off. The dialog box beeps when it is created and remains on top of other windows in the
///                system. The dialog box can be moved but not closed. A timer counts down the remaining time before a forced
///                shutdown. If <i>dwTimeout</i> is zero, the computer shuts down without displaying the dialog box, and the
///                shutdown cannot be stopped by AbortSystemShutdown. <b>Windows Server 2003 and Windows XP with SP1: </b>The
///                time-out value is limited to <b>MAX_SHUTDOWN_TIMEOUT</b> seconds. <b>Windows Server 2003 and Windows XP with SP1:
///                </b>If the computer to be shut down is a Terminal Services server, the system displays a dialog box to all local
///                and remote users warning them that shutdown has been initiated. The dialog box includes who requested the
///                shutdown, the display message (see <i>lpMessage</i>), and how much time there is until the server is shut down.
///    bForceAppsClosed = If this parameter is <b>TRUE</b>, applications with unsaved changes are to be forcibly closed. Note that this can
///                       result in data loss. If this parameter is <b>FALSE</b>, the system displays a dialog box instructing the user to
///                       close the applications.
///    bRebootAfterShutdown = If this parameter is <b>TRUE</b>, the computer is to restart immediately after shutting down. If this parameter
///                           is <b>FALSE</b>, the system flushes all caches to disk and safely powers down the system.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL InitiateSystemShutdownA(PSTR lpMachineName, PSTR lpMessage, uint dwTimeout, BOOL bForceAppsClosed, 
                             BOOL bRebootAfterShutdown);

///Initiates a shutdown and optional restart of the specified computer. To record a reason for the shutdown in the event
///log, call the InitiateSystemShutdownEx function.
///Params:
///    lpMachineName = The network name of the computer to be shut down. If <i>lpMachineName</i> is <b>NULL</b> or an empty string, the
///                    function shuts down the local computer.
///    lpMessage = The message to be displayed in the shutdown dialog box. This parameter can be <b>NULL</b> if no message is
///                required. <b>Windows Server 2003 and Windows XP: </b>This string is also stored as a comment in the event log
///                entry. <b>Windows Server 2003 and Windows XP with SP1: </b>The string is limited to 3072 <b>TCHARs</b>.
///    dwTimeout = The length of time that the shutdown dialog box should be displayed, in seconds. While this dialog box is
///                displayed, the shutdown can be stopped by the AbortSystemShutdown function. If <i>dwTimeout</i> is not zero,
///                <b>InitiateSystemShutdown</b> displays a dialog box on the specified computer. The dialog box displays the name
///                of the user who called the function, displays the message specified by the <i>lpMessage</i> parameter, and
///                prompts the user to log off. The dialog box beeps when it is created and remains on top of other windows in the
///                system. The dialog box can be moved but not closed. A timer counts down the remaining time before a forced
///                shutdown. If <i>dwTimeout</i> is zero, the computer shuts down without displaying the dialog box, and the
///                shutdown cannot be stopped by AbortSystemShutdown. <b>Windows Server 2003 and Windows XP with SP1: </b>The
///                time-out value is limited to <b>MAX_SHUTDOWN_TIMEOUT</b> seconds. <b>Windows Server 2003 and Windows XP with SP1:
///                </b>If the computer to be shut down is a Terminal Services server, the system displays a dialog box to all local
///                and remote users warning them that shutdown has been initiated. The dialog box includes who requested the
///                shutdown, the display message (see <i>lpMessage</i>), and how much time there is until the server is shut down.
///    bForceAppsClosed = If this parameter is <b>TRUE</b>, applications with unsaved changes are to be forcibly closed. Note that this can
///                       result in data loss. If this parameter is <b>FALSE</b>, the system displays a dialog box instructing the user to
///                       close the applications.
///    bRebootAfterShutdown = If this parameter is <b>TRUE</b>, the computer is to restart immediately after shutting down. If this parameter
///                           is <b>FALSE</b>, the system flushes all caches to disk and safely powers down the system.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL InitiateSystemShutdownW(PWSTR lpMachineName, PWSTR lpMessage, uint dwTimeout, BOOL bForceAppsClosed, 
                             BOOL bRebootAfterShutdown);

///Stops a system shutdown that has been initiated.
///Params:
///    lpMachineName = The network name of the computer where the shutdown is to be stopped. If <i>lpMachineName</i> is <b>NULL</b> or
///                    an empty string, the function stops the shutdown on the local computer.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL AbortSystemShutdownA(PSTR lpMachineName);

///Stops a system shutdown that has been initiated.
///Params:
///    lpMachineName = The network name of the computer where the shutdown is to be stopped. If <i>lpMachineName</i> is <b>NULL</b> or
///                    an empty string, the function stops the shutdown on the local computer.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL AbortSystemShutdownW(PWSTR lpMachineName);

///Initiates a shutdown and optional restart of the specified computer, and optionally records the reason for the
///shutdown.
///Params:
///    lpMachineName = The network name of the computer to be shut down. If <i>lpMachineName</i> is <b>NULL</b> or an empty string, the
///                    function shuts down the local computer.
///    lpMessage = The message to be displayed in the shutdown dialog box. This parameter can be <b>NULL</b> if no message is
///                required. <b>Windows Server 2003 and Windows XP: </b>This string is also stored as a comment in the event log
///                entry. <b>Windows Server 2003 and Windows XP with SP1: </b>The string is limited to 3072 <b>TCHARs</b>.
///    dwTimeout = The length of time that the shutdown dialog box should be displayed, in seconds. While this dialog box is
///                displayed, shutdown can be stopped by the AbortSystemShutdown function. If <i>dwTimeout</i> is not zero,
///                <b>InitiateSystemShutdownEx</b> displays a dialog box on the specified computer. The dialog box displays the name
///                of the user who called the function, displays the message specified by the <i>lpMessage</i> parameter, and
///                prompts the user to log off. The dialog box beeps when it is created and remains on top of other windows in the
///                system. The dialog box can be moved but not closed. A timer counts down the remaining time before shutdown. If
///                <i>dwTimeout</i> is zero, the computer shuts down without displaying the dialog box, and the shutdown cannot be
///                stopped by AbortSystemShutdown. <b>Windows Server 2003 and Windows XP with SP1: </b>The time-out value is limited
///                to MAX_SHUTDOWN_TIMEOUT seconds. <b>Windows Server 2003 and Windows XP with SP1: </b>If the computer to be shut
///                down is a Terminal Services server, the system displays a dialog box to all local and remote users warning them
///                that shutdown has been initiated. The dialog box includes who requested the shutdown, the display message (see
///                <i>lpMessage</i>), and how much time there is until the server is shut down.
///    bForceAppsClosed = If this parameter is <b>TRUE</b>, applications with unsaved changes are to be forcibly closed. If this parameter
///                       is <b>FALSE</b>, the system displays a dialog box instructing the user to close the applications.
///    bRebootAfterShutdown = If this parameter is <b>TRUE</b>, the computer is to restart immediately after shutting down. If this parameter
///                           is <b>FALSE</b>, the system flushes all caches to disk and safely powers down the system.
///    dwReason = The reason for initiating the shutdown. This parameter must be one of the system shutdown reason codes. If this
///               parameter is zero, the default is an undefined shutdown that is logged as "No title for this reason could be
///               found". By default, it is also an unplanned shutdown. Depending on how the system is configured, an unplanned
///               shutdown triggers the creation of a file that contains the system state information, which can delay shutdown.
///               Therefore, do not use zero for this parameter. <b>Windows XP: </b>System state information is not saved during an
///               unplanned system shutdown. The preceding text does not apply.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL InitiateSystemShutdownExA(PSTR lpMachineName, PSTR lpMessage, uint dwTimeout, BOOL bForceAppsClosed, 
                               BOOL bRebootAfterShutdown, uint dwReason);

///Initiates a shutdown and optional restart of the specified computer, and optionally records the reason for the
///shutdown.
///Params:
///    lpMachineName = The network name of the computer to be shut down. If <i>lpMachineName</i> is <b>NULL</b> or an empty string, the
///                    function shuts down the local computer.
///    lpMessage = The message to be displayed in the shutdown dialog box. This parameter can be <b>NULL</b> if no message is
///                required. <b>Windows Server 2003 and Windows XP: </b>This string is also stored as a comment in the event log
///                entry. <b>Windows Server 2003 and Windows XP with SP1: </b>The string is limited to 3072 <b>TCHARs</b>.
///    dwTimeout = The length of time that the shutdown dialog box should be displayed, in seconds. While this dialog box is
///                displayed, shutdown can be stopped by the AbortSystemShutdown function. If <i>dwTimeout</i> is not zero,
///                <b>InitiateSystemShutdownEx</b> displays a dialog box on the specified computer. The dialog box displays the name
///                of the user who called the function, displays the message specified by the <i>lpMessage</i> parameter, and
///                prompts the user to log off. The dialog box beeps when it is created and remains on top of other windows in the
///                system. The dialog box can be moved but not closed. A timer counts down the remaining time before shutdown. If
///                <i>dwTimeout</i> is zero, the computer shuts down without displaying the dialog box, and the shutdown cannot be
///                stopped by AbortSystemShutdown. <b>Windows Server 2003 and Windows XP with SP1: </b>The time-out value is limited
///                to MAX_SHUTDOWN_TIMEOUT seconds. <b>Windows Server 2003 and Windows XP with SP1: </b>If the computer to be shut
///                down is a Terminal Services server, the system displays a dialog box to all local and remote users warning them
///                that shutdown has been initiated. The dialog box includes who requested the shutdown, the display message (see
///                <i>lpMessage</i>), and how much time there is until the server is shut down.
///    bForceAppsClosed = If this parameter is <b>TRUE</b>, applications with unsaved changes are to be forcibly closed. If this parameter
///                       is <b>FALSE</b>, the system displays a dialog box instructing the user to close the applications.
///    bRebootAfterShutdown = If this parameter is <b>TRUE</b>, the computer is to restart immediately after shutting down. If this parameter
///                           is <b>FALSE</b>, the system flushes all caches to disk and safely powers down the system.
///    dwReason = The reason for initiating the shutdown. This parameter must be one of the system shutdown reason codes. If this
///               parameter is zero, the default is an undefined shutdown that is logged as "No title for this reason could be
///               found". By default, it is also an unplanned shutdown. Depending on how the system is configured, an unplanned
///               shutdown triggers the creation of a file that contains the system state information, which can delay shutdown.
///               Therefore, do not use zero for this parameter. <b>Windows XP: </b>System state information is not saved during an
///               unplanned system shutdown. The preceding text does not apply.
///Returns:
///    If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
///    extended error information, call GetLastError.
///    
@DllImport("ADVAPI32")
BOOL InitiateSystemShutdownExW(PWSTR lpMachineName, PWSTR lpMessage, uint dwTimeout, BOOL bForceAppsClosed, 
                               BOOL bRebootAfterShutdown, uint dwReason);

///Initiates a shutdown and restart of the specified computer, and restarts any applications that have been registered
///for restart.
///Params:
///    lpMachineName = The name of the computer to be shut down. If the value of this parameter is <b>NULL</b>, the local computer is
///                    shut down.
///    lpMessage = The message to be displayed in the interactive shutdown dialog box.
///    dwGracePeriod = The number of seconds to wait before shutting down the computer. If the value of this parameter is zero, the
///                    computer is shut down immediately. This value is limited to <b>MAX_SHUTDOWN_TIMEOUT</b>. If the value of this
///                    parameter is greater than zero, and the <i>dwShutdownFlags</i> parameter specifies the flag
///                    <b>SHUTDOWN_GRACE_OVERRIDE</b>, the function fails and returns the error code <b>ERROR_BAD_ARGUMENTS</b>.
///    dwShutdownFlags = One or more bit flags that specify options for the shutdown. The following values are defined. <table> <tr>
///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SHUTDOWN_FORCE_OTHERS"></a><a
///                      id="shutdown_force_others"></a><dl> <dt><b>SHUTDOWN_FORCE_OTHERS</b></dt> <dt>0x00000001 (0x1)</dt> </dl> </td>
///                      <td width="60%"> All sessions are forcefully logged off. If this flag is not set and users other than the current
///                      user are logged on to the computer specified by the <i>lpMachineName</i> parameter, this function fails with a
///                      return value of <b>ERROR_SHUTDOWN_USERS_LOGGED_ON</b>. </td> </tr> <tr> <td width="40%"><a
///                      id="SHUTDOWN_FORCE_SELF"></a><a id="shutdown_force_self"></a><dl> <dt><b>SHUTDOWN_FORCE_SELF</b></dt>
///                      <dt>0x00000002 (0x2)</dt> </dl> </td> <td width="60%"> Specifies that the originating session is logged off
///                      forcefully. If this flag is not set, the originating session is shut down interactively, so a shutdown is not
///                      guaranteed even if the function returns successfully. </td> </tr> <tr> <td width="40%"><a
///                      id="SHUTDOWN_GRACE_OVERRIDE"></a><a id="shutdown_grace_override"></a><dl> <dt><b>SHUTDOWN_GRACE_OVERRIDE</b></dt>
///                      <dt>0x00000020 (0x20)</dt> </dl> </td> <td width="60%"> Overrides the grace period so that the computer is shut
///                      down immediately. </td> </tr> <tr> <td width="40%"><a id="SHUTDOWN_HYBRID"></a><a id="shutdown_hybrid"></a><dl>
///                      <dt><b>SHUTDOWN_HYBRID</b></dt> <dt>0x00000200 (0x200)</dt> </dl> </td> <td width="60%"> Beginning with
///                      <b>InitiateShutdown</b> running on Windows 8, you must include the <b>SHUTDOWN_HYBRID</b> flag with one or more
///                      of the flags in this table to specify options for the shutdown. Beginning with Windows 8, <b>InitiateShutdown</b>
///                      always initiate a full system shutdown if the <b>SHUTDOWN_HYBRID</b> flag is absent. </td> </tr> <tr> <td
///                      width="40%"><a id="SHUTDOWN_INSTALL_UPDATES"></a><a id="shutdown_install_updates"></a><dl>
///                      <dt><b>SHUTDOWN_INSTALL_UPDATES</b></dt> <dt>0x00000040 (0x40)</dt> </dl> </td> <td width="60%"> The computer
///                      installs any updates before starting the shutdown. </td> </tr> <tr> <td width="40%"><a
///                      id="SHUTDOWN_NOREBOOT"></a><a id="shutdown_noreboot"></a><dl> <dt><b>SHUTDOWN_NOREBOOT</b></dt> <dt>0x00000010
///                      (0x10)</dt> </dl> </td> <td width="60%"> The computer is shut down but is not powered down or rebooted. </td>
///                      </tr> <tr> <td width="40%"><a id="SHUTDOWN_POWEROFF"></a><a id="shutdown_poweroff"></a><dl>
///                      <dt><b>SHUTDOWN_POWEROFF</b></dt> <dt>0x00000008 (0x8)</dt> </dl> </td> <td width="60%"> The computer is shut
///                      down and powered down. </td> </tr> <tr> <td width="40%"><a id="SHUTDOWN_RESTART"></a><a
///                      id="shutdown_restart"></a><dl> <dt><b>SHUTDOWN_RESTART</b></dt> <dt>0x00000004 (0x4)</dt> </dl> </td> <td
///                      width="60%"> The computer is shut down and rebooted. </td> </tr> <tr> <td width="40%"><a
///                      id="SHUTDOWN_RESTARTAPPS"></a><a id="shutdown_restartapps"></a><dl> <dt><b>SHUTDOWN_RESTARTAPPS</b></dt>
///                      <dt>0x00000080 (0x80)</dt> </dl> </td> <td width="60%"> The system is rebooted using the ExitWindowsEx function
///                      with the EWX_RESTARTAPPS flag. This restarts any applications that have been registered for restart using the
///                      RegisterApplicationRestart function. </td> </tr> </table>
///    dwReason = The reason for initiating the shutdown. This parameter must be one of the system shutdown reason codes. If this
///               parameter is zero, the default is an undefined shutdown that is logged as "No title for this reason could be
///               found". By default, it is also an unplanned shutdown. Depending on how the system is configured, an unplanned
///               shutdown triggers the creation of a file that contains the system state information, which can delay shutdown.
///               Therefore, do not use zero for this parameter.
///Returns:
///    If the function succeeds, it returns <b>ERROR_SUCCESS</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The caller does not have the required privilege
///    (SE_SHUTDOWN_PRIVILEGE or SE_REMOTE_SHUTDOWN_PRIVILEGE) to perform this operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_NETPATH</b></dt> </dl> </td> <td width="60%"> The specified computer does not
///    exist or is not accessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_COMPUTERNAME</b></dt>
///    </dl> </td> <td width="60%"> The specified computer name is not a valid computer name. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_FUNCTION</b></dt> </dl> </td> <td width="60%"> The specified computer does
///    not support a shutdown interface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid set of parameters was passed. This includes the following combinations.
///    <ul> <li>The <i>lpMachineName</i> parameter specifies a remote computer, and the <i>dwShutdownFlags</i> parameter
///    does not specify <b>SHUTDOWN_FORCE_SELF</b>.</li> <li>The value of the <i>dwGracePeriod</i> is greater than zero
///    and the <i>dwShutdownFlags</i> parameter does not specify <b>SHUTDOWN_FORCE_SELF</b>.</li> <li>The value of the
///    <i>dwGracePeriod</i> is greater than zero and the <i>dwShutdownFlags</i> parameter specifies
///    <b>SHUTDOWN_GRACE_OVERRIDE</b>.</li> </ul> </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SHUTDOWN_IN_PROGRESS</b></dt> </dl> </td> <td width="60%"> A shutdown has already been started on
///    the specified computer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SHUTDOWN_IS_SCHEDULED</b></dt> </dl>
///    </td> <td width="60%"> A shutdown for the specified computer has been scheduled but not started. For this
///    function to succeed, the <b>SHUTDOWN_GRACE_OVERRIDE</b> flag must be set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SHUTDOWN_USERS_LOGGED_ON</b></dt> </dl> </td> <td width="60%"> One or more users other than the
///    current user are logged on the specified machine, and the <b>SHUTDOWN_FORCE_OTHERS</b> flag was not set. </td>
///    </tr> </table>
///    
@DllImport("ADVAPI32")
uint InitiateShutdownA(PSTR lpMachineName, PSTR lpMessage, uint dwGracePeriod, uint dwShutdownFlags, uint dwReason);

///Initiates a shutdown and restart of the specified computer, and restarts any applications that have been registered
///for restart.
///Params:
///    lpMachineName = The name of the computer to be shut down. If the value of this parameter is <b>NULL</b>, the local computer is
///                    shut down.
///    lpMessage = The message to be displayed in the interactive shutdown dialog box.
///    dwGracePeriod = The number of seconds to wait before shutting down the computer. If the value of this parameter is zero, the
///                    computer is shut down immediately. This value is limited to <b>MAX_SHUTDOWN_TIMEOUT</b>. If the value of this
///                    parameter is greater than zero, and the <i>dwShutdownFlags</i> parameter specifies the flag
///                    <b>SHUTDOWN_GRACE_OVERRIDE</b>, the function fails and returns the error code <b>ERROR_BAD_ARGUMENTS</b>.
///    dwShutdownFlags = One or more bit flags that specify options for the shutdown. The following values are defined. <table> <tr>
///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SHUTDOWN_FORCE_OTHERS"></a><a
///                      id="shutdown_force_others"></a><dl> <dt><b>SHUTDOWN_FORCE_OTHERS</b></dt> <dt>0x00000001 (0x1)</dt> </dl> </td>
///                      <td width="60%"> All sessions are forcefully logged off. If this flag is not set and users other than the current
///                      user are logged on to the computer specified by the <i>lpMachineName</i> parameter, this function fails with a
///                      return value of <b>ERROR_SHUTDOWN_USERS_LOGGED_ON</b>. </td> </tr> <tr> <td width="40%"><a
///                      id="SHUTDOWN_FORCE_SELF"></a><a id="shutdown_force_self"></a><dl> <dt><b>SHUTDOWN_FORCE_SELF</b></dt>
///                      <dt>0x00000002 (0x2)</dt> </dl> </td> <td width="60%"> Specifies that the originating session is logged off
///                      forcefully. If this flag is not set, the originating session is shut down interactively, so a shutdown is not
///                      guaranteed even if the function returns successfully. </td> </tr> <tr> <td width="40%"><a
///                      id="SHUTDOWN_GRACE_OVERRIDE"></a><a id="shutdown_grace_override"></a><dl> <dt><b>SHUTDOWN_GRACE_OVERRIDE</b></dt>
///                      <dt>0x00000020 (0x20)</dt> </dl> </td> <td width="60%"> Overrides the grace period so that the computer is shut
///                      down immediately. </td> </tr> <tr> <td width="40%"><a id="SHUTDOWN_HYBRID"></a><a id="shutdown_hybrid"></a><dl>
///                      <dt><b>SHUTDOWN_HYBRID</b></dt> <dt>0x00000200 (0x200)</dt> </dl> </td> <td width="60%"> Beginning with
///                      <b>InitiateShutdown</b> running on Windows 8, you must include the <b>SHUTDOWN_HYBRID</b> flag with one or more
///                      of the flags in this table to specify options for the shutdown. Beginning with Windows 8, <b>InitiateShutdown</b>
///                      always initiate a full system shutdown if the <b>SHUTDOWN_HYBRID</b> flag is absent. </td> </tr> <tr> <td
///                      width="40%"><a id="SHUTDOWN_INSTALL_UPDATES"></a><a id="shutdown_install_updates"></a><dl>
///                      <dt><b>SHUTDOWN_INSTALL_UPDATES</b></dt> <dt>0x00000040 (0x40)</dt> </dl> </td> <td width="60%"> The computer
///                      installs any updates before starting the shutdown. </td> </tr> <tr> <td width="40%"><a
///                      id="SHUTDOWN_NOREBOOT"></a><a id="shutdown_noreboot"></a><dl> <dt><b>SHUTDOWN_NOREBOOT</b></dt> <dt>0x00000010
///                      (0x10)</dt> </dl> </td> <td width="60%"> The computer is shut down but is not powered down or rebooted. </td>
///                      </tr> <tr> <td width="40%"><a id="SHUTDOWN_POWEROFF"></a><a id="shutdown_poweroff"></a><dl>
///                      <dt><b>SHUTDOWN_POWEROFF</b></dt> <dt>0x00000008 (0x8)</dt> </dl> </td> <td width="60%"> The computer is shut
///                      down and powered down. </td> </tr> <tr> <td width="40%"><a id="SHUTDOWN_RESTART"></a><a
///                      id="shutdown_restart"></a><dl> <dt><b>SHUTDOWN_RESTART</b></dt> <dt>0x00000004 (0x4)</dt> </dl> </td> <td
///                      width="60%"> The computer is shut down and rebooted. </td> </tr> <tr> <td width="40%"><a
///                      id="SHUTDOWN_RESTARTAPPS"></a><a id="shutdown_restartapps"></a><dl> <dt><b>SHUTDOWN_RESTARTAPPS</b></dt>
///                      <dt>0x00000080 (0x80)</dt> </dl> </td> <td width="60%"> The system is rebooted using the ExitWindowsEx function
///                      with the EWX_RESTARTAPPS flag. This restarts any applications that have been registered for restart using the
///                      RegisterApplicationRestart function. </td> </tr> </table>
///    dwReason = The reason for initiating the shutdown. This parameter must be one of the system shutdown reason codes. If this
///               parameter is zero, the default is an undefined shutdown that is logged as "No title for this reason could be
///               found". By default, it is also an unplanned shutdown. Depending on how the system is configured, an unplanned
///               shutdown triggers the creation of a file that contains the system state information, which can delay shutdown.
///               Therefore, do not use zero for this parameter.
///Returns:
///    If the function succeeds, it returns <b>ERROR_SUCCESS</b>. If the function fails, it returns one of the following
///    error codes. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_ACCESS_DENIED</b></dt> </dl> </td> <td width="60%"> The caller does not have the required privilege
///    (SE_SHUTDOWN_PRIVILEGE or SE_REMOTE_SHUTDOWN_PRIVILEGE) to perform this operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_BAD_NETPATH</b></dt> </dl> </td> <td width="60%"> The specified computer does not
///    exist or is not accessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_COMPUTERNAME</b></dt>
///    </dl> </td> <td width="60%"> The specified computer name is not a valid computer name. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>ERROR_INVALID_FUNCTION</b></dt> </dl> </td> <td width="60%"> The specified computer does
///    not support a shutdown interface. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt>
///    </dl> </td> <td width="60%"> An invalid set of parameters was passed. This includes the following combinations.
///    <ul> <li>The <i>lpMachineName</i> parameter specifies a remote computer, and the <i>dwShutdownFlags</i> parameter
///    does not specify <b>SHUTDOWN_FORCE_SELF</b>.</li> <li>The value of the <i>dwGracePeriod</i> is greater than zero
///    and the <i>dwShutdownFlags</i> parameter does not specify <b>SHUTDOWN_FORCE_SELF</b>.</li> <li>The value of the
///    <i>dwGracePeriod</i> is greater than zero and the <i>dwShutdownFlags</i> parameter specifies
///    <b>SHUTDOWN_GRACE_OVERRIDE</b>.</li> </ul> </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SHUTDOWN_IN_PROGRESS</b></dt> </dl> </td> <td width="60%"> A shutdown has already been started on
///    the specified computer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_SHUTDOWN_IS_SCHEDULED</b></dt> </dl>
///    </td> <td width="60%"> A shutdown for the specified computer has been scheduled but not started. For this
///    function to succeed, the <b>SHUTDOWN_GRACE_OVERRIDE</b> flag must be set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SHUTDOWN_USERS_LOGGED_ON</b></dt> </dl> </td> <td width="60%"> One or more users other than the
///    current user are logged on the specified machine, and the <b>SHUTDOWN_FORCE_OTHERS</b> flag was not set. </td>
///    </tr> </table>
///    
@DllImport("ADVAPI32")
uint InitiateShutdownW(PWSTR lpMachineName, PWSTR lpMessage, uint dwGracePeriod, uint dwShutdownFlags, 
                       uint dwReason);

///<p class="CCE_Message">[<b>NtQueryInformationProcess</b> may be altered or unavailable in future versions of Windows.
///Applications should use the alternate functions listed in this topic.] Retrieves information about the specified
///process.
///Params:
///    ProcessHandle = A handle to the process for which information is to be retrieved.
///    ProcessInformationClass = The type of process information to be retrieved. This parameter can be one of the following values from the
///                              <b>PROCESSINFOCLASS</b> enumeration. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                              id="ProcessBasicInformation"></a><a id="processbasicinformation"></a><a id="PROCESSBASICINFORMATION"></a><dl>
///                              <dt><b>ProcessBasicInformation</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> Retrieves a pointer to a PEB
///                              structure that can be used to determine whether the specified process is being debugged, and a unique value used
///                              by the system to identify the specified process. Use the CheckRemoteDebuggerPresent and GetProcessId functions to
///                              obtain this information. </td> </tr> <tr> <td width="40%"><a id="ProcessDebugPort"></a><a
///                              id="processdebugport"></a><a id="PROCESSDEBUGPORT"></a><dl> <dt><b>ProcessDebugPort</b></dt> <dt>7</dt> </dl>
///                              </td> <td width="60%"> Retrieves a <b>DWORD_PTR</b> value that is the port number of the debugger for the
///                              process. A nonzero value indicates that the process is being run under the control of a ring 3 debugger. Use the
///                              CheckRemoteDebuggerPresent or IsDebuggerPresent function. </td> </tr> <tr> <td width="40%"><a
///                              id="ProcessWow64Information"></a><a id="processwow64information"></a><a id="PROCESSWOW64INFORMATION"></a><dl>
///                              <dt><b>ProcessWow64Information</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> Determines whether the process
///                              is running in the WOW64 environment (WOW64 is the x86 emulator that allows Win32-based applications to run on
///                              64-bit Windows). Use the IsWow64Process2 function to obtain this information. </td> </tr> <tr> <td width="40%"><a
///                              id="ProcessImageFileName"></a><a id="processimagefilename"></a><a id="PROCESSIMAGEFILENAME"></a><dl>
///                              <dt><b>ProcessImageFileName</b></dt> <dt>27</dt> </dl> </td> <td width="60%"> Retrieves a <b>UNICODE_STRING</b>
///                              value containing the name of the image file for the process. Use the QueryFullProcessImageName or
///                              GetProcessImageFileName function to obtain this information. </td> </tr> <tr> <td width="40%"><a
///                              id="ProcessBreakOnTermination"></a><a id="processbreakontermination"></a><a
///                              id="PROCESSBREAKONTERMINATION"></a><dl> <dt><b>ProcessBreakOnTermination</b></dt> <dt>29</dt> </dl> </td> <td
///                              width="60%"> Retrieves a <b>ULONG</b> value indicating whether the process is considered critical. <div
///                              class="alert"><b>Note</b> This value can be used starting in Windows XP with SP3. Starting in Windows 8.1,
///                              IsProcessCritical should be used instead.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
///                              id="ProcessSubsystemInformation"></a><a id="processsubsysteminformation"></a><a
///                              id="PROCESSSUBSYSTEMINFORMATION"></a><dl> <dt><b>ProcessSubsystemInformation</b></dt> <dt>75</dt> </dl> </td> <td
///                              width="60%"> Retrieves a <b>SUBSYSTEM_INFORMATION_TYPE</b> value indicating the subsystem type of the process.
///                              The buffer pointed to by the <i>ProcessInformation</i> parameter should be large enough to hold a single
///                              SUBSYSTEM_INFORMATION_TYPE enumeration. </td> </tr> </table>
///    ProcessInformation = A pointer to a buffer supplied by the calling application into which the function writes the requested
///                         information. The size of the information written varies depending on the data type of the
///                         <i>ProcessInformationClass</i> parameter:
///    ProcessInformationLength = The size of the buffer pointed to by the <i>ProcessInformation</i> parameter, in bytes.
///    ReturnLength = A pointer to a variable in which the function returns the size of the requested information. If the function was
///                   successful, this is the size of the information written to the buffer pointed to by the <i>ProcessInformation</i>
///                   parameter, but if the buffer was too small, this is the minimum size of buffer needed to receive the information
///                   successfully.
///Returns:
///    The function returns an NTSTATUS success or error code. The forms and significance of NTSTATUS error codes are
///    listed in the Ntstatus.h header file available in the DDK, and are described in the DDK documentation under
///    Kernel-Mode Driver Architecture / Design Guide / Driver Programming Techniques / Logging Errors.
///    
@DllImport("ntdll")
NTSTATUS NtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, 
                                   void* ProcessInformation, uint ProcessInformationLength, uint* ReturnLength);

///<p class="CCE_Message">[<b>NtQueryInformationThread</b> may be altered or unavailable in future versions of Windows.
///Applications should use the alternate functions listed in this topic.] Retrieves information about the specified
///thread.
///Params:
///    ThreadHandle = A handle to the thread about which information is being requested.
///    ThreadInformationClass = If this parameter is the <b>ThreadIsIoPending</b> value of the <b>THREADINFOCLASS</b> enumeration, the function
///                             determines whether the thread has any I/O operations pending. Use the public function GetThreadIOPendingFlag
///                             instead to obtain this information. If this parameter is the <b>ThreadQuerySetWin32StartAddress</b> value of the
///                             <b>THREADINFOCLASS</b> enumeration, the function returns the start address of the thread. Note that on versions
///                             of Windows prior to Windows Vista, the returned start address is only reliable before the thread starts running.
///                             If this parameter is the <b>ThreadSubsystemInformation</b> value of the <b>THREADINFOCLASS</b> enumeration, the
///                             function retrieves a SUBSYSTEM_INFORMATION_TYPE value indicating the subsystem type of the thread. The buffer
///                             pointed to by the <i>ThreadInformation</i> parameter should be large enough to hold a single
///                             <b>SUBSYSTEM_INFORMATION_TYPE</b> enumeration.
///    ThreadInformation = A pointer to a buffer in which the function writes the requested information. If <b>ThreadIsIoPending</b> is
///                        specified for the <i>ThreadInformationClass</i> parameter, this buffer must be large enough to hold a
///                        <b>ULONG</b> value, which indicates whether the specified thread has I/O requests pending. If this value is equal
///                        to zero, then there are no I/O operations pending; otherwise, if the value is nonzero, then the thread does have
///                        I/O operations pending. Use the public function GetThreadIOPendingFlag instead to obtain this information. If
///                        <b>ThreadQuerySetWin32StartAddress</b> is specified for the <i>ThreadInformationClass</i> parameter, this buffer
///                        must be large enough to hold a PVOID value, which is the start address of the thread.
///    ThreadInformationLength = The size of the buffer pointed to by the <i>ThreadInformation</i> parameter, in bytes.
///    ReturnLength = A pointer to a variable in which the function returns the size of the requested information. If the function was
///                   successful, this is the size of the information written to the buffer pointed to by the <i>ThreadInformation</i>
///                   parameter, but if the buffer was too small, this is the minimum size of buffer required to receive the
///                   information successfully.
///Returns:
///    Returns an NTSTATUS success or error code. The forms and significance of NTSTATUS error codes are listed in the
///    Ntstatus.h header file available in the DDK, and are described in the DDK documentation under Kernel-Mode Driver
///    Architecture / Design Guide / Driver Programming Techniques / Logging Errors.
///    
@DllImport("ntdll")
NTSTATUS NtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, 
                                  void* ThreadInformation, uint ThreadInformationLength, uint* ReturnLength);


// Interfaces

@GUID("0B5A2C52-3EB9-470A-96E2-6C6D4570E40F")
struct VssSnapshotMgmt;

@GUID("E579AB5F-1CC4-44B4-BED9-DE0991FF0623")
struct VSSCoordinator;

@GUID("6D5140C1-7436-11CE-8034-00AA006009FA")
interface IServiceProvider : IUnknown
{
    HRESULT QueryService(const(GUID)* guidService, const(GUID)* riid, void** ppvObject);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Enumerates through a set of VDS objects of a given type. Objects
///can be providers, subsystems, controllers, LUNs, LUN plexes, drives, disk packs, disks, volumes, or volume plexes.
@GUID("118610B7-8D94-4030-B5B8-500889788E4E")
interface IEnumVdsObject : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns a specified number of objects in the enumeration,
    ///beginning from the current point. For more information, see Working with Enumeration Objects.
    ///Params:
    ///    celt = The number of objects to return.
    ///    ppObjectArray = The address of an array of IUnknown pointers, which VDS initializes on return.
    ///    pcFetched = The address of a <b>ULONG</b>, which VDS initializes on return to the number of objects in
    ///                <i>ppObjectArray</i>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method returned the specified number of objects.
    ///    The number of returned objects reported in <i>pcFetched</i> equals <i>celt</i>; returns those objects. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The specified number of
    ///    returned objects is greater than the number of objects remaining. All remaining objects are returned, and the
    ///    number of returned objects is reported in <i>pcFetched</i> is less than <i>celt</i>; returns those objects.
    ///    </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, IUnknown* ppObjectArray, uint* pcFetched);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Skips a specified number of objects in the enumeration.
    ///Params:
    ///    celt = The number of objects to skip.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method skipped the specified number of objects.
    ///    The number of skipped objects equals <i>celt</i>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The number of objects specified is greater than the
    ///    number of objects remaining. If the number of objects remaining is less than the number specified in
    ///    <i>celt</i>, the Skip method skips all remaining objects. </td> </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Resets to the beginning of the enumeration.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt>
    ///    </dl> </td> <td width="60%"> The enumeration has been reset. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Creates an enumeration with the same state as the current
    ///enumeration.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject pointer, which VDS initializes on return. Callers must release the
    ///             interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The new enumeration has been created. </td> </tr>
    ///    </table>
    ///    
    HRESULT Clone(IEnumVdsObject* ppEnum);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Manages asynchronous operations. Methods that initiate
///asynchronous operations return a pointer to an <b>IVdsAsync</b> interface, allowing the caller to optionally cancel,
///wait for, or query the status of the asynchronous operation.
@GUID("D5D23B6D-5A55-4492-9889-397A3C2D2DBC")
interface IVdsAsync : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Cancels the asynchronous operation.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> The method is not
    ///    supported. Neither the basic provider nor the current dynamic provider support this method. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VDS_E_OPERATION_CANCELED</b></dt> <dt>0x8004240DL</dt> </dl> </td> <td
    ///    width="60%"> The operation has already been canceled. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_CANCEL_TOO_LATE</b></dt> <dt>0x8004240CL</dt> </dl> </td> <td width="60%"> The operation has
    ///    progressed too far to cancel. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_INCOMPATIBLE_FILE_SYSTEM</b></dt> <dt>0x80042425L</dt> </dl> </td> <td width="60%"> The file
    ///    system is incompatible with the specified operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_INCOMPATIBLE_MEDIA</b></dt> <dt>0x80042426L</dt> </dl> </td> <td width="60%"> The media is
    ///    incompatible with this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ACCESS_DENIED</b></dt>
    ///    <dt>0x80042427L</dt> </dl> </td> <td width="60%"> Access is denied. An application using VDS must run under
    ///    the Backup Operator or Administrators group account. </td> </tr> </table>
    ///    
    HRESULT Cancel();
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns when the asynchronous operation has either finished
    ///successfully or failed.
    ///Params:
    ///    pHrResult = The address of an <b>HRESULT</b> passed in by the caller.
    ///    pAsyncOut = The address of a VDS_ASYNC_OUTPUT structure passed in by the caller.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. There are two
    ///    <b>HRESULT</b> return values to examine. The one returned by the method reports failures from the call. The
    ///    <b>HRESULT</b> returned through <i>pHrResult</i> is used to report failures with the asynchronous operation
    ///    associated with the IVdsAsync object. Both values must be examined.
    ///    
    HRESULT Wait(HRESULT* pHrResult, VDS_ASYNC_OUTPUT* pAsyncOut);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns when the asynchronous operation is in progress, or
    ///has either finished successfully or failed.
    ///Params:
    ///    pHrResult = The address of an <b>HRESULT</b> for the asynchronous operation passed in by the caller. If the operation is
    ///                in progress, the value is <b>VDS_E_OPERATION_PENDING</b>. If the operation has finished, the value is the
    ///                returned <b>HRESULT</b> of the operation.
    ///    pulPercentCompleted = The address of a <b>ULONG</b> passed in by the caller, representing the status of the asynchronous operation,
    ///                          given as a percentage. If the operation is in progress, the value is between 0 and 99. If the operation has
    ///                          finished, the value is 100. If the progress of the operation cannot be estimated, the value is 0.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation is in progress or has
    ///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OPERATION_PENDING</b></dt>
    ///    <dt>0x80042409L</dt> </dl> </td> <td width="60%"> The operation is in progress. </td> </tr> </table>
    ///    
    HRESULT QueryStatus(HRESULT* pHrResult, uint* pulPercentCompleted);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Receives VDS notifications.
@GUID("8326CD1D-CF59-4936-B786-5EFC08798E25")
interface IVdsAdviseSink : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Passes notifications from providers to VDS, and from VDS to
    ///applications.
    ///Params:
    ///    lNumberOfNotifications = The number of notifications specified in <i>pNotificationArray</i>.
    ///    pNotificationArray = A pointer to an array of VDS_NOTIFICATION structures. A provider allocates the memory for the array when the
    ///                         provider calls into the service; the service frees the array. VDS allocates the array when the service calls
    ///                         into an application. In this case, callers must free the array by using the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> VDS returns this value to a provider if the service
    ///    is not fully initialized when the provider calls into this method, or if some notifications are lost by the
    ///    service. </td> </tr> </table>
    ///    
    HRESULT OnNotify(int lNumberOfNotifications, VDS_NOTIFICATION* pNotificationArray);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Returns the properties of a hardware or software provider.
@GUID("10C5E575-7984-4E81-A56B-431F5F92AE42")
interface IVdsProvider : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a provider.
    ///Params:
    ///    pProviderProp = The address of the VDS_PROVIDER_PROP structure allocated and passed in by the caller. VDS allocates memory
    ///                    for the <b>pwszName</b> and <b>pwszVersion</b> member strings. Callers must free the strings by using the
    ///                    CoTaskMemFreefunction.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt> <dt>0x00042715L</dt> </dl> </td> <td
    ///    width="60%"> Some but not all of the properties were successfully retrieved. Note that there are many
    ///    possible reasons for failing to retrieve all properties, including device removal. </td> </tr> </table>
    ///    
    HRESULT GetProperties(VDS_PROVIDER_PROP* pProviderProp);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method to indicate what versions of the VDS interfaces
///are supported by the provider.
@GUID("1732BE13-E8F9-4A03-BFBC-5F616AA66CE1")
interface IVdsProviderSupport : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns a bitmask of values enumerated by
    ///VDS_VERSION_SUPPORT_FLAG indicating the versions of the VDS interfaces supported by this provider. This method is
    ///implemented only by hardware providers.
    ///Params:
    ///    ulVersionSupport = Address of a <b>ULONG</b> that receives a bitmask of one or more of the values enumerated by
    ///                       VDS_VERSION_SUPPORT_FLAG indicating the versions of the VDS interfaces supported by the provider.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used.
    ///    
    HRESULT GetVersionSupport(uint* ulVersionSupport);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods to enable VDS to perform miscellaneous operations
///on provider objects.
@GUID("11F3CD41-B7E8-48FF-9472-9DFF018AA292")
interface IVdsProviderPrivate : IUnknown
{
    HRESULT GetObjectA(GUID ObjectId, VDS_OBJECT_TYPE type, IUnknown* ppObjectUnk);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Prompts the provider to initialize itself, and passes a
    ///callback object that the provider uses to get necessary interfaces.
    ///Params:
    ///    pwszMachineName = This parameter is reserved.
    ///    pCallbackObject = Pointer to a callback object.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The provider is initialized. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VDS_E_INITIALIZED_FAILED</b></dt> <dt>0x80042401L</dt> </dl> </td> <td
    ///    width="60%"> The provider failed to initialize. </td> </tr> </table>
    ///    
    HRESULT OnLoad(PWSTR pwszMachineName, IUnknown pCallbackObject);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Prompts the provider object to uninitialize itself.
    ///Params:
    ///    bForceUnload = If true, VDS attempts to forcibly unload the provider. If false, VDS makes no such attempt.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The provider is unloaded. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The provider is unable to unload at
    ///    this time. VDS tries again later. </td> </tr> </table>
    ///    
    HRESULT OnUnload(BOOL bForceUnload);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query, reenumeration, and refresh
///operations on a hardware provider.
@GUID("D99BDAAE-B13A-4178-9FDB-E27F16B4603E")
interface IVdsHwProvider : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of the subsystems managed by the
    ///provider.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the subsystems as subsystem
    ///             objects. For more information, see Working with Enumeration Objects. Callers must release the interface and
    ///             each of the subsystem objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Returns the enumeration of subsystem
    ///    identifiers. If the provider manages no subsystems, the enumeration is empty. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The provider is
    ///    in a failed state, and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_INITIALIZE_NOT_CALLED</b></dt>
    ///    <dt>0x80042402L</dt> </dl> </td> <td width="60%"> The initialization method has not been called. </td> </tr>
    ///    </table>
    ///    
    HRESULT QuerySubSystems(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Discovers newly connected and disconnected subsystems.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt>
    ///    </dl> </td> <td width="60%"> The provider is in a failed state, and is unable to perform the requested
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_INITIALIZE_NOT_CALLED</b></dt> <dt>0x80042402L</dt> </dl> </td> <td width="60%"> The
    ///    initialization method has not been called. </td> </tr> </table>
    ///    
    HRESULT Reenumerate();
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Refreshes VDS's internally cached data about existing
    ///subsystems that are managed by VDS providers.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt>
    ///    </dl> </td> <td width="60%"> The provider is in a failed state, and is unable to perform the requested
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_INITIALIZE_NOT_CALLED</b></dt> <dt>0x80042402L</dt> </dl> </td> <td width="60%"> The
    ///    initialization method has not been called. </td> </tr> </table>
    ///    
    HRESULT Refresh();
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method to retrieve the type of hardware provider.
@GUID("3E0F5166-542D-4FC6-947A-012174240B7E")
interface IVdsHwProviderType : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Retrieves the type of the hardware provider.
    ///Params:
    ///    pType = A pointer to a caller-allocated variable that receives a VDS_HWPROVIDER_TYPE enumeration value that specifies
    ///            the hardware provider type. This parameter is required and cannot be <b>NULL</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The hardware provider type was returned successfully.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetProviderType(VDS_HWPROVIDER_TYPE* pType);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] This interface is not implemented. Use IVdsHwProviderType instead.
@GUID("8190236F-C4D0-4E81-8011-D69512FCC984")
interface IVdsHwProviderType2 : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Not implemented. Retrieves the type of the hardware
    ///provider. If the provider wants to maintain backward compatibility with clients that do not recognize the new
    ///provider type, the provider should continue to return the old provider type in the
    ///IVdsHwProviderType::GetProviderType method.<div class="alert"><b>Note</b> This method is identical to
    ///IVdsHwProviderType::GetProviderType and should not be used.</div> <div> </div>
    ///Params:
    ///    pType = A pointer to a caller-allocated variable that receives a VDS_HWPROVIDER_TYPE enumeration value that specifies
    ///            the hardware provider type. This parameter is required and cannot be <b>NULL</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The hardware provider type was returned successfully.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetProviderType2(VDS_HWPROVIDER_TYPE* pType);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods to create LUNs in a storage pool and enumerate
///the storage pools managed by a hardware provider.
@GUID("D5B5937A-F188-4C79-B86C-11C920AD11B8")
interface IVdsHwProviderStoragePools : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an IEnumVdsObject enumeration object containing a
    ///list of the storage pools managed by the hardware provider.
    ///Params:
    ///    ulFlags = A bitmask of one or more VDS_STORAGE_POOL_TYPE flags that specify the types of storage pools to be queried.
    ///              One of the flags must be either VDS_SPT_CONCRETE or VDS_SPT_PRIMORDIAL. The default value of this parameter
    ///              is zero. A value of zero means that all storage pools should be queried.
    ///    ullRemainingFreeSpace = The minimum amount of free space, in bytes, that each storage pool must contain. The default value for this
    ///                            parameter is zero. A value of zero means that the storage pools can contain any amount of free space.
    ///    pPoolAttributes = A pointer to a VDS_POOL_ATTRIBUTES structure that specifies the attribute values that the returned storage
    ///                      pools must have. The default value for this parameter is <b>NULL</b>. A value of <b>NULL</b> means that the
    ///                      storage pools can have any attribute values.
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the storage pools. For more
    ///             information, see Working with Enumeration Objects. Callers must release the interface and each of the storage
    ///             pool objects when they are no longer needed by calling the IUnknown::Release method. This parameter is
    ///             required and cannot be <b>NULL</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueryStoragePools(uint ulFlags, ulong ullRemainingFreeSpace, VDS_POOL_ATTRIBUTES* pPoolAttributes, 
                              IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Creates a LUN in a storage pool.
    ///Params:
    ///    type = A VDS_LUN_TYPE enumeration value that specifies the type of LUN to be created. The new LUN can be an
    ///           automagic type or a specific RAID type, but not both. If the caller specifies an automagic type, one or more
    ///           automagic hints should be specified in the <i>pHints2</i> parameter. The interface pointer for the new LUN
    ///           object can be retrieved by calling the IVdsAsync::Wait method on the interface pointer returned in the
    ///           <i>ppAsync</i> parameter. The VDS_ASYNC_OUTPUT structure returned by <b>Wait</b> contains the LUN object
    ///           interface pointer in the <b>cl.pLunUnk</b> member.
    ///    ullSizeInBytes = The size, in bytes, of the new LUN. The provider can round the size up or down to meet alignment requirements
    ///                     or other restrictions. (In most cases, the provider rounds up, ensuring that, with rare exceptions, the LUN
    ///                     is at least as large as requested.) After the LUN is created, the caller can determine the actual size of the
    ///                     LUN by calling the IVdsLun::GetProperties method.
    ///    StoragePoolId = A VDS_OBJECT_ID value that identifies the storage pool where the LUN is to be created. This parameter is
    ///                    required and cannot be GUID_NULL.
    ///    pwszUnmaskingList = A list specifying the computers to be granted access the LUN. The list is a semicolon-delimited,
    ///                        <b>NULL</b>-terminated, human-readable string. If the value is "*", all computers that have an HBA port
    ///                        attached to the storage subsystem are to be granted access to the LUN. If the value is "", no computers are
    ///                        to be granted access to the LUN.<div class="alert"><b>Note</b> In practice, if the value is "*", most
    ///                        hardware providers only grant the ports and initiators on the local computer access to the LUN.</div> <div>
    ///                        </div> If "*" or "" is specified, no other value can be specified. For Fibre Channel networks and serial
    ///                        attached SCSI (SAS) networks, each entry is a 64-bit World-Wide Name (WWN) of each port to which the LUN is
    ///                        unmasked, formatted as a hexadecimal string (16 characters long), most significant byte first. For example, a
    ///                        WWN address of 01:23:45:67:89:AB:CD:EF is represented as "0123456789ABCDEF". For more information, see the
    ///                        T10 specifications for <a href="https://t10.org/drafts.htm
    ///    pHints2 = A pointer to a VDS_HINTS2 structure that specifies the hints to be used in creating the LUN. The provider is
    ///              not required to apply the hints to the LUN. The hints specified in the <b>VDS_HINTS2</b> structure are only a
    ///              request to the provider. After the LUN is created, the caller can determine the hints that the provider
    ///              applied by calling the IVdsLun2::QueryHints2 method. If the <i>type</i> parameter specifies a non-automagic
    ///              type, this parameter should be <b>NULL</b>.
    ///    ppAsync = A pointer to an IVdsAsync interface that upon successful completion receives the <b>IVdsAsync</b> interface
    ///              to monitor and control this operation. Callers must release the interface received when they are done with
    ///              it. If the IVdsAsync::Wait method is called on the interface and a success HRESULT value is returned, the
    ///              interfaces returned in the VDS_ASYNC_OUTPUT structure must be released by calling the IUnknown::Release
    ///              method on each interface pointer. However, if <b>Wait</b> returns a failure HRESULT value, or if the
    ///              <i>pHrResult</i> parameter of <b>Wait</b> receives a failure HRESULT value, the interface pointers in the
    ///              <b>VDS_ASYNC_OUTPUT</b> structure are <b>NULL</b> and do not need to be released. You can test for success or
    ///              failure HRESULT values by using the SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT CreateLunInStoragePool(VDS_LUN_TYPE type, ulong ullSizeInBytes, GUID StoragePoolId, 
                                   PWSTR pwszUnmaskingList, VDS_HINTS2* pHints2, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the maximum size of the LUN that can be created in
    ///the storage pool based on the specified LUN type and hints.
    ///Params:
    ///    type = A VDS_LUN_TYPE enumeration value that specifies the LUN type. This parameter is required and must be a valid
    ///           LUN type.
    ///    StoragePoolId = A VDS_OBJECT_ID (GUID) value that identifies the storage pools to be used to create the new LUN. This
    ///                    parameter is required and cannot be GUID_NULL.
    ///    pHints2 = A pointer to a VDS_HINTS2 structure that contains hints to be used in creating the LUN.
    ///    pullMaxLunSize = The address of a ULONGLONG value that receives the maximum LUN size, in bytes.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueryMaxLunCreateSizeInStoragePool(VDS_LUN_TYPE type, GUID StoragePoolId, VDS_HINTS2* pHints2, 
                                               ulong* pullMaxLunSize);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on a subsystem.
@GUID("6FCEE2D3-6D90-4F91-80E2-A5C7CAACA9D8")
interface IVdsSubSystem : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a subsystem.
    ///Params:
    ///    pSubSystemProp = The address of the VDS_SUB_SYSTEM_PROP structure allocated and passed in by the caller. VDS allocates memory
    ///                     for the <b>pwszFriendlyName</b> and <b>pwszIdentification</b> member strings. Callers must free the strings
    ///                     by using the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt> <dt>0x00042715L</dt> </dl> </td> <td
    ///    width="60%"> Some but not all of the properties were successfully retrieved. Note that there are many
    ///    possible reasons for failing to retrieve all properties, including device removal. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> </table>
    ///    
    HRESULT GetProperties(VDS_SUB_SYSTEM_PROP* pSubSystemProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the provider that manages the subsystem.
    ///Params:
    ///    ppProvider = The address of an IVdsProvider interface pointer. Callers must release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> </table>
    ///    
    HRESULT GetProvider(IVdsProvider* ppProvider);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an object that enumerates the online and offline
    ///controllers managed by the subsystem.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the controllers in the
    ///             subsystem as controller objects. For more information, see Working with Enumeration Objects. Callers must
    ///             release the interface and each of the controller objects when they are no longer needed by calling the
    ///             IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Returns the enumeration of controllers.
    ///    If the subsystem has no controllers, the enumeration is empty. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is
    ///    in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> </table>
    ///    
    HRESULT QueryControllers(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of LUNs surfaced in the subsystem.
    ///This method applies to hardware provider objects only.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the LUNs as LUN objects. For
    ///             more information, see Working with Enumeration Objects. Callers must release the interface and each of the
    ///             LUN objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Returns the enumeration of LUNs in the
    ///    subsystem. If the subsystem has no LUNs, the enumeration is empty. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is
    ///    in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> </table>
    ///    
    HRESULT QueryLuns(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an object that enumerates the drives in the
    ///subsystem.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the drives as drive objects.
    ///             For more information, see Working with Enumeration Objects. Callers must release the interface and each of
    ///             the drive objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Returns the enumeration of drives. If the
    ///    subsystem has no drives, the enumeration is empty. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is
    ///    in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> </table>
    ///    
    HRESULT QueryDrives(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the specified drive.
    ///Params:
    ///    sBusNumber = The number of the bus to which the drive is connected.
    ///    sSlotNumber = The number of the slot the drive occupies.
    ///    ppDrive = The address of an IVdsDrive interface pointer. Callers must release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is in a failed state and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> </table>
    ///    
    HRESULT GetDrive(short sBusNumber, short sSlotNumber, IVdsDrive* ppDrive);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Prompts the subsystem to scan its bus to discover
    ///newly-connected drives or newly-disconnected drives.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is
    ///    in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> </table>
    ///    
    HRESULT Reenumerate();
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the status (either online or offline) of the
    ///controllers in the subsystem.
    ///Params:
    ///    pOnlineControllerIdArray = Pointer to an array of controller GUIDs. The provider sets these controllers to online. This array includes
    ///                               controllers already set to online that are to remain so.
    ///    lNumberOfOnlineControllers = The number of controllers specified in <i>pOnlineControllersArray</i>.
    ///    pOfflineControllerIdArray = Pointer to an array of controller GUIDs. The provider sets these controllers to offline. This array includes
    ///                                controllers already set to offline that are to remain so.
    ///    lNumberOfOfflineControllers = The number of controllers specified in <i>pOfflineControllersArray</i>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is in a failed state and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt>
    ///    </dl> </td> <td width="60%"> Can be returned from any method that takes a <b>VDS_OBJECT_ID</b> constant. This
    ///    return value indicates that the identifier does not refer to an existing object. </td> </tr> </table>
    ///    
    HRESULT SetControllerStatus(GUID* pOnlineControllerIdArray, int lNumberOfOnlineControllers, 
                                GUID* pOfflineControllerIdArray, int lNumberOfOfflineControllers);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] The <b>CreateLun</b> method creates a logical unit number
    ///(LUN).
    ///Params:
    ///    type = A VDS_LUN_TYPE enumeration value that specifies the LUN type. The new LUN can be an automagic type or a
    ///           specific RAID type, but not both. If the caller specifies an automagic type, one or more automagic hints
    ///           should be specified in the <i>pHints</i> parameter. The interface pointer for the new LUN object can be
    ///           retrieved by calling the IVdsAsync::Wait method on the interface pointer returned in the <i>ppAsync</i>
    ///           parameter. The VDS_ASYNC_OUTPUT structure returned by <b>Wait</b> contains the LUN object interface pointer
    ///           in the <b>cl.pLunUnk</b> member.
    ///    ullSizeInBytes = The size, in bytes, of the new LUN. The provider can round the size up or down to meet alignment requirements
    ///                     or other restrictions. (In most cases, the provider rounds up, ensuring that, with rare exceptions, the LUN
    ///                     is at least as large as requested.) After the LUN is created, the caller can determine the actual size of the
    ///                     LUN by calling the IVdsLun::GetProperties method.
    ///    pDriveIdArray = A pointer to an array that contains a VDS_OBJECT_ID for each of the drives to be used to create the LUN. By
    ///                    specifying a non-<b>NULL</b> value for this parameter, the caller is requesting that the provider use all of
    ///                    the drives, in the order provided, using all of the extents on one drive before moving on to the next, and
    ///                    stopping when the LUN has reached the requested size. Alternatively, the caller can direct the provider to
    ///                    select the drives automatically by passing <b>NULL</b> in this parameter and 0 in <i>lNumberOfDrives</i>.
    ///                    (Pass <b>NULL</b> if and only if <i>lNumberOfDrives</i> is 0.) If the <i>type</i> parameter specifies an
    ///                    automagic type, this parameter should be <b>NULL</b>.
    ///    lNumberOfDrives = The number of drives specified in <i>pDriveIdArray</i>. If the caller passes 0, the provider selects the
    ///                      drives. If the <i>type</i> parameter specifies an automagic type, this parameter should be 0. After the LUN
    ///                      is created, the caller can determine which drives are in use by calling the IVdsLunPlex::QueryExtents method.
    ///    pwszUnmaskingList = A list specifying the computers to be granted access the LUN. The list is a semicolon-delimited,
    ///                        <b>NULL</b>-terminated, human-readable string. If the value is "*", all computers that have an HBA port
    ///                        attached to the storage subsystem are to be granted access to the LUN. If the value is "", no computers are
    ///                        to be granted access to the LUN. <div class="alert"><b>Note</b> In practice, if the value is "*", most
    ///                        hardware providers only grant the ports and initiators on the local computer access to the LUN.</div> <div>
    ///                        </div> If "*" or "" is specified, no other value can be specified. For Fibre Channel networks and serial
    ///                        attached SCSI (SAS) networks, each entry is a 64-bit World-Wide Name (WWN) of each port to which the LUN is
    ///                        unmasked, formatted as a hexadecimal string (16 characters long), most significant byte first. For example, a
    ///                        WWN address of 01:23:45:67:89:AB:CD:EF is represented as "0123456789ABCDEF". For more information, see the
    ///                        T10 specifications for <a href="https://t10.org/drafts.htm
    ///    pHints = Pointer to a VDS_HINTS structure that specifies the hints to be used in creating the LUN. The provider is not
    ///             required to apply the hints to the LUN. The hints specified in the VDS_HINTS structure are only a request to
    ///             the provider. After the LUN is created, the caller can determine the hints that the provider applied by
    ///             calling either the IVdsLun::QueryHints method or the IVdsLunPlex::QueryHints method. If the <i>type</i>
    ///             parameter specifies a non-automagic type, this parameter should be <b>NULL</b>.
    ///    ppAsync = The address of an IVdsAsync interface pointer, which VDS initializes on return. Callers must release the
    ///              interface. Use this interface to cancel, wait for, or query the status of the operation. If IVdsAsync::Wait
    ///              is called on the returned interface pointer and a success HRESULT value is returned, the interfaces returned
    ///              in the VDS_ASYNC_OUTPUT structure must be released by calling the IUnknown::Release method on each interface
    ///              pointer. However, if <b>Wait</b> returns a failure HRESULT value, or if the <i>pHrResult</i> parameter of
    ///              <b>Wait</b> receives a failure HRESULT value, the interface pointers in the <b>VDS_ASYNC_OUTPUT</b> structure
    ///              are <b>NULL</b> and do not need to be released. You can test for success or failure HRESULT values by using
    ///              the SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is in a failed state and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt>
    ///    </dl> </td> <td width="60%"> Can be returned from any method that takes a <b>VDS_OBJECT_ID</b> constant. This
    ///    return value indicates that the identifier does not refer to an existing object. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This
    ///    operation or combination of parameters is not supported by this provider. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VDS_E_NOT_ENOUGH_SPACE</b></dt> <dt>0x8004240FL</dt> </dl> </td> <td width="60%"> There is not
    ///    enough usable space for this operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_NOT_ENOUGH_DRIVE</b></dt> <dt>0x80042410L</dt> </dl> </td> <td width="60%"> Too few free drives
    ///    are present in the subsystem to complete this operation. </td> </tr> </table>
    ///    
    HRESULT CreateLun(VDS_LUN_TYPE type, ulong ullSizeInBytes, GUID* pDriveIdArray, int lNumberOfDrives, 
                      PWSTR pwszUnmaskingList, VDS_HINTS* pHints, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Replaces or migrates one drive with another in the
    ///subsystem.
    ///Params:
    ///    DriveToBeReplaced = The GUID of the drive to be replaced.
    ///    ReplacementDrive = The GUID of the replacement drive.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is in a failed state and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt>
    ///    </dl> </td> <td width="60%"> Can be returned from any method that takes a <b>VDS_OBJECT_ID</b> constant. This
    ///    return value indicates that the identifier does not refer to an existing object. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This
    ///    operation or combination of parameters is not supported by this provider. </td> </tr> </table>
    ///    
    HRESULT ReplaceDrive(GUID DriveToBeReplaced, GUID ReplacementDrive);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the status of the subsystem to the specified value.
    ///Params:
    ///    status = Values enumerated by VDS_SUB_SYSTEM_STATUS. Callers can pass in a subset of the possible enumeration values.
    ///             Passing in <b>VDS_SSS_UNKNOWN</b> returns <b>E_INVALIDARG</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is in a failed state and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetStatus(VDS_SUB_SYSTEM_STATUS status);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the size of the maximum LUN that can be created
    ///using the specified LUN type and hints.
    ///Params:
    ///    type = The LUN type enumerated by VDS_LUN_TYPE.
    ///    pDriveIdArray = A pointer to an array containing a <b>VDS_OBJECT_ID</b> for each of the drives to be used in the LUN
    ///                    creation. The provider should attempt to use the drives in the order provided. This parameter can be
    ///                    <b>NULL</b> if the <i>lNumberOfDrives</i> parameter is 0, in which case the provider should automatically
    ///                    pick drives.
    ///    lNumberOfDrives = The number of entries in <i>pDriveIdArray</i>. This can be set to 0.
    ///    pHints = A pointer to the VDS_HINTS structure used for creating the LUN. The hints always take lower priority than
    ///             parameters listed before. This argument must be non-NULL.
    ///    pullMaxLunSize = A pointer to a buffer containing the maximum size of the LUN in bytes. This argument must be non-NULL.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is in a failed state and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt>
    ///    </dl> </td> <td width="60%"> Can be returned from any method that takes a <b>VDS_OBJECT_ID</b> constant. This
    ///    return value indicates that the identifier does not refer to an existing object. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This
    ///    operation or combination of parameters is not supported by this provider. </td> </tr> </table>
    ///    
    HRESULT QueryMaxLunCreateSize(VDS_LUN_TYPE type, GUID* pDriveIdArray, int lNumberOfDrives, VDS_HINTS* pHints, 
                                  ulong* pullMaxLunSize);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on a subsystem using the VDS_HINTS2 and VDS_SUB_SYSTEM_PROP2 structures.
@GUID("BE666735-7800-4A77-9D9C-40F85B87E292")
interface IVdsSubSystem2 : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a subsystem. This method is
    ///identical to the IVdsSubSystem::GetProperties method, except that it returns a VDS_SUB_SYSTEM_PROP2 structure
    ///instead of a VDS_SUB_SYSTEM_PROP structure.
    ///Params:
    ///    pSubSystemProp2 = The address of the VDS_SUB_SYSTEM_PROP2 structure allocated and passed in by the caller. VDS allocates memory
    ///                      for the <b>pwszFriendlyName</b> and <b>pwszIdentification</b> member strings. Callers must free the strings
    ///                      by using the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt> <dt>0x00042715L</dt> </dl> </td> <td
    ///    width="60%"> Some but not all of the properties were successfully retrieved. Note that there are many
    ///    possible reasons for failing to retrieve all properties, including device removal. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> There is a software or communication problem inside a provider that caches information about the
    ///    array. Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore
    ///    the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt>
    ///    </dl> </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> </table>
    ///    
    HRESULT GetProperties2(VDS_SUB_SYSTEM_PROP2* pSubSystemProp2);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the specified drive. This method is identical to
    ///the IVdsSubSystem::GetDrive method, except that it includes the enclosure number as a parameter.
    ///Params:
    ///    sBusNumber = The number of the bus to which the drive is connected.
    ///    sSlotNumber = The number of the slot the drive occupies.
    ///    ulEnclosureNumber = The number of the enclosure that contains the drive. This parameter corresponds to the
    ///                        <b>ulEnclosureNumber</b> member of the VDS_DRIVE_PROP2 structure.
    ///    ppDrive = The address of an IVdsDrive interface pointer. Callers must release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> There is a software or communication problem inside a provider that caches information about the
    ///    array. Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore
    ///    the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt>
    ///    </dl> </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The
    ///    subsystem is in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td
    ///    width="60%"> Another operation is in progress; this operation cannot proceed until the previous operation or
    ///    operations are complete. </td> </tr> </table>
    ///    
    HRESULT GetDrive2(short sBusNumber, short sSlotNumber, uint ulEnclosureNumber, IVdsDrive* ppDrive);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Creates a LUN. This method is identical to the
    ///IVdsSubSystem::CreateLun method, except that automagic hints are provided using a VDS_HINTS2 structure instead of
    ///a VDS_HINTS structure.
    ///Params:
    ///    type = A VDS_LUN_TYPE enumeration value that specifies the LUN type. The new LUN can be an automagic type or a
    ///           specific RAID type, but not both. If the caller specifies an automagic type, one or more automagic hints
    ///           should be specified in the <i>pHints</i> parameter. The interface pointer for the new LUN object can be
    ///           retrieved by calling the IVdsAsync::Wait method on the interface pointer returned in the <i>ppAsync</i>
    ///           parameter. The VDS_ASYNC_OUTPUT structure returned by <b>Wait</b> contains the LUN object interface pointer
    ///           in the <b>cl.pLunUnk</b> member.
    ///    ullSizeInBytes = The size, in bytes, of the new LUN. The provider can round the size up or down to meet alignment requirements
    ///                     or other restrictions. (In most cases, the provider rounds up, ensuring that, with rare exceptions, the LUN
    ///                     is at least as large as requested.) After the LUN is created, the caller can determine the actual size of the
    ///                     LUN by calling the IVdsLun::GetProperties method.
    ///    pDriveIdArray = A pointer to an array that contains a VDS_OBJECT_ID for each of the drives to be used to create the LUN. By
    ///                    specifying a non-<b>NULL</b> value for this parameter, the caller is requesting that the provider use all of
    ///                    the drives, in the order provided, using all of the extents on one drive before moving on to the next, and
    ///                    stopping when the LUN has reached the requested size. Alternatively, the caller can direct the provider to
    ///                    select the drives automatically by passing <b>NULL</b> in this parameter and 0 in <i>lNumberOfDrives</i>.
    ///                    (Pass <b>NULL</b> if and only if <i>lNumberOfDrives</i> is 0.) If the <i>type</i> parameter specifies an
    ///                    automagic type, this parameter should be <b>NULL</b>.
    ///    lNumberOfDrives = The number of drives specified in <i>pDriveIdArray</i>. If the caller passes 0, the provider selects the
    ///                      drives. If the <i>type</i> parameter specifies an automagic type, this parameter should be 0. After the LUN
    ///                      is created, the caller can determine which drives are in use by calling the IVdsLunPlex::QueryExtents method.
    ///    pwszUnmaskingList = A list specifying the computers to be granted access the LUN. The list is a semicolon-delimited,
    ///                        <b>NULL</b>-terminated, human-readable string. If the value is "*", all computers that have an HBA port
    ///                        attached to the storage subsystem are to be granted access to the LUN. If the value is "", no computers are
    ///                        to be granted access to the LUN.<div class="alert"><b>Note</b> In practice, if the value is "*", most
    ///                        hardware providers only grant the ports and initiators on the local computer access to the LUN.</div> <div>
    ///                        </div> If "*" or "" is specified, no other value can be specified. For Fibre Channel networks and serial
    ///                        attached SCSI (SAS) networks, each entry is a 64-bit World-Wide Name (WWN) of each port to which the LUN is
    ///                        unmasked, formatted as a hexadecimal string (16 characters long), most significant byte first. For example, a
    ///                        WWN address of 01:23:45:67:89:AB:CD:EF is represented as "0123456789ABCDEF". For more information, see the
    ///                        T10 specifications for <a href="https://t10.org/drafts.htm
    ///    pHints2 = Pointer to a VDS_HINTS2 structure that specifies the hints to be used in creating the LUN. The provider is
    ///              not required to apply the hints to the LUN. The hints specified in the <b>VDS_HINTS2</b> structure are only a
    ///              request to the provider. After the LUN is created, the caller can determine the hints that the provider
    ///              applied by calling the IVdsLun2::QueryHints2 method. If the <i>type</i> parameter specifies a non-automagic
    ///              type, this parameter should be <b>NULL</b>.
    ///    ppAsync = The address of an IVdsAsync interface pointer, which VDS initializes on return. Callers must release the
    ///              interface. Use this interface to cancel, wait for, or query the status of the operation. If IVdsAsync::Wait
    ///              is called on the returned interface pointer and a success HRESULT value is returned, the interfaces returned
    ///              in the VDS_ASYNC_OUTPUT structure must be released by calling the IUnknown::Release method on each interface
    ///              pointer. However, if <b>Wait</b> returns a failure HRESULT value, or if the <i>pHrResult</i> parameter of
    ///              <b>Wait</b> receives a failure HRESULT value, the interface pointers in the <b>VDS_ASYNC_OUTPUT</b> structure
    ///              are <b>NULL</b> and do not need to be released. You can test for success or failure HRESULT values by using
    ///              the SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> There is a software or communication problem inside a provider that caches information about the
    ///    array. Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore
    ///    the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt>
    ///    </dl> </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The
    ///    subsystem is in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td
    ///    width="60%"> Another operation is in progress; this operation cannot proceed until the previous operation or
    ///    operations are complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt>
    ///    <dt>0x80042405L</dt> </dl> </td> <td width="60%"> The identifier does not refer to an existing object. This
    ///    value can be returned from any method that takes a <b>VDS_OBJECT_ID</b> constant. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This
    ///    operation or combination of parameters is not supported by this provider. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VDS_E_NOT_ENOUGH_SPACE</b></dt> <dt>0x8004240FL</dt> </dl> </td> <td width="60%"> There is not
    ///    enough usable space for this operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_NOT_ENOUGH_DRIVE</b></dt> <dt>0x80042410L</dt> </dl> </td> <td width="60%"> Too few free drives
    ///    are present in the subsystem to complete this operation. </td> </tr> </table>
    ///    
    HRESULT CreateLun2(VDS_LUN_TYPE type, ulong ullSizeInBytes, GUID* pDriveIdArray, int lNumberOfDrives, 
                       PWSTR pwszUnmaskingList, VDS_HINTS2* pHints2, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the size of the maximum LUN that can be created
    ///using the specified LUN type and hints. This method is identical to the IVdsSubSystem::QueryMaxLunCreateSize
    ///method, except that the automagic hints are provided using a VDS_HINTS2 structure instead of a VDS_HINTS
    ///structure.
    ///Params:
    ///    type = A VDS_LUN_TYPE enumeration value that specifies the LUN type.
    ///    pDriveIdArray = A pointer to an array containing a <b>VDS_OBJECT_ID</b> for each of the drives to be used in the LUN
    ///                    creation. The provider should attempt to use the drives in the order provided. This parameter can be
    ///                    <b>NULL</b> if the <i>lNumberOfDrives</i> parameter is zero, in which case the provider should automatically
    ///                    select drives.
    ///    lNumberOfDrives = The number of entries in the <i>pDriveIdArray</i> array. This parameter is optional and can be zero.
    ///    pHints2 = A pointer to the VDS_HINTS2 structure used for creating the LUN. The hints always take lower priority than
    ///              parameters listed before. This parameter is required and cannot be <b>NULL</b>.
    ///    pullMaxLunSize = A pointer to a buffer containing the maximum size of the LUN in bytes. This parameter is required and cannot
    ///                     be <b>NULL</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> There is a software or communication problem inside a provider that caches information about the
    ///    array. Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore
    ///    the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt>
    ///    </dl> </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The
    ///    subsystem is in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td
    ///    width="60%"> Another operation is in progress; this operation cannot proceed until the previous operation or
    ///    operations are complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt>
    ///    <dt>0x80042405L</dt> </dl> </td> <td width="60%"> The identifier does not refer to an existing object. This
    ///    value can be returned from any method that takes a <b>VDS_OBJECT_ID</b> constant. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This
    ///    operation or combination of parameters is not supported by this provider. </td> </tr> </table>
    ///    
    HRESULT QueryMaxLunCreateSize2(VDS_LUN_TYPE type, GUID* pDriveIdArray, int lNumberOfDrives, 
                                   VDS_HINTS2* pHints2, ulong* pullMaxLunSize);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method to name subsystems for a class implementing the
///IVdsSubSystem interface.
@GUID("0D70FAA3-9CD4-4900-AA20-6981B6AAFC75")
interface IVdsSubSystemNaming : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the friendly name of a subsystem.
    ///Params:
    ///    pwszFriendlyName = A pointer to a null-terminated string specifying the name to assign to the subsystem.
    ///Returns:
    ///    This method can return standard <b>HRESULT</b> values, such as <b>E_INVALIDARG</b> or <b>E_OUTOFMEMORY</b>,
    ///    and VDS-specific return values. It can also return converted system error codes using the HRESULT_FROM_WIN32
    ///    macro. Errors can originate from VDS itself or from the underlying VDS provider that is being used. Possible
    ///    return values include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The name was successfully set.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_S_NAME_TRUNCATED</b></b></dt> <dt>0x00042700L</dt> </dl>
    ///    </td> <td width="60%"> The name was set successfully but had to be truncated due to limitations in the
    ///    subsystem. The name that was set might not match the name passed in the <i>pwszName</i> parameter. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt>
    ///    </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a software or
    ///    communication problem inside a provider that caches information about the attached devices. The caller can
    ///    use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td
    ///    width="60%"> The subsystem is in a failed state and is unable to perform the requested operation. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl>
    ///    </td> <td width="60%"> Another operation is in progress. This operation cannot proceed until previous
    ///    operations are complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt>
    ///    <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation is not supported by this provider. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetFriendlyName(PWSTR pwszFriendlyName);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods to query and configure iSCSI targets and portals
///on a subsystem.
@GUID("0027346F-40D0-4B45-8CEC-5906DC0380C8")
interface IVdsSubSystemIscsi : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an object that enumerates the iSCSI targets of the
    ///subsystem.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the iSCSI targets as target
    ///             objects. For more information, see Working with Enumeration Objects. Callers must release the interface and
    ///             each of the target objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The enumeration of targets was
    ///    successfully returned. If the subsystem has no iSCSI targets, the enumeration is empty. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> The cache of the provider is corrupted. This indicates a software or communication problem
    ///    inside a provider that caches information about the attached devices. The caller can use the
    ///    IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the cache. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td>
    ///    <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The
    ///    subsystem is in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td
    ///    width="60%"> Another operation is in progress. This operation cannot proceed until previous operations are
    ///    complete. </td> </tr> </table>
    ///    
    HRESULT QueryTargets(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an object that enumerates the iSCSI portals of the
    ///subsystem.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the portals as portal
    ///             objects. For more information, see Working with Enumeration Objects. Callers must release the interface and
    ///             each of the portal objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The enumeration of portals was
    ///    successfully returned. If the subsystem has no iSCSI portals, the enumeration is empty. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> The cache of the provider is corrupted. This indicates a software or communication problem
    ///    inside a provider that caches information about the attached devices. The caller can use the
    ///    IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the cache. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td>
    ///    <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The
    ///    subsystem is in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td
    ///    width="60%"> Another operation is in progress. This operation cannot proceed until previous operations are
    ///    complete. </td> </tr> </table>
    ///    
    HRESULT QueryPortals(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Creates an iSCSI target. The interface pointer for the new
    ///target object can be retrieved by calling IVdsAsync::Wait through the <i>ppAsync</i> parameter. The
    ///VDS_ASYNC_OUTPUT structure returned contains the target object interface pointer in the <b>ct.pTargetUnk</b>
    ///member.
    ///Params:
    ///    pwszIscsiName = A string specifying the iSCSI name to assign to the target. The target name must be unique across all targets
    ///                    in all subsystems visible on the network. If <i>pwszIscsiName</i> is <b>NULL</b> or points to an empty
    ///                    string, the provider will generate the iSCSI name to assign to the target.
    ///    pwszFriendlyName = A string specifying the friendly name to assign to the target. This corresponds to the iSCSI alias.
    ///    ppAsync = The address of an IVdsAsync interface pointer, which VDS initializes on return. Callers must release the
    ///              interface. Use this interface to cancel, wait for, or query the status of the operation. If you call
    ///              IVdsAsync::Wait on this method and a success HRESULT value is returned, you must release the interfaces
    ///              returned in the VDS_ASYNC_OUTPUT structure by calling the IUnknown::Release method on each interface pointer.
    ///              However, if <b>Wait</b> returns a failure HRESULT value, or if the <i>pHrResult</i> parameter of <b>Wait</b>
    ///              receives a failure HRESULT value, the interface pointers in the <b>VDS_ASYNC_OUTPUT</b> structure are
    ///              <b>NULL</b> and do not need to be released. You can test for success or failure HRESULT values by using the
    ///              SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The target was created successfully.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td>
    ///    <td width="60%"> The subsystem object does not support this method. This indicates that the hardware provider
    ///    has set the VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG flag in the <b>ulFlags</b> member of the VDS_SUB_SYSTEM_PROP
    ///    structure for the subsystem object. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of
    ///    the provider is corrupted. This indicates a software or communication problem inside a provider that caches
    ///    information about the attached devices. The caller can use the IVdsHwProvider::Reenumerate method followed by
    ///    the IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is in a failed state and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress. This operation cannot proceed until previous operations are complete. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VDS_E_NAME_NOT_UNIQUE</b></dt> <dt>0x80042701L</dt> </dl> </td> <td
    ///    width="60%"> A non-unique name was specified in the <i>pwszIscsiName</i> parameter. </td> </tr> </table>
    ///    
    HRESULT CreateTarget(PWSTR pwszIscsiName, PWSTR pwszFriendlyName, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Not supported. This method is reserved for future use.
    ///Params:
    ///    pIpsecKey = Reserved for future use.
    HRESULT SetIpsecGroupPresharedKey(VDS_ISCSI_IPSEC_KEY* pIpsecKey);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method to query the interconnect types that are
///supported by a subsystem.
@GUID("9E6FA560-C141-477B-83BA-0B6C38F7FEBF")
interface IVdsSubSystemInterconnect : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the interconnect types that the subsystem supports.
    ///Params:
    ///    pulSupportedInterconnectsFlag = A pointer to a caller-allocated <b>ULONG</b> value that receives a bitmask of VDS_INTERCONNECT_FLAG flags,
    ///                                    one for each interconnect type that the subsystem supports. This parameter is required and cannot be
    ///                                    <b>NULL</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetSupportedInterconnects(uint* pulSupportedInterconnectsFlag);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on a controller port.
@GUID("18691D0D-4E7F-43E8-92E4-CF44BEEED11C")
interface IVdsControllerPort : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Retrieves the properties of a controller port.
    ///Params:
    ///    pPortProp = The address of a member of the VDS_PORT_PROP structure that is allocated and passed in by the caller. VDS
    ///                allocates memory for the <b>pwszFriendlyName</b> and <b>pwszIdentification</b> strings. Callers must free the
    ///                strings by using the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The properties were successfully
    ///    retrieved. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt>
    ///    <dt>0x00042715L</dt> </dl> </td> <td width="60%"> Some but not all of the properties were successfully
    ///    retrieved. Note that there are many possible reasons for failing to retrieve all properties, including device
    ///    removal. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller port object is no longer present. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetProperties(VDS_PORT_PROP* pPortProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the controller to which the controller port
    ///belongs.
    ///Params:
    ///    ppController = The address of an IVdsController interface pointer. Callers must release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The controller object was
    ///    successfully retrieved. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The
    ///    cache of the provider is corrupted. This indicates a software or communication problem inside a provider that
    ///    caches information about the attached devices. The caller can use the IVdsHwProvider::Reenumerate method
    ///    followed by the IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller
    ///    port object is no longer present. </td> </tr> </table>
    ///    
    HRESULT GetController(IVdsController* ppController);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of the LUNs with which the
    ///controller port is associated—the LUNs for which the controller is active. This method replaces
    ///IVdsController::QueryAssociatedLuns.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the LUNs as LUN objects. For
    ///             more information, see Working with Enumeration Objects. Callers must release the interface and each of the
    ///             LUN objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The enumeration of associated LUNs
    ///    was successfully returned. If the controller port has no associated LUNs, the enumeration is empty. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt>
    ///    </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a software or
    ///    communication problem inside a provider that caches information about the attached devices. The caller can
    ///    use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller port object is no longer present. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl>
    ///    </td> <td width="60%"> The controller port is in a failed state and is unable to perform the requested
    ///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress. This operation cannot
    ///    proceed until previous operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation
    ///    is not supported by this provider. </td> </tr> </table>
    ///    
    HRESULT QueryAssociatedLuns(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Reinitializes the controller port.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The controller port was successfully reset. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt>
    ///    </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a software or
    ///    communication problem inside a provider that caches information about the attached devices. The caller can
    ///    use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller port object is no longer present. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt>
    ///    </dl> </td> <td width="60%"> Another operation is in progress. This operation cannot proceed until previous
    ///    operations are complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt>
    ///    <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation is not supported by this provider. </td>
    ///    </tr> </table>
    ///    
    HRESULT Reset();
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the status of a controller port to the specified
    ///value.
    ///Params:
    ///    status = A value enumerated by the VDS_PORT_STATUS enumeration. Passing in <b>VDS_PRS_UNKNOWN</b> fails with
    ///             <b>E_INVALIDARG</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The status was successfully set.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller port object is no longer present. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt>
    ///    </dl> </td> <td width="60%"> Another operation is in progress. This operation cannot proceed until previous
    ///    operations are complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt>
    ///    <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation is not supported by this provider. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetStatus(VDS_PORT_STATUS status);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on a controller.
@GUID("CB53D96E-DFFB-474A-A078-790D1E2BC082")
interface IVdsController : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a controller.
    ///Params:
    ///    pControllerProp = The address of a VDS_CONTROLLER_PROPstructure allocated and passed in by the caller. VDS allocates memory for
    ///                      the <b>pwszFriendlyName</b> and <b>pwszIdentification</b> member strings. Callers must free the strings by
    ///                      using the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt> <dt>0x00042715L</dt> </dl> </td> <td
    ///    width="60%"> Some but not all of the properties were successfully retrieved. Note that there are many
    ///    possible reasons for failing to retrieve all properties, including device removal. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller object
    ///    is no longer present. </td> </tr> </table>
    ///    
    HRESULT GetProperties(VDS_CONTROLLER_PROP* pControllerProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the subsystem to which the controller belongs.
    ///Params:
    ///    ppSubSystem = The address of an IVdsSubSystem interface pointer. Callers must release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller object
    ///    is no longer present. </td> </tr> </table>
    ///    
    HRESULT GetSubSystem(IVdsSubSystem* ppSubSystem);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of the specified controller port.
    ///Params:
    ///    sPortNumber = The number of the port. Port numbers are permanent. Ports are numbered from 0.
    ///    pPortProp = The address of a VDS_PORT_PROP structure allocated and passed in by the caller. VDS allocates memory for the
    ///                <b>pwszFriendlyName</b> and <b>pwszIdentification</b> member strings. Callers must free the strings by using
    ///                the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt>
    ///    <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation or combination of parameters is not
    ///    supported by this provider. </td> </tr> </table>
    ///    
    HRESULT GetPortProperties(short sPortNumber, VDS_PORT_PROP* pPortProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Flushes the cache of the controller to a persistent store.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The controller object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The controller
    ///    is in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT FlushCache();
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Invalidates the cache of the controller. All data in the
    ///cache is lost.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The controller object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT InvalidateCache();
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Reinitializes the controller and invalidates the cache.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The controller object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of the LUNs with which the
    ///controller is associated—in other words, the LUNs for which the controller is active.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the LUNs as LUN objects. For
    ///             more information, see Working with Enumeration Objects. Callers must release the interface and each of the
    ///             LUN objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Returns the enumeration of associated
    ///    LUNs. If the controller has no associated LUNs, the enumeration is empty. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This
    ///    return value signals a software or communication problem inside a provider that caches information about the
    ///    array. Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore
    ///    the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt>
    ///    </dl> </td> <td width="60%"> The controller object is no longer present. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The
    ///    controller is in a failed state, and is unable to perform the requested operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This
    ///    operation or combination of parameters is not supported by this provider. </td> </tr> </table>
    ///    
    HRESULT QueryAssociatedLuns(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the status of a controller to the specified value.
    ///Params:
    ///    status = Values enumerated by VDS_CONTROLLER_STATUS. Callers can pass in a subset of the possible enumeration values.
    ///             Passing in <b>VDS_CS_UNKNOWN</b> returns <b>E_INVALIDARG</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The controller is in a failed state and is unable to
    ///    perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetStatus(VDS_CONTROLLER_STATUS status);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method to enumerate controller ports for a class
///implementing the IVdsController interface. This is needed to support MPIO.
@GUID("CA5D735F-6BAE-42C0-B30E-F2666045CE71")
interface IVdsControllerControllerPort : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an IEnumVdsObject object that enumerates the ports
    ///of the controller.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the controller ports as
    ///             controller port objects. For more information, see Working with Enumeration Objects. Callers must release the
    ///             interface and each of the controller port objects when they are no longer needed by calling the
    ///             IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The enumeration of controller
    ///    ports was returned successfully. If the controller has no ports, the enumeration is empty. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td>
    ///    <td width="60%"> The cache of the provider is corrupted. This indicates a software or communication problem
    ///    inside a provider that caches information about the attached devices. The caller can use the
    ///    IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the cache. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td>
    ///    <td width="60%"> The controller object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The
    ///    controller is in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td
    ///    width="60%"> Another operation is in progress. This operation cannot proceed until previous operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt>
    ///    <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation is not supported by this provider. </td>
    ///    </tr> </table>
    ///    
    HRESULT QueryControllerPorts(IEnumVdsObject* ppEnum);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on a drive.
@GUID("FF24EFA4-AADE-4B6B-898B-EAA6A20887C7")
interface IVdsDrive : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a drive object.
    ///Params:
    ///    pDriveProp = The address of the VDS_DRIVE_PROP structure allocated and passed in by the caller. VDS allocates memory for
    ///                 the <b>pwszFriendlyName</b> and <b>pwszIdentification</b> member strings. Callers must free the strings by
    ///                 using the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt> <dt>0x00042715L</dt> </dl> </td> <td
    ///    width="60%"> Some but not all of the properties were successfully retrieved. Note that there are many
    ///    possible reasons for failing to retrieve all properties, including device removal. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The drive object is no
    ///    longer present. </td> </tr> </table>
    ///    
    HRESULT GetProperties(VDS_DRIVE_PROP* pDriveProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the subsystem to which the drive belongs.
    ///Params:
    ///    ppSubSystem = The address of an IVdsSubSystem interface pointer. The caller must release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The drive object is no
    ///    longer present. </td> </tr> </table>
    ///    
    HRESULT GetSubSystem(IVdsSubSystem* ppSubSystem);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an array of the extents on a drive, including both
    ///allocated and unallocated extents.
    ///Params:
    ///    ppExtentArray = A pointer to the array of VDS_DRIVE_EXTENT structures passed in by the caller. Callers must free this array
    ///                    by using the CoTaskMemFree function.
    ///    plNumberOfExtents = A pointer to the number of drive extents returned in the VDS_DRIVE_EXTENT structure.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The extents information was returned
    ///    successfully. For a drive without extents, the array is empty, the value of <i>plNumberOfExtents</i> is set
    ///    to 0, and the value of <i>ppExtentArray</i> is set to <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The drive object no longer exists. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The drive is in
    ///    a failed state, and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> The subsystem does not support this method. </td> </tr> </table>
    ///    
    HRESULT QueryExtents(VDS_DRIVE_EXTENT** ppExtentArray, int* plNumberOfExtents);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets flags of a drive object.
    ///Params:
    ///    ulFlags = Flags enumerated by VDS_DRIVE_FLAG. Callers can set the <b>VDS_DRF_HOTSPARE</b> flag.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The drive object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The drive is in a failed state, and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetFlags(uint ulFlags);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Clears the flags of a drive object.
    ///Params:
    ///    ulFlags = The flags enumerated by VDS_DRIVE_FLAG. Callers can clear the <b>VDS_DRF_HOTSPARE</b> flag.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The controller object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The drive is in a failed state, and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT ClearFlags(uint ulFlags);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the status of the drive to the specified value.
    ///Params:
    ///    status = Values enumerated by VDS_DRIVE_STATUS. Callers can pass in a subset of the possible enumeration values.
    ///             Passing in <b>VDS_DRS_UNKNOWN</b> returns <b>E_INVALIDARG</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The drive object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The drive is in a failed state, and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetStatus(VDS_DRIVE_STATUS status);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method for querying the properties of a drive.
@GUID("60B5A730-ADDF-4436-8CA7-5769E2D1FFA4")
interface IVdsDrive2 : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a drive object.
    ///Params:
    ///    pDriveProp2 = The address of the VDS_DRIVE_PROP2 structure allocated and passed in by the caller. VDS allocates memory for
    ///                  the <b>pwszFriendlyName</b> and <b>pwszIdentification</b> member strings. Callers must free the strings by
    ///                  using the CoTaskMemFree function. This parameter is required and cannot be <b>NULL</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used.
    ///    
    HRESULT GetProperties2(VDS_DRIVE_PROP2* pDriveProp2);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on a logical unit number (LUN).
@GUID("3540A9C7-E60F-4111-A840-8BBA6C2C83D8")
interface IVdsLun : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a LUN object.
    ///Params:
    ///    pLunProp = The address of the VDS_LUN_PROP structure allocated and passed in by the caller. VDS allocates memory for the
    ///               <b>pwszFriendlyName</b>, <b>pwszIdentification</b>, and <b>pwszUnmaskingList</b> member strings. Callers must
    ///               free the strings by using the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt> <dt>0x00042715L</dt> </dl> </td> <td
    ///    width="60%"> Some but not all of the properties were successfully retrieved. Note that there are many
    ///    possible reasons for failing to retrieve all properties, including device removal. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> </table>
    ///    
    HRESULT GetProperties(VDS_LUN_PROP* pLunProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the subsystem that surfaces the LUN.
    ///Params:
    ///    ppSubSystem = The address of an IVdsSubSystem interface pointer. Callers must release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> </table>
    ///    
    HRESULT GetSubSystem(IVdsSubSystem* ppSubSystem);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns data from the SCSI Inquiry Data and Vital Product
    ///Data pages 0x80 and 0x83.
    ///Params:
    ///    pLunInfo = The address of the VDS_LUN_INFORMATIONstructure allocated and passed in by the caller. VDS allocates memory
    ///               for the <b>m_szVendorId</b>, <b>m_szProductId</b>, <b>m_szProductRevision</b>, and <b>m_szSerialNumber</b>
    ///               member strings, as well as the <b>m_pbPort</b> and <b>m_pbAddress</b> member strings of each element in the
    ///               array of VDS_INTERCONNECT structures. Callers must free the strings by using the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> </table>
    ///    
    HRESULT GetIdentificationData(VDS_LUN_INFORMATION* pLunInfo);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of currently active
    ///controllers—the controllers through which the LUN is accessible.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the controllers in the
    ///             subsystem as controller objects. For more information, see Working with Enumeration Objects. Callers must
    ///             release the interface and each of the controller objects when they are no longer needed by calling the
    ///             IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Returns the enumeration of active
    ///    controllers. If the LUN has no active controllers, the enumeration is empty. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> </table>
    ///    
    HRESULT QueryActiveControllers(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Extends a LUN by a specified number of bytes.
    ///Params:
    ///    ullNumberOfBytesToAdd = The number of bytes by which to extend the LUN. The number of bytes is not required to be an even multiple of
    ///                            the block or sector size of the drives. The provider can round the number of bytes up or down to meet
    ///                            alignment requirements or other restrictions. In most cases, the provider rounds up, ensuring that, with rare
    ///                            exceptions, the LUN is extended by at least the number of bytes requested.
    ///    pDriveIdArray = A pointer to an array of drive GUIDs. The provider uses these drives to extend the LUN. The drives are used
    ///                    in the specified sequence; the provider uses all of the extents on one drive before moving on to the next and
    ///                    stops when the LUN has been extended by the requested number of bytes. Alternatively, the caller can direct
    ///                    the provider to select the drives automatically by passing <b>NULL</b> in this parameter and zero in the
    ///                    <i>lNumberOfDrives</i> parameter. Note that passing <b>NULL</b> is valid only if the <i>lNumberOfDrives</i>
    ///                    parameter is zero.
    ///    lNumberOfDrives = The number of drives specified in the <i>pDriveIdArray</i> parameter. If the caller passes zero, the provider
    ///                      selects the drives.
    ///    ppAsync = The address of an IVdsAsync interface pointer, which VDS initializes on return. Callers must release the
    ///              interface. Use this interface to cancel, wait for, or query the status of the operation.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt> </dl> </td> <td width="60%"> Can be returned from
    ///    any method that takes a <b>VDS_OBJECT_ID</b> constant. This return value indicates that the identifier does
    ///    not refer to an existing object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt>
    ///    <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation or combination of parameters is not
    ///    supported by this provider. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_ENOUGH_SPACE</b></dt>
    ///    <dt>0x8004240FL</dt> </dl> </td> <td width="60%"> There is not enough usable space for this operation. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_ENOUGH_DRIVE</b></dt> <dt>0x80042410L</dt> </dl> </td> <td
    ///    width="60%"> Not enough free drives are present in the subsystem to complete this operation. </td> </tr>
    ///    </table>
    ///    
    HRESULT Extend(ulong ullNumberOfBytesToAdd, GUID* pDriveIdArray, int lNumberOfDrives, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Shrinks a LUN by a specified number of bytes.
    ///Params:
    ///    ullNumberOfBytesToRemove = The number of bytes by which to shrink the LUN. The number of bytes is not required to be an even multiple of
    ///                               the block or sector size.
    ///    ppAsync = The address of an IVdsAsync interface pointer. Callers must release the interface. Use this interface to
    ///              cancel, wait for, or query the status of the operation.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> </table>
    ///    
    HRESULT Shrink(ulong ullNumberOfBytesToRemove, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of the plexes in a LUN.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the plexes as LUN plex
    ///             objects. For more information, see Working with Enumeration Objects. Callers must release the interface and
    ///             each of the LUN plex objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following.
    ///    
    HRESULT QueryPlexes(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Adds a LUN to the target LUN as a new plex.
    ///Params:
    ///    lunId = The GUID of the LUN to be added as a plex.
    ///    ppAsync = The address of an IVdsAsync interface pointer, which VDS initializes on return. Callers must release the
    ///              interface. Use this interface to cancel, wait for, or query the status of the operation.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress. This operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt> </dl> </td> <td width="60%"> This can be returned
    ///    from any method that takes a <b>VDS_OBJECT_ID</b> constant. It indicates that the identifier does not refer
    ///    to an existing object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_INVALID_OPERATION</b></dt>
    ///    <dt>0x80042415L</dt> </dl> </td> <td width="60%"> The operation is not valid. Alternatively, the source LUN
    ///    is smaller than the target LUN. If the source LUN is larger than the target LUN, the target LUN remains the
    ///    same size and the operation is successful. </td> </tr> </table>
    ///    
    HRESULT AddPlex(GUID lunId, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Removes a plex from a LUN.
    ///Params:
    ///    plexId = The GUID of the LUN plex to be removed.
    ///    ppAsync = The address of an IVdsAsync interface pointer, which VDS initializes on return. Callers must release the
    ///              interface. Use this interface to cancel, wait for, or query the status of the operation. If you call
    ///              IVdsAsync::Wait on this method and a success HRESULT value is returned, you must release the interfaces
    ///              returned in the VDS_ASYNC_OUTPUT structure by calling the IUnknown::Release method on each interface pointer.
    ///              However, if <b>Wait</b> returns a failure HRESULT value, or if the <i>pHrResult</i> parameter of <b>Wait</b>
    ///              receives a failure HRESULT value, the interface pointers in the <b>VDS_ASYNC_OUTPUT</b> structure are
    ///              <b>NULL</b> and do not need to be released. You can test for success or failure HRESULT values by using the
    ///              SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt> </dl> </td> <td width="60%"> Can be returned from
    ///    any method that takes a <b>VDS_OBJECT_ID</b> constant. This return value indicates that the identifier does
    ///    not refer to an existing object. </td> </tr> </table>
    ///    
    HRESULT RemovePlex(GUID plexId, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Starts a recovery operation on a LUN.
    ///Params:
    ///    ppAsync = The address of an IVdsAsync interface pointer. Callers must release the interface. Use this interface to
    ///              cancel, wait for, or query the status of the operation.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_INVALID_OPERATION</b></dt> <dt>0x80042415L</dt> </dl> </td> <td width="60%"> This LUN is not
    ///    fault tolerant; a recovery operation is not possible. </td> </tr> </table>
    ///    
    HRESULT Recover(IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Specifies the unmasking list, which is the list of
    ///computers to be granted access to the LUN.
    ///Params:
    ///    pwszUnmaskingList = A list specifying the computers to be granted access to the LUN. The list is a semicolon-delimited,
    ///                        NULL-terminated, human-readable string. If the value is "*", all computers that have an HBA port attached to
    ///                        the storage subsystem are to be granted access to the LUN. <div class="alert"><b>Note</b> In practice, if the
    ///                        value is "*", most hardware providers only grant the ports and initiators on the local computer access to the
    ///                        LUN.</div> <div> </div> If the value is "", access is revoked for all computers that were previously granted
    ///                        access to the LUN. If "*" or "" is specified, no other value can be specified. For Fibre Channel networks and
    ///                        serial attached SCSI (SAS) networks, each entry is a 64-bit World-Wide Name (WWN) of each port to which the
    ///                        LUN is unmasked, formatted as a hexadecimal string (16 characters long), most significant byte first. For
    ///                        example, a WWN address of 01:23:45:67:89:AB:CD:EF is represented as "0123456789ABCDEF". For more information,
    ///                        see the T10 specifications for <a href="https://t10.org/drafts.htm
    ///Returns:
    ///    This method can return standard <b>HRESULT</b> values, such as <b>E_INVALIDARG</b> or <b>E_OUTOFMEMORY</b>,
    ///    and VDS-specific return values. It can also return converted system error codes using the HRESULT_FROM_WIN32
    ///    macro. Errors can originate from VDS itself or from the underlying VDS provider that is being used. Possible
    ///    return values include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state, and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> </table>
    ///    
    HRESULT SetMask(PWSTR pwszUnmaskingList);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Deletes the LUN and all of its plexes. Any data on the LUN
    ///is lost. VDS frees the extents allocated to the LUN.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_OUTOFMEMORY, and VDS-specific return values. It can
    ///    also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can originate from VDS
    ///    itself or from the underlying VDS provider that is being used. Possible return values include the following.
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The LUN object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a
    ///    failed state and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> </table>
    ///    
    HRESULT Delete();
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the subsystem controllers to active or inactive with
    ///respect to the LUN.
    ///Params:
    ///    pActiveControllerIdArray = A pointer to an array of controller GUIDs. The provider sets these controllers to active. This array includes
    ///                               controllers already set to active that are to remain so.
    ///    lNumberOfActiveControllers = The number of controllers specified in the <i>pActiveControllerArray</i> parameter.
    ///    pInactiveControllerIdArray = A pointer to an array of controller GUIDs. The provider sets these controllers to inactive. This array
    ///                                 includes controllers already set to inactive that are to remain so.
    ///    lNumberOfInactiveControllers = The number of controllers specified in the <i>pInactiveControllerIdArray</i> parameter.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress. This operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt> </dl> </td> <td width="60%"> One or more of the
    ///    GUIDs specified in the active or inactive arrays do not refer to an existing object. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This
    ///    operation or combination of parameters is not supported by this provider. </td> </tr> </table>
    ///    
    HRESULT AssociateControllers(GUID* pActiveControllerIdArray, int lNumberOfActiveControllers, 
                                 GUID* pInactiveControllerIdArray, int lNumberOfInactiveControllers);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the hints currently applied to the LUN.
    ///Params:
    ///    pHints = A pointer to the returned LUN hints. See the VDS_HINTS structure.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation or
    ///    combination of parameters is not supported by this provider. </td> </tr> </table>
    ///    
    HRESULT QueryHints(VDS_HINTS* pHints);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Applies a new set of hints to the LUN. Hints that are
    ///applied to a LUN are simultaneously applied to all plexes.
    ///Params:
    ///    pHints = A pointer to the new hints to be applied to the LUN. See the VDS_HINTS structure.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress. This operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation or
    ///    combination of parameters is not supported by this provider. </td> </tr> </table>
    ///    
    HRESULT ApplyHints(VDS_HINTS* pHints);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the status of the LUN to the specified value.
    ///Params:
    ///    status = Values enumerated by VDS_LUN_STATUS. Callers can pass in a subset of the possible enumeration values. Passing
    ///             in <b>VDS_LS_UNKNOWN</b> returns <b>E_INVALIDARG</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> </table>
    ///    
    HRESULT SetStatus(VDS_LUN_STATUS status);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the maximum size by which a LUN can be extended.
    ///Params:
    ///    pDriveIdArray = A pointer to an array containing the GUIDs of the drives used for growing the LUN. This argument can be
    ///                    <b>NULL</b> if <i>lNumberOfDrives</i> is 0. In this case, the provider is expected to select all the drives
    ///                    possible to get the maximum size.
    ///    lNumberOfDrives = The count of drives in <i>pDriveIdArray</i>.
    ///    pullMaxBytesToBeAdded = A pointer to a buffer containing the maximum bytes by which the LUN can be extended. This argument must be
    ///                            non-NULL.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt> </dl> </td> <td width="60%"> Can be returned from
    ///    any method that takes a <b>VDS_OBJECT_ID</b> constant. This return value indicates that the identifier does
    ///    not refer to an existing object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt>
    ///    <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation or combination of parameters is not
    ///    supported by this provider. </td> </tr> </table>
    ///    
    HRESULT QueryMaxLunExtendSize(GUID* pDriveIdArray, int lNumberOfDrives, ulong* pullMaxBytesToBeAdded);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for applying and querying logical unit number
///(LUN) hints.
@GUID("E5B3A735-9EFB-499A-8071-4394D9EE6FCB")
interface IVdsLun2 : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the hints currently applied to the LUN. This method
    ///is identical to the IVdsLun::QueryHints method, except that it uses a VDS_HINTS2 structure instead of a VDS_HINTS
    ///structure.
    ///Params:
    ///    pHints2 = A pointer to the returned LUN hints. See the VDS_HINTS2 structure.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> There is a software or communication problem inside a provider that caches information about the
    ///    array. Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore
    ///    the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt>
    ///    </dl> </td> <td width="60%"> The LUN object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a
    ///    failed state and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT QueryHints2(VDS_HINTS2* pHints2);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Applies a new set of hints to the LUN. Hints that are
    ///applied to a LUN are simultaneously applied to all plexes. This method is identical to the IVdsLun::ApplyHints
    ///method, except that it uses a VDS_HINTS2 structure instead of a VDS_HINTS structure.
    ///Params:
    ///    pHints2 = A pointer to the new hints to be applied to the LUN. See the VDS_HINTS2 structure.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> There is a software or communication problem inside a provider that caches information about the
    ///    array. Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore
    ///    the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt>
    ///    </dl> </td> <td width="60%"> The LUN object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a
    ///    failed state and unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress. This operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT ApplyHints2(VDS_HINTS2* pHints2);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method to name LUNs for a class implementing the
///IVdsLun interface.
@GUID("907504CB-6B4E-4D88-A34D-17BA661FBB06")
interface IVdsLunNaming : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the friendly name of a LUN.
    ///Params:
    ///    pwszFriendlyName = A pointer to a null-terminated string specifying the name to assign to the LUN.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The name was successfully set.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_S_NAME_TRUNCATED</b></b></dt> <dt>0x00042700L</dt> </dl>
    ///    </td> <td width="60%"> The name was set successfully but had to be truncated due to limitations in the
    ///    subsystem. The name that was set might not match the name passed in the <i>pwszName</i> parameter. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt>
    ///    </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a software or
    ///    communication problem inside a provider that caches information about the attached devices. The caller can
    ///    use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no longer present. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td
    ///    width="60%"> The LUN is in a failed state and is unable to perform the requested operation. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td>
    ///    <td width="60%"> Another operation is in progress. This operation cannot proceed until previous operations
    ///    are complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt>
    ///    <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation is not supported by this provider. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetFriendlyName(PWSTR pwszFriendlyName);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method to query the LUN number for a LUN.
@GUID("D3F95E46-54B3-41F9-B678-0F1871443A08")
interface IVdsLunNumber : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Retrieves the LUN number for a LUN.
    ///Params:
    ///    pulLunNumber = The address of a variable that receives the LUN number. This value is required and cannot be <b>NULL</b>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetLunNumber(uint* pulLunNumber);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing controller port configuration
///operations on a LUN.
@GUID("451FE266-DA6D-406A-BB60-82E534F85AEB")
interface IVdsLunControllerPorts : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the subsystem controller ports to active or inactive
    ///with respect to the LUN. This method replaces IVdsLun::AssociateControllers.
    ///Params:
    ///    pActiveControllerPortIdArray = A pointer to an array of controller port GUIDs. The provider sets these controller ports to active. This
    ///                                   array includes controller ports already set to active that are to remain active.
    ///    lNumberOfActiveControllerPorts = The number of controller ports specified in the <i>pActiveControllerPortIdArray</i> parameter.
    ///    pInactiveControllerPortIdArray = A pointer to an array of controller port GUIDs. The provider sets these controller ports to inactive. This
    ///                                     array includes controller ports already set to inactive that are to remain inactive.
    ///    lNumberOfInactiveControllerPorts = The number of controller ports specified in the <i>pInactiveControllerPortIdArray</i> parameter.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The association name was
    ///    successfully set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no longer present. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td
    ///    width="60%"> The LUN is in a failed state and is unable to perform the requested operation. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td>
    ///    <td width="60%"> Another operation is in progress. This operation cannot proceed until previous operations
    ///    are complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_NOT_FOUND</b></b></dt>
    ///    <dt>0x80042405L</dt> </dl> </td> <td width="60%"> One or more GUIDs of data type <b>VDS_OBJECT_ID</b>
    ///    specified in the <i>pActiveControllerPortIdArray</i> or <i>pInactiveControllerPortIdArray</i> parameters do
    ///    not refer to an existing object. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt> <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation
    ///    or combination of parameters is not supported by this provider. </td> </tr> </table>
    ///    
    HRESULT AssociateControllerPorts(GUID* pActiveControllerPortIdArray, int lNumberOfActiveControllerPorts, 
                                     GUID* pInactiveControllerPortIdArray, int lNumberOfInactiveControllerPorts);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of currently active controller
    ///ports— the controller ports through which the LUN can be accessed. This method replaces
    ///IVdsLun::QueryActiveControllers.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the controller ports as
    ///             controller port objects. For more information, see Working with Enumeration Objects. Callers must release the
    ///             interface and each of the controller port objects when they are no longer needed by calling the
    ///             IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The enumeration of controller
    ///    ports was successfully returned. If the LUN has no active controller ports, the enumeration is empty. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt>
    ///    </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a software or
    ///    communication problem inside a provider that caches information about the attached devices. The caller can
    ///    use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no longer present. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td
    ///    width="60%"> The LUN is in a failed state and is unable to perform the requested operation. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td>
    ///    <td width="60%"> Another operation is in progress. This operation cannot proceed until previous operations
    ///    are complete. </td> </tr> </table>
    ///    
    HRESULT QueryActiveControllerPorts(IEnumVdsObject* ppEnum);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on a LUN with MPIO extensions.
@GUID("7C5FBAE3-333A-48A1-A982-33C15788CDE3")
interface IVdsLunMpio : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an array of VDS_PATH_INFO structures, one for each
    ///path to the LUN.
    ///Params:
    ///    ppPaths = The address of a variable that receives an array of VDS_PATH_INFO structures. Callers must free each element
    ///              in the array, and the array itself, by using the CoTaskMemFree function.
    ///    plNumberOfPaths = The address of a variable that receives the number of elements in the array returned in the <i>ppPaths</i>
    ///                      parameter. The number of paths returned by this method will match the number of paths returned by the
    ///                      IVdsLunMpio::GetLoadBalancePolicy method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The path information was
    ///    successfully returned. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The
    ///    cache of the provider is corrupted. This indicates a software or communication problem inside a provider that
    ///    caches information about the attached devices. The caller can use the IVdsHwProvider::Reenumerate method
    ///    followed by the IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN
    ///    is in a failed state and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%">
    ///    Another operation is in progress. This operation cannot proceed until previous operations are complete. </td>
    ///    </tr> </table>
    ///    
    HRESULT GetPathInfo(VDS_PATH_INFO** ppPaths, int* plNumberOfPaths);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the current load balance policy on the LUN.
    ///Params:
    ///    pPolicy = A pointer to a variable that receives an VDS_LOADBALANCE_POLICY_ENUM enumeration value that specifies the
    ///              load balance policy.
    ///    ppPaths = A pointer to the array of VDS_PATH_POLICY structures passed in by the caller. Callers must free this array by
    ///              using the CoTaskMemFree function.
    ///    plNumberOfPaths = A pointer to a variable that receives the number of path-specific policy information structures returned in
    ///                      the <i>ppPaths</i> parameter.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The load balance policy was
    ///    successfully returned. If the LUN has no paths, the array is empty, the value pointed to by the
    ///    <i>plNumberOfPaths</i> parameter is set to 0, and the value pointed to by the <i>ppPaths</i> parameter is set
    ///    to <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no longer present. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td
    ///    width="60%"> The LUN is in a failed state and is unable to perform the requested operation. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td>
    ///    <td width="60%"> Another operation is in progress. This operation cannot proceed until previous operations
    ///    are complete. </td> </tr> </table>
    ///    
    HRESULT GetLoadBalancePolicy(VDS_LOADBALANCE_POLICY_ENUM* pPolicy, VDS_PATH_POLICY** ppPaths, 
                                 int* plNumberOfPaths);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the load balance policy on the LUN.
    ///Params:
    ///    policy = The load balance policy enumerated by the VDS_LOADBALANCE_POLICY_ENUM enumeration.
    ///    pPaths = A pointer to an array of members of the VDS_PATH_POLICY structure that contain the path-specific policy
    ///             information.
    ///    lNumberOfPaths = The number of members of the VDS_PATH_POLICY structure in the array pointed to by the <i>pPaths</i>
    ///                     parameter.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The load balance policy was
    ///    successfully set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no longer present. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_STATUS_FAILED</b></b></dt> <dt>0x80042431L</dt> </dl> </td> <td
    ///    width="60%"> The LUN is in a failed state and is unable to perform the requested operation. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td>
    ///    <td width="60%"> Another operation is in progress. This operation cannot proceed until previous operations
    ///    are complete. </td> </tr> </table>
    ///    
    HRESULT SetLoadBalancePolicy(VDS_LOADBALANCE_POLICY_ENUM policy, VDS_PATH_POLICY* pPaths, int lNumberOfPaths);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Retrieves the load balance policies that are supported by
    ///the hardware provider.
    ///Params:
    ///    pulLbFlags = The address of a <b>ULONG</b> that will receive the supported flags (as enumerated by the
    ///                 VDS_PROVIDER_LBSUPPORT_FLAG enumeration.)
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The load balance policy was successfully
    ///    returned. </td> </tr> </table>
    ///    
    HRESULT GetSupportedLbPolicies(uint* pulLbFlags);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on an iSCSI LUN.
@GUID("0D7C1E64-B59B-45AE-B86A-2C2CC6A42067")
interface IVdsLunIscsi : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Associates LUNs with subsystem iSCSI targets.
    ///Params:
    ///    pTargetIdArray = A pointer to an array of target <b>VDS_OBJECT_ID</b> data types. The provider associates these iSCSI targets
    ///                     with the LUN. This array includes targets already associated with the LUN that are to remain so.
    ///    lNumberOfTargets = The number of targets specified in the <i>pTargetArray</i> parameter.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state, and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042405L</dt> </dl> </td> <td width="60%"> Can be returned from
    ///    any method that takes a <b>VDS_OBJECT_ID</b> constant. This return value indicates that the identifier does
    ///    not refer to an existing object. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt>
    ///    <dt>0x80042400L</dt> </dl> </td> <td width="60%"> This operation or combination of parameters is not
    ///    supported by this provider. </td> </tr> </table>
    ///    
    HRESULT AssociateTargets(GUID* pTargetIdArray, int lNumberOfTargets);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of currently associated iSCSI
    ///targets—the targets through which the LUN is accessible.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the iSCSI targets as target
    ///             objects. For more information, see Working with Enumeration Objects. Callers must release the interface and
    ///             each of the target objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN object is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN is in a failed state, and is unable to perform the
    ///    requested operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt>
    ///    <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another operation is in progress; this operation cannot
    ///    proceed until the previous operation or operations are complete. </td> </tr> </table>
    ///    
    HRESULT QueryAssociatedTargets(IEnumVdsObject* ppEnum);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on a LUN plex.
@GUID("0EE1A790-5D2E-4ABB-8C99-C481E8BE2138")
interface IVdsLunPlex : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of the LUN plex.
    ///Params:
    ///    pPlexProp = The address of the VDS_LUN_PLEX_PROP structure allocated and passed in by the caller.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt> <dt>0x00042715L</dt> </dl> </td> <td
    ///    width="60%"> Some but not all of the properties were successfully retrieved. Note that there are many
    ///    possible reasons for failing to retrieve all properties, including device removal. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN plex is no
    ///    longer present. </td> </tr> </table>
    ///    
    HRESULT GetProperties(VDS_LUN_PLEX_PROP* pPlexProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the LUN to which the plex belongs.
    ///Params:
    ///    ppLun = The address of an IVdsLuninterface pointer. Callers must release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN plex is no
    ///    longer present. </td> </tr> </table>
    ///    
    HRESULT GetLun(IVdsLun* ppLun);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an array of the drive extents that contribute to
    ///the plex.
    ///Params:
    ///    ppExtentArray = A pointer to the array of pointers to drive extents passed in by the caller. These are the extents that
    ///                    contribute to the plex. See the VDS_DRIVE_EXTENT structure. Callers must free this array by using the
    ///                    CoTaskMemFree function.
    ///    plNumberOfExtents = A pointer to the number of drive extents returned in <i>ppExtentArray</i>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN plex is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN plex is in a failed state, and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> </table>
    ///    
    HRESULT QueryExtents(VDS_DRIVE_EXTENT** ppExtentArray, int* plNumberOfExtents);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the hints that are currently applied to the LUN
    ///plex.
    ///Params:
    ///    pHints = Pointer to the returned plex hints. See the VDS_HINTS structure.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN plex object is
    ///    no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN plex is in a failed state, and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT QueryHints(VDS_HINTS* pHints);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Applies a new set of hints to the LUN plex. Hints applied
    ///to a plex affect neither the LUN nor its other plexes.
    ///Params:
    ///    pHints = Pointer to the hints to be applied to the LUN plex. See the VDS_HINTS structure. Only fields relevant to a
    ///             LUN plex are expected to be set; irrelevant fields are ignored.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The LUN plex is no
    ///    longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The LUN plex is in a failed state, and is unable to perform
    ///    the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT ApplyHints(VDS_HINTS* pHints);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on an iSCSI portal.
@GUID("7FA1499D-EC85-4A8A-A47B-FF69201FCD34")
interface IVdsIscsiPortal : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a portal.
    ///Params:
    ///    pPortalProp = The address of an VDS_ISCSI_PORTAL_PROP structure.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The properties were retrieved
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt>
    ///    <dt>0x00042715L</dt> </dl> </td> <td width="60%"> Some but not all of the properties were successfully
    ///    retrieved. Note that there are many possible reasons for failing to retrieve all properties, including device
    ///    removal. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal object is no longer present. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetProperties(VDS_ISCSI_PORTAL_PROP* pPortalProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the subsystem to which the portal belongs.
    ///Params:
    ///    ppSubSystem = The address of an IVdsSubSystem interface pointer. Callers must release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The subsystem was retrieved
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal object is no longer present. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetSubSystem(IVdsSubSystem* ppSubSystem);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of the portal groups with which the
    ///portal is associated.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the portal groups as portal
    ///             group objects. For more information, see Working with Enumeration Objects. Callers must release the interface
    ///             and each of the portal group objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The enumeration of associated
    ///    portal groups was returned successfully. If the portal has no associated portal groups, the enumeration is
    ///    empty. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal object is no longer present. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td>
    ///    <td width="60%"> Another operation is in progress. This operation cannot proceed until the previous
    ///    operations are complete. </td> </tr> </table>
    ///    
    HRESULT QueryAssociatedPortalGroups(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Not supported. Sets the status of a portal to the specified
    ///value.
    ///Params:
    ///    status = Values enumerated by VDS_ISCSI_PORTAL_STATUS. Only <b>VDS_IPS_ONLINE</b> and <b>VDS_IPS_OFFLINE</b>
    ///             enumeration values are supported; the remaining values are only to be used by a provider to report status.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The status was set successfully. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> </dl> </td> <td width="60%">
    ///    The cache of the provider is corrupted. This indicates a software or communication problem inside a provider
    ///    that caches information about the attached devices. The caller can use the IVdsHwProvider::Reenumerate method
    ///    followed by the IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> </dl> </td> <td width="60%"> The portal object is no longer
    ///    present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> </dl>
    ///    </td> <td width="60%"> Another operation is in progress. This operation cannot proceed until the previous
    ///    operations are complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt>
    ///    </dl> </td> <td width="60%"> The operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetStatus(VDS_ISCSI_PORTAL_STATUS status);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Not supported. This method is reserved for future use.
    ///Params:
    ///    pTunnelAddress = Reserved for future use.
    ///    pDestinationAddress = Reserved for future use.
    HRESULT SetIpsecTunnelAddress(VDS_IPADDRESS* pTunnelAddress, VDS_IPADDRESS* pDestinationAddress);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Not supported. This method is reserved for future use.
    ///Params:
    ///    pInitiatorPortalAddress = Reserved for future use.
    ///    pullSecurityFlags = Reserved for future use.
    HRESULT GetIpsecSecurity(VDS_IPADDRESS* pInitiatorPortalAddress, ulong* pullSecurityFlags);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Not supported. This method is reserved for future use.
    ///Params:
    ///    pInitiatorPortalAddress = Reserved for future use.
    ///    ullSecurityFlags = Reserved for future use.
    ///    pIpsecKey = Reserved for future use.
    HRESULT SetIpsecSecurity(VDS_IPADDRESS* pInitiatorPortalAddress, ulong ullSecurityFlags, 
                             VDS_ISCSI_IPSEC_KEY* pIpsecKey);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration operations
///on an iSCSI target.
@GUID("AA8F5055-83E5-4BCC-AA73-19851A36A849")
interface IVdsIscsiTarget : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of an iSCSI target.
    ///Params:
    ///    pTargetProp = The address of a VDS_ISCSI_TARGET_PROP structure allocated by the caller. VDS allocates memory for the
    ///                  strings pointed to by the <b>pwszIscsiName</b> and <b>pwszFriendlyName</b> members of this structure. Callers
    ///                  must free the strings by using the CoTaskMemFree function.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The properties were returned
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt>
    ///    <dt>0x00042715L</dt> </dl> </td> <td width="60%"> Some but not all of the properties were successfully
    ///    retrieved. Note that there are many possible reasons for failing to retrieve all properties, including device
    ///    removal. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal object is no longer present. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetProperties(VDS_ISCSI_TARGET_PROP* pTargetProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the subsystem to which the target belongs.
    ///Params:
    ///    ppSubSystem = The address of an IVdsSubSystem interface pointer. VDS initializes the interface on return. Callers must
    ///                  release the interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The subsystem object was returned
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The target object is no longer present. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetSubSystem(IVdsSubSystem* ppSubSystem);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of the iSCSI portal groups within
    ///the target.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the portal groups as portal
    ///             group objects. For more information, see Working with Enumeration Objects. Callers must release the interface
    ///             and each of the portal group objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The enumeration of portal groups
    ///    was returned successfully. If the target has no portal groups, the enumeration is empty. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> The cache of the provider is corrupted. This indicates a software or communication problem
    ///    inside a provider that caches information about the attached devices. The caller can use the
    ///    IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the cache. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td>
    ///    <td width="60%"> The target object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%">
    ///    Another operation is in progress; this operation cannot proceed until the previous operations are complete.
    ///    </td> </tr> </table>
    ///    
    HRESULT QueryPortalGroups(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns a enumeration of the LUNs associated with the
    ///target.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the LUNs as LUN objects. For
    ///             more information, see Working with Enumeration Objects. Callers must release the interface and each of the
    ///             LUN objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The enumeration of associated LUNs
    ///    was returned successfully. If the target has no associated LUNs, the enumeration is empty. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td>
    ///    <td width="60%"> The cache of the provider is corrupted. This indicates a software or communication problem
    ///    inside a provider that caches information about the attached devices. The caller can use the
    ///    IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the cache. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td>
    ///    <td width="60%"> The target object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%">
    ///    Another operation is in progress; this operation cannot proceed until the previous operations are complete.
    ///    </td> </tr> </table>
    ///    
    HRESULT QueryAssociatedLuns(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Creates a portal group. The interface pointer for the new
    ///portal group object can be retrieved by calling IVdsAsync::Wait through the <i>ppAsync</i> parameter. The
    ///VDS_ASYNC_OUTPUT structure returned contains the volume object interface pointer in the
    ///<b>cpg.pPortalGroupUnk</b> member.
    ///Params:
    ///    ppAsync = The address of an IVdsAsync interface pointer, which VDS initializes on return. Callers must release the
    ///              interface. Use this interface to cancel, wait for, or query the status of the operation. If you call the
    ///              IVdsAsync::Wait method on this interface and a success HRESULT value is returned, you must release the
    ///              interfaces returned in the VDS_ASYNC_OUTPUT structure by calling the IUnknown::Release method on each
    ///              interface pointer. However, if <b>Wait</b> returns a failure HRESULT value, or if the <i>pHrResult</i>
    ///              parameter of <b>Wait</b> receives a failure HRESULT value, the interface pointers in the
    ///              <b>VDS_ASYNC_OUTPUT</b> structure are <b>NULL</b> and do not need to be released. You can test for success or
    ///              failure HRESULT values by using the SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The portal group was created
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_S_ALREADY_EXISTS</b></b></dt>
    ///    <dt>0x00042714L</dt> </dl> </td> <td width="60%"> No more portal groups can be created. The CreatePortalGroup
    ///    method did not create a new portal group. If you call the IVdsAsync::Wait method on the interface pointer
    ///    returned in the <i>ppAsync</i> parameter, an existing portal group object is retrieved. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> The cache of the provider is corrupted. This indicates a software or communication problem
    ///    inside a provider that caches information about the attached devices. The caller can use the
    ///    IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the cache. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td>
    ///    <td width="60%"> The target object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%">
    ///    Another operation is in progress; this operation cannot proceed until the previous operations are complete.
    ///    </td> </tr> </table>
    ///    
    HRESULT CreatePortalGroup(IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Deletes the target and all of its portal groups if no LUNs
    ///are associated with the target.
    ///Params:
    ///    ppAsync = The address of an IVdsAsync interface pointer, which VDS initializes on return. Callers must release the
    ///              interface. Use this interface to cancel, wait for, or query the status of the operation. If you call the
    ///              IVdsAsync::Wait method on this interface and a success HRESULT value is returned, you must release the
    ///              interfaces returned in the VDS_ASYNC_OUTPUT structure by calling the IUnknown::Release method on each
    ///              interface pointer. However, if <b>Wait</b> returns a failure HRESULT value, or if the <i>pHrResult</i>
    ///              parameter of <b>Wait</b> receives a failure HRESULT value, the interface pointers in the
    ///              <b>VDS_ASYNC_OUTPUT</b> structure are <b>NULL</b> and do not need to be released. You can test for success or
    ///              failure HRESULT values by using the SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The portal group was created
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The target object is no longer present. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td>
    ///    <td width="60%"> Another operation is in progress; this operation cannot proceed until the previous
    ///    operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ASSOCIATED_LUNS_EXIST</b></b></dt> <dt>0x8004270BL</dt> </dl> </td> <td width="60%"> LUNs are
    ///    associated with this target. All LUNs must be disassociated from this target before this target can be
    ///    deleted. </td> </tr> </table>
    ///    
    HRESULT Delete(IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the friendly name of the target.
    ///Params:
    ///    pwszFriendlyName = A string specifying the friendly name to assign to the target. This corresponds to the iSCSI alias.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The friendly name was set
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_S_NAME_TRUNCATED</b></b></dt>
    ///    <dt>0x00042700L</dt> </dl> </td> <td width="60%"> The name was set successfully but had to be truncated due
    ///    to limitations in the subsystem. The name that was set might not match the name passed in the
    ///    <i>pwszFriendlyName</i> parameter. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The
    ///    cache of the provider is corrupted. This indicates a software or communication problem inside a provider that
    ///    caches information about the attached devices. The caller can use the IVdsHwProvider::Reenumerate method
    ///    followed by the IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The target
    ///    object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%">
    ///    Another operation is in progress; this operation cannot proceed until the previous operations are complete.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt> <dt>0x80042400L</dt> </dl>
    ///    </td> <td width="60%"> This operation or combination of parameters is not supported by this provider. </td>
    ///    </tr> </table>
    ///    
    HRESULT SetFriendlyName(PWSTR pwszFriendlyName);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the target CHAP shared secret that is used for CHAP
    ///authentication when the target authenticates the initiator.
    ///Params:
    ///    pTargetSharedSecret = The address of an VDS_ISCSI_SHARED_SECRET structure that contains the shared secret. If the
    ///                          <b>pSharedSecret</b> member is <b>NULL</b> and the <b>ulSharedSecretSize</b> is zero, the
    ///                          <b>SetSharedSecret</b> method clears any existing secret.
    ///    pwszInitiatorName = The string specifying the iSCSI name to which the shared secret is to be associated, if the secret is
    ///                        initiator-specific. The value passed is used as the CHAP name. If the address is <b>NULL</b> the changes
    ///                        apply to the default secret for all initiators.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The shared secret was set
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The target object is no longer present. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt> <dt>0x80042400L</dt> </dl> </td> <td
    ///    width="60%"> This operation or combination of parameters is not supported by this provider. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_INITIATOR_SPECIFIC_NOT_SUPPORTED</b></b></dt> <dt>0x80042707L</dt>
    ///    </dl> </td> <td width="60%"> The target does not support initiator-specific shared secrets. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetSharedSecret(VDS_ISCSI_SHARED_SECRET* pTargetSharedSecret, PWSTR pwszInitiatorName);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Communicates the initiator CHAP secret that is used for
    ///mutual CHAP authentication when the initiator authenticates the target.
    ///Params:
    ///    pwszInitiatorName = The string specifying the iSCSI name of the initiator. This parameter is required and cannot be <b>NULL</b>.
    ///    pInitiatorSharedSecret = The address of a VDS_ISCSI_SHARED_SECRET structure that contains the shared secret.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The shared secret was remembered
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The target object is no longer present. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_NOT_SUPPORTED</b></b></dt> <dt>0x80042400L</dt> </dl> </td> <td
    ///    width="60%"> This operation or combination of parameters is not supported by this provider. </td> </tr>
    ///    </table>
    ///    
    HRESULT RememberInitiatorSharedSecret(PWSTR pwszInitiatorName, VDS_ISCSI_SHARED_SECRET* pInitiatorSharedSecret);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the list of iSCSI names of the initiators currently
    ///logged into the target.
    ///Params:
    ///    pppwszInitiatorList = The address of a variable that receives an array of strings containing the iSCSI names of the initiators
    ///                          currently logged into the target. Callers must free each string in this array, as well as the array itself,
    ///                          by using the CoTaskMemFree function.
    ///    plNumberOfInitiators = A pointer to the number of strings returned in <i>pppwszInitiatorList</i>.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The list of connected initiators
    ///    was returned successfully. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%">
    ///    Another operation is in progress; this operation cannot proceed until the previous operations are complete.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The target object is no longer present. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetConnectedInitiators(PWSTR** pppwszInitiatorList, int* plNumberOfInitiators);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing query and configuration services
///on an iSCSI portal group.
@GUID("FEF5F89D-A3DD-4B36-BF28-E7DDE045C593")
interface IVdsIscsiPortalGroup : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a portal group.
    ///Params:
    ///    pPortalGroupProp = The address of a VDS_ISCSI_PORTALGROUP_PROP structure allocated and passed in by the caller.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The properties were returned
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_S_PROPERTIES_INCOMPLETE</b></b></dt>
    ///    <dt>0x00042715L</dt> </dl> </td> <td width="60%"> Some but not all of the properties were successfully
    ///    retrieved. Note that there are many possible reasons for failing to retrieve all properties, including device
    ///    removal. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal group object is no longer present. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetProperties(VDS_ISCSI_PORTALGROUP_PROP* pPortalGroupProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the target to which the portal group belongs.
    ///Params:
    ///    ppTarget = The address of an IVdsIscsiTarget. VDS initializes the interface on return. Callers must release the
    ///               interface.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The target object was returned
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal group object is no longer present. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetTarget(IVdsIscsiTarget* ppTarget);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an enumeration of the portals with which the portal
    ///group is associated.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the portals as portal
    ///             objects. For more information, see Working with Enumeration Objects. Callers must release the interface and
    ///             each of the portal objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The enumeration of associated
    ///    portals was returned successfully. If the portal group has no associated portals, the enumeration is empty.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal group object is no longer present. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl>
    ///    </td> <td width="60%"> Another operation is in progress. This operation cannot proceed until the previous
    ///    operations are complete. </td> </tr> </table>
    ///    
    HRESULT QueryAssociatedPortals(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Adds a portal to a portal group. A portal can belong only
    ///to a single portal group within a particular target. It can belong to other portal groups in other targets.
    ///Params:
    ///    portalId = The <b>VDS_OBJECT_ID</b> of the portal to be added to the portal group.
    ///    ppAsync = The address of an IVdsAsync interface pointer. VDS initializes the interface on return. Callers must release
    ///              the interface. Use this interface to cancel, wait for, or query the status of the operation. If
    ///              IVdsAsync::Wait is called and a success HRESULT value is returned, the interfaces returned in the
    ///              VDS_ASYNC_OUTPUT structure must be released by calling the IUnknown::Release method on each interface
    ///              pointer. However, if <b>Wait</b> returns a failure HRESULT value, or if the <i>pHrResult</i> parameter of
    ///              <b>Wait</b> receives a failure HRESULT value, the interface pointers in the <b>VDS_ASYNC_OUTPUT</b> structure
    ///              are <b>NULL</b> and do not need to be released. You can test for success or failure HRESULT values by using
    ///              the SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The portal was added successfully
    ///    to the portal group. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The
    ///    cache of the provider is corrupted. This indicates a software or communication problem inside a provider that
    ///    caches information about the attached devices. The caller can use the IVdsHwProvider::Reenumerate method
    ///    followed by the IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal
    ///    group object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%">
    ///    Another operation is in progress. This operation cannot proceed until the previous operations are complete.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_NOT_FOUND</b></b></dt> <dt>0x80042405L</dt>
    ///    </dl> </td> <td width="60%"> The <i>portalID</i> parameter does not refer to an existing object. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddPortal(GUID portalId, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Removes a portal from a portal group.
    ///Params:
    ///    portalId = The <b>VDS_OBJECT_ID</b> of the portal to be removed from the portal group.
    ///    ppAsync = The address of an IVdsAsync interface pointer. VDS initializes the interface on return. Callers must release
    ///              the interface. Use this interface to cancel, wait for, or query the status of the operation. If
    ///              IVdsAsync::Wait is called and a success HRESULT value is returned, the interfaces returned in the
    ///              VDS_ASYNC_OUTPUT structure must be released by calling the IUnknown::Release method on each interface
    ///              pointer. However, if <b>Wait</b> returns a failure HRESULT value, or if the <i>pHrResult</i> parameter of
    ///              <b>Wait</b> receives a failure HRESULT value, the interface pointers in the <b>VDS_ASYNC_OUTPUT</b> structure
    ///              are <b>NULL</b> and do not need to be released. You can test for success or failure HRESULT values by using
    ///              the SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The portal was removed
    ///    successfully from the portal group. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The
    ///    cache of the provider is corrupted. This indicates a software or communication problem inside a provider that
    ///    caches information about the attached devices. The caller can use the IVdsHwProvider::Reenumerate method
    ///    followed by the IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal
    ///    group object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%">
    ///    Another operation is in progress. This operation cannot proceed until the previous operations are complete.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_NOT_FOUND</b></b></dt> <dt>0x80042405L</dt>
    ///    </dl> </td> <td width="60%"> The <i>portalID</i> parameter does not refer to an existing object. </td> </tr>
    ///    </table>
    ///    
    HRESULT RemovePortal(GUID portalId, IVdsAsync* ppAsync);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Deletes the portal group.
    ///Params:
    ///    ppAsync = The address of an IVdsAsync interface pointer. VDS initializes the interface on return. Callers must release
    ///              the interface. Use this interface to cancel, wait for, or query the status of the operation. If
    ///              IVdsAsync::Wait is called and a success HRESULT value is returned, the interfaces returned in the
    ///              VDS_ASYNC_OUTPUT structure must be released by calling the IUnknown::Release method on each interface
    ///              pointer. However, if <b>Wait</b> returns a failure HRESULT value, or if the <i>pHrResult</i> parameter of
    ///              <b>Wait</b> receives a failure HRESULT value, the interface pointers in the <b>VDS_ASYNC_OUTPUT</b> structure
    ///              are <b>NULL</b> and do not need to be released. You can test for success or failure HRESULT values by using
    ///              the SUCCEEDED and FAILED macros defined in Winerror.h.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The portal group was successfully
    ///    deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></b></dt>
    ///    <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> The cache of the provider is corrupted. This indicates a
    ///    software or communication problem inside a provider that caches information about the attached devices. The
    ///    caller can use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to
    ///    restore the cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VDS_E_OBJECT_DELETED</b></b></dt>
    ///    <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The portal object is no longer present. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></b></dt> <dt>0x80042404L</dt> </dl> </td>
    ///    <td width="60%"> Another operation is in progress. This operation cannot proceed until the previous
    ///    operations are complete. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_E_ASSOCIATED_PORTALS_EXIST</b></b></dt> <dt>0x8004270CL</dt> </dl> </td> <td width="60%">
    ///    Portals are associated with this portal group. All portals must be disassociated from this portal group
    ///    before this portal group can be deleted. </td> </tr> </table>
    ///    
    HRESULT Delete(IVdsAsync* ppAsync);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods to query information and enumerate related
///objects for a storage pool.
@GUID("932CA8CF-0EB3-4BA8-9620-22665D7F8450")
interface IVdsStoragePool : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the hardware provider that manages the storage
    ///pool.
    ///Params:
    ///    ppProvider = The address of a variable that receives an IVdsProvider interface pointer. Callers must release the interface
    ///                 when it is no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetProvider(IVdsProvider* ppProvider);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the properties of a storage pool.
    ///Params:
    ///    pStoragePoolProp = The address of a caller-allocated VDS_STORAGE_POOL_PROP structure that receives the storage pool property
    ///                       information.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetProperties(VDS_STORAGE_POOL_PROP* pStoragePoolProp);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns the attributes of a storage pool.
    ///Params:
    ///    pStoragePoolAttributes = The address of a caller-allocated VDS_POOL_ATTRIBUTES structure that receives the storage pool attributes.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT GetAttributes(VDS_POOL_ATTRIBUTES* pStoragePoolAttributes);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an array of the drive extents that are used by a
    ///storage pool.
    ///Params:
    ///    ppExtentArray = A pointer to the array of VDS_STORAGE_POOL_DRIVE_EXTENT structures passed in by the caller. These structures
    ///                    describe the drive extents used by the storage pool. Callers must free this array by using the CoTaskMemFree
    ///                    function.
    ///    plNumberOfExtents = A pointer to the number of extents returned in the <i>ppExtentArray</i> array.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueryDriveExtents(VDS_STORAGE_POOL_DRIVE_EXTENT** ppExtentArray, int* plNumberOfExtents);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an object that enumerates the allocated LUNs for a
    ///storage pool.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the allocated LUNs. For more
    ///             information, see Working with Enumeration Objects. Callers must release the interface and each of the LUN
    ///             objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueryAllocatedLuns(IEnumVdsObject* ppEnum);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Returns an object that enumerates the allocated storage
    ///pools that are managed by the provider.
    ///Params:
    ///    ppEnum = The address of an IEnumVdsObject interface pointer that can be used to enumerate the allocated storage pools.
    ///             For more information, see Working with Enumeration Objects. Callers must release the interface and each of
    ///             the storage pool objects when they are no longer needed by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The method completed successfully. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueryAllocatedStoragePools(IEnumVdsObject* ppEnum);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides methods for performing maintenance operations on a
///subsystem, controller, LUN, or drive.
@GUID("DAEBEEF3-8523-47ED-A2B9-05CECCE2A1AE")
interface IVdsMaintenance : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Starts a maintenance operation.
    ///Params:
    ///    operation = A maintenance operation enumerated by VDS_MAINTENANCE_OPERATION.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td
    ///    width="60%"> This return value signals a software or communication problem inside a provider that caches
    ///    information about the array. Use the IVdsHwProvider::Reenumerate method followed by the
    ///    IVdsHwProvider::Refresh method to restore the cache. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl> </td> <td width="60%"> The subsystem object
    ///    is no longer present. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt>
    ///    <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is in a failed state, and is unable to
    ///    perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT StartMaintenance(VDS_MAINTENANCE_OPERATION operation);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Stops a maintenance operation.
    ///Params:
    ///    operation = A maintenance operation enumerated by VDS_MAINTENANCE_OPERATION.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The specified maintenance operation is
    ///    not running; the method does nothing. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is
    ///    in a failed state, and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT StopMaintenance(VDS_MAINTENANCE_OPERATION operation);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Performs the specified operation a specified number of
    ///times.
    ///Params:
    ///    operation = A maintenance operation enumerated by VDS_MAINTENANCE_OPERATION.
    ///    ulCount = The number of times to perform the operation.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The specified operation is not
    ///    running; the method does nothing. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_PROVIDER_CACHE_CORRUPT</b></dt> <dt>0x8004241FL</dt> </dl> </td> <td width="60%"> This return
    ///    value signals a software or communication problem inside a provider that caches information about the array.
    ///    Use the IVdsHwProvider::Reenumerate method followed by the IVdsHwProvider::Refresh method to restore the
    ///    cache. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_OBJECT_DELETED</b></dt> <dt>0x8004240BL</dt> </dl>
    ///    </td> <td width="60%"> The subsystem object is no longer present. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_OBJECT_STATUS_FAILED</b></dt> <dt>0x80042431L</dt> </dl> </td> <td width="60%"> The subsystem is
    ///    in a failed state, and is unable to perform the requested operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VDS_E_ANOTHER_CALL_IN_PROGRESS</b></dt> <dt>0x80042404L</dt> </dl> </td> <td width="60%"> Another
    ///    operation is in progress; this operation cannot proceed until the previous operation or operations are
    ///    complete. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VDS_E_NOT_SUPPORTED</b></dt> <dt>0x80042400L</dt>
    ///    </dl> </td> <td width="60%"> This operation or combination of parameters is not supported by this provider.
    ///    </td> </tr> </table>
    ///    
    HRESULT PulseMaintenance(VDS_MAINTENANCE_OPERATION operation, uint ulCount);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method that enables VDS to determine whether the
///hardware provider manages a specified LUN.
@GUID("98F17BF3-9F33-4F12-8714-8B4075092C2E")
interface IVdsHwProviderPrivate : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Enables VDS to determine whether the hardware provider
    ///manages the specified LUN.
    ///Params:
    ///    pwszDevicePath = A pointer to the path to the LUN on the local computer; a zero-terminated, human-readable string.
    ///    pVdsLunInformation = A pointer to the identification data of the specified LUN. See the VDS_LUN_INFORMATIONstructure.
    ///    pLunId = A pointer to the returned LUN GUID. If the provider does not manage the LUN, set this parameter to GUID_NULL.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The provider owns the LUN; returns the GUID of the
    ///    LUN. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The provider
    ///    does not own the LUN. </td> </tr> </table>
    ///    
    HRESULT QueryIfCreatedLun(PWSTR pwszDevicePath, VDS_LUN_INFORMATION* pVdsLunInformation, GUID* pLunId);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Provides a method that sets the status of paths originating from a
///particular HBA port to the provider.
@GUID("310A7715-AC2B-4C6F-9827-3D742F351676")
interface IVdsHwProviderPrivateMpio : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Sets the statuses of paths originating from a particular
    ///HBA port to a specified status.
    ///Params:
    ///    hbaPortProp = The properties of the HBA port from which the paths to be set originate. The only fields that need to be
    ///                  provided are <b>wwnNode</b> and <b>wwnPort</b>. The hardware provider must ignore all other fields.
    ///    status = The status (enumerated by the VDS_PATH_STATUS enumeration) to set the paths.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The association name was
    ///    successfully set. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VDS_S_STATUSES_INCOMPLETELY_SET</b></b></dt> <dt>0x00042702L</dt> </dl> </td> <td width="60%"> At
    ///    least one path's status was not successfully set due to a nonfatal error (for example, the status conflicts
    ///    with the current load balance policy). </td> </tr> </table>
    ///    
    HRESULT SetAllPathStatusesFromHbaPort(VDS_HBAPORT_PROP hbaPortProp, VDS_PATH_STATUS status);
}

///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface is
///superseded by the Windows Storage Management API.] Registers providers with VDS.
@GUID("D188E97D-85AA-4D33-ABC6-26299A10FFC1")
interface IVdsAdmin : IUnknown
{
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Registers the specified hardware provider with VDS.
    ///Hardware providers call this method.
    ///Params:
    ///    providerId = The GUID of the hardware provider.
    ///    providerClsid = The COM class identifier (Clsid) of the hardware provider.
    ///    pwszName = The name of the hardware provider as a zero-terminated, human-readable string.
    ///    type = The provider types enumerated by VDS_PROVIDER_TYPE. Use the <b>VDS_PT_HARDWARE</b> value to register a
    ///           hardware provider with VDS.
    ///    pwszMachineName = The name of the computer on which the hardware provider executes; a null-terminated, human-readable string.
    ///                      Use <b>NULL</b> to reference the current computer.
    ///    pwszVersion = The version of the provider as a zero-terminated, human-readable string.
    ///    guidVersionId = The GUID for this version of the provider.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used. Possible return values
    ///    include the following. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VDS_E_ALREADY_REGISTERED</b></dt> <dt>0x80042403L</dt> </dl> </td> <td width="60%">
    ///    The <i>providerId</i> is already registered. Only one version of a provider can be registered at any given
    ///    time. </td> </tr> </table>
    ///    
    HRESULT RegisterProvider(GUID providerId, GUID providerClsid, PWSTR pwszName, VDS_PROVIDER_TYPE type, 
                             PWSTR pwszMachineName, PWSTR pwszVersion, GUID guidVersionId);
    ///<p class="CCE_Message">[Beginning with Windows 8 and Windows Server 2012, the Virtual Disk Service COM interface
    ///is superseded by the Windows Storage Management API.] Removes VDS provider registration data. Hardware providers
    ///call this method.
    ///Params:
    ///    providerId = The GUID of the provider.
    ///Returns:
    ///    This method can return standard HRESULT values, such as E_INVALIDARG or E_OUTOFMEMORY, and VDS-specific
    ///    return values. It can also return converted system error codes using the HRESULT_FROM_WIN32 macro. Errors can
    ///    originate from VDS itself or from the underlying VDS provider that is being used.
    ///    
    HRESULT UnregisterProvider(GUID providerId);
}

///The <b>IVssEnumObject</b> interface contains methods to iterate over and perform other operations on a list of
///enumerated objects. The calling application is responsible for calling IUnknown::Release to release the resources
///held by the returned <b>IVssEnumObject</b> when it is no longer needed. It may also need to call
///<b>IUnknown::Release</b> to release temporary objects (such as strings) returned during enumeration. The
///IVssBackupComponents::Query method returns an <b>IVssEnumObject</b> object.
@GUID("AE1C7110-2F60-11D3-8A39-00C04F72D8E3")
interface IVssEnumObject : IUnknown
{
    ///The <b>Next</b> method returns the specified number of objects from the specified list of enumerated objects.
    ///Params:
    ///    celt = The number of elements to be read from the list of enumerated objects into the <i>rgelt</i> buffer.
    ///    rgelt = The address of a caller-allocated buffer that receives <i>celt</i>VSS_OBJECT_PROP structures that contain the
    ///            returned objects. This parameter is required and cannot be NULL.
    ///    pceltFetched = The number of elements that were returned in the <i>rgelt</i> buffer.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> The number of
    ///    returned items is less than the number requested. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There is an internal error in the enumerator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> One of the required pointer
    ///    parameters is NULL. </td> </tr> </table>
    ///    
    HRESULT Next(uint celt, VSS_OBJECT_PROP* rgelt, uint* pceltFetched);
    ///The <b>Skip</b> method skips the specified number of objects.
    ///Params:
    ///    celt = Number of elements to be skipped in the list of enumerated objects.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> An attempt was
    ///    made to access a location beyond the end of the list of items. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There was an internal error in the enumerator. </td>
    ///    </tr> </table>
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Reset</b> method resets the enumerator so that IVssEnumObject:Next starts at the first enumerated object.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There was an
    ///    internal error in the enumerator. </td> </tr> </table>
    ///    
    HRESULT Reset();
    ///The <b>Clone</b> method creates a copy of the specified list of enumerated elements by creating a copy of the
    ///IVssEnumObject enumerator object.
    ///Params:
    ///    ppenum = Doubly indirect pointer to an IVssEnumObject enumerator object. Set the value of this parameter to
    ///             <b>NULL</b> before calling this method.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_FAIL</b></dt> </dl> </td> <td width="60%"> There is an
    ///    internal error in the enumerator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_POINTER</b></dt> </dl> </td> <td width="60%"> One of the required pointer
    ///    parameters is NULL. </td> </tr> </table>
    ///    
    HRESULT Clone(IVssEnumObject* ppenum);
}

///The <b>IVssAsync</b> interface is returned to calling applications by methods that initiate asynchronous operations,
///which run in the background and typically require a long time to complete. The <b>IVssAsync</b> interface permits an
///application to monitor and control an asynchronous operation by waiting on its completion, querying its status, or
///canceling it. The calling application is responsible for calling IUnknown::Release to release the resources held by
///the returned <b>IVssAsync</b> interface when it is no longer needed. The following methods return an <b>IVssAsync</b>
///interface: <ul> <li> IVssBackupComponents::BackupComplete </li> <li> IVssBackupComponents::DoSnapshotSet </li> <li>
///IVssBackupComponents::GatherWriterMetadata </li> <li> IVssBackupComponents::GatherWriterStatus </li> <li>
///IVssBackupComponents::ImportSnapshots </li> <li> IVssBackupComponents::PostRestore </li> <li>
///IVssBackupComponents::PrepareForBackup </li> <li> IVssBackupComponents::PreRestore </li> </ul>
@GUID("507C37B4-CF5B-4E95-B0AF-14EB9767467E")
interface IVssAsync : IUnknown
{
    ///The <b>Cancel</b> method cancels an incomplete asynchronous operation.
    ///Returns:
    ///    All calls to <b>Cancel</b> for all IVssAsync objects support the following status codes. <table> <tr>
    ///    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The asynchronous operation had been successfully canceled. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VSS_S_ASYNC_CANCELLED</b></dt> </dl> </td> <td width="60%"> The asynchronous operation had been
    ///    canceled prior to calling this method. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_S_ASYNC_FINISHED</b></dt> </dl> </td> <td width="60%"> The asynchronous operation had completed
    ///    prior to calling this method. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> Unexpected error. The error code is logged in the error log file. For more
    ///    information, see Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server
    ///    2003 and Windows XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED
    ///    is used instead. </td> </tr> </table> If an operation has completed unsuccessfully before <b>Cancel</b> was
    ///    called, then <b>Cancel</b> returns the error that operation encountered. To obtain a complete list of return
    ///    values for a specific <b>IVssAsync::Cancel</b>, see the error codes of the method that returned the IVssAsync
    ///    object.
    ///    
    HRESULT Cancel();
    ///The <b>Wait</b> method waits until an incomplete asynchronous operation finishes.
    ///Params:
    ///    dwMilliseconds = Length of time, in milliseconds, that the method will wait for an asynchronous process to return before
    ///                     timing out. The default value for this argument is INFINITE. <b>Windows Server 2003: </b>This parameter is
    ///                     reserved and must be INFINITE. If any other value is specified for this parameter, the call to <b>Wait</b>
    ///                     fails with E_INVALIDARG. <b>Windows XP: </b>This method has no parameters.
    ///Returns:
    ///    All calls to <b>Wait</b> for all IVssAsync objects support the following status codes. <table> <tr>
    ///    <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td
    ///    width="60%"> The wait operation was successful. Call IVssAsync::QueryStatus to determine the final status of
    ///    the asynchronous operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td>
    ///    <td width="60%"> The wait operation failed because the user did not have the correct privileges. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error.
    ///    The error code is logged in the error log file. For more information, see Event and Error Handling Under VSS.
    ///    <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported
    ///    until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table> If an
    ///    operation fails while being waited on, <b>Wait</b> returns the error that operation encountered. To obtain a
    ///    complete list of return values for a specific <b>Wait</b>, see the error codes of the method that returned
    ///    the IVssAsync object.
    ///    
    HRESULT Wait(uint dwMilliseconds);
    ///The <b>QueryStatus</b> method queries the status of an asynchronous operation.
    ///Params:
    ///    pHrResult = The status of the asynchronous operation that returned the current IVssAsync object. All calls to
    ///                <b>QueryStatus</b> for all IVssAsync objects support the following status codes. <table> <tr> <th>Value</th>
    ///                <th>Meaning</th> </tr> <tr> <td width="40%"><a id="VSS_S_ASYNC_CANCELLED"></a><a
    ///                id="vss_s_async_cancelled"></a><dl> <dt><b>VSS_S_ASYNC_CANCELLED</b></dt> </dl> </td> <td width="60%"> The
    ///                asynchronous operation was canceled by a previous call to IVssAsync::Cancel. </td> </tr> <tr> <td
    ///                width="40%"><a id="VSS_S_ASYNC_FINISHED"></a><a id="vss_s_async_finished"></a><dl>
    ///                <dt><b>VSS_S_ASYNC_FINISHED</b></dt> </dl> </td> <td width="60%"> The asynchronous operation was completed
    ///                successfully. </td> </tr> <tr> <td width="40%"><a id="VSS_S_ASYNC_PENDING"></a><a
    ///                id="vss_s_async_pending"></a><dl> <dt><b>VSS_S_ASYNC_PENDING</b></dt> </dl> </td> <td width="60%"> The
    ///                asynchronous operation is still running. </td> </tr> </table> Additional return values can be returned, but
    ///                depend on the return codes of the method that initially returned the IVssAsync object.
    ///    pReserved = The value of this parameter should be <b>NULL</b>.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The query operation was
    ///    successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The query operation failed because the user did not have the correct privileges. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The pointer to the
    ///    variable used to hold the <i>pHrResult</i> return value is <b>NULL</b> or is not a valid memory location.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr>
    ///    </table>
    ///    
    HRESULT QueryStatus(HRESULT* pHrResult, int* pReserved);
}

///The <b>IVssWMFiledesc</b> interface is a C++ (not COM) interface returned to a calling application by a number of
///query methods. It provides detailed information about a file or set of files (a file set). The calling application is
///responsible for calling IUnknown::Release to release the resources held by the returned <b>IVssWMFiledesc</b>
///interface when it is no longer needed. The following methods return an <b>IVssWMFiledesc</b> interface: <ul> <li>
///IVssComponent::GetAlternateLocationMapping </li> <li> IVssComponent::GetNewTarget </li> <li>
///IVssExamineWriterMetadata::GetExcludeFile </li> <li> IVssExamineWriterMetadata::GetAlternateLocationMapping </li>
///<li> IVssWMComponent::GetFile </li> <li> IVssWMComponent::GetDatabaseFile </li> <li>
///IVssWMComponent::GetDatabaseLogFile </li> </ul>
interface IVssWMFiledesc : IUnknown
{
    ///The <b>GetPath</b> method obtains the fully qualified directory path or the UNC path of the remote file share to
    ///obtain the list of files described in the current IVssWMFiledesc object. A querying method used this path and a
    ///file specification to return the current IVssWMFiledesc object.
    ///Params:
    ///    pbstrPath = The address of a caller-allocated variable that receives a <b>NULL</b>-terminated wide character string
    ///                specifying the fully qualified directory path or the UNC path of the remote file share directory. The path
    ///                can be a long or short file name and can use the prefix "\\?\". For more information, see Naming a File.
    ///                Users of this method need to check to determine whether this path ends with a backslash ("\").
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the path
    ///    information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> Unexpected error. The error code is logged in the error log file. For more
    ///    information, see Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server
    ///    2003 and Windows XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED
    ///    is used instead. </td> </tr> </table>
    ///    
    HRESULT GetPath(BSTR* pbstrPath);
    ///The <b>GetFilespec</b> method returns the file specification used to obtain the list of files that the current
    ///IVssWMFiledesc object is a member of. A querying method used a path and this file specification to return the
    ///current IVssWMFiledesc object.
    ///Params:
    ///    pbstrFilespec = The address of a caller-allocated variable that receives a string specifying the returned file specification.
    ///                    A file specification cannot contain directory specifications (for example, no backslashes) but can contain
    ///                    the ? and * wildcard characters.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    filespec information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> Unexpected error. The error code is logged in the error log file. For more
    ///    information, see Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server
    ///    2003 and Windows XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED
    ///    is used instead. </td> </tr> </table>
    ///    
    HRESULT GetFilespec(BSTR* pbstrFilespec);
    ///The <b>GetRecursive</b> method indicates whether the list of files described in a IVssWMFiledesc object with a
    ///root directory returned by IVssWMFiledesc::GetPath contains only files in that directory or whether the file list
    ///contains files from the directory hierarchy as well.
    ///Params:
    ///    pbRecursive = A pointer to a Boolean value specifying whether the value returned by IVssWMFiledesc::GetPath identifies only
    ///                  a single directory or if it indicates a hierarchy of directories to be traversed recursively. The Boolean
    ///                  value receives <b>true</b> if the path is treated as a hierarchy of directories to be traversed recursively,
    ///                  or <b>false</b> if not. For information on traversing over mounted folders, see Working with Mounted Folders
    ///                  and Reparse Points.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    recursive information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetRecursive(bool* pbRecursive);
    ///The <b>GetAlternateLocation</b> method obtains an alternate location for a file set.
    ///Params:
    ///    pbstrAlternateLocation = The address of a caller-allocated variable that receives a string specifying the alternate backup location.
    ///                             The path of this location can be a local path or the UNC path of a remote file share. If there is no
    ///                             alternate location, the pointer is <b>NULL</b>.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    alternate location information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td>
    ///    <td width="60%"> The requested information could not be found. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error
    ///    code is logged in the error log file. For more information, see Event and Error Handling Under VSS.
    ///    <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported
    ///    until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT GetAlternateLocation(BSTR* pbstrAlternateLocation);
    ///The <b>GetBackupTypeMask</b> method returns the file backup specification for the files specified by the current
    ///file descriptor as a bit mask (or bitwise OR) of VSS_FILE_SPEC_BACKUP_TYPE values. This information indicates if
    ///the files are to be evaluated by their writer for participation in various specific types of backup operations
    ///(or if they will participate in an incremental or differential backups).
    ///Params:
    ///    pdwTypeMask = Pointer to a <b>DWORD</b> containing a bit mask (or bitwise OR) of VSS_FILE_SPEC_BACKUP_TYPE values
    ///                  indicating the file backup specification for the file or file set described by the current IVssWMFiledesc
    ///                  interface.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    filespec information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> The <i>pdwTypeMask</i> variable points to a <b>NULL</b> region of memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or
    ///    other system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt>
    ///    </dl> </td> <td width="60%"> The XML document is not valid. Check the event log for details. For more
    ///    information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error code is logged in
    ///    the error log file. For more information, see Event and Error Handling Under VSS. <b>Windows Server 2008,
    ///    Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008
    ///    R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT GetBackupTypeMask(uint* pdwTypeMask);
}

///The <b>IVssWMDependency</b> is a C++ (not COM) interface returned by the IVssWMComponent interface and used by
///applications when backing up or restoring a component that has an explicit writer-component dependency on a component
///managed by another writer. (Dependencies must be between writers, not within writers.) <b>IVssWMDependency</b> is
///used to determine the writer ID, logical path, and component name of components that must be restored or backed up
///along with the target component. Dependencies are created by writers while handling Identify events
///(CVssWriter::OnIdentify) using the IVssCreateWriterMetadata::AddComponentDependency method. Calling applications are
///responsible for calling IUnknown::Release to release resources held by a returned <b>IVssWMDependency</b> object when
///it is no longer needed. The IVssWMComponent::GetDependency method returns an <b>IVssWMDependency</b> interface. Note
///that a dependency does not indicate an order of preference between the component with the documented dependencies and
///the components it depends on. A dependency merely indicates that the component and the components it depends on must
///always be backed up or restored together.
interface IVssWMDependency : IUnknown
{
    ///The <b>GetWriterId</b> method retrieves the class ID of a writer containing a component that the current
    ///component depends on in an explicit writer-component dependency.
    ///Params:
    ///    pWriterId = The class ID of a writer that manages a component on which the current component depends.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the class ID of the
    ///    writer managing the component that the current component depends on. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No writer can be found that manages the component that
    ///    the current component depends on. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The pointer <i>pWriterId</i> points to unallocated memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or
    ///    other system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt>
    ///    </dl> </td> <td width="60%"> The XML document is not valid. Check the event log for details. For more
    ///    information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error code is logged in
    ///    the error log file. For more information, see Event and Error Handling Under VSS. <b>Windows Server 2008,
    ///    Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008
    ///    R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT GetWriterId(GUID* pWriterId);
    ///The <b>GetLogicalPath</b> method retrieves the logical path of a component that the current component depends on
    ///in explicit writer-component dependency.
    ///Params:
    ///    pbstrLogicalPath = The address of a caller-allocated variable that receives a <b>NULL</b>-terminated wide character string
    ///                       containing the logical path of the component that the current component depends on.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the logical path of
    ///    the component that the current component depends on. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No writer can be found that manages the component that
    ///    the current component depends on. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The pointer <i>pbstrLogicalPath</i> points to unallocated memory. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or
    ///    other system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt>
    ///    </dl> </td> <td width="60%"> The XML document is not valid. Check the event log for details. For more
    ///    information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error code is logged in
    ///    the error log file. For more information, see Event and Error Handling Under VSS. <b>Windows Server 2008,
    ///    Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008
    ///    R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT GetLogicalPath(BSTR* pbstrLogicalPath);
    ///The <b>GetComponentName</b> method retrieves the name of a component that the current component depends on in an
    ///explicit writer-component dependency.
    ///Params:
    ///    pbstrComponentName = The address of a caller-allocated variable that receives a <b>NULL</b>-terminated wide character string
    ///                         containing the name of the component that the current component depends on.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the name of the
    ///    component that the current component depends on. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%"> No writer can be found that manages the component that
    ///    the current component depends on. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> The pointer <i>pbstrComponentName</i> points to unallocated memory. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory
    ///    or other system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt>
    ///    </dl> </td> <td width="60%"> The XML document is not valid. Check the event log for details. For more
    ///    information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error code is logged in
    ///    the error log file. For more information, see Event and Error Handling Under VSS. <b>Windows Server 2008,
    ///    Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008
    ///    R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT GetComponentName(BSTR* pbstrComponentName);
}

///The <b>IVssComponent</b> interface is a C++ (not COM) interface containing methods for examining and modifying
///information about components contained in a requester's Backup Components Document. <b>IVssComponent</b> objects can
///be obtained only for those components that have been explicitly added to the Backup Components Document during a
///backup operation by the IVssBackupComponents::AddComponent method. Information about components explicitly added
///during a restore operation using IVssBackupComponents::AddRestoreSubcomponent are not available through the
///<b>IVssComponent</b> interface. Some information common to both components and implicitly selected subcomponents
///available through <b>IVssComponent</b> objects includes the following: <ul> <li>Backup time stamp</li>
///<li>Pre-/post-restore Failure Messages</li> <li>Restore metadata</li> <li>Restore target</li> </ul>Some information
///in the <b>IVssComponent</b> object is on a per-file basis and can refer to files managed either by explicitly
///selected components or by implicitly selected subcomponents: <ul> <li>Alternate location mappings</li> <li>Partial
///files</li> <li>Directed target</li> </ul>Other information is not included in the Backup Components Document and can
///be inferred using the <b>IVssComponent</b> object in conjunction with the appropriate Writer Metadata Documents based
///on a writer's component hierarchy expressed in the logical paths (see <a
///href="/windows/desktop/VSS/working-with-selectability-and-logical-paths">Working with Selectability and Logical
///Paths</a>). The interface can be used by either a writer or a requester, although certain methods are supported only
///for writers. In this way, a writer can request changes in a backup or restore operation, such as adding a new target,
///or learn of requester actions, such as the use of an alternate location. The following methods return an
///<b>IVssComponent</b> interface: <ul> <li> IVssWriterComponents::GetComponent </li> <li>
///IVssWriterComponentsExt::GetComponent </li> </ul>
@GUID("D2C72C96-C121-4518-B627-E5A93D010EAD")
interface IVssComponent : IUnknown
{
    ///The <b>GetLogicalPath</b> method returns the logical path of this component. Either a writer or a requester can
    ///call this method.
    ///Params:
    ///    pbstrPath = Pointer to a string containing the logical path of the component.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    This component has no logical path. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl>
    ///    </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetLogicalPath(BSTR* pbstrPath);
    ///The <b>GetComponentType</b> method returns the type of this component in terms of the VSS_COMPONENT_TYPE
    ///enumeration. Either a writer or a requester can call this method.
    ///Params:
    ///    pct = The address of a caller-allocated variable that receives a VSS_COMPONENT_TYPE enumeration value that
    ///          specifies the type of the component.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetComponentType(VSS_COMPONENT_TYPE* pct);
    ///The <b>GetComponentName</b> method returns the logical name of this component. Either a writer or a requester can
    ///call this method.
    ///Params:
    ///    pbstrName = Pointer to a string containing the logical name of the component.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    This component has no name. This state should never occur. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetComponentName(BSTR* pbstrName);
    ///The <b>GetBackupSucceeded</b> method returns the status of a complete attempt at backing up all the files of a
    ///selected component or component set as a VSS_FILE_RESTORE_STATUS enumeration. (See Working with Selectability and
    ///Logical Paths for information on selecting components.) Either a writer or a requester can call this method.
    ///Params:
    ///    pbSucceeded = The address of a caller-allocated variable that receives <b>true</b> if the backup was successful, or
    ///                  <b>false</b> otherwise.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The backup success state is undefined because the method was called prior to a BackupComplete event. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetBackupSucceeded(bool* pbSucceeded);
    ///The <b>GetAlternateLocationMappingCount</b> method returns the number of alternate location mappings used by a
    ///requester in restoring data. Either a writer or a requester can call this method.
    ///Params:
    ///    pcMappings = The address of a caller-allocated variable that receives the number of alternate location mappings.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> </table>
    ///    
    HRESULT GetAlternateLocationMappingCount(uint* pcMappings);
    ///The <b>GetAlternateLocationMapping</b> is used to return a file set's alternate location for file restoration.
    ///This method can be called by either a writer or a requester.
    ///Params:
    ///    iMapping = Index of a particular mapping. The value of this parameter is an integer from 0 to <i>n</i>–1 inclusive,
    ///               where <i>n</i> is the total number of alternate location mappings associated with the current component. The
    ///               value of <i>n</i> is returned by IVssComponent::GetAlternateLocationMappingCount.
    ///    ppFiledesc = Doubly indirect pointer to a IVssWMFiledesc object containing the mapping information.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt>
    ///    </dl> </td> <td width="60%"> The specified item was not found. </td> </tr> </table>
    ///    
    HRESULT GetAlternateLocationMapping(uint iMapping, IVssWMFiledesc* ppFiledesc);
    ///The <b>SetBackupMetadata</b> method sets backup metadata with the component. A writer can call this method only
    ///during a backup operation. This method cannot be called while handling a BackupComplete
    ///(CVssWriter::OnBackupComplete) or BackupShutdown (CVssWriter::OnBackupShutdown) event.
    ///Params:
    ///    wszData = A <b>NULL</b>-terminated wide character string that contains the backup metadata.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the item. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_OBJECT_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> Private metadata
    ///    has already been written for this component. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> This method was not called by a writer or, if
    ///    called by a writer, it either was not called during a backup operation or was called while handling a
    ///    BackupComplete or BackupShutdown event. </td> </tr> </table>
    ///    
    HRESULT SetBackupMetadata(const(PWSTR) wszData);
    ///The <b>GetBackupMetadata</b> method retrieves private, writer-specific backup metadata that might have been set
    ///during a PrepareForBackup event by CVssWriter::OnPrepareBackup using IVssComponent::SetBackupMetadata. Only a
    ///writer can call this method.
    ///Params:
    ///    pbstrData = The address of a caller-allocated variable that receives a string containing the backup metadata that was
    ///                added during an OnPrepareBackup event.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    There is no backup metadata associated with this component. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetBackupMetadata(BSTR* pbstrData);
    ///The <b>AddPartialFile</b> method indicates that only portions of a given file are to be backed up and which
    ///portions those are. Only a writer can call this method, and only during a backup operation.
    ///Params:
    ///    wszPath = <b>Null</b>-terminated wide character string containing the path of the file involved in partial file
    ///              operations. The path can contain environment variables (for example, %SystemRoot%) but cannot contain
    ///              wildcard characters. There is no requirement that the path end with a backslash ("\"). It is up to
    ///              applications that retrieve this information to check. This path should match or be beneath the path of a file
    ///              set already in the component (or one of its subcomponents if the component defines a component set).
    ///    wszFilename = <b>Null</b>-terminated wide character string containing the name of the file involved in partial file
    ///                  operations. The name of the file (<i>wszFilename</i>) cannot contain wildcard characters (* or ?) and must be
    ///                  consistent with the file specification of a file set containing the source path (<i>wszPath</i>).
    ///    wszRanges = <b>Null</b>-terminated wide character string containing either a listing of file offsets and lengths that
    ///                make up the partial file support range (the sections of the file to actually be backed up), or the name of a
    ///                file containing such a list. Specifying the partial file support range is required, and this value cannot be
    ///                <b>NULL</b>.
    ///    wszMetadata = <b>Null</b>-terminated wide character string containing any additional metadata required by a writer to
    ///                  validate a partial file restore operation. The information in this metadata string will be opaque to
    ///                  requesters. If additional metadata is not required, this value can be <b>NULL</b>.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the item. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> The method was not called by a
    ///    writer or, if called by a writer, was not called during a restore operation. </td> </tr> </table>
    ///    
    HRESULT AddPartialFile(const(PWSTR) wszPath, const(PWSTR) wszFilename, const(PWSTR) wszRanges, 
                           const(PWSTR) wszMetadata);
    ///The <b>GetPartialFileCount</b> method returns the number of partial files associated with a component.
    ///Params:
    ///    pcPartialFiles = The address of a caller-allocated variable that receives the number of partial files.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> </table>
    ///    
    HRESULT GetPartialFileCount(uint* pcPartialFiles);
    ///The <b>GetPartialFile</b> method returns information on a partial file associated with this component.
    ///Params:
    ///    iPartialFile = Index number of the partial file. The value of this parameter is an integer from 0 to <i>n</i>–1 inclusive,
    ///                   where <i>n</i> is the total number of partial files associated with a given component. The value of <i>n</i>
    ///                   is returned by IVssComponent::GetPartialFileCount.
    ///    pbstrPath = Pointer to a string containing the path of the partial file. Users of this method need to check to determine
    ///                whether this path ends with a backslash ("\").
    ///    pbstrFilename = Pointer to a string containing the name of the partial file.
    ///    pbstrRange = A pointer to a string containing either a listing of file offsets and lengths that make up the partial file
    ///                 support range (the sections of the file that were backed up), or the name of a file containing such a list.
    ///    pbstrMetadata = Pointer to a string containing any additional metadata required by a writer to validate a partial file
    ///                    restore operation. The information in this metadata string will be opaque to requesters. Additional metadata
    ///                    is not required, so <i>pbstrMetadata</i> may also be empty (zero length).
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is not in the correct state (either backup or restore) for the operation. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML
    ///    document is not valid. Check the event log for details. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td
    ///    width="60%"> The specified item was not found. </td> </tr> </table>
    ///    
    HRESULT GetPartialFile(uint iPartialFile, BSTR* pbstrPath, BSTR* pbstrFilename, BSTR* pbstrRange, 
                           BSTR* pbstrMetadata);
    ///The <b>IsSelectedForRestore</b> method determines whether the current component has been selected to be restored.
    ///Either a writer or a requester can call this method.
    ///Params:
    ///    pbSelectedForRestore = The address of a caller-allocated variable that receives <b>true</b> if the component has been selected to be
    ///                           restored, or <b>false</b> otherwise.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the item. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> The caller is not in the
    ///    correct state (either backup or restore) for the operation. </td> </tr> </table>
    ///    
    HRESULT IsSelectedForRestore(bool* pbSelectedForRestore);
    ///The <b>GetAdditionalRestores</b> method is used by a writer during incremental or differential restore operations
    ///to determine whether a given component will require additional restore operations to completely retrieve it.
    ///Either a writer or a requester can call this method.
    ///Params:
    ///    pbAdditionalRestores = The address of a caller-allocated variable that receives <b>true</b> if additional restores will occur for
    ///                           the current component, or <b>false</b> otherwise.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The specified attribute does not have a value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetAdditionalRestores(bool* pbAdditionalRestores);
    ///The <b>GetNewTargetCount</b> method returns the number of new target restore locations associated with a given
    ///component. Either a writer or a requester can call this method.
    ///Params:
    ///    pcNewTarget = The address of a caller-allocated variable that receives the number of new target restore locations.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> </table>
    ///    
    HRESULT GetNewTargetCount(uint* pcNewTarget);
    ///The <b>GetNewTarget</b> method returns the new file restoration locations for the selected component or component
    ///set. (See Working with Selectability and Logical Paths for information on selecting components.) Either a writer
    ///or a requester can call this method.
    ///Params:
    ///    iNewTarget = Index number of the new target. The value of this parameter is an integer from 0 to <i>n</i>–1 inclusive,
    ///                 where <i>n</i> is the total number of new targets associated with a given component. The value of <i>n</i> is
    ///                 returned by IVssComponent::GetNewTargetCount.
    ///    ppFiledesc = Doubly indirect pointer to an IVssWMFiledesc object containing the new target restore location information.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt>
    ///    </dl> </td> <td width="60%"> The specified item was not found. </td> </tr> </table>
    ///    
    HRESULT GetNewTarget(uint iNewTarget, IVssWMFiledesc* ppFiledesc);
    ///The <b>AddDirectedTarget</b> method allows a writer to indicate at restore time that when a file is to be
    ///restored, it (the source file) should be remapped. The file can be restored to a new restore location and/or
    ///ranges of its data restored to different offsets within the restore location. This method can be called by a
    ///writer only during a restore operation. This method cannot be called while handling a BackupComplete
    ///(CVssWriter::OnBackupComplete) or BackupShutdown (CVssWriter::OnBackupShutdown) event.
    ///Params:
    ///    wszSourcePath = Null-terminated wide character string containing the path to the directory at restore time containing the
    ///                    file to be restored (the source file). This path should match or be beneath the path of a file set already in
    ///                    the component (or one of its subcomponents if the component defines a component set).
    ///    wszSourceFilename = Null-terminated wide character string containing the name of the file (at backup time) that will be remapped
    ///                        at restore time (the source file). The name of the file (<i>wszSourceFilename</i>) cannot contain wildcard
    ///                        characters (* or ?) and must be consistent with the file specification of a file set containing the source
    ///                        path (<i>wszSourcePath</i>).
    ///    wszSourceRangeList = A null-terminated wide character string containing a comma-separated list of file offsets and lengths
    ///                         indicating the source file support range (the sections of the file to actually be restored). The number and
    ///                         length of the source file support ranges must match the number and size of destination file support ranges.
    ///    wszDestinationPath = Null-terminated wide character string containing the path to which source file data will be remapped at
    ///                         restore time.
    ///    wszDestinationFilename = Null-terminated wide character string containing the name of the file to which source file data will be
    ///                             remapped at restore time. The name of the file (<i>wszDestinationFilename</i>) cannot contain wildcard
    ///                             characters (* or ?).
    ///    wszDestinationRangeList = A null-terminated wide character string containing a comma-separated list of file offsets and lengths
    ///                              indicating the destination file support range (locations to which the sections of the source file are to be
    ///                              restored). The number and length of the destination file support ranges must match the number and size of
    ///                              source file support ranges.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the item. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> This method was not called by
    ///    a writer or, if called by a writer, it either was not called during a restore operation or was called while
    ///    handling a BackupComplete or BackupShutdown event. </td> </tr> </table>
    ///    
    HRESULT AddDirectedTarget(const(PWSTR) wszSourcePath, const(PWSTR) wszSourceFilename, 
                              const(PWSTR) wszSourceRangeList, const(PWSTR) wszDestinationPath, 
                              const(PWSTR) wszDestinationFilename, const(PWSTR) wszDestinationRangeList);
    ///The <b>GetDirectedTargetCount</b> method returns the number of directed target specifications associated with the
    ///current component. Either a writer or a requester can call this method.
    ///Params:
    ///    pcDirectedTarget = The address of a caller-allocated variable that receives the number of directed target specifications.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> </table>
    ///    
    HRESULT GetDirectedTargetCount(uint* pcDirectedTarget);
    ///The <b>GetDirectedTarget</b> method returns information stored by a writer, at backup time, to the Backup
    ///Components Document to indicate that when a file is to be restored, it (the source file) should be remapped. The
    ///file may be restored to a new restore target and/or ranges of its data restored to different locations with the
    ///restore target. Either a writer or a requester can call this method.
    ///Params:
    ///    iDirectedTarget = Index number of the directed target. The value of this parameter is an integer from 0 to <i>n</i>–1
    ///                      inclusive, where <i>n</i> is the total number of directed targets associated with a given component (and its
    ///                      subcomponents if it defines a component set). The value of <i>n</i> is returned by
    ///                      IVssComponent::GetDirectedTargetCount.
    ///    pbstrSourcePath = The address of a caller-allocated variable that receives a string containing the path to the directory that
    ///                      at backup time contained the file to be restored (the source file). This path should match or be beneath the
    ///                      path of a file set already in the component or one of its subcomponents (if the component defines a component
    ///                      set).
    ///    pbstrSourceFileName = The address of a caller-allocated variable that receives a string containing the name of the file (at backup
    ///                          time) that is to be remapped during a restore (the source file). The name of this file should not contain any
    ///                          wildcard characters, and must be a member of the same file set as the source path (<i>pbstrSourcePath</i>).
    ///    pbstrSourceRangeList = The address of a caller-allocated variable that receives a string containing a comma-separated list of file
    ///                           offsets and lengths indicating the source file support range (the sections of the file to be restored). The
    ///                           number and length of the source file support ranges must match the number and size of destination file
    ///                           support ranges.
    ///    pbstrDestinationPath = The address of a caller-allocated variable that receives a string containing the path to which source file
    ///                           data will be remapped at restore time.
    ///    pbstrDestinationFilename = The address of a caller-allocated variable that receives a string containing the name of the file to which
    ///                               source file data will be remapped at restore time.
    ///    pbstrDestinationRangeList = The address of a caller-allocated variable that receives a string containing a comma-separated list of file
    ///                                offsets and lengths indicating the destination file support range (locations to which the sections of the
    ///                                source file are to be restored). The number and length of the destination file support ranges must match the
    ///                                number and size of source file support ranges.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt>
    ///    </dl> </td> <td width="60%"> The specified item was not found. </td> </tr> </table>
    ///    
    HRESULT GetDirectedTarget(uint iDirectedTarget, BSTR* pbstrSourcePath, BSTR* pbstrSourceFileName, 
                              BSTR* pbstrSourceRangeList, BSTR* pbstrDestinationPath, BSTR* pbstrDestinationFilename, 
                              BSTR* pbstrDestinationRangeList);
    ///The <b>SetRestoreMetadata</b> method sets writer-specific metadata for the current component. Only a writer can
    ///call this method, and only in the context of implementing CVssWriter::OnPreRestore.
    ///Params:
    ///    wszRestoreMetadata = A caller-allocated <b>NULL</b>-terminated wide character string containing the restore metadata for the
    ///                         component.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the item. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_OBJECT_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> Private metadata
    ///    has already been written for this component. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> The method was called outside of the context of
    ///    a writer handling a PreRestore event. </td> </tr> </table>
    ///    
    HRESULT SetRestoreMetadata(const(PWSTR) wszRestoreMetadata);
    ///The <b>GetRestoreMetadata</b> method retrieves private, writer-specific restore metadata that might have been set
    ///during a PreRestore event by CVssWriter::OnPreRestore using IVssComponent::SetRestoreMetadata. Only a writer can
    ///call this method.
    ///Params:
    ///    pbstrRestoreMetadata = A string containing the restore metadata.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    The specified attribute does not have a value. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetRestoreMetadata(BSTR* pbstrRestoreMetadata);
    ///The <b>SetRestoreTarget</b> method sets the restore target (in terms of the VSS_RESTORE_TARGET enumeration) for
    ///the current component. Only a writer can call this method, and only during a restore operation.
    ///Params:
    ///    target = A value from VSS_RESTORE_TARGET containing the restore target information.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the item. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> The caller is not in the
    ///    correct state (either backup or restore) for the operation. </td> </tr> </table>
    ///    
    HRESULT SetRestoreTarget(VSS_RESTORE_TARGET target);
    ///The <b>GetRestoreTarget</b> method returns the restore target (in terms of the VSS_RESTORE_TARGET enumeration)
    ///for the current component. Either a writer or a requester can call this method. It can be called only during a
    ///restore operation.
    ///Params:
    ///    pTarget = The address of a caller-allocated variable that receives a VSS_RESTORE_TARGET enumeration value that
    ///              specifies the restore target.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt>
    ///    </dl> </td> <td width="60%"> The specified item was not found. </td> </tr> </table>
    ///    
    HRESULT GetRestoreTarget(VSS_RESTORE_TARGET* pTarget);
    ///The <b>SetPreRestoreFailureMsg</b> method is used to create a message describing a failure in processing a
    ///PreRestore event. Only a writer can call this method, and only during a restore operation.
    ///Params:
    ///    wszPreRestoreFailureMsg = A caller-allocated <b>NULL</b>-terminated wide character string containing the failure message describing an
    ///                              error that occurred while processing a PreRestore event.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the failure
    ///    message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One
    ///    of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> The caller is not in the
    ///    correct state (either backup or restore) for the operation. </td> </tr> </table>
    ///    
    HRESULT SetPreRestoreFailureMsg(const(PWSTR) wszPreRestoreFailureMsg);
    ///The <b>GetPreRestoreFailureMsg</b> method retrieves the error message generated by a writer while handling the
    ///PreRestore event, if IVssComponent::SetPreRestoreFailureMsg set one. Either a writer or a requester can call this
    ///method.
    ///Params:
    ///    pbstrPreRestoreFailureMsg = String containing the failure message that describes an error that occurred while processing the PreRestore
    ///                                event.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    No PreRestore failure message was available to retrieve. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetPreRestoreFailureMsg(BSTR* pbstrPreRestoreFailureMsg);
    ///The <b>SetPostRestoreFailureMsg</b> method is used to create a message describing a failure in processing a
    ///PostRestore event. Only a writer can call this method, and only during a restore operation.
    ///Params:
    ///    wszPostRestoreFailureMsg = A caller-allocated <b>NULL</b>-terminated wide character string containing the failure message that describes
    ///                               an error that occurred while processing a PostRestore event.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the failure
    ///    message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One
    ///    of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> The caller is not in the
    ///    correct state (either backup or restore) for the operation. </td> </tr> </table>
    ///    
    HRESULT SetPostRestoreFailureMsg(const(PWSTR) wszPostRestoreFailureMsg);
    ///The <b>GetPostRestoreFailureMsg</b> method returns the failure message generated by a writer while handling the
    ///PostRestore event, if IVssComponent::SetPostRestoreFailureMsg set one. Either a writer or a requester can call
    ///this method.
    ///Params:
    ///    pbstrPostRestoreFailureMsg = Pointer to a string containing the failure message that describes an error that occurred while processing the
    ///                                 PostRestore event.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    No PostRestoreFailure message was available to retrieve. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetPostRestoreFailureMsg(BSTR* pbstrPostRestoreFailureMsg);
    ///The <b>SetBackupStamp</b> method sets a string containing information indicating when a backup took place. A
    ///writer can call this method only during a backup operation. This method cannot be called while handling a
    ///BackupComplete (CVssWriter::OnBackupComplete) or BackupShutdown (CVssWriter::OnBackupShutdown) event.
    ///Params:
    ///    wszBackupStamp = Null-terminated wide character string information indicating when a backup took place.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the backup time
    ///    stamp. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One
    ///    of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> This method was not called by
    ///    a writer or, if called by a writer, it either was not called during a backup operation or was called while
    ///    handling a BackupComplete or BackupShutdown event. </td> </tr> </table>
    ///    
    HRESULT SetBackupStamp(const(PWSTR) wszBackupStamp);
    ///The <b>GetBackupStamp</b> method returns the backup stamp string stored by a writer for a given component. Either
    ///a writer or a requester can call this method.
    ///Params:
    ///    pbstrBackupStamp = The address of a caller-allocated variable that receives a string containing the backup stamp indicating the
    ///                       time at which the component was backed up.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    There is no time stamp associated with this component. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetBackupStamp(BSTR* pbstrBackupStamp);
    ///The <b>GetPreviousBackupStamp</b> method returns a previous backup stamp loaded by a requester in the Backup
    ///Components Document. The value is used by a writer when deciding if files should participate in differential or
    ///incremental backup operation. Either a writer or a requester can call this method.
    ///Params:
    ///    pbstrBackupStamp = Pointer to a string containing the time stamp of a previous backup so that a differential or incremental
    ///                       backup can be correctly implemented.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    No previous backup time stamp has been set. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetPreviousBackupStamp(BSTR* pbstrBackupStamp);
    ///The <b>GetBackupOptions</b> method returns the backup options specified to the writer that manages the currently
    ///selected component or component set by a requester using IVssBackupComponents::SetBackupOptions. Either a writer
    ///or a requester can call this method.
    ///Params:
    ///    pbstrBackupOptions = The address of a caller-allocated variable that receives a string containing the backup options for the
    ///                         current writer.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    No backup options have been specified for this component. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out
    ///    of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetBackupOptions(BSTR* pbstrBackupOptions);
    ///The <b>GetRestoreOptions</b> method gets the restore options specified to the current writer by a requester using
    ///IVssBackupComponents::SetRestoreOptions. Either a writer or a requester can call this method.
    ///Params:
    ///    pbstrRestoreOptions = String containing the restore options of the writer.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td width="60%">
    ///    No restore options have been specified. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetRestoreOptions(BSTR* pbstrRestoreOptions);
    ///The <b>GetRestoreSubcomponentCount</b> method returns the number of subcomponents associated with a component.
    ///Either a writer or a requester can call this method.
    ///Params:
    ///    pcRestoreSubcomponent = The address of a caller-allocated variable that receives the number of subcomponents that are associated with
    ///                            a component.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> </table>
    ///    
    HRESULT GetRestoreSubcomponentCount(uint* pcRestoreSubcomponent);
    ///The <b>GetRestoreSubcomponent</b> method returns the specified subcomponent associated with a given component.
    ///Either a writer or a requester can call this method.
    ///Params:
    ///    iComponent = Index of the subcomponent. The value of this parameter is an integer from 0 to <i>n</i>–1 inclusive, where
    ///                 <i>n</i> is the total number of subcomponents associated with a given component. The value of <i>n</i> is
    ///                 returned by IVssComponent::GetRestoreSubcomponentCount.
    ///    pbstrLogicalPath = Pointer to a string containing the logical path of the subcomponent. The logical path cannot be empty when
    ///                       working with subcomponents.
    ///    pbstrComponentName = Pointer to a string containing the name of the subcomponent. The string cannot be empty.
    ///    pbRepair = Reserved for future use.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt>
    ///    </dl> </td> <td width="60%"> The specified item was not found. </td> </tr> </table>
    ///    
    HRESULT GetRestoreSubcomponent(uint iComponent, BSTR* pbstrLogicalPath, BSTR* pbstrComponentName, 
                                   bool* pbRepair);
    ///The <b>GetFileRestoreStatus</b> method returns the status of a completed attempt to restore all the files of a
    ///selected component or component set as a VSS_FILE_RESTORE_STATUS enumeration. (See Working with Selectability and
    ///Logical Paths for information on selecting components.) Either a writer or a requester can call this method.
    ///Params:
    ///    pStatus = The address of a caller-allocated variable that receives a VSS_FILE_RESTORE_STATUS enumeration value that
    ///              specifies whether all files were successfully restored.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td
    ///    width="60%"> The method was not called as part of a restore operation. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetFileRestoreStatus(VSS_FILE_RESTORE_STATUS* pStatus);
    ///The <b>AddDifferencedFilesByLastModifyTime</b> method is used by a writer to indicate that a file set (a
    ///specified file or files) should be evaluated against a last modification time stamp for inclusion in a time
    ///stamped incremental or differential backup using entire files, not partial files. This method can be called by a
    ///writer only during a backup operation.
    ///Params:
    ///    wszPath = Null-terminated wide character string containing the name of the directory or directory hierarchy containing
    ///              the files to be mapped. The path can contain environment variables (for example, %SystemRoot%) but cannot
    ///              contain wildcard characters. There is no requirement that the path end with a backslash ("\"). It is up to
    ///              applications that retrieve this information to check.
    ///    wszFilespec = Null-terminated wide character string containing the file specification of the files to be mapped. A file
    ///                  specification cannot contain directory specifications (for example, no backslashes) but can contain the ? and
    ///                  * wildcard characters.
    ///    bRecursive = A Boolean value specifying whether the path specified by the <i>wszPath</i> parameter identifies only a
    ///                 single directory or if it indicates a hierarchy of directories to be traversed recursively. This parameter
    ///                 should be set to <b>true</b> if the path is treated as a hierarchy of directories to be traversed
    ///                 recursively, or <b>false</b> if not. For information on traversing mounted folders, see Working with Mounted
    ///                 Folders and Reparse Points.
    ///    ftLastModifyTime = The writer specification of the time of last modification for the difference files, expressed as a FILETIME
    ///                       structure. The last-modify time is always given in Greenwich Mean Time.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully added differenced
    ///    files. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One
    ///    of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> This method was not called by
    ///    a writer or, if called by a writer, it either was not called during a backup operation or was called while
    ///    handling a BackupComplete or BackupShutdown event. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error
    ///    code is logged in the error log file. For more information, see Event and Error Handling Under VSS.
    ///    <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported
    ///    until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT AddDifferencedFilesByLastModifyTime(const(PWSTR) wszPath, const(PWSTR) wszFilespec, BOOL bRecursive, 
                                                FILETIME ftLastModifyTime);
    ///Not supported. This method is reserved for system use.
    ///Params:
    ///    wszPath = This parameter is reserved for system use.
    ///    wszFilespec = This parameter is reserved for system use.
    ///    bRecursive = This parameter is reserved for system use.
    ///    bstrLsnString = This parameter is reserved for system use.
    HRESULT AddDifferencedFilesByLastModifyLSN(const(PWSTR) wszPath, const(PWSTR) wszFilespec, BOOL bRecursive, 
                                               BSTR bstrLsnString);
    ///The <b>GetDifferencedFilesCount</b> method returns the number of file specifications in this component (and in
    ///any subcomponents of the component set it defines) marked by a writer supporting an incremental backup or restore
    ///as differenced files—that is, backup and restores associated with it are to be implemented as if entire files
    ///are copied to and from backup media (as opposed to using partial files).
    ///Params:
    ///    pcDifferencedFiles = The address of a caller-allocated variable that receives the number of differenced file specifications.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> </table>
    ///    
    HRESULT GetDifferencedFilesCount(uint* pcDifferencedFiles);
    ///The <b>GetDifferencedFile</b> method returns information about a file set (a specified file or files) to
    ///participate in an incremental or differential backup or restore as a differenced file—that is, backup and
    ///restores associated with it are to be implemented as if entire files are copied to and from backup media (as
    ///opposed to using partial files). This method can be called by a requester or a writer during backup or restore
    ///operations.
    ///Params:
    ///    iDifferencedFile = Index number of the differenced file to be examined. The value of this parameter is an integer from 0 to
    ///                       <i>n</i>–1 inclusive, where <i>n</i> is the total number of differenced files associated with a given
    ///                       component (and its subcomponents if it defines a component set). The value of <i>n</i> is returned by
    ///                       IVssComponent::GetDifferencedFilesCount.
    ///    pbstrPath = The address of a caller-allocated variable that receives a string containing the path to the differenced
    ///                files. Users of this method need to check to determine whether this path ends with a backslash (\\).
    ///    pbstrFilespec = The address of a caller-allocated variable that receives a string containing the file specification of the
    ///                    differenced files.
    ///    pbRecursive = The address of a caller-allocated variable that receives a Boolean specifying whether the file specification
    ///                  for the differenced files should be interpreted recursively. If <b>TRUE</b>, then the entire directory
    ///                  hierarchy will need to be searched for files matching the file specification <i>pbstrFilespec</i> to find
    ///                  files to be handled as differenced files during incremental or differential backups. If <b>FALSE</b>, only
    ///                  the root directory needs to be searched.
    ///    pbstrLsnString = Reserved for future use.
    ///    pftLastModifyTime = The address of a caller-allocated variable that receives the writer specification of the time of last
    ///                        modification for the difference files, expressed as a FILETIME structure.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    attribute value. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td
    ///    width="60%"> No differenced file corresponding to the supplied index was found. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetDifferencedFile(uint iDifferencedFile, BSTR* pbstrPath, BSTR* pbstrFilespec, BOOL* pbRecursive, 
                               BSTR* pbstrLsnString, FILETIME* pftLastModifyTime);
}

///Contains methods used to obtain and modify component information.
interface IVssWriterComponents
{
    ///The <b>GetComponentCount</b> method returns the number of a given writer's components explicitly stored in the
    ///Backup Components Document.
    ///Params:
    ///    pcComponents = Pointer to the number of a writer's components stored in the Backup Components Document.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    component. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> </table>
    ///    
    HRESULT GetComponentCount(uint* pcComponents);
    ///The <b>GetWriterInfo</b> method gets the instance and class identifier of the writer responsible for the
    ///components.
    ///Params:
    ///    pidInstance = Identifier of the writer instance.
    ///    pidWriter = Identifier of the writer class.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    component. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td
    ///    width="60%"> The XML document is not valid. Check the event log for details. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetWriterInfo(GUID* pidInstance, GUID* pidWriter);
    ///The <b>GetComponent</b> method returns an IVssComponent interface to one of a given writer's components
    ///explicitly stored in the Backup Components Document.
    ///Params:
    ///    iComponent = Number of the component. The value of this parameter is an integer from 0 to <i>n</i>–1 inclusive, where
    ///                 <i>n</i> is the total number of components returned by IVssWriterComponents::GetComponentCount.
    ///    ppComponent = Doubly indirect pointer to an instance of the IVssComponent object that contains component information.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully returned the
    ///    component. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%">
    ///    One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td
    ///    width="60%"> The specified component was not found. </td> </tr> </table>
    ///    
    HRESULT GetComponent(uint iComponent, IVssComponent* ppComponent);
}

///Defines additional methods for examining and modifying information about components contained in a requester's Backup
///Components Document. The <b>IVssComponentEx</b> interface is a C++ (not COM) interface. To obtain an instance of the
///<b>IVssComponentEx</b> interface, call the QueryInterface method of the IVssComponent interface, and pass the
///<b>IID_IVssComponentEx</b> constant as the interface identifier (IID) parameter.
@GUID("156C8B5E-F131-4BD7-9C97-D1923BE7E1FA")
interface IVssComponentEx : IVssComponent
{
    ///Sets a PrepareForBackup failure message string for a component. This method can only be called by a writer's
    ///CVssWriter::OnPrepareBackup method.
    ///Params:
    ///    wszFailureMsg = The address of a caller-allocated <b>NULL</b>-terminated wide character string containing the failure message
    ///                    that describes an error that occurred while processing a PrepareForBackup event.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The failure message was
    ///    successfully set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td
    ///    width="60%"> This method was not called by a writer's CVssWriter::OnPrepareBackup method. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetPrepareForBackupFailureMsg(const(PWSTR) wszFailureMsg);
    ///Sets a PostSnapshot failure message string for a component. This method can only be called by a writer's
    ///CVssWriter::OnPostSnapshot method.
    ///Params:
    ///    wszFailureMsg = The address of a caller-allocated <b>NULL</b>-terminated wide character string containing the failure message
    ///                    that describes an error that occurred while processing a PostSnapshot event.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The failure message was
    ///    successfully set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td
    ///    width="60%"> This method was not called by a writer's CVssWriter::OnPostSnapshot method. </td> </tr> </table>
    ///    
    HRESULT SetPostSnapshotFailureMsg(const(PWSTR) wszFailureMsg);
    ///Returns the PrepareForBackup failure message string that a writer has set for a given component. Both writers and
    ///requesters can call this method.
    ///Params:
    ///    pbstrFailureMsg = A pointer to a null-terminated wide character string containing the failure message that describes an error
    ///                      that occurred while processing a PrepareForBackup event.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The failure message was
    ///    successfully obtained. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> No PrepareForBackup failure message was set for the component. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller
    ///    is out of memory or other system resources. </td> </tr> </table>
    ///    
    HRESULT GetPrepareForBackupFailureMsg(BSTR* pbstrFailureMsg);
    ///Returns the PostSnapshot failure message string that a writer has set for a given component. Both writers and
    ///requesters can call this method. Writers should call this method after the IVssBackupComponents::DoSnapshotSet
    ///asynchronous operation has completed.
    ///Params:
    ///    pbstrFailureMsg = A pointer to a null-terminated wide character string containing the failure message that describes an error
    ///                      that occurred while processing a PostSnapshot event.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The failure message was
    ///    successfully obtained. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>S_FALSE</b></dt> </dl> </td> <td
    ///    width="60%"> No PostSnapshot failure message was set for the component. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is not valid.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller
    ///    is out of memory or other system resources. </td> </tr> </table>
    ///    
    HRESULT GetPostSnapshotFailureMsg(BSTR* pbstrFailureMsg);
    ///Determines whether a requester has marked the restore of a component as authoritative for a replicated data
    ///store.
    ///Params:
    ///    pbAuth = The address of a caller-allocated variable that receives <b>true</b> if the restore is authoritative, or
    ///             <b>false</b> otherwise.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> </table>
    ///    
    HRESULT GetAuthoritativeRestore(bool* pbAuth);
    ///Obtains the roll-forward operation type for a component and obtains the restore point for a partial roll-forward
    ///operation.
    ///Params:
    ///    pRollType = A VSS_ROLLFORWARD_TYPE enumeration value indicating the type of roll-forward operation to be performed.
    ///    pbstrPoint = The address of a caller-allocated variable that receives a null-terminated wide character string specifying
    ///                 the roll-forward restore point.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> </table>
    ///    
    HRESULT GetRollForward(VSS_ROLLFORWARD_TYPE* pRollType, BSTR* pbstrPoint);
    ///Obtains the logical name assigned to a component that is being restored.
    ///Params:
    ///    pbstrName = The address of a caller-allocated variable that receives a null-terminated wide character string containing
    ///                the restore name for the component.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> </table>
    ///    
    HRESULT GetRestoreName(BSTR* pbstrName);
}

///Defines additional methods for reporting and retrieving component-level writer errors. The <b>IVssComponentEx2</b>
///interface is a C++ (not COM) interface. To obtain an instance of the <b>IVssComponentEx2</b> interface, call the
///QueryInterface method of the IVssComponent interface and pass the <b>IID_IVssComponentEx2</b> constant as the
///interface identifier (IID) parameter.
@GUID("3B5BE0F2-07A9-4E4B-BDD3-CFDC8E2C0D2D")
interface IVssComponentEx2 : IVssComponentEx
{
    ///VSS writers call this method to report errors at the component level.
    ///Params:
    ///    hr = The error code to be returned to the requester that calls the IVssComponentEx2::GetFailure method. The
    ///         following are the error codes that this method can set. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///         <tr> <td width="40%"><a id="S_OK"></a><a id="s_ok"></a><dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%">
    ///         The writer was successful. </td> </tr> <tr> <td width="40%"><a
    ///         id="VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT"></a><a id="vss_e_writererror_inconsistentsnapshot"></a><dl>
    ///         <dt><b>VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT</b></dt> </dl> </td> <td width="60%"> The shadow copy contains
    ///         only a subset of the volumes needed by the writer to correctly back up the application component. </td> </tr>
    ///         <tr> <td width="40%"><a id="VSS_E_WRITERERROR_OUTOFRESOURCES"></a><a
    ///         id="vss_e_writererror_outofresources"></a><dl> <dt><b>VSS_E_WRITERERROR_OUTOFRESOURCES</b></dt> </dl> </td>
    ///         <td width="60%"> The writer ran out of memory or other system resources. The recommended way to handle this
    ///         error code is to wait ten minutes and then repeat the operation, up to three times. </td> </tr> <tr> <td
    ///         width="40%"><a id="VSS_E_WRITERERROR_TIMEOUT"></a><a id="vss_e_writererror_timeout"></a><dl>
    ///         <dt><b>VSS_E_WRITERERROR_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The writer operation failed because of
    ///         a time-out between the Freeze and Thaw events. The recommended way to handle this error code is to wait ten
    ///         minutes and then repeat the operation, up to three times. </td> </tr> <tr> <td width="40%"><a
    ///         id="VSS_E_WRITERERROR_RETRYABLE"></a><a id="vss_e_writererror_retryable"></a><dl>
    ///         <dt><b>VSS_E_WRITERERROR_RETRYABLE</b></dt> </dl> </td> <td width="60%"> The writer failed due to an error
    ///         that would likely not occur if the entire backup, restore, or shadow copy creation process was restarted. The
    ///         recommended way to handle this error code is to wait ten minutes and then repeat the operation, up to three
    ///         times. </td> </tr> <tr> <td width="40%"><a id="VSS_E_WRITERERROR_NONRETRYABLE"></a><a
    ///         id="vss_e_writererror_nonretryable"></a><dl> <dt><b>VSS_E_WRITERERROR_NONRETRYABLE</b></dt> </dl> </td> <td
    ///         width="60%"> The writer operation failed because of an error that might recur if another shadow copy is
    ///         created. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    hrApplication = An additional error code to be returned to the requester. This parameter is optional.
    ///    wszApplicationMessage = A string containing an error message for the requester to display to the end user. The writer is responsible
    ///                            for localizing this string if necessary before using it in this method. This parameter is optional and can be
    ///                            <b>NULL</b> or an empty string.
    ///    dwReserved = This parameter is reserved for future use and should be set to zero.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT SetFailure(HRESULT hr, HRESULT hrApplication, const(PWSTR) wszApplicationMessage, uint dwReserved);
    ///VSS requesters call this method to retrieve component-level errors reported by writers.
    ///Params:
    ///    phr = The address of a caller-allocated variable that receives the HRESULT failure code that the writer passed for
    ///          the <i>hr</i> parameter of the IVssComponentEx2::SetFailure method. This parameter is required and cannot be
    ///          <b>NULL</b>. The following are the supported values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///          <td width="40%"><a id="S_OK"></a><a id="s_ok"></a><dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The
    ///          writer was successful. </td> </tr> <tr> <td width="40%"><a id="VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT"></a><a
    ///          id="vss_e_writererror_inconsistentsnapshot"></a><dl> <dt><b>VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT</b></dt>
    ///          </dl> </td> <td width="60%"> The shadow copy contains only a subset of the volumes needed by the writer to
    ///          correctly back up the application component. </td> </tr> <tr> <td width="40%"><a
    ///          id="VSS_E_WRITERERROR_OUTOFRESOURCES"></a><a id="vss_e_writererror_outofresources"></a><dl>
    ///          <dt><b>VSS_E_WRITERERROR_OUTOFRESOURCES</b></dt> </dl> </td> <td width="60%"> The writer ran out of memory or
    ///          other system resources. The recommended way to handle this error code is to wait ten minutes and then repeat
    ///          the operation, up to three times. </td> </tr> <tr> <td width="40%"><a id="VSS_E_WRITERERROR_TIMEOUT"></a><a
    ///          id="vss_e_writererror_timeout"></a><dl> <dt><b>VSS_E_WRITERERROR_TIMEOUT</b></dt> </dl> </td> <td
    ///          width="60%"> The writer operation failed because of a time-out between the Freeze and Thaw events. The
    ///          recommended way to handle this error code is to wait ten minutes and then repeat the operation, up to three
    ///          times. </td> </tr> <tr> <td width="40%"><a id="VSS_E_WRITERERROR_RETRYABLE"></a><a
    ///          id="vss_e_writererror_retryable"></a><dl> <dt><b>VSS_E_WRITERERROR_RETRYABLE</b></dt> </dl> </td> <td
    ///          width="60%"> The writer failed due to an error that would likely not occur if the entire backup, restore, or
    ///          shadow copy creation process was restarted. The recommended way to handle this error code is to wait ten
    ///          minutes and then repeat the operation, up to three times. </td> </tr> <tr> <td width="40%"><a
    ///          id="VSS_E_WRITERERROR_NONRETRYABLE"></a><a id="vss_e_writererror_nonretryable"></a><dl>
    ///          <dt><b>VSS_E_WRITERERROR_NONRETRYABLE</b></dt> </dl> </td> <td width="60%"> The writer operation failed
    ///          because of an error that might recur if another shadow copy is created. For more information, see Event and
    ///          Error Handling Under VSS. </td> </tr> <tr> <td width="40%"><a id="VSS_E_WRITER_NOT_RESPONDING"></a><a
    ///          id="vss_e_writer_not_responding"></a><dl> <dt><b>VSS_E_WRITER_NOT_RESPONDING</b></dt> </dl> </td> <td
    ///          width="60%"> The writer is not responding. </td> </tr> <tr> <td width="40%"><a
    ///          id="VSS_E_WRITER_STATUS_NOT_AVAILABLE"></a><a id="vss_e_writer_status_not_available"></a><dl>
    ///          <dt><b>VSS_E_WRITER_STATUS_NOT_AVAILABLE</b></dt> </dl> </td> <td width="60%"> The writer status is not
    ///          available for one or more writers. A writer may have reached the maximum number of available backup and
    ///          restore sessions. </td> </tr> </table>
    ///    phrApplication = The address of a caller-allocated variable that receives the return code that the writer passed for the
    ///                     <i>hrApplication</i> parameter of the SetFailure method. This parameter is required and cannot be
    ///                     <b>NULL</b>.
    ///    pbstrApplicationMessage = The address of a caller-allocated variable that receives the application failure message that the writer
    ///                              passed for the <i>wszApplicationMessage</i> parameter of the SetFailure method. This parameter is required
    ///                              and cannot be <b>NULL</b>.
    ///    pdwReserved = The address of a caller-allocated DWORD variable. This parameter is reserved for future use, but it is
    ///                  required and cannot be <b>NULL</b>.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%">
    ///    Successfully returned the status of the specified writer. Note that the value of the <i>phrFailureWriter</i>
    ///    parameter must be checked to verify that the writer was successful. The writer failure codes can be among
    ///    those listed in VsWriter.h and in Writer Errors and Vetoes. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> The <i>phr</i>,
    ///    <i>phrApplication</i>, <i>pbstrApplicationMessage</i>, or <i>pdwReserved</i> parameter is <b>NULL</b>. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> <dt>0x8007000EL</dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_BAD_STATE</b></dt> <dt>0x80042301L</dt> </dl> </td> <td width="60%"> The backup components
    ///    object is not initialized, this method has been called during a restore operation, or this method has not
    ///    been called within the correct sequence. </td> </tr> </table>
    ///    
    HRESULT GetFailure(HRESULT* phr, HRESULT* phrApplication, BSTR* pbstrApplicationMessage, uint* pdwReserved);
}

///The <b>IVssCreateWriterMetadata</b> interface is a C++ (not COM) interface containing methods to construct the Writer
///Metadata Document in response to an Identify event. It is used only in the CVssWriter::OnIdentify method. The
///addition and specification of components by a writer is managed through this interface. After it is constructed, the
///Writer Metadata Document is a read-only object that requesters query for information about a writer and its
///components. <b>IVssCreateWriterMetadata</b> defines the following methods.<table> <tr> <th>Method</th>
///<th>Description</th> </tr> <tr> <td> AddAlternateLocationMapping </td> <td>Creates an alternate location
///mapping.</td> </tr> <tr> <td> AddComponent </td> <td>Adds a database or file group as a component to be backed
///up.</td> </tr> <tr> <td> AddComponentDependency </td> <td>Indicates that a component participates in a backup or
///restore only if specified components managed by other writers also participate.</td> </tr> <tr> <td> AddDatabaseFiles
///</td> <td>Indicates the physical files that are associated with a database to be backed up, as well as their
///location.</td> </tr> <tr> <td> AddDatabaseLogFiles </td> <td>Indicates the log files that are associated with a
///database to be backed up, as well as their location.</td> </tr> <tr> <td> AddExcludeFiles </td> <td>Specifies the
///files that will be excluded from the backup.</td> </tr> <tr> <td> AddFilesToFileGroup </td> <td>Adds the specified
///file or files to the specified file group.</td> </tr> <tr> <td> AddIncludeFiles </td> <td>Reserved for system
///use.</td> </tr> <tr> <td> GetDocument </td> <td>Reserved for system use.</td> </tr> <tr> <td> SaveAsXML </td>
///<td>Saves a text string containing the Writer Metadata Document.</td> </tr> <tr> <td> SetBackupSchema </td> <td>Sets
///the backup schema (how a backup is to be executed) to be used when processing a writer's files.</td> </tr> <tr> <td>
///SetRestoreMethod </td> <td>Indicates how writer data is to be restored.</td> </tr> </table>
interface IVssCreateWriterMetadata
{
    ///Not supported. This method is reserved for system use.
    ///Params:
    ///    wszPath = This parameter is reserved for system use.
    ///    wszFilespec = This parameter is reserved for system use.
    ///    bRecursive = This parameter is reserved for system use.
    ///    wszAlternateLocation = This parameter is reserved for system use.
    HRESULT AddIncludeFiles(const(PWSTR) wszPath, const(PWSTR) wszFilespec, ubyte bRecursive, 
                            const(PWSTR) wszAlternateLocation);
    ///The <b>AddExcludeFiles</b> method is used to explicitly exclude a file set (a specified file or files) that might
    ///otherwise be implicitly included when a component of the current writer is backed up.
    ///Params:
    ///    wszPath = Pointer to a null-terminated wide character string containing the root directory under which files are to be
    ///              excluded. The directory can be a local directory on the VSS machine, or it can be a file share directory on a
    ///              remote file server. UNC paths are supported. The path can contain environment variables (for example,
    ///              %SystemRoot%) but cannot contain wildcard characters. There is no requirement that the path end with a
    ///              backslash ("\"). It is up to applications that retrieve this information to check.
    ///    wszFilespec = Pointer to a null-terminated wide character string containing the file specification of the files to be
    ///                  excluded. A file specification cannot contain directory specifications (for example, no backslashes) but can
    ///                  contain the ? and * wildcard characters.
    ///    bRecursive = A Boolean value specifying whether the path specified by the <i>wszPath</i> parameter identifies only a
    ///                 single directory or if it indicates a hierarchy of directories to be traversed recursively. This parameter
    ///                 should be set to <b>true</b> if the path is treated as a hierarchy of directories to be recursed through, or
    ///                 <b>false</b> otherwise. For information on traversing over mounted folders, see Working with Mounted Folders
    ///                 and Reparse Points.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddExcludeFiles(const(PWSTR) wszPath, const(PWSTR) wszFilespec, ubyte bRecursive);
    ///The <b>AddComponent</b> method adds a database or file group as a component to be backed up.
    ///Params:
    ///    ct = A VSS_COMPONENT_TYPE enumeration value specifying the type of the component. <b>Windows Server 2003 and
    ///         Windows XP: </b>Before Windows Server 2003 with SP1, this parameter is reserved for system use, and the
    ///         caller should not override the default value.
    ///    wszLogicalPath = A pointer to a <b>null</b>-terminated wide character string containing the logical path of the database or
    ///                     file group. For more information, see Logical Pathing of Components. A logical path is optional and can be
    ///                     <b>NULL</b>.
    ///    wszComponentName = A pointer to a <b>null</b>-terminated wide character string containing the name of the component. This string
    ///                       is not localized. This parameter is required and cannot be <b>NULL</b>. The string cannot contain
    ///                       backslashes.
    ///    wszCaption = A pointer to a <b>null</b>-terminated wide character string containing a description (also called a "friendly
    ///                 name") for the component. This string might be localized, and therefore requesters must assume that it is
    ///                 localized. This parameter is optional and can be <b>NULL</b>. The string can contain backslashes.
    ///    pbIcon = A pointer to a bitmap of the icon representing the database, to be displayed in a user interface. The size,
    ///             in bytes, of the buffer is specified by the <i>cbIcon</i> parameter. If the writer does not want to specify
    ///             an icon, <i>pbIcon</i> should be set to <b>NULL</b>.
    ///    cbIcon = The size, in bytes, of the buffer. If the <i>pbIcon</i> parameter is <b>NULL</b>, <i>cbIcon</i> should be
    ///             zero.
    ///    bRestoreMetadata = This parameter is reserved for future use and should always be set to <b>false</b>.
    ///    bNotifyOnBackupComplete = This parameter is reserved for future use and should always be set to <b>false</b>.
    ///    bSelectable = A Boolean that indicates whether the component can be optionally backed up (which means it can be excluded
    ///                  from the backup) or is always backed up when any of the writer's component is backed up. The Boolean is
    ///                  <b>true</b> if the component can be selectively backed up and <b>false</b> if it is backed up when any of the
    ///                  components is backed up.
    ///    bSelectableForRestore = A Boolean that determines whether a component can be individually restored when it has not been explicitly
    ///                            included in the backup document. If the component was explicitly added to the backup document, it can always
    ///                            be individually selected for restore; in this case, this flag has no meaning. When <b>true</b>, the component
    ///                            can be restored by itself; when <b>false</b>, the component can be restored only if the entire component set
    ///                            is being restored. (See VSS_COMPONENTINFO and <a
    ///                            href="/windows/desktop/VSS/working-with-selectability-and-logical-paths">Working with Selectability and
    ///                            Logical Paths</a> for more information). The default value for this parameter is <b>false</b>.
    ///    dwComponentFlags = A bit mask (or bitwise OR) of members of the VSS_COMPONENT_FLAGS enumeration indicating the features that
    ///                       this component supports. The default value for this argument is zero.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_ALREADY_EXISTS</b></dt> </dl> </td> <td
    ///    width="60%"> The object is a duplicate. A component with the same logical path and component name already
    ///    exists. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddComponent(VSS_COMPONENT_TYPE ct, const(PWSTR) wszLogicalPath, const(PWSTR) wszComponentName, 
                         const(PWSTR) wszCaption, const(ubyte)* pbIcon, uint cbIcon, ubyte bRestoreMetadata, 
                         ubyte bNotifyOnBackupComplete, ubyte bSelectable, ubyte bSelectableForRestore, 
                         uint dwComponentFlags);
    ///The <b>AddDatabaseFiles</b> method indicates the file set (the specified file or files) that make up the database
    ///component to be backed up.
    ///Params:
    ///    wszLogicalPath = Pointer to a <b>null</b>-terminated wide character string containing the logical path of the component to
    ///                     which the database will be added. For more information, see Logical Pathing of Components. A logical path is
    ///                     not required and can be <b>NULL</b>.
    ///    wszDatabaseName = Pointer to a <b>null</b>-terminated wide character string containing the name of the database. This name is
    ///                      required and must match the name of the component to which the database is being added.
    ///    wszPath = Pointer to a <b>null</b>-terminated wide character string containing the path of the directory containing the
    ///              database file. The path can contain environment variables (for example, %SystemRoot%) but cannot contain
    ///              wildcard characters. UNC paths are supported. There is no requirement that the path end with a backslash
    ///              ("\"). It is up to applications that retrieve this information to check.
    ///    wszFilespec = Pointer to a <b>null</b>-terminated wide character string containing the file specification of the file or
    ///                  files associated with the database. A file specification cannot contain directory specifications (for
    ///                  example, no backslashes) but can contain the ? and * wildcard characters.
    ///    dwBackupTypeMask = A bit mask (or bitwise OR) of VSS_FILE_SPEC_BACKUP_TYPE enumeration values to indicate whether a writer
    ///                       should evaluate the file for participation in certain types of backup operations. The default value for this
    ///                       argument is (VSS_FSBT_ALL_BACKUP_REQUIRED | VSS_FSBT_ALL_SNAPSHOT_REQUIRED).
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
    ///    The specified component does not exist. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error code is logged in
    ///    the error log file. For more information, see Event and Error Handling Under VSS. <b>Windows Server 2008,
    ///    Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008
    ///    R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT AddDatabaseFiles(const(PWSTR) wszLogicalPath, const(PWSTR) wszDatabaseName, const(PWSTR) wszPath, 
                             const(PWSTR) wszFilespec, uint dwBackupTypeMask);
    ///The <b>AddDatabaseLogFiles</b> method indicates the log files that are associated with a database to be backed
    ///up, as well as their location.
    ///Params:
    ///    wszLogicalPath = Pointer to a <b>null</b>-terminated wide character string containing the logical path of the database
    ///                     component to which the log files will be added. For more information, see Logical Pathing of Components. A
    ///                     logical path is not required, and can be <b>NULL</b>.
    ///    wszDatabaseName = Pointer to a <b>null</b>-terminated wide character string containing the name of the database component
    ///                      associated with the log files. The type of this component must be VSS_CT_DATABASE; otherwise, the method will
    ///                      return an error.
    ///    wszPath = Pointer to a <b>null</b>-terminated wide character string containing the path of the directory containing the
    ///              log files. The directory can be a local directory on the VSS machine, or it can be a file share directory on
    ///              a remote file server. UNC paths are supported. The path can contain environment variables (for example,
    ///              %SystemRoot%) but cannot contain wildcard characters. There is no requirement that the path end with a
    ///              backslash ("\"). It is up to applications that retrieve this information to check.
    ///    wszFilespec = Pointer to a <b>null</b>-terminated wide character string containing the file specification of the log
    ///                  file(s) associated with the database. A file specification cannot contain directory specifications (for
    ///                  example, no backslashes) but can contain the ? and * wildcard characters.
    ///    dwBackupTypeMask = A bit mask (or bitwise OR) of VSS_FILE_SPEC_BACKUP_TYPE enumeration values to indicate if a writer should
    ///                       evaluate the file for participation in a certain type of backup operations. The default value for this
    ///                       argument is (VSS_FSBT_ALL_BACKUP_REQUIRED | VSS_FSBT_ALL_SNAPSHOT_REQUIRED).
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid, or the caller attempted to add database files to a non-database component.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller
    ///    is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified component
    ///    does not exist. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> </table>
    ///    
    HRESULT AddDatabaseLogFiles(const(PWSTR) wszLogicalPath, const(PWSTR) wszDatabaseName, const(PWSTR) wszPath, 
                                const(PWSTR) wszFilespec, uint dwBackupTypeMask);
    ///The <b>AddFilesToFileGroup</b> method adds a file set (a specified file or files) to a specified file group
    ///component.
    ///Params:
    ///    wszLogicalPath = Pointer to a <b>null</b>-terminated wide character string containing the logical path (which may be
    ///                     <b>NULL</b>) of the component to which to add the files. For more information, see Logical Pathing of
    ///                     Components.
    ///    wszGroupName = Pointer to a <b>null</b>-terminated wide character string containing the name of the file group component.
    ///                   The type of this component must be VSS_CT_FILEGROUP; otherwise, the method will return an error.
    ///    wszPath = Pointer to a <b>null</b>-terminated wide character string containing the default root directory of the files
    ///              to be added. The directory can be a local directory on the VSS machine, or it can be a file share directory
    ///              on a remote file server. UNC paths are supported. The path can contain environment variables (for example,
    ///              %SystemRoot%) but cannot contain wildcard characters. There is no requirement that the path end with a
    ///              backslash ("\"). It is up to applications that retrieve this information to check.
    ///    wszFilespec = Pointer to a <b>null</b>-terminated wide character string containing the file specification of the files to
    ///                  be included. A file specification cannot contain directory specifications (for example, no backslashes) but
    ///                  can contain the ? and * wildcard characters.
    ///    bRecursive = A Boolean value specifying whether the path specified by the <i>wszPath</i> parameter identifies only a
    ///                 single directory or if it indicates a hierarchy of directories to be traversed recursively. This parameter
    ///                 should be set to <b>true</b> if the path is treated as a hierarchy of directories to be recursed through, or
    ///                 <b>false</b> otherwise. For information on traversing over mounted folders, see Working with Mounted Folders
    ///                 and Reparse Points.
    ///    wszAlternateLocation = Pointer to a <b>null</b>-terminated wide character string containing the alternate path, which actually
    ///                           contains the files to be backed up with this component. The directory can be a local directory on the VSS
    ///                           machine, or it can be a file share directory on a remote file server. UNC paths are supported. Specifying an
    ///                           alternate path is optional; if no alternate path is needed, <i>wszAlternatePath</i> should be <b>NULL</b>. An
    ///                           alternate path should not be confused with an alternate location mapping.
    ///    dwBackupTypeMask = A bitmask of VSS_FILE_SPEC_BACKUP_TYPE enumeration values to indicate if a writer should evaluate the file
    ///                       for participation in a certain type of backup operations. The default value for this argument is
    ///                       (VSS_FSBT_ALL_BACKUP_REQUIRED | VSS_FSBT_ALL_SNAPSHOT_REQUIRED).
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The
    ///    operation was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is not valid, or the caller
    ///    attempted to add file-group files to a non-file-group component. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> The caller is out of memory
    ///    or other system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt>
    ///    <dt>0x80042311L</dt> </dl> </td> <td width="60%"> The XML document is not valid. Check the event log for
    ///    details. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_NOT_SUPPORTED</b></dt> <dt>0x8004232FL</dt> </dl> </td> <td width="60%"> For express writers,
    ///    the value of <i>wszAlternatePath</i> must be <b>NULL</b>, and the <i>dwBackupTypeMask</i> bitmask cannot
    ///    include <b>VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED</b>, <b>VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED</b>, or
    ///    <b>VSS_FSBT_LOG_BACKUP_REQUIRED</b>. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The specified
    ///    component does not exist. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td>
    ///    <td width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> </table>
    ///    
    HRESULT AddFilesToFileGroup(const(PWSTR) wszLogicalPath, const(PWSTR) wszGroupName, const(PWSTR) wszPath, 
                                const(PWSTR) wszFilespec, ubyte bRecursive, const(PWSTR) wszAlternateLocation, 
                                uint dwBackupTypeMask);
    ///The <b>SetRestoreMethod</b> method indicates how the writer's data is to be restored.
    ///Params:
    ///    method = VSS_RESTOREMETHOD_ENUM value specifying the method that will be used in the restore operation.
    ///    wszService = A pointer to a wide character string containing the name of a service that must be stopped prior to a restore
    ///                 operation and then started after the restore operation takes place, if the value of <i>method</i> is
    ///                 VSS_RME_STOP_RESTORE_START or VSS_RME_RESTORE_STOP_START. If the value of <i>method</i> is not
    ///                 VSS_RME_STOP_RESTORE_START or VSS_RME_RESTORE_STOP_START, this argument is not used and should be set to
    ///                 <b>NULL</b>.
    ///    wszUserProcedure = Reserved for future use. The value of this parameter should always be set to <b>NULL</b>.
    ///    writerRestore = VSS_WRITERRESTORE_ENUM value specifying whether the writer will be involved in restoring its data. Express
    ///                    writers must set this parameter to <i>VSS_WRE_NEVER</i>.
    ///    bRebootRequired = Boolean indicating whether a reboot will be required after the restore operation is complete.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The
    ///    operation was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> The
    ///    caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> <dt>0x80042311L</dt> </dl> </td> <td width="60%"> The XML document
    ///    is not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_NOT_SUPPORTED</b></dt> <dt>0x8004232FL</dt> </dl> </td>
    ///    <td width="60%"> The caller specified a VSS_WRITERRESTORE_ENUM value that is not supported for express
    ///    writers. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetRestoreMethod(VSS_RESTOREMETHOD_ENUM method, const(PWSTR) wszService, const(PWSTR) wszUserProcedure, 
                             VSS_WRITERRESTORE_ENUM writerRestore, ubyte bRebootRequired);
    ///The <b>AddAlternateLocationMapping</b> method creates an alternate location mapping for a file set.
    ///Params:
    ///    wszSourcePath = Null-terminated wide character string containing the name of the directory or directory hierarchy containing
    ///                    the files to be mapped. The directory can be a local directory on the VSS machine, or it can be a file share
    ///                    directory on a remote file server. The path can contain environment variables (for example, %SystemRoot%) but
    ///                    cannot contain wildcard characters. There is no requirement that the path end with a backslash ("\"). It is
    ///                    up to applications that retrieve this information to check.
    ///    wszSourceFilespec = Null-terminated wide character string containing the file specification of the files to be mapped. A file
    ///                        specification cannot contain directory specifications (for example, no backslashes) but can contain the ? and
    ///                        * wildcard characters.
    ///    bRecursive = A Boolean value specifying whether the path specified by the <i>wszPath</i> parameter identifies only a
    ///                 single directory or if it indicates a hierarchy of directories to be traversed recursively. This parameter
    ///                 should be set to <b>true</b> if the path is treated as a hierarchy of directories to be traversed
    ///                 recursively, or <b>false</b> if not. For information on traversing mounted folders, see Working with Mounted
    ///                 Folders and Reparse Points.
    ///    wszDestination = Null-terminated wide character string containing the fully qualified path to the directory where the files
    ///                     will be relocated. The directory can be a local directory on the VSS machine, or it can be a file share
    ///                     directory on a remote file server. UNC paths are supported.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The
    ///    operation was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> The
    ///    caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> <dt>0x80042311L</dt> </dl> </td> <td width="60%"> The XML document
    ///    is not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042308L</dt> </dl>
    ///    </td> <td width="60%"> The IVssCreateWriterMetadata::SetRestoreMethod method was not called before this
    ///    method was called. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> </table>
    ///    
    HRESULT AddAlternateLocationMapping(const(PWSTR) wszSourcePath, const(PWSTR) wszSourceFilespec, 
                                        ubyte bRecursive, const(PWSTR) wszDestination);
    ///The <b>AddComponentDependency</b> method allows a writer to indicate that a component it manages has an explicit
    ///writer-component dependency; that is, another component in another writer must be backed up and restored with it.
    ///Params:
    ///    wszForLogicalPath = A null-terminated wide character string containing the logical path of the component (managed by the current
    ///                        writer) that requires a dependency.
    ///    wszForComponentName = A null-terminated wide character string containing the component (managed by the current writer) that
    ///                          requires a dependency.
    ///    onWriterId = The class ID or VSS_ID (GUID) of the writer managing the component on which the current component depends.
    ///    wszOnLogicalPath = The logical path of the component (managed by the writer identified by <i>onWriterId</i>) on which the
    ///                       current component depends.
    ///    wszOnComponentName = The name of the component (managed by the writer identified by <i>onWriterId</i>) on which the current
    ///                         component depends.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
    ///    The component specified by <i>wszForLogicalPath</i> and <i>wszForComponentName</i> does not exist. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected
    ///    error. The error code is logged in the error log file. For more information, see Event and Error Handling
    ///    Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not
    ///    supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT AddComponentDependency(const(PWSTR) wszForLogicalPath, const(PWSTR) wszForComponentName, 
                                   GUID onWriterId, const(PWSTR) wszOnLogicalPath, const(PWSTR) wszOnComponentName);
    ///The <b>SetBackupSchema</b> method is used by a writer to indicate in its Writer Metadata Document the types of
    ///backup operations it can participate in.
    ///Params:
    ///    dwSchemaMask = The types of backup operations this writer supports expressed as a bitmask of VSS_BACKUP_SCHEMA enumeration
    ///                   values. For express writers, only the <b>VSS_BS_UNDEFINED</b>, <b>VSS_BS_COPY</b>, and
    ///                   <b>VSS_BS_INDEPENDENT_SYSTEM_STATE</b> values are supported.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%">
    ///    Successfully set the failure message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    <dt>0x80070057L</dt> </dl> </td> <td width="60%"> The backup schema argument is not valid. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> The
    ///    caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> <dt>0x80042311L</dt> </dl> </td> <td width="60%"> The XML document
    ///    is not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_NOT_SUPPORTED</b></dt> <dt>0x8004232FL</dt> </dl> </td>
    ///    <td width="60%"> The caller specified a VSS_BACKUP_SCHEMA value that is not supported for express writers.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetBackupSchema(uint dwSchemaMask);
    ///Not supported. This method is reserved for system use.
    ///Params:
    ///    pDoc = This parameter is reserved for system use.
    HRESULT GetDocument(IXMLDOMDocument* pDoc);
    ///The <b>SaveAsXML</b> method saves the Writer Metadata Document that contains a writer's state information to a
    ///specified string.
    ///Params:
    ///    pbstrXML = Pointer to a string to be used to store the Writer Metadata Document that contains a writer's state
    ///               information.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr>
    ///    </table>
    ///    
    HRESULT SaveAsXML(BSTR* pbstrXML);
}

///The <b>IVssCreateWriterMetadataEx</b> interface is a C++ (not COM) interface that defines a method to report any file
///sets that will be explicitly excluded when a shadow copy is created. This interface is used only in the
///CVssWriterEx::OnIdentifyEx method. The <b>IVssCreateWriterMetadataEx</b> interface inherits from the
///IVssCreateWriterMetadata interface and IUnknown. <b>IVssCreateWriterMetadataEx</b> defines the following
///method.<table> <tr> <th>Method</th> <th>Description</th> </tr> <tr> <td> AddExcludeFilesFromSnapshot </td>
///<td>Reports any file sets that will be explicitly excluded by the writer when a shadow copy is created.</td> </tr>
///</table>
@GUID("9F21981D-D469-4349-B807-39E64E4674E1")
interface IVssCreateWriterMetadataEx : IUnknown
{
    HRESULT AddDatabaseFiles(const(PWSTR) wszLogicalPath, const(PWSTR) wszDatabaseName, const(PWSTR) wszPath, 
                             const(PWSTR) wszFilespec, uint dwBackupTypeMask);
    HRESULT AddDatabaseLogFiles(const(PWSTR) wszLogicalPath, const(PWSTR) wszDatabaseName, const(PWSTR) wszPath, 
                                const(PWSTR) wszFilespec, uint dwBackupTypeMask);
    HRESULT AddFilesToFileGroup(const(PWSTR) wszLogicalPath, const(PWSTR) wszGroupName, const(PWSTR) wszPath, 
                                const(PWSTR) wszFilespec, ubyte bRecursive, const(PWSTR) wszAlternateLocation, 
                                uint dwBackupTypeMask);
    HRESULT SetRestoreMethod(VSS_RESTOREMETHOD_ENUM method, const(PWSTR) wszService, const(PWSTR) wszUserProcedure, 
                             VSS_WRITERRESTORE_ENUM writerRestore, ubyte bRebootRequired);
    HRESULT AddAlternateLocationMapping(const(PWSTR) wszSourcePath, const(PWSTR) wszSourceFilespec, 
                                        ubyte bRecursive, const(PWSTR) wszDestination);
    HRESULT AddComponentDependency(const(PWSTR) wszForLogicalPath, const(PWSTR) wszForComponentName, 
                                   GUID onWriterId, const(PWSTR) wszOnLogicalPath, const(PWSTR) wszOnComponentName);
    HRESULT SetBackupSchema(uint dwSchemaMask);
    HRESULT GetDocument(IXMLDOMDocument* pDoc);
    HRESULT SaveAsXML(BSTR* pbstrXML);
    HRESULT QueryInterface(const(GUID)* riid, void** ppvObject);
    uint    AddRef();
    uint    Release();
    ///Reports any file sets that will be explicitly excluded by the writer when a shadow copy is created. Calling this
    ///method does not cause the files to be excluded. The writer is responsible for deleting the files from the shadow
    ///copy in its CVssWriter::OnPostSnapshot method.
    ///Params:
    ///    wszPath = A pointer to a null-terminated wide character string containing the root directory under which files are to
    ///              be excluded. The directory can be a local directory on the VSS machine, or it can be a file share directory
    ///              on a remote file server. UNC paths are supported. The path can contain environment variables (for example,
    ///              %SystemRoot%) but cannot contain wildcard characters. There is no requirement that the path end with a
    ///              backslash ("\"). It is up to applications that retrieve this information to check whether the path ends with
    ///              a backslash.
    ///    wszFilespec = A pointer to a null-terminated wide character string containing the file specification of the files to be
    ///                  excluded. A file specification cannot contain directory specifications (for example, no backslashes) but can
    ///                  contain the ? and * wildcard characters.
    ///    bRecursive = A Boolean value specifying whether the path specified by the <i>wszPath</i> parameter identifies only a
    ///                 single directory or if it indicates a hierarchy of directories to be traversed recursively. This parameter
    ///                 should be set to <b>true</b> if the path is treated as a hierarchy of directories to be recursed through, or
    ///                 <b>false</b> otherwise. For information on traversing over mounted folders, see Working with Mounted Folders
    ///                 and Reparse Points.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The
    ///    operation was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt>
    ///    <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> The
    ///    caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> <dt>0x80042311L</dt> </dl> </td> <td width="60%"> The XML document
    ///    is not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_NOT_SUPPORTED</b></dt> <dt>0x8004232FL</dt> </dl> </td>
    ///    <td width="60%"> This method is not supported for express writers. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error code is logged in
    ///    the error log file. For more information, see Event and Error Handling Under VSS. <b>Windows Server 2008,
    ///    Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008
    ///    R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT AddExcludeFilesFromSnapshot(const(PWSTR) wszPath, const(PWSTR) wszFilespec, ubyte bRecursive);
}

interface IVssWriterImpl : IUnknown
{
    HRESULT Initialize(GUID writerId, const(PWSTR) wszWriterName, const(PWSTR) wszWriterInstanceName, 
                       uint dwMajorVersion, uint dwMinorVersion, VSS_USAGE_TYPE ut, VSS_SOURCE_TYPE st, 
                       VSS_APPLICATION_LEVEL nLevel, uint dwTimeout, VSS_ALTERNATE_WRITER_STATE aws, 
                       ubyte bIOThrottlingOnly);
    HRESULT Subscribe(uint dwSubscribeTimeout, uint dwEventFlags);
    HRESULT Unsubscribe();
    void    Uninitialize();
    PWSTR*  GetCurrentVolumeArray();
    uint    GetCurrentVolumeCount();
    HRESULT GetSnapshotDeviceName(const(PWSTR) wszOriginalVolume, PWSTR* ppwszSnapshotDevice);
    GUID    GetCurrentSnapshotSetId();
    int     GetContext();
    VSS_APPLICATION_LEVEL GetCurrentLevel();
    bool    IsPathAffected(const(PWSTR) wszPath);
    bool    IsBootableSystemStateBackedUp();
    bool    AreComponentsSelected();
    VSS_BACKUP_TYPE GetBackupType();
    VSS_RESTORE_TYPE GetRestoreType();
    HRESULT SetWriterFailure(HRESULT hr);
    bool    IsPartialFileSupportEnabled();
    HRESULT InstallAlternateWriter(GUID idWriter, GUID clsid);
    IVssExamineWriterMetadata* GetIdentityInformation();
    HRESULT SetWriterFailureEx(HRESULT hr, HRESULT hrApplication, const(PWSTR) wszApplicationMessage);
    HRESULT GetSessionId(GUID* idSession);
    bool    IsWriterShuttingDown();
}

///The <b>IVssCreateExpressWriterMetadata</b> interface is a COM interface containing methods to construct the Writer
///Metadata Document for an express writer. After it is constructed, the Writer Metadata Document is a read-only object
///that requesters query for information about a writer and its components.
@GUID("9C772E77-B26E-427F-92DD-C996F41EA5E3")
interface IVssCreateExpressWriterMetadata : IUnknown
{
    ///Excludes a file set (a specified file or files) that might otherwise be implicitly included when a component of
    ///an express writer is backed up.
    ///Params:
    ///    wszPath = A pointer to a null-terminated wide character string containing the root directory under which files are to
    ///              be excluded. The path can contain environment variables (for example, %SystemRoot%) but cannot contain
    ///              wildcard characters. There is no requirement that the path end with a backslash (\\). It is up to
    ///              applications that retrieve this information to check.
    ///    wszFilespec = A pointer to a null-terminated wide character string containing the file specification of the files to be
    ///                  excluded. A file specification cannot contain directory specifications (for example, no backslashes) but can
    ///                  contain the ? and * wildcard characters.
    ///    bRecursive = A Boolean value specifying whether the path specified by the <i>wszPath</i> parameter identifies only a
    ///                 single directory or if it indicates a hierarchy of directories to be traversed recursively. This parameter
    ///                 should be set to <b>true</b> if the path is treated as a hierarchy of directories to be recursed through, or
    ///                 <b>false</b> otherwise. For information on traversing over mounted folders, see Working with Mounted Folders
    ///                 and Reparse Points.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddExcludeFiles(const(PWSTR) wszPath, const(PWSTR) wszFilespec, ubyte bRecursive);
    ///Adds a file group to an express writer's set of components to be backed up.
    ///Params:
    ///    ct = A VSS_COMPONENT_TYPE enumeration value that specifies the type of the component. Only <b>VSS_CT_FILEGROUP</b>
    ///         is supported for this parameter.
    ///    wszLogicalPath = A pointer to a <b>null</b>-terminated wide character string containing the logical path of the database or
    ///                     file group. For more information, see Logical Pathing of Components. This parameter is optional and can be
    ///                     <b>NULL</b>.
    ///    wszComponentName = A pointer to a <b>null</b>-terminated wide character string containing the name of the component. This string
    ///                       is not localized. This parameter is required and cannot be <b>NULL</b>. The string cannot contain
    ///                       backslashes.
    ///    wszCaption = A pointer to a <b>null</b>-terminated wide character string containing a description (also called a "friendly
    ///                 name") for the component. This string might be localized, and therefore requesters must assume that it is
    ///                 localized. This parameter is optional and can be <b>NULL</b>. The string can contain backslashes.
    ///    pbIcon = A pointer to a bitmap of the icon representing the database, to be displayed in a user interface. The size,
    ///             in bytes, of the buffer is specified by the <i>cbIcon</i> parameter. This parameter is optional and can be
    ///             <b>NULL</b>.
    ///    cbIcon = The size, in bytes, of the buffer. If the <i>pbIcon</i> parameter is <b>NULL</b>, <i>cbIcon</i> must be zero.
    ///    bRestoreMetadata = This parameter is reserved for future use and should always be set to <b>false</b>.
    ///    bNotifyOnBackupComplete = This parameter is reserved for future use and should always be set to <b>false</b>.
    ///    bSelectable = A Boolean value that indicates whether the component can be optionally backed up (which means it can be
    ///                  excluded from the backup) or is always backed up when any of the writer's components is backed up. This
    ///                  parameter should be set to <b>true</b> if the component can be selectively backed up, or <b>false</b> if the
    ///                  component is backed up when any of the components is backed up.
    ///    bSelectableForRestore = A Boolean value that determines whether a component can be individually restored when it has not been
    ///                            explicitly included in the backup document. If the component was explicitly added to the backup document, it
    ///                            can always be individually selected for restore; in this case, this flag has no meaning. When this parameter
    ///                            is <b>true</b>, the component can be restored by itself; when <b>false</b>, the component can be restored
    ///                            only if the entire component set is being restored. (For more information, see VSS_COMPONENTINFO and <a
    ///                            href="/windows/desktop/VSS/working-with-selectability-and-logical-paths">Working with Selectability and
    ///                            Logical Paths</a>.) The default value for this parameter is <b>false</b>.
    ///    dwComponentFlags = A bitmask of VSS_COMPONENT_FLAGS enumeration values indicating the features that this component supports.
    ///                       This bitmask cannot include <b>VSS_CF_APP_ROLLBACK_RECOVERY</b> or <b>VSS_CF_BACKUP_RECOVERY</b>. The default
    ///                       value for this parameter is zero.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_ALREADY_EXISTS</b></dt> </dl> </td> <td
    ///    width="60%"> The object is a duplicate. A component with the same logical path and component name already
    ///    exists. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddComponent(VSS_COMPONENT_TYPE ct, const(PWSTR) wszLogicalPath, const(PWSTR) wszComponentName, 
                         const(PWSTR) wszCaption, const(ubyte)* pbIcon, uint cbIcon, ubyte bRestoreMetadata, 
                         ubyte bNotifyOnBackupComplete, ubyte bSelectable, ubyte bSelectableForRestore, 
                         uint dwComponentFlags);
    ///Adds a file set (a specified file or files) to a specified file group component for an express writer.
    ///Params:
    ///    wszLogicalPath = A pointer to a <b>null</b>-terminated wide character string containing the logical path (which may be
    ///                     <b>NULL</b>) of the component to which to add the files. For more information, see Logical Pathing of
    ///                     Components.
    ///    wszGroupName = A pointer to a <b>null</b>-terminated wide character string containing the name of the file group component.
    ///                   The type of this component must be VSS_CT_FILEGROUP; otherwise, the method will return an error.
    ///    wszPath = A pointer to a <b>null</b>-terminated wide character string containing the default root directory of the
    ///              files to be added. The path can contain environment variables (for example, %SystemRoot%) but cannot contain
    ///              wildcard characters. There is no requirement that the path end with a backslash (\\). It is up to
    ///              applications that retrieve this information to check.
    ///    wszFilespec = A pointer to a <b>null</b>-terminated wide character string containing the file specification of the files to
    ///                  be included. A file specification cannot contain directory specifications (for example, no backslashes) but
    ///                  can contain the ? and * wildcard characters.
    ///    bRecursive = A Boolean value specifying whether the path specified by the <i>wszPath</i> parameter identifies only a
    ///                 single directory or if it indicates a hierarchy of directories to be traversed recursively. This parameter
    ///                 should be set to <b>true</b> if the path is treated as a hierarchy of directories to be recursed through, or
    ///                 <b>false</b> otherwise. For information on traversing over mounted folders, see Working with Mounted Folders
    ///                 and Reparse Points.
    ///    wszAlternateLocation = This parameter is reserved and must be <b>NULL</b>.
    ///    dwBackupTypeMask = A bitmask of VSS_FILE_SPEC_BACKUP_TYPE enumeration values to indicate if a writer should evaluate the file
    ///                       for participation in a certain type of backup operations. This parameter cannot include
    ///                       <b>VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED</b>, <b>VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED</b>, or
    ///                       <b>VSS_FSBT_LOG_BACKUP_REQUIRED</b>. The default value for this argument is (VSS_FSBT_ALL_BACKUP_REQUIRED |
    ///                       VSS_FSBT_ALL_SNAPSHOT_REQUIRED).
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid, or the caller attempted to add file-group files to a non-file-group component.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller
    ///    is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is not valid. Check
    ///    the event log for details. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified component
    ///    does not exist. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> </table>
    ///    
    HRESULT AddFilesToFileGroup(const(PWSTR) wszLogicalPath, const(PWSTR) wszGroupName, const(PWSTR) wszPath, 
                                const(PWSTR) wszFilespec, ubyte bRecursive, const(PWSTR) wszAlternateLocation, 
                                uint dwBackupTypeMask);
    ///Specifies how an express writer's data is to be restored.
    ///Params:
    ///    method = A VSS_RESTOREMETHOD_ENUM enumeration value specifying the restore method to be used in the restore operation.
    ///             This parameter is required and cannot be <b>VSS_RME_UNDEFINED</b>,
    ///             <b>VSS_RME_RESTORE_TO_ALTERNATE_LOCATION</b>, or <b>VSS_RME_CUSTOM</b>.
    ///    wszService = A pointer to a wide character string containing the name of a service that must be stopped prior to a restore
    ///                 operation and then started after the restore operation takes place, if the value of <i>method</i> is
    ///                 <b>VSS_RME_STOP_RESTORE_START</b> or <b>VSS_RME_RESTORE_STOP_START</b>. If the value of <i>method</i> is not
    ///                 <b>VSS_RME_STOP_RESTORE_START</b> or <b>VSS_RME_RESTORE_STOP_START</b>, this parameter is not used and should
    ///                 be set to <b>NULL</b>.
    ///    wszUserProcedure = Reserved for future use. The value of this parameter should always be set to <b>NULL</b>.
    ///    writerRestore = A VSS_WRITERRESTORE_ENUM enumeration value specifying whether the writer will be involved in restoring its
    ///                    data. This parameter must be set to <b>VSS_WRE_NEVER</b>.
    ///    bRebootRequired = A Boolean value indicating whether a reboot will be required after the restore operation is complete.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr>
    ///    </table>
    ///    
    HRESULT SetRestoreMethod(VSS_RESTOREMETHOD_ENUM method, const(PWSTR) wszService, const(PWSTR) wszUserProcedure, 
                             VSS_WRITERRESTORE_ENUM writerRestore, ubyte bRebootRequired);
    ///Allows an express writer to indicate that a component it manages has an explicit writer-component dependency;
    ///that is, another component (possibly managed by another writer) must be backed up and restored with it.
    ///Params:
    ///    wszForLogicalPath = A null-terminated wide character string containing the logical path of the component (managed by the express
    ///                        writer) that requires a dependency.
    ///    wszForComponentName = A null-terminated wide character string containing the component (managed by the express writer) that
    ///                          requires a dependency.
    ///    onWriterId = A VSS_ID (GUID) value that specifies the writer class of the express writer managing the component on which
    ///                 the current component depends.
    ///    wszOnLogicalPath = The logical path of the component (managed by the express writer identified by <i>onWriterId</i>) on which
    ///                       the current component depends.
    ///    wszOnComponentName = The name of the component (managed by the express writer identified by <i>onWriterId</i>) on which the
    ///                         current component depends.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
    ///    The component specified by <i>wszForLogicalPath</i> and <i>wszForComponentName</i> does not exist. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected
    ///    error. The error code is logged in the error log file. For more information, see Event and Error Handling
    ///    Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not
    ///    supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT AddComponentDependency(const(PWSTR) wszForLogicalPath, const(PWSTR) wszForComponentName, 
                                   GUID onWriterId, const(PWSTR) wszOnLogicalPath, const(PWSTR) wszOnComponentName);
    ///Used by an express writer to indicate in its Writer Metadata Document the types of backup operations it can
    ///participate in.
    ///Params:
    ///    dwSchemaMask = A bitmask of VSS_BACKUP_SCHEMA enumeration values that specify the types of backup operations this writer
    ///                   supports.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully set the failure
    ///    message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    backup schema argument is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    </dl> </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetBackupSchema(uint dwSchemaMask);
    ///Stores the Writer Metadata Document that contains an express writer's state information into a specified string.
    ///Params:
    ///    pbstrXML = A pointer to a string to be used to store the Writer Metadata Document that contains a writer's state
    ///               information.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The operation was successful.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> The
    ///    parameter value is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt> </dl> </td> <td width="60%"> The XML document is
    ///    not valid. Check the event log for details. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr>
    ///    </table>
    ///    
    HRESULT SaveAsXML(BSTR* pbstrXML);
}

///Defines methods to manage metadata for a VSS express writer.
@GUID("E33AFFDC-59C7-47B1-97D5-4266598F6235")
interface IVssExpressWriter : IUnknown
{
    ///Creates an express writer metadata object and returns an IVssCreateExpressWriterMetadata interface pointer to it.
    ///Params:
    ///    writerId = The globally unique identifier (GUID) of the writer class.
    ///    writerName = A null-terminated wide character string that contains the name of the writer class. This string is not
    ///                 localized.
    ///    usageType = A VSS_USAGE_TYPE enumeration value that indicates how the data that is managed by the writer is used on the
    ///                host system. The only valid values for this parameter are VSS_UT_BOOTABLESYSTEMSTATE, VSS_UT_SYSTEMSERVICE,
    ///                and VSS_UT_USERDATA.
    ///    versionMajor = The major version of the writer application. For more information, see the Remarks section.
    ///    versionMinor = The minor version of the writer application. For more information, see the Remarks section.
    ///    reserved = This parameter is reserved for system use.
    ///    ppMetadata = A pointer to a variable that receives an IVssCreateExpressWriterMetadata interface pointer to the newly
    ///                 created express writer metadata.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT CreateMetadata(GUID writerId, const(PWSTR) writerName, VSS_USAGE_TYPE usageType, uint versionMajor, 
                           uint versionMinor, uint reserved, IVssCreateExpressWriterMetadata* ppMetadata);
    ///Causes VSS to load the writer's metadata from a string instead of the express writer metadata store.
    ///Params:
    ///    metadata = A null-terminated wide character string that contains the writer's metadata.
    ///    reserved = This parameter is reserved for system use.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The
    ///    operation was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_INVALID_XML_DOCUMENT</b></dt>
    ///    <dt>0x80042311L</dt> </dl> </td> <td width="60%"> The XML document is not valid. Check the event log for
    ///    details. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT LoadMetadata(const(PWSTR) metadata, uint reserved);
    ///Causes VSS to store the writer's metadata in the express writer metadata store.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The
    ///    operation was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_ALREADY_EXISTS</b></dt>
    ///    <dt>0x8004230DL</dt> </dl> </td> <td width="60%"> Metadata has already been stored for this writer. </td>
    ///    </tr> </table>
    ///    
    HRESULT Register();
    ///Causes VSS to delete the writer's metadata from the express writer metadata store.
    ///Params:
    ///    writerId = The globally unique identifier (GUID) of the writer class.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The
    ///    operation was successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt>
    ///    <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The <i>writerId</i> parameter specified a writer that does
    ///    not exist. </td> </tr> </table>
    ///    
    HRESULT Unregister(GUID writerId);
}

///The <b>IVssSnapshotMgmt</b> interface provides a method that returns an interface to further configure a shadow copy
///provider.
@GUID("FA7DF749-66E7-4986-A27F-E2F04AE53772")
interface IVssSnapshotMgmt : IUnknown
{
    ///The <b>GetProviderMgmtInterface</b> method returns an interface to further configure the system provider.
    ///Params:
    ///    ProviderId = This must be the system provider. The <b>VSS_ID</b> for the system provider
    ///                 <code>{b5946137-7b9f-4925-af80-51abd60b20d5}</code>.
    ///    InterfaceId = Must be <b>IID_IVssDifferentialSoftwareSnapshotMgmt</b>, which represents the
    ///                  IVssDifferentialSoftwareSnapshotMgmt interface.
    ///    ppItf = Address of an interface pointer that is filled in with the returned interface pointer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetProviderMgmtInterface(GUID ProviderId, const(GUID)* InterfaceId, IUnknown* ppItf);
    ///Not supported. The <b>QueryVolumesSupportedForSnapshots</b> method is reserved for system use.
    ///Params:
    ///    ProviderId = Reserved for system use. Do not use.
    ///    lContext = Reserved for system use. Do not use.
    ///    ppEnum = Reserved for system use. Do not use.
    HRESULT QueryVolumesSupportedForSnapshots(GUID ProviderId, int lContext, IVssEnumMgmtObject* ppEnum);
    ///Not supported. The <b>QuerySnapshotsByVolume</b> method is reserved for system use.
    ///Params:
    ///    pwszVolumeName = Reserved for system use. Do not use.
    ///    ProviderId = Reserved for system use. Do not use.
    ///    ppEnum = Reserved for system use. Do not use.
    HRESULT QuerySnapshotsByVolume(ushort* pwszVolumeName, GUID ProviderId, IVssEnumObject* ppEnum);
}

///The <b>IVssSnapshotMgmt2</b> interface provides a method to retrieve the minimum size of the shadow copy storage
///area.
@GUID("0F61EC39-FE82-45F2-A3F0-768B5D427102")
interface IVssSnapshotMgmt2 : IUnknown
{
    ///Returns the current minimum size of the shadow copy storage area.
    ///Params:
    ///    pllMinDiffAreaSize = A pointer to a variable that receives the minimum size, in bytes, of the shadow copy storage area.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT GetMinDiffAreaSize(long* pllMinDiffAreaSize);
}

///The <b>IVssDifferentialSoftwareSnapshotMgmt</b> interface contains methods that allow applications to query and
///manage shadow copy storage areas generated by the system shadow copy provider.
@GUID("214A0F28-B737-4026-B847-4F9E37D79529")
interface IVssDifferentialSoftwareSnapshotMgmt : IUnknown
{
    ///The <b>AddDiffArea</b> method adds a shadow copy storage area association for the specified volume. If the
    ///association is not supported, an error code will be returned.
    ///Params:
    ///    pwszVolumeName = The name of the volume that will be the source of shadow copies. This volume is associated with a shadow copy
    ///                     storage area on the <i>pwszDiffAreaVolumeName</i> volume. The name of the volume must be in one of the
    ///                     following formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for
    ///                     example, Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    pwszDiffAreaVolumeName = The name of the volume that will contain the shadow copy storage area to be associated with the
    ///                             <i>pwszVolumeName</i> volume. The name of the volume must be in one of the following formats and must include
    ///                             a trailing backslash (\\): <ul> <li>The path of a mounted folder</li> <li>A drive letter, for example,
    ///                             D:\</li> <li>A volume GUID path of the form \\?&
    ///    llMaximumDiffSpace = The maximum size, in bytes, of the shadow copy storage area on the volume. This value must be at least 320
    ///                         MB, up to the system-wide limit. If this value is –1, the maximum size is unlimited. <b>Windows Server
    ///                         2003: </b>Prior to Windows Server 2003 with SP1, the shadow copy storage area size was fixed at 100 MB.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully added the shadow copy
    ///    storage area association. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td>
    ///    <td width="60%"> Caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED</b></dt> </dl> </td> <td width="60%"> The maximum number
    ///    of shadow copy storage areas has been added to the shadow copy source volume. The specified shadow copy
    ///    storage volume was not associated with the specified shadow copy source volume. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_NESTED_VOLUME_LIMIT</b></dt> </dl> </td> <td width="60%"> The specified volume
    ///    is nested too deeply to participate in the VSS operation. <b>Windows Server 2008, Windows Vista, Windows
    ///    Server 2003 and Windows XP: </b>This return code is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_ALREADY_EXISTS</b></dt> </dl> </td> <td width="60%"> The association between the
    ///    <i>pwszVolumeName</i> and <i>pwszDiffAreaVolumeName</i> volumes already exists. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Expected provider error.
    ///    The provider logged the error in the event log. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VSS_E_VOLUME_NOT_SUPPORTED</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pwszDiffAreaVolumeName</i> volume is not an NTFS volume or has insufficient free space. </td> </tr>
    ///    </table>
    ///    
    HRESULT AddDiffArea(ushort* pwszVolumeName, ushort* pwszDiffAreaVolumeName, long llMaximumDiffSpace);
    ///The <b>ChangeDiffAreaMaximumSize</b> method updates the shadow copy storage area maximum size for a certain
    ///volume. This may not have an immediate effect.
    ///Params:
    ///    pwszVolumeName = Name of the volume that is the source of shadow copies. This volume is associated with a shadow copy storage
    ///                     area on the <i>pwszDiffAreaVolumeName</i> volume. The name of the volume must be in one of the following
    ///                     formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for example,
    ///                     Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    pwszDiffAreaVolumeName = Name of the volume that contains the shadow copy storage area associated with the <i>pwszVolumeName</i>
    ///                             volume. The name of the volume must be in one of the following formats and must include a trailing backslash
    ///                             (\\): <ul> <li>The path of a mounted folder</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID
    ///                             path of the form \\?&
    ///    llMaximumDiffSpace = Specifies the maximum size, in bytes, for the shadow copy storage area to use for the volume. If this value
    ///                         is zero, the shadow copy storage area will be deleted. If this value is –1, the maximum size is unlimited.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully changed the shadow copy
    ///    storage area maximum size. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td>
    ///    <td width="60%"> Caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_INSUFFICIENT_STORAGE</b></dt> </dl> </td> <td width="60%"> The <i>pwszDiffAreaVolumeName</i>
    ///    volume does not have sufficient free space. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The association between the
    ///    <i>pwszVolumeName</i> and <i>pwszDiffAreaVolumeName</i> volumes was not found. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider error - the
    ///    provider logged the error in the event log. For more information, see Event and Error Handling Under VSS.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%">
    ///    Unexpected error. The error code is logged in the error log file. For more information, see Event and Error
    ///    Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value
    ///    is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VSS_E_VOLUME_IN_USE</b></dt> </dl> </td> <td width="60%"> A shadow copy is
    ///    currently using the shadow copy storage area. </td> </tr> </table>
    ///    
    HRESULT ChangeDiffAreaMaximumSize(ushort* pwszVolumeName, ushort* pwszDiffAreaVolumeName, 
                                      long llMaximumDiffSpace);
    ///The <b>QueryVolumesSupportedForDiffAreas</b> method queries volumes that support shadow copy storage areas
    ///(including volumes with disabled shadow copy storage areas).
    ///Params:
    ///    pwszOriginalVolumeName = Name of the original volume that is the source of the shadow copies. The name of the volume must be in one of
    ///                             the following formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for
    ///                             example, Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    ppEnum = The address of an IVssEnumMgmtObject interface pointer, which is initialized on return. Callers must release
    ///             the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully queried the shadow copy
    ///    storage area volumes. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Caller does not have sufficient backup privileges or is not an administrator. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider error - the provider logged the
    ///    error in the event log. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error
    ///    code is logged in the error log file. For more information, see Event and Error Handling Under VSS.
    ///    <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported
    ///    until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT QueryVolumesSupportedForDiffAreas(ushort* pwszOriginalVolumeName, IVssEnumMgmtObject* ppEnum);
    ///The <b>QueryDiffAreasForVolume</b> method queries shadow copy storage areas in use by the volume.
    ///Params:
    ///    pwszVolumeName = Name of the volume that contains shadow copy storage areas. The name of the volume must be in one of the
    ///                     following formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for
    ///                     example, Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    ppEnum = The address of an IVssEnumMgmtObject interface pointer, which is initialized on return. Callers must release
    ///             the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully queried the shadow copy
    ///    storage areas. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Caller does not have sufficient backup privileges or is not an administrator. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider error - the provider logged the
    ///    error in the event log. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error
    ///    code is logged in the error log file. For more information, see Event and Error Handling Under VSS.
    ///    <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported
    ///    until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT QueryDiffAreasForVolume(ushort* pwszVolumeName, IVssEnumMgmtObject* ppEnum);
    ///The <b>QueryDiffAreasOnVolume</b> method queries shadow copy storage areas that physically reside on the given
    ///volume.
    ///Params:
    ///    pwszVolumeName = Name of the volume that contains shadow copy storage areas. The name of the volume must be in one of the
    ///                     following formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for
    ///                     example, Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    ppEnum = The address of an IVssEnumMgmtObject interface pointer, which is initialized on return. Callers must release
    ///             the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully queried the shadow copy
    ///    storage areas. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Caller does not have sufficient backup privileges or is not an administrator. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider error - the provider logged the
    ///    error in the event log. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error
    ///    code is logged in the error log file. For more information, see Event and Error Handling Under VSS.
    ///    <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported
    ///    until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT QueryDiffAreasOnVolume(ushort* pwszVolumeName, IVssEnumMgmtObject* ppEnum);
    ///The <b>QueryDiffAreasForSnapshot</b> method queries shadow copy storage areas in use by the original volume
    ///associated with the input shadow copy.
    ///Params:
    ///    SnapshotId = The <b>VSS_ID</b> of a shadow copy.
    ///    ppEnum = The address of an IVssEnumMgmtObject interface pointer, which is initialized on return. Callers must release
    ///             the interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> Successfully queried the shadow copy
    ///    storage areas. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> Caller does not have sufficient backup privileges or is not an administrator. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values
    ///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider error - the provider logged the
    ///    error in the event log. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error
    ///    code is logged in the error log file. For more information, see Event and Error Handling Under VSS.
    ///    <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported
    ///    until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT QueryDiffAreasForSnapshot(GUID SnapshotId, IVssEnumMgmtObject* ppEnum);
}

///Defines additional methods that allow applications to query and manage shadow copy storage areas generated by the
///system shadow copy provider. To obtain an instance of the <b>IVssDifferentialSoftwareSnapshotMgmt2</b> interface,
///call the QueryInterface method of the IVssDifferentialSoftwareSnapshotMgmt interface, and pass the
///<b>IID_IVssDifferentialSoftwareSnapshotMgmt2</b> constant as the interface identifier (IID) parameter.
@GUID("949D7353-675F-4275-8969-F044C6277815")
interface IVssDifferentialSoftwareSnapshotMgmt2 : IVssDifferentialSoftwareSnapshotMgmt
{
    ///Updates the shadow copy storage area maximum size for a certain volume. This may not have an immediate effect. If
    ///the <i>bVolatile</i> parameter is <b>FALSE</b>, the change continues even if the computer is rebooted.
    ///Params:
    ///    pwszVolumeName = The name of the volume that is the source of shadow copies. This volume is associated with a shadow copy
    ///                     storage area on the <i>pwszDiffAreaVolumeName</i> volume. The name of the volume must be in one of the
    ///                     following formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for
    ///                     example, Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    pwszDiffAreaVolumeName = The name of the volume that contains the shadow copy storage area that is associated with the
    ///                             <i>pwszVolumeName</i> volume. The name of the volume must be in one of the following formats and must include
    ///                             a trailing backslash (\\): <ul> <li>The path of a mounted folder</li> <li>A drive letter with, for example,
    ///                             D:\</li> <li>A volume GUID path of the form \\?&
    ///    llMaximumDiffSpace = Specifies the maximum size, in bytes, for the shadow copy storage area to use for the volume. If this value
    ///                         is zero, the shadow copy storage area will be deleted. If this value is –1, the maximum size is unlimited.
    ///    bVolatile = TRUE to indicate that the effect of calling the <b>ChangeDiffAreaMaximumSizeEx</b> method should not continue
    ///                if the computer is rebooted; otherwise, <b>FALSE</b>. The default value is <b>FALSE</b>. If the
    ///                <i>llMaximumDiffSpace</i> parameter is zero, the <i>bVolatile</i> parameter must be <b>FALSE</b>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The shadow copy storage area maximum size
    ///    was successfully changed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td>
    ///    <td width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl>
    ///    </td> <td width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_INSUFFICIENT_STORAGE</b></dt> </dl> </td> <td width="60%"> The
    ///    <i>pwszDiffAreaVolumeName</i> volume does not have sufficient free space. </td> </tr> <tr> <td width="40%">
    ///    <dl> <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The association between the
    ///    <i>pwszVolumeName</i> and <i>pwszDiffAreaVolumeName</i> volumes was not found. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> An expected provider error
    ///    has occurred. The error code is logged in the event log. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_VOLUME_IN_USE</b></dt> </dl> </td> <td width="60%"> A
    ///    shadow copy is currently using the shadow copy storage area. </td> </tr> </table>
    ///    
    HRESULT ChangeDiffAreaMaximumSizeEx(ushort* pwszVolumeName, ushort* pwszDiffAreaVolumeName, 
                                        long llMaximumDiffSpace, BOOL bVolatile);
    ///Not supported. This method is reserved for future use.
    ///Params:
    ///    pwszVolumeName = 
    ///    pwszDiffAreaVolumeName = 
    ///    pwszNewDiffAreaVolumeName = 
    HRESULT MigrateDiffAreas(ushort* pwszVolumeName, ushort* pwszDiffAreaVolumeName, 
                             ushort* pwszNewDiffAreaVolumeName);
    ///Not supported. This method is reserved for future use.
    ///Params:
    ///    pwszVolumeName = 
    ///    pwszDiffAreaVolumeName = 
    ///    ppAsync = 
    HRESULT QueryMigrationStatus(ushort* pwszVolumeName, ushort* pwszDiffAreaVolumeName, IVssAsync* ppAsync);
    ///Not supported. This method is reserved for future use.
    ///Params:
    ///    idSnapshot = 
    ///    priority = 
    HRESULT SetSnapshotPriority(GUID idSnapshot, ubyte priority);
}

///Defines methods that allow applications to use the shadow copy protection feature of VSS. To obtain an instance of
///the <b>IVssDifferentialSoftwareSnapshotMgmt3</b> interface, call the QueryInterface method of the
///IVssDifferentialSoftwareSnapshotMgmt interface and pass the <b>IID_IVssDifferentialSoftwareSnapshotMgmt3</b> constant
///as the interface identifier (IID) parameter.
@GUID("383F7E71-A4C5-401F-B27F-F826289F8458")
interface IVssDifferentialSoftwareSnapshotMgmt3 : IVssDifferentialSoftwareSnapshotMgmt2
{
    ///Sets the shadow copy protection level for an original volume or a shadow copy storage area volume.
    ///Params:
    ///    pwszVolumeName = The name of the volume. This parameter is required and cannot be <b>NULL</b>. The name must be in one of the
    ///                     following formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for
    ///                     example, Y:\MountX\</li> <li>A drive letter, for example, D:\ </li> <li>A volume GUID path in the form \\?&
    ///    protectionLevel = A value from the VSS_PROTECTION_LEVEL enumeration that specifies the shadow copy protection level.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The shadow copy protection level
    ///    was set successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    <dt>0x80070005L</dt> </dl> </td> <td width="60%"> The caller is not an administrator. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt>
    ///    <dt>0x80000001L</dt> </dl> </td> <td width="60%"> The provider for the volume does not support shadow copy
    ///    protection. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> <dt>0x80042306L</dt>
    ///    </dl> </td> <td width="60%"> An expected provider error has occurred. The error code is logged in the event
    ///    log. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The specified volume
    ///    was not found. </td> </tr> </table>
    ///    
    HRESULT SetVolumeProtectLevel(ushort* pwszVolumeName, VSS_PROTECTION_LEVEL protectionLevel);
    ///Gets the shadow copy protection level and status for the specified volume.
    ///Params:
    ///    pwszVolumeName = The name of the volume. This parameter is required and cannot be <b>NULL</b>. The name must be in one of the
    ///                     following formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for
    ///                     example, Y:\MountX\</li> <li>A drive letter, for example, D:\ </li> <li>A volume GUID path in the form \\?&
    ///    protectionLevel = The address of a caller-allocated buffer that receives a VSS_VOLUME_PROTECTION_INFO structure containing
    ///                      information about the volume's shadow copy protection level.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The shadow copy protection level
    ///    was queried successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    <dt>0x80070005L</dt> </dl> </td> <td width="60%"> The caller is not an administrator. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt>
    ///    <dt>0x80000001L</dt> </dl> </td> <td width="60%"> The provider for the volume does not support shadow copy
    ///    protection. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> <dt>0x80042306L</dt>
    ///    </dl> </td> <td width="60%"> An expected provider error has occurred. The error code is logged in the event
    ///    log. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The specified volume
    ///    was not found. </td> </tr> </table>
    ///    
    HRESULT GetVolumeProtectLevel(ushort* pwszVolumeName, VSS_VOLUME_PROTECTION_INFO* protectionLevel);
    ///Clears the protection fault state for the specified volume.
    ///Params:
    ///    pwszVolumeName = The name of the volume. This parameter is required and cannot be <b>NULL</b>. The name must be in one of the
    ///                     following formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for
    ///                     example, Y:\MountX\</li> <li>A drive letter, for example, D:\ </li> <li>A volume GUID path in the form \\?&
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The protection fault state was
    ///    cleared successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    <dt>0x80070005L</dt> </dl> </td> <td width="60%"> The caller is not an administrator. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt>
    ///    <dt>0x80000001L</dt> </dl> </td> <td width="60%"> The provider for the volume does not support shadow copy
    ///    protection. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> <dt>0x80042306L</dt>
    ///    </dl> </td> <td width="60%"> An expected provider error has occurred. The error code is logged in the event
    ///    log. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The specified volume
    ///    was not found. </td> </tr> </table>
    ///    
    HRESULT ClearVolumeProtectFault(ushort* pwszVolumeName);
    ///Deletes all shadow copy storage areas (also called diff areas) on the specified volume that are not in use.
    ///Params:
    ///    pwszDiffAreaVolumeName = The name of the volume. This parameter is required and cannot be <b>NULL</b>. The name must be in one of the
    ///                             following formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for
    ///                             example, Y:\MountX\</li> <li>A drive letter, for example, D:\ </li> <li>A volume GUID path in the form \\?&
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The shadow copy storage areas
    ///    were successfully deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    <dt>0x80070005L</dt> </dl> </td> <td width="60%"> The caller is not an administrator. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the
    ///    parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_NOTIMPL</b></dt>
    ///    <dt>0x80000001L</dt> </dl> </td> <td width="60%"> The provider for the volume does not support shadow copy
    ///    protection. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> <dt>0x80042306L</dt>
    ///    </dl> </td> <td width="60%"> An expected provider error has occurred. The error code is logged in the event
    ///    log. For more information, see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The specified volume
    ///    was not found. </td> </tr> </table>
    ///    
    HRESULT DeleteUnusedDiffAreas(ushort* pwszDiffAreaVolumeName);
    ///Not supported. This method is reserved for future use.
    ///Params:
    ///    idSnapshotOlder = 
    ///    idSnapshotYounger = 
    ///    pcBlockSizePerBit = 
    ///    pcBitmapLength = 
    ///    ppbBitmap = 
    HRESULT QuerySnapshotDeltaBitmap(GUID idSnapshotOlder, GUID idSnapshotYounger, uint* pcBlockSizePerBit, 
                                     uint* pcBitmapLength, ubyte** ppbBitmap);
}

///The <b>IVssEnumMgmtObject</b> interface contains methods to iterate over and perform other operations on a list of
///enumerated objects. The calling application is responsible for calling IUnknown::Release to release the resources
///held by the returned <b>IVssEnumMgmtObject</b> when it is no longer needed. It may also need to call
///<b>IUnknown::Release</b> to release temporary objects (such as strings) returned during enumeration. The
///IVssDifferentialSoftwareSnapshotMgmt::QueryDiffAreasForSnapshot,
///IVssDifferentialSoftwareSnapshotMgmt::QueryDiffAreasForVolume,
///IVssDifferentialSoftwareSnapshotMgmt::QueryDiffAreasOnVolume, and
///IVssDifferentialSoftwareSnapshotMgmt::QueryVolumesSupportedForDiffAreas methods return an <b>IVssEnumMgmtObject</b>
///object.
@GUID("01954E6B-9254-4E6E-808C-C9E05D007696")
interface IVssEnumMgmtObject : IUnknown
{
    ///The <b>Next</b> method returns the specified number of objects from the specified list of enumerated objects.
    ///Params:
    ///    celt = The number of elements to be read from the list of enumerated objects into the <i>rgelt</i> buffer.
    ///    rgelt = The address of a caller-allocated buffer that receives <i>celt</i>VSS_MGMT_OBJECT_PROP structures that
    ///            contain the returned objects. This parameter is required and cannot be <b>NULL</b>.
    ///    pceltFetched = The number of elements that were returned in the <i>rgelt</i> buffer.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Next(uint celt, VSS_MGMT_OBJECT_PROP* rgelt, uint* pceltFetched);
    ///The <b>Skip</b> method skips the specified number of objects.
    ///Params:
    ///    celt = Number of elements to be skipped in the list of enumerated objects.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Skip(uint celt);
    ///The <b>Reset</b> method resets the enumerator so that IVssEnumMgmtObject starts at the first enumerated object.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Reset();
    ///The <b>Clone</b> method creates a copy of the specified list of enumerated elements by creating a copy of the
    ///IVssEnumMgmtObject enumerator object.
    ///Params:
    ///    ppenum = Address of an IVssEnumMgmtObject interface pointer. Set the value of this parameter to <b>NULL</b> before
    ///             calling this method.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT Clone(IVssEnumMgmtObject* ppenum);
}

///The <b>IVssAdmin</b> interface manages providers registered with VSS.
@GUID("77ED5996-2F63-11D3-8A39-00C04F72D8E3")
interface IVssAdmin : IUnknown
{
    ///The <b>RegisterProvider</b> method registers a new shadow copy provider.
    ///Params:
    ///    pProviderId = The <b>VSS_ID</b> that uniquely and persistently identifies the provider. After it is defined, the
    ///                  <i>ProviderId</i> parameter should remain the same, even when the software revision is updated. A
    ///                  <i>ProviderId</i> parameter should be changed only when the functionality changes enough that both providers
    ///                  would be active on the same system. A requester may use the <i>ProviderId</i> parameter to request that a
    ///                  specific provider be used in a shadow copy creation.
    ///    ClassId = The CLSID of the provider.
    ///    pwszProviderName = The name of the provider.
    ///    eProviderType = A VSS_PROVIDER_TYPE enumeration value that specifies the provider type. Note that <b>VSS_PROV_HARDWARE</b> is
    ///                    not a valid provider type on Windows client operating system versions. Hardware providers will run only on
    ///                    Windows server operating system versions.
    ///    pwszProviderVersion = The version of the provider.
    ///    ProviderVersionId = The <b>VSS_ID</b> that uniquely identifies this version of the provider. The combination of the
    ///                        <i>pProviderId</i> and <i>ProviderVersionId</i> parameters should be unique. The <i>ProviderVersionId</i>
    ///                        parameter can be the same as the <i>ProviderVersionId</i> parameter of another provider.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The provider was registered
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td
    ///    width="60%"> One or more of the parameter values is not valid. For example, <b>VSS_PROV_HARDWARE</b> is not a
    ///    valid provider type on Windows client operating system versions. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> </dl> </td> <td width="60%"> Out of memory or other system resources.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_ACCESSDENIED</b></b></dt> </dl> </td> <td width="60%"> The
    ///    caller is not an administrator. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_ALREADY_REGISTERED</b></b></dt> </dl> </td> <td width="60%"> The provider has
    ///    already been registered on this computer. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error code is logged in
    ///    the error log file. For more information, see Event and Error Handling Under VSS. <b>Windows Server 2008,
    ///    Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008
    ///    R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT RegisterProvider(GUID pProviderId, GUID ClassId, ushort* pwszProviderName, 
                             VSS_PROVIDER_TYPE eProviderType, ushort* pwszProviderVersion, GUID ProviderVersionId);
    ///The <b>UnregisterProvider</b> method unregisters an existing provider.
    ///Params:
    ///    ProviderId = The <b>VSS_ID</b> of the provider.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The provider was unregistered
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_PROVIDER_IN_USE</b></b></dt> </dl> </td>
    ///    <td width="60%"> The provider is in use. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_NOT_REGISTERED</b></b></dt> </dl> </td> <td width="60%"> The provider is not
    ///    registered. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_OUTOFMEMORY</b></b></dt> </dl> </td> <td
    ///    width="60%"> Out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error code is logged in
    ///    the error log file. For more information, see Event and Error Handling Under VSS. <b>Windows Server 2008,
    ///    Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008
    ///    R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> </table>
    ///    
    HRESULT UnregisterProvider(GUID ProviderId);
    ///The <b>QueryProviders</b> method queries all registered providers.
    ///Params:
    ///    ppEnum = The address of an IVssEnumObject interface pointer, which is initialized on return. Callers must release the
    ///             interface.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> </dl> </td> <td width="60%"> The query was returned
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_INVALIDARG</b></b></dt> </dl> </td> <td
    ///    width="60%"> One or more of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> </dl> </td> <td width="60%"> Out of memory or other system resources.
    ///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_ACCESSDENIED</b></b></dt> </dl> </td> <td width="60%"> The
    ///    caller is not an administrator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_UNEXPECTED</b></b></dt>
    ///    </dl> </td> <td width="60%"> An unexpected error occurred. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_OBJECT_NOT_FOUND</b></b></dt> </dl> </td> <td width="60%"> An unexpected provider error
    ///    occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td
    ///    width="60%"> Expected provider error. The provider logged the error in the event log. For more information,
    ///    see Event and Error Handling Under VSS. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td width="60%"> Unexpected error. The error code is logged in
    ///    the error log file. For more information, see Event and Error Handling Under VSS. <b>Windows Server 2008,
    ///    Windows Vista, Windows Server 2003 and Windows XP: </b>This value is not supported until Windows Server 2008
    ///    R2 and Windows 7. E_UNEXPECTED is used instead. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_UNEXPECTED_PROVIDER_ERROR</b></dt> </dl> </td> <td width="60%"> Unexpected provider error. The
    ///    error code is logged in the error log. For more information, see Event and Error Handling Under VSS. </td>
    ///    </tr> </table>
    ///    
    HRESULT QueryProviders(IVssEnumObject* ppEnum);
    ///Not supported. This method is reserved for system use.
    HRESULT AbortAllSnapshotsInProgress();
}

@GUID("7858A9F8-B1FA-41A6-964F-B9B36B8CD8D8")
interface IVssAdminEx : IVssAdmin
{
    HRESULT GetProviderCapability(GUID pProviderId, ulong* pllOriginalCapabilityMask);
    HRESULT GetProviderContext(GUID ProviderId, int* plContext);
    HRESULT SetProviderContext(GUID ProviderId, int lContext);
}

///Contains the methods used by VSS to manage shadow copy volumes. All software providers must support this interface.
@GUID("609E123E-2C5A-44D3-8F01-0B1D9A47D1FF")
interface IVssSoftwareSnapshotProvider : IUnknown
{
    ///Sets the context for subsequent shadow copy-related operations.
    ///Params:
    ///    lContext = The context to be set. The context must be one of the supported values of _VSS_SNAPSHOT_CONTEXT or a
    ///               supported combination of _VSS_VOLUME_SNAPSHOT_ATTRIBUTES and <b>_VSS_SNAPSHOT_CONTEXT</b> values.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The context was set
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> The context is frozen and cannot be changed.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetContext(int lContext);
    ///Gets the properties of the specified shadow copy.
    ///Params:
    ///    SnapshotId = Shadow copy identifier.
    ///    pProp = The address of a caller-allocated VSS_SNAPSHOT_PROP structure that receives the shadow copy properties. The
    ///            provider is responsible for setting the members of this structure. All members are required except
    ///            <b>m_pwszExposedName</b> and <b>m_pwszExposedPath</b>, which the provider can set to <b>NULL</b>. The
    ///            provider allocates memory for all string members that it sets in the structure. When the structure is no
    ///            longer needed, the caller is responsible for freeing these strings by calling the VssFreeSnapshotProperties
    ///            function.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The requested information was
    ///    successfully returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified volume was not found. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider
    ///    error. The provider logged the error in the event log. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> </table>
    ///    
    HRESULT GetSnapshotProperties(GUID SnapshotId, VSS_SNAPSHOT_PROP* pProp);
    ///Queries the provider for information about the shadow copies that the provider has completed.
    ///Params:
    ///    QueriedObjectId = Reserved for system use. The value of this parameter must be GUID_NULL.
    ///    eQueriedObjectType = Reserved for system use. The value of this parameter must be VSS_OBJECT_NONE.
    ///    eReturnedObjectsType = Reserved for system use. The value of this parameter must be VSS_OBJECT_SNAPSHOT.
    ///    ppEnum = The address of an IVssEnumObject interface pointer, which is initialized on return. Callers must release the
    ///             interface. This parameter is required and cannot be null.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The query operation was
    ///    successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider error. The provider logged the
    ///    error in the event log. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT Query(GUID QueriedObjectId, VSS_OBJECT_TYPE eQueriedObjectType, VSS_OBJECT_TYPE eReturnedObjectsType, 
                  IVssEnumObject* ppEnum);
    ///Deletes one or more shadow copies or a shadow copy set.
    ///Params:
    ///    SourceObjectId = Identifier of the shadow copy or shadow copy set to be deleted.
    ///    eSourceObjectType = Type of the object to be deleted. The value of this parameter is VSS_OBJECT_SNAPSHOT or
    ///                        VSS_OBJECT_SNAPSHOT_SET.
    ///    bForceDelete = If the value of this parameter is <b>TRUE</b>, the provider will do everything possible to delete the shadow
    ///                   copy or shadow copies in a shadow copy set. If it is <b>FALSE</b>, no additional effort will be made.
    ///    plDeletedSnapshots = Pointer to a variable that receives the number of shadow copies that were deleted.
    ///    pNondeletedSnapshotID = If an error occurs, this parameter receives a pointer to the identifier of the first shadow copy that could
    ///                            not be deleted. Otherwise, it points to GUID_NULL.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The shadow copies were
    ///    successfully deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified shadow copies were not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td
    ///    width="60%"> Provider error. The provider logged the error in the event log. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT DeleteSnapshots(GUID SourceObjectId, VSS_OBJECT_TYPE eSourceObjectType, BOOL bForceDelete, 
                            int* plDeletedSnapshots, GUID* pNondeletedSnapshotID);
    ///VSS calls this method for each shadow copy that is added to the shadow copy set.
    ///Params:
    ///    SnapshotSetId = Shadow copy set identifier.
    ///    SnapshotId = Identifier of the shadow copy to be created.
    ///    pwszVolumeName = Null-terminated wide character string containing the volume name. The name must be in one of the following
    ///                     formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for example,
    ///                     Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    lNewContext = The context for the shadow copy set. This context consists of a bitmask of _VSS_VOLUME_SNAPSHOT_ATTRIBUTES
    ///                  values.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The shadow copy was successfully
    ///    created. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%">
    ///    The caller does not have sufficient backup privileges or is not an administrator. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified volume was not found. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider
    ///    error. The provider logged the error in the event log. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNSUPPORTED_CONTEXT</b></dt> </dl> </td> <td
    ///    width="60%"> The specified context is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER</b></dt> </dl> </td> <td width="60%"> The provider does not
    ///    support the specified volume. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> Unexpected error. The error code is logged in the error log file. For more
    ///    information, see Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server
    ///    2003 and Windows XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED
    ///    is used instead. </td> </tr> </table>
    ///    
    HRESULT BeginPrepareSnapshot(GUID SnapshotSetId, GUID SnapshotId, ushort* pwszVolumeName, int lNewContext);
    ///Determines whether the provider supports shadow copies on the specified volume.
    ///Params:
    ///    pwszVolumeName = Null-terminated wide character string containing the volume name. The name must be in one of the following
    ///                     formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for example,
    ///                     Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    pbSupportedByThisProvider = This parameter receives <b>TRUE</b> if shadow copies are supported on the specified volume, otherwise
    ///                                <b>FALSE</b>.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The requested information was
    ///    successfully returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_NESTED_VOLUME_LIMIT</b></dt> </dl>
    ///    </td> <td width="60%"> The specified volume is nested too deeply to participate in the VSS operation.
    ///    <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This return code is not
    ///    supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified volume was not found. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider
    ///    error. The provider logged the error in the event log. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> </table>
    ///    
    HRESULT IsVolumeSupported(ushort* pwszVolumeName, BOOL* pbSupportedByThisProvider);
    ///Determines whether any shadow copies exist for the specified volume.
    ///Params:
    ///    pwszVolumeName = Null-terminated wide character string containing the volume name. The name must be in one of the following
    ///                     formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for example,
    ///                     Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    pbSnapshotsPresent = This parameter receives <b>TRUE</b> if the volume has a shadow copy, or <b>FALSE</b> if the volume does not
    ///                         have a shadow copy.
    ///    plSnapshotCompatibility = A bitmask of VSS_SNAPSHOT_COMPATIBILITY values that indicate whether certain volume control or file I/O
    ///                              operations are disabled for the given volume, if the volume has a shadow copy.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The requested information was
    ///    successfully returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified volume was not found. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider
    ///    error. The provider logged the error in the event log. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> </table>
    ///    
    HRESULT IsVolumeSnapshotted(ushort* pwszVolumeName, BOOL* pbSnapshotsPresent, int* plSnapshotCompatibility);
    ///Sets a property for a shadow copy.
    ///Params:
    ///    SnapshotId = Shadow copy identifier. This parameter is required and cannot be GUID_NULL.
    ///    eSnapshotPropertyId = A VSS_SNAPSHOT_PROPERTY_ID value that specifies the property to be set for the shadow copy.
    ///    vProperty = The value to be set for the property. See the VSS_SNAPSHOT_PROP structure for valid data types and
    ///                descriptions of the properties that can be set for a shadow copy.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The property was set
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified shadow copy was not found.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetSnapshotProperty(GUID SnapshotId, VSS_SNAPSHOT_PROPERTY_ID eSnapshotPropertyId, VARIANT vProperty);
    ///Reverts a volume to a previous shadow copy. Only shadow copies created with persistent contexts
    ///(VSS_CTX_APP_ROLLBACK, VSS_CTX_CLIENT_ACCESSIBLE, VSS_CTX_CLIENT_ACCESSIBLE_WRITERS, or VSS_CTX_NAS_ROLLBACK) are
    ///supported.
    ///Params:
    ///    SnapshotId = Shadow copy identifier of the shadow copy to revert.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The revert operation was
    ///    successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_REVERT_IN_PROGRESS</b></b></dt> </dl> </td> <td width="60%"> The volume already has a revert
    ///    operation in process. </td> </tr> </table>
    ///    
    HRESULT RevertToSnapshot(GUID SnapshotId);
    ///Returns an IVssAsync interface pointer that can be used to determine the status of the revert operation.
    ///Params:
    ///    pwszVolume = Null-terminated wide character string containing the volume name. The name must be in one of the following
    ///                 formats and must include a trailing backslash (\\): <ul> <li>The path of a mounted folder, for example,
    ///                 Y:\MountX\</li> <li>A drive letter, for example, D:\</li> <li>A volume GUID path of the form \\?&
    ///    ppAsync = Pointer to a location that will receive an IVssAsync interface pointer that can be used to retrieve the
    ///              status of the revert operation. When the operation is complete, the caller must release the interface pointer
    ///              by calling the IUnknown::Release method.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The status of the revert
    ///    operation was successfully queried. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt>
    ///    </dl> </td> <td width="60%"> The caller does not have sufficient backup privileges or is not an
    ///    administrator. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td
    ///    width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%"> The caller is out of memory or other system
    ///    resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_OBJECT_NOT_FOUND</b></b></dt> </dl> </td>
    ///    <td width="60%"> The <i>pwszVolume</i> parameter does not specify a valid volume. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b><b>VSS_E_VOLUME_NOT_SUPPORTED</b></b></dt> </dl> </td> <td width="60%"> The revert
    ///    operation is not supported on this volume. </td> </tr> </table>
    ///    
    HRESULT QueryRevertStatus(ushort* pwszVolume, IVssAsync* ppAsync);
}

///The <b>IVssProviderCreateSnapshotSet</b> interface contains the methods used during shadow copy creation.
@GUID("5F894E5B-1E39-4778-8E23-9ABAD9F0E08C")
interface IVssProviderCreateSnapshotSet : IUnknown
{
    ///The <b>EndPrepareSnapshots</b> method is called once for the complete shadow copy set, after the last
    ///IVssHardwareSnapshotProvider::BeginPrepareSnapshot call. This method is intended as a point where the provider
    ///can wait for any shadow copy preparation work to complete. Because <b>EndPrepareSnapshots</b> may take a long
    ///time to complete, a provider should be prepared to accept an AbortSnapshots method call at any time and
    ///immediately end the preparation work.
    ///Params:
    ///    SnapshotSetId = The <b>VSS_ID</b> of the shadow copy set.
    ///Returns:
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The operation was successfully
    ///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt>
    ///    </dl> </td> <td width="60%"> Out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_INSUFFICIENT_STORAGE</b></b></dt>
    ///    <dt>0x8004231FL</dt> </dl> </td> <td width="60%"> There is not enough disk storage to create a shadow copy.
    ///    Insufficient disk space can also generate <b>VSS_E_PROVIDER_VETO</b> or <b>VSS_E_OBJECT_NOT_FOUND</b> error
    ///    return values. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_OBJECT_NOT_FOUND</b></b></dt>
    ///    <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The <i>SnapshotSetId</i> parameter refers to an object that
    ///    was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt>
    ///    <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected provider error occurred. If this is returned,
    ///    the error must be described in an entry in the application event log, giving the user information on how to
    ///    resolve the problem. </td> </tr> </table> If any other value is returned, VSS will write an event to the
    ///    event log and convert the error to <b>VSS_E_UNEXPECTED_PROVIDER_ERROR</b>.
    ///    
    HRESULT EndPrepareSnapshots(GUID SnapshotSetId);
    ///The <b>PreCommitSnapshots</b> method ensures the provider is ready to quickly commit the prepared LUNs. This
    ///happens immediately before the flush-and-hold writes, but while applications are in a frozen state. During this
    ///call the provider should prepare all shadow copies in the shadow copy set indicated by <i>SnapshotSetId</i> for
    ///committing by the CommitSnapshots method call that will follow. While the provider is processing this method, the
    ///applications have been frozen, so the time spent in this method should be minimized.
    ///Params:
    ///    SnapshotSetId = The <b>VSS_ID</b> that identifies the shadow copy set.
    ///Returns:
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The operation was successfully
    ///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt>
    ///    </dl> </td> <td width="60%"> Out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_OBJECT_NOT_FOUND</b></b></dt>
    ///    <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The <i>SnapshotSetId</i> parameter refers to an object that
    ///    was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt>
    ///    <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected provider error occurred. If this is returned,
    ///    the error must be described in an entry in the application event log, giving the user information on how to
    ///    resolve the problem. </td> </tr> </table> If any other value is returned, VSS will write an event to the
    ///    event log and convert the error to <b>VSS_E_UNEXPECTED_PROVIDER_ERROR</b>.
    ///    
    HRESULT PreCommitSnapshots(GUID SnapshotSetId);
    ///The <b>CommitSnapshots</b> method quickly commits all LUNs in this provider.
    ///Params:
    ///    SnapshotSetId = The <b>VSS_ID</b> that identifies the shadow copy set.
    ///Returns:
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The operation was successfully
    ///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt>
    ///    </dl> </td> <td width="60%"> Out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_OBJECT_NOT_FOUND</b></b></dt>
    ///    <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The <i>SnapshotSetId</i> parameter refers to an object that
    ///    was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt>
    ///    <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected provider error occurred. The provider must
    ///    log the details of this error in the application event log. </td> </tr> </table> If any other value is
    ///    returned, VSS will write an event to the event log and convert the error to
    ///    <b>VSS_E_UNEXPECTED_PROVIDER_ERROR</b>.
    ///    
    HRESULT CommitSnapshots(GUID SnapshotSetId);
    ///The <b>PostCommitSnapshots</b> method is called after all providers involved in the shadow copy set have
    ///succeeded with CommitSnapshots. The lock on the I/O system has been lifted, but the applications have not yet
    ///been unfrozen. This is an opportunity for the provider to perform additional cleanup work after the shadow copy
    ///commit.
    ///Params:
    ///    SnapshotSetId = The <b>VSS_ID</b> that identifies the shadow copy set.
    ///    lSnapshotsCount = Count of shadow copies in the shadow copy set.
    ///Returns:
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The operation was successfully
    ///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt>
    ///    </dl> </td> <td width="60%"> Out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_OBJECT_NOT_FOUND</b></b></dt>
    ///    <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The <i>SnapshotSetId</i> parameter refers to an object that
    ///    was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt>
    ///    <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected provider error occurred. If this is returned,
    ///    the error must be described in an entry in the application event log, giving the user information on how to
    ///    resolve the problem. </td> </tr> </table> If any other value is returned, VSS will write an event to the
    ///    event log and convert the error to <b>VSS_E_UNEXPECTED_PROVIDER_ERROR</b>.
    ///    
    HRESULT PostCommitSnapshots(GUID SnapshotSetId, int lSnapshotsCount);
    ///The <b>PreFinalCommitSnapshots</b> method enables providers to support auto-recover shadow copies. If the shadow
    ///copy has the <b>VSS_VOLSNAP_ATTR_AUTORECOVER</b> flag set in the context, the volume can receive a large number
    ///of writes during the auto-recovery operation.
    ///Params:
    ///    SnapshotSetId = The <b>VSS_ID</b> that identifies the shadow copy set.
    ///Returns:
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The operation was successfully
    ///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt>
    ///    </dl> </td> <td width="60%"> Out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt>
    ///    <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected provider error occurred. If this is returned,
    ///    the error must be described in an entry in the application event log, giving the user information on how to
    ///    resolve the problem. </td> </tr> </table> If any other value is returned, VSS will write an event to the
    ///    event log and convert the error to <b>VSS_E_UNEXPECTED_PROVIDER_ERROR</b>.
    ///    
    HRESULT PreFinalCommitSnapshots(GUID SnapshotSetId);
    ///The <b>PostFinalCommitSnapshots</b> method supports auto-recover shadow copies. VSS calls this method to notify
    ///the provider that the volume will now be read-only until a requester calls
    ///IVssBackupComponents::BreakSnapshotSet.
    ///Params:
    ///    SnapshotSetId = The <b>VSS_ID</b> that identifies the shadow copy set.
    ///Returns:
    ///    <table> <tr> <th>Return code/value</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The operation was successfully
    ///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt>
    ///    </dl> </td> <td width="60%"> Out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of the parameter values is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt>
    ///    <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected provider error occurred. If this is returned,
    ///    the error must be described in an entry in the application event log, giving the user information on how to
    ///    resolve the problem. </td> </tr> </table> If any other value is returned, VSS will write an event to the
    ///    event log and convert the error to <b>VSS_E_UNEXPECTED_PROVIDER_ERROR</b>.
    ///    
    HRESULT PostFinalCommitSnapshots(GUID SnapshotSetId);
    ///The <b>AbortSnapshots</b> method aborts prepared shadow copies in this provider. This includes all non-committed
    ///shadow copies and pre-committed ones.
    ///Params:
    ///    SnapshotSetId = The <b>VSS_ID</b> that identifies the shadow copy set.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td
    ///    width="60%"> The operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other
    ///    system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt>
    ///    </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_OBJECT_NOT_FOUND</b></b></dt> <dt>0x80042308L</dt> </dl> </td> <td width="60%"> The
    ///    <i>SnapshotSetId</i> parameter refers to an object that was not found. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt> <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected
    ///    provider error occurred. The provider must log a message in the application event log providing the user with
    ///    information on how to resolve the problem. </td> </tr> </table>
    ///    
    HRESULT AbortSnapshots(GUID SnapshotSetId);
}

///The <b>IVssProviderNotifications</b> interface manages providers registered with VSS.
@GUID("E561901F-03A5-4AFE-86D0-72BAEECE7004")
interface IVssProviderNotifications : IUnknown
{
    ///The <b>OnLoad</b> method notifies a provider that it was loaded.
    ///Params:
    ///    pCallback = This parameter is reserved.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td
    ///    width="60%"> The operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other
    ///    system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt>
    ///    </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt> <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected
    ///    provider error occurred. If this is returned, the error must be described in an entry in the application
    ///    event log, giving the user information on how to resolve the problem. </td> </tr> </table>
    ///    
    HRESULT OnLoad(IUnknown pCallback);
    ///The <b>OnUnload</b> method notifies the provider to prepare to be unloaded.
    ///Params:
    ///    bForceUnload = If <b>TRUE</b>, the provider must prepare to be released.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td
    ///    width="60%"> There are no pending operations and the provider is ready to be released. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>S_FALSE</b></dt> <dt>0x00000001L</dt> </dl> </td> <td width="60%"> The provider
    ///    should not be unloaded. This value can only be returned if <i>bForceUnload</i> is <b>FALSE</b>. </td> </tr>
    ///    </table>
    ///    
    HRESULT OnUnload(BOOL bForceUnload);
}

///The <b>IVssHardwareSnapshotProvider</b> interface contains the methods used by VSS to map volumes to LUNs, discover
///LUNs created during the shadow copy process, and transport LUNs on a SAN. All hardware providers must support this
///interface. <div class="alert"><b>Note</b> Hardware providers are only supported on Windows Server operating
///systems.</div><div> </div>
@GUID("9593A157-44E9-4344-BBEB-44FBF9B06B10")
interface IVssHardwareSnapshotProvider : IUnknown
{
    ///The <b>AreLunsSupported</b> method determines whether the hardware provider supports shadow copy creation for all
    ///LUNs that contribute to the volume. VSS calls the <b>AreLunsSupported</b> method for each volume that is added to
    ///the shadow copy set. Before calling this method, VSS determines the LUNs that contribute to the volume. For a
    ///specific volume, each LUN can contribute only once. A specific LUN may contribute to multiple volumes. <div
    ///class="alert"><b>Note</b> Hardware providers are only supported on Windows Server operating systems.</div><div>
    ///</div>
    ///Params:
    ///    lLunCount = Count of LUNs contributing to this shadow copy volume.
    ///    lContext = Shadow copy context for the current shadow copy set as enumerated by a bitmask of flags from the
    ///               _VSS_VOLUME_SNAPSHOT_ATTRIBUTES enumeration. If the <b>VSS_VOLSNAP_ATTR_TRANSPORTABLE</b> flag is set, the
    ///               shadow copy set is transportable.
    ///    rgwszDevices = List of devices corresponding to the LUNs to be shadow copied.
    ///    pLunInformation = Array of <i>lLunCount</i>VDS_LUN_INFORMATION structures, one for each LUN contributing to this shadow copy
    ///                      volume.
    ///    pbIsSupported = Pointer to a <b>BOOL</b> value. If all devices are supported for shadow copy, the provider should store a
    ///                    <b>TRUE</b> value at the location pointed to by <i>pbIsSupported</i>.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td
    ///    width="60%"> The operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other
    ///    system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt>
    ///    </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt> <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected
    ///    provider error occurred. The provider must report an event in the application event log providing the user
    ///    with information on how to resolve the problem. </td> </tr> </table>
    ///    
    HRESULT AreLunsSupported(int lLunCount, int lContext, ushort** rgwszDevices, 
                             VDS_LUN_INFORMATION* pLunInformation, BOOL* pbIsSupported);
    ///The <b>FillInLunInfo</b> method prompts the hardware provider to indicate whether it supports the corresponding
    ///disk device and correct any omissions in the VDS_LUN_INFORMATION structure. VSS calls the <b>FillInLunInfo</b>
    ///method after the IVssHardwareSnapshotProvider::LocateLuns method or before the
    ///IVssHardwareSnapshotProvider::OnLunEmpty method to obtain the VDS_LUN_INFORMATION structure associated with a
    ///shadow copy LUN. VSS will compare the <b>VDS_LUN_INFORMATION</b> structure received in the
    ///IVssHardwareSnapshotProvider::GetTargetLuns method to identify shadow copy LUNs. If the structures do not match,
    ///the requester will receive <b>VSS_S_SOME_SNAPSHOTS_NOT_IMPORTED</b>, which indicates a mismatch. <div
    ///class="alert"><b>Note</b> Hardware providers are only supported on Windows Server operating systems.</div><div>
    ///</div>
    ///Params:
    ///    wszDeviceName = Device corresponding to the shadow copy LUN.
    ///    pLunInfo = The VDS_LUN_INFORMATION structure for the shadow copy LUN.
    ///    pbIsSupported = The provider must return <b>TRUE</b> in the location pointed to by the <i>pbIsSupported</i> parameter if the
    ///                    device is supported.
    ///Returns:
    ///    VSS ignores this method's return value. <b>Windows Server 2003: </b>VSS does not ignore the return value,
    ///    which can be one of the following values. <table> <tr> <th>Return code/value</th> <th>Description</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The
    ///    operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other system resources. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt> </dl> </td> <td width="60%"> One of
    ///    the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt>
    ///    <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected provider error has occurred. The provider
    ///    must report an event in the application event log providing the user with information on how to resolve the
    ///    problem. </td> </tr> </table>
    ///    
    HRESULT FillInLunInfo(ushort* wszDeviceName, VDS_LUN_INFORMATION* pLunInfo, BOOL* pbIsSupported);
    ///The <b>BeginPrepareSnapshot</b> method is called for each shadow copy that is added to the shadow copy set. <div
    ///class="alert"><b>Note</b> Hardware providers are only supported on Windows Server operating systems.</div><div>
    ///</div>
    ///Params:
    ///    SnapshotSetId = Shadow copy set identifier.
    ///    SnapshotId = Identifier of the shadow copy to be created.
    ///    lContext = Shadow copy context for current shadow copy set as enumerated by _VSS_VOLUME_SNAPSHOT_ATTRIBUTES.
    ///    lLunCount = Count of LUNs contributing to this shadow copy volume.
    ///    rgDeviceNames = Pointer to array of <i>lLunCount</i> pointers to strings, each string containing the name of a LUN to be
    ///                    shadow copied.
    ///    rgLunInformation = Pointer to array of <i>lLunCount</i>VDS_LUN_INFORMATION structures, one for each LUN contributing to this
    ///                       shadow copy volume.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td
    ///    width="60%"> The operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other
    ///    system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt>
    ///    </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED</b></b></dt> <dt>0x80042312L</dt> </dl> </td> <td
    ///    width="60%"> The provider has reached the maximum number of volumes it can support. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>VSS_E_NESTED_VOLUME_LIMIT</b></dt> </dl> </td> <td width="60%"> The specified volume
    ///    is nested too deeply to participate in the VSS operation. <b>Windows Server 2008, Windows Vista, Windows
    ///    Server 2003 and Windows XP: </b>This return code is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt> <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected
    ///    provider error occurred. The provider must report an event in the application event log providing the user
    ///    with information on how to resolve the problem. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER</b></b></dt> <dt>0x8004230EL</dt> </dl> </td> <td
    ///    width="60%"> The provider does not support this volume. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_UNSUPPORTED_CONTEXT</b></b></dt> <dt>0x8004231BL</dt> </dl> </td> <td width="60%"> The
    ///    context specified by <i>lContext</i> is not supported. </td> </tr> </table>
    ///    
    HRESULT BeginPrepareSnapshot(GUID SnapshotSetId, GUID SnapshotId, int lContext, int lLunCount, 
                                 ushort** rgDeviceNames, VDS_LUN_INFORMATION* rgLunInformation);
    ///The <b>GetTargetLuns</b> method prompts the hardware provider to initialize the VDS_LUN_INFORMATION structures
    ///for the newly created shadow copy LUNs. The <b>GetTargetLuns</b> method is called after the
    ///IVssProviderCreateSnapshotSet::PostCommitSnapshots method. Identifying information for each newly created LUN is
    ///returned to VSS through VDS_LUN_INFORMATION structures. <div class="alert"><b>Note</b> Hardware providers are
    ///only supported on Windows Server operating systems.</div><div> </div>
    ///Params:
    ///    lLunCount = Count of LUNs that contribute to the original volume.
    ///    rgDeviceNames = Pointer to an array of <i>lLunCount</i> pointers to strings. Each string contains the name of an original LUN
    ///                    to be shadow copied.
    ///    rgSourceLuns = Pointer to an array of <i>lLunCount</i>VDS_LUN_INFORMATION structures, one for each LUN that contributes to
    ///                   the original volume.
    ///    rgDestinationLuns = Pointer to an array of <i>lLunCount</i>VDS_LUN_INFORMATION structures, one for each new shadow copy LUN
    ///                        created during shadow copy processing. There should be a one-to-one correspondence between the elements of
    ///                        the <i>rgSourceLuns</i> and <i>rgDestinationLuns</i> arrays.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td
    ///    width="60%"> The operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other
    ///    system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt>
    ///    </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt> <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected
    ///    provider error occurred. The provider must report an event in the application event log providing the user
    ///    with information on how to resolve the problem. </td> </tr> </table>
    ///    
    HRESULT GetTargetLuns(int lLunCount, ushort** rgDeviceNames, VDS_LUN_INFORMATION* rgSourceLuns, 
                          VDS_LUN_INFORMATION* rgDestinationLuns);
    ///The <b>LocateLuns</b> method prompts the hardware provider to make the shadow copy LUNs visible to the computer.
    ///The <b>LocateLuns</b> method is called by VSS when a hardware shadow copy set is imported to a computer. The
    ///provider is responsible for any unmasking (or "surfacing") at the hardware level. <div class="alert"><b>Note</b>
    ///Hardware providers are only supported on Windows Server operating systems.</div><div> </div>
    ///Params:
    ///    lLunCount = Number of LUNs that contribute to this shadow copy set.
    ///    rgSourceLuns = Pointer to an array of <i>iLunCount</i>VDS_LUN_INFORMATION structures, one for each LUN that is part of the
    ///                   shadow copy set to be imported.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td
    ///    width="60%"> The operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other
    ///    system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt>
    ///    </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt> <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected
    ///    provider error occurred. The provider must report an event in the application event log providing the user
    ///    with information on how to resolve the problem. </td> </tr> </table>
    ///    
    HRESULT LocateLuns(int lLunCount, VDS_LUN_INFORMATION* rgSourceLuns);
    ///The <b>OnLunEmpty</b> method is called whenever VSS determines that a shadow copy LUN contains no interesting
    ///data. All shadow copies have been deleted (which also causes deletion of the LUN.) The LUN resources may be
    ///reclaimed by the provider and reused for another purpose. VSS will dismount any affected volumes. A provider
    ///should not issue a rescan during <b>OnLunEmpty</b>. VSS will handle this cleanup. <div class="alert"><b>Note</b>
    ///Hardware providers are only supported on Windows Server operating systems.</div><div> </div>
    ///Params:
    ///    wszDeviceName = Device corresponding to the LUN that contains the shadow copy to be deleted.
    ///    pInformation = Pointer to a VDS_LUN_INFORMATION structure containing information about the LUN containing the shadow copy to
    ///                   be deleted.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td
    ///    width="60%"> The operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other
    ///    system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt>
    ///    </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt> <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected
    ///    provider error occurred. The provider must report an event in the application event log providing the user
    ///    with information on how to resolve the problem. </td> </tr> </table>
    ///    
    HRESULT OnLunEmpty(ushort* wszDeviceName, VDS_LUN_INFORMATION* pInformation);
}

///Provides an additional method used by VSS to notify hardware providers of LUN state changes. All hardware providers
///must support this interface. <div class="alert"><b>Note</b> Hardware providers are only supported on Windows Server
///operating systems.</div><div> </div>
@GUID("7F5BA925-CDB1-4D11-A71F-339EB7E709FD")
interface IVssHardwareSnapshotProviderEx : IVssHardwareSnapshotProvider
{
    ///Not supported. This method is reserved for future use.
    HRESULT GetProviderCapabilities(ulong* pllOriginalCapabilityMask);
    ///The VSS service calls this method to notify hardware providers of a LUN state change. <div
    ///class="alert"><b>Note</b> Hardware providers are only supported on Windows Server operating systems.</div><div>
    ///</div>
    ///Params:
    ///    pSnapshotLuns = A pointer to an array of <i>dwCount</i> VDS_LUN_INFORMATION structures, one for each LUN that contributes to
    ///                    the shadow copy volume.
    ///    pOriginalLuns = A pointer to an array of <i>dwCount</i> VDS_LUN_INFORMATION structures, one for each LUN that contributes to
    ///                    the original volume.
    ///    dwCount = Number of elements in the <i>pSnapshotLuns</i> array. This is also the number of elements in the
    ///              <i>pOriginalLuns</i> array.
    ///    dwFlags = A bitmask of _VSS_HARDWARE_OPTIONS flags that provide information about the state change that the shadow copy
    ///              LUNs have undergone. The following table describes how each flag is used in this parameter. <table> <tr>
    ///              <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///              id="VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE"></a><a id="vss_onlunstatechange_notify_read_write"></a><dl>
    ///              <dt><b>VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> The
    ///              shadow copy LUN will be converted permanently to read-write. </td> </tr> <tr> <td width="40%"><a
    ///              id="VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY"></a><a
    ///              id="vss_onlunstatechange_notify_lun_pre_recovery"></a><dl>
    ///              <dt><b>VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%">
    ///              The shadow copy LUNs will be converted temporarily to read-write and are about to undergo TxF recovery or VSS
    ///              auto-recovery. </td> </tr> <tr> <td width="40%"><a id="VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY"></a><a
    ///              id="vss_onlunstatechange_notify_lun_post_recovery"></a><dl>
    ///              <dt><b>VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY</b></dt> <dt>0x00000400</dt> </dl> </td> <td
    ///              width="60%"> The shadow copy LUNs have just undergone TxF recovery or VSS auto-recovery and have been
    ///              converted back to read-only. </td> </tr> <tr> <td width="40%"><a
    ///              id="VSS_ONLUNSTATECHANGE_DO_MASK_LUNS"></a><a id="vss_onlunstatechange_do_mask_luns"></a><dl>
    ///              <dt><b>VSS_ONLUNSTATECHANGE_DO_MASK_LUNS</b></dt> <dt>0x00000800</dt> </dl> </td> <td width="60%"> The shadow
    ///              copy LUNs must be masked from the current machine but not deleted. </td> </tr> </table>
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b><b>S_OK</b></b></dt> <dt>0x00000000L</dt> </dl> </td> <td
    ///    width="60%"> The operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>E_OUTOFMEMORY</b></b></dt> <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other
    ///    system resources. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> <dt>0x80070057L</dt>
    ///    </dl> </td> <td width="60%"> One of the parameter values is not valid. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b><b>VSS_E_PROVIDER_VETO</b></b></dt> <dt>0x80042306L</dt> </dl> </td> <td width="60%"> An unexpected
    ///    provider error occurred. If this is returned, the error must be described in an entry in the application
    ///    event log, giving the user information on how to resolve the problem. </td> </tr> </table>
    ///    
    HRESULT OnLunStateChange(VDS_LUN_INFORMATION* pSnapshotLuns, VDS_LUN_INFORMATION* pOriginalLuns, uint dwCount, 
                             uint dwFlags);
    ///The VSS service calls this method to notify hardware providers that a LUN resynchronization is needed.<div
    ///class="alert"><b>Note</b> Hardware providers are only supported on Windows Server operating systems.</div> <div>
    ///</div>
    ///Params:
    ///    pSourceLuns = A pointer to an array of <i>dwCount</i> VDS_LUN_INFORMATION structures, one for each LUN that contributes to
    ///                  the shadow copy volume.
    ///    pTargetLuns = A pointer to an array of <i>dwCount</i> VDS_LUN_INFORMATION structures, one for each LUN that contributes to
    ///                  the destination volume where the contents of the shadow copy volume are to be copied.
    ///    dwCount = The number of elements in the <i>pSourceLuns</i> array. This is also the number of elements in the
    ///              <i>pTargetLuns</i> array.
    ///    ppAsync = A pointer to a location that will receive an IVssAsync interface pointer that can be used to retrieve the
    ///              status of the resynchronization operation. When the operation is complete, the caller must release the
    ///              interface pointer by calling the IUnknown::Release method.
    ///Returns:
    ///    This method can return one of these values. <table> <tr> <th>Return code/value</th> <th>Description</th>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> <dt>0x00000000L</dt> </dl> </td> <td width="60%"> The
    ///    operation was successfully completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt>
    ///    <dt>0x8007000EL</dt> </dl> </td> <td width="60%"> Out of memory or other system resources. </td> </tr> <tr>
    ///    <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> <dt>0x80042306L</dt> </dl> </td> <td width="60%">
    ///    An unexpected provider error occurred. If this error code is returned, the error must be described in an
    ///    entry in the application event log, giving the user information on how to resolve the problem. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>VSS_E_INSUFFICIENT_STORAGE</b></dt> <dt>0x8004231FL</dt> </dl> </td> <td
    ///    width="60%"> The provider cannot perform the operation because there is not enough disk space. </td> </tr>
    ///    </table>
    ///    
    HRESULT ResyncLuns(VDS_LUN_INFORMATION* pSourceLuns, VDS_LUN_INFORMATION* pTargetLuns, uint dwCount, 
                       IVssAsync* ppAsync);
    ///Not supported. This method is reserved for future use.
    ///Params:
    ///    pSnapshotLuns = This parameter is reserved for future use.
    ///    pOriginalLuns = This parameter is reserved for future use.
    ///    dwCount = This parameter is reserved for future use.
    ///Returns:
    ///    If this method succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it
    ///    returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
    ///    
    HRESULT OnReuseLuns(VDS_LUN_INFORMATION* pSnapshotLuns, VDS_LUN_INFORMATION* pOriginalLuns, uint dwCount);
}

///Contains the methods used by VSS to manage shadow copy volumes.
@GUID("C8636060-7C2E-11DF-8C4A-0800200C9A66")
interface IVssFileShareSnapshotProvider : IUnknown
{
    ///Sets the context for the subsequent shadow copy-related operations.
    ///Params:
    ///    lContext = The context to be set. The context must be one of the supported values of _VSS_SNAPSHOT_CONTEXT or a
    ///               supported combination of _VSS_VOLUME_SNAPSHOT_ATTRIBUTES and <b>_VSS_SNAPSHOT_CONTEXT</b> values.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The context was set
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_BAD_STATE</b></dt> </dl> </td> <td width="60%"> The context is frozen and cannot be changed.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetContext(int lContext);
    ///Gets the VSS_SNAPSHOT_PROP structure for a file share snapshot.
    ///Params:
    ///    SnapshotId = Shadow copy identifier.
    ///    pProp = The address of a caller-allocated VSS_SNAPSHOT_PROP structure that receives the shadow copy properties. The
    ///            provider is responsible for setting the members of this structure. All members are required except
    ///            <b>m_pwszExposedName</b> and <b>m_pwszExposedPath</b>, which the provider can set to <b>NULL</b>. The
    ///            provider allocates memory for all string members that it sets in the structure. When the structure is no
    ///            longer needed, the caller is responsible for freeing these strings by calling the VssFreeSnapshotProperties
    ///            function.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The requested information was
    ///    successfully returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified volume was not found. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider
    ///    error. The provider logged the error in the event log. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT GetSnapshotProperties(GUID SnapshotId, VSS_SNAPSHOT_PROP* pProp);
    ///Gets an enumeration of VSS_SNAPSHOT_PROP structures for all file share snapshots that are available to the
    ///application server.
    ///Params:
    ///    QueriedObjectId = Reserved for system use. The value of this parameter must be GUID_NULL.
    ///    eQueriedObjectType = Reserved for system use. The value of this parameter must be VSS_OBJECT_NONE.
    ///    eReturnedObjectsType = Reserved for system use. The value of this parameter must be VSS_OBJECT_SNAPSHOT.
    ///    ppEnum = The address of an IVssEnumObject interface pointer, which is initialized on return. Callers must release the
    ///             interface. This parameter is required and cannot be null.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The query operation was
    ///    successful. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider error. The provider logged the
    ///    error in the event log. For more information, see Event and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT Query(GUID QueriedObjectId, VSS_OBJECT_TYPE eQueriedObjectType, VSS_OBJECT_TYPE eReturnedObjectsType, 
                  IVssEnumObject* ppEnum);
    ///Deletes specific snapshots, or all snapshots in a specified snapshot set.
    ///Params:
    ///    SourceObjectId = Identifier of the shadow copy or shadow copy set to be deleted.
    ///    eSourceObjectType = Type of the object to be deleted. The value of this parameter is VSS_OBJECT_SNAPSHOT or
    ///                        VSS_OBJECT_SNAPSHOT_SET.
    ///    bForceDelete = If the value of this parameter is <b>TRUE</b>, the provider will do everything possible to delete the shadow
    ///                   copy or shadow copies in a shadow copy set. If it is <b>FALSE</b>, no additional effort will be made.
    ///    plDeletedSnapshots = Pointer to a variable that receives the number of shadow copies that were deleted.
    ///    pNondeletedSnapshotID = If an error occurs, this parameter receives a pointer to the identifier of the first shadow copy that could
    ///                            not be deleted. Otherwise, it points to GUID_NULL.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The shadow copies were
    ///    successfully deleted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified shadow copies were not
    ///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td
    ///    width="60%"> Provider error. The provider logged the error in the event log. For more information, see Event
    ///    and Error Handling Under VSS. </td> </tr> </table>
    ///    
    HRESULT DeleteSnapshots(GUID SourceObjectId, VSS_OBJECT_TYPE eSourceObjectType, BOOL bForceDelete, 
                            int* plDeletedSnapshots, GUID* pNondeletedSnapshotID);
    ///VSS calls this method for each shadow copy that is added to the shadow copy set.
    ///Params:
    ///    SnapshotSetId = Shadow copy set identifier.
    ///    SnapshotId = Identifier of the shadow copy to be created.
    ///    pwszSharePath = The file share path.
    ///    lNewContext = The context for the shadow copy set. This context consists of a bitmask of _VSS_VOLUME_SNAPSHOT_ATTRIBUTES
    ///                  values.
    ///    ProviderId = The provider ID.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The shadow copy was successfully
    ///    created. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td width="60%">
    ///    The caller does not have sufficient backup privileges or is not an administrator. </td> </tr> <tr> <td
    ///    width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter values is
    ///    not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified volume was not found. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider
    ///    error. The provider logged the error in the event log. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNSUPPORTED_CONTEXT</b></dt> </dl> </td> <td
    ///    width="60%"> The specified context is not supported. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER</b></dt> </dl> </td> <td width="60%"> The provider does not
    ///    support the specified volume. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl>
    ///    </td> <td width="60%"> Unexpected error. The error code is logged in the error log file. For more
    ///    information, see Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server
    ///    2003 and Windows XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED
    ///    is used instead. </td> </tr> </table>
    ///    
    HRESULT BeginPrepareSnapshot(GUID SnapshotSetId, GUID SnapshotId, ushort* pwszSharePath, int lNewContext, 
                                 GUID ProviderId);
    ///Determines whether the given Universal Naming Convention (UNC) path is supported by this provider.
    ///Params:
    ///    pwszSharePath = The path to the file share.
    ///    pbSupportedByThisProvider = This parameter receives <b>TRUE</b> if shadow copies are supported on the specified volume, otherwise
    ///                                <b>FALSE</b>.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The requested information was
    ///    successfully returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_NESTED_VOLUME_LIMIT</b></dt> </dl>
    ///    </td> <td width="60%"> The specified volume is nested too deeply to participate in the VSS operation.
    ///    <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: </b>This return code is not
    ///    supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td width="60%">
    ///    The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified volume was not found. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider
    ///    error. The provider logged the error in the event log. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> </table>
    ///    
    HRESULT IsPathSupported(ushort* pwszSharePath, BOOL* pbSupportedByThisProvider);
    ///Determines whether the given Universal Naming Convention (UNC) path currently has any snapshots.
    ///Params:
    ///    pwszSharePath = The path to the file share.
    ///    pbSnapshotsPresent = This parameter receives <b>TRUE</b> if the volume has a shadow copy, or <b>FALSE</b> if the volume does not
    ///                         have a shadow copy.
    ///    plSnapshotCompatibility = A bitmask of VSS_SNAPSHOT_COMPATIBILITY values that indicate whether certain volume control or file I/O
    ///                              operations are disabled for the given volume, if the volume has a shadow copy.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The requested information was
    ///    successfully returned. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified volume was not found. </td>
    ///    </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_PROVIDER_VETO</b></dt> </dl> </td> <td width="60%"> Provider
    ///    error. The provider logged the error in the event log. For more information, see Event and Error Handling
    ///    Under VSS. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>VSS_E_UNEXPECTED</b></dt> </dl> </td> <td
    ///    width="60%"> Unexpected error. The error code is logged in the error log file. For more information, see
    ///    Event and Error Handling Under VSS. <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows
    ///    XP: </b>This value is not supported until Windows Server 2008 R2 and Windows 7. E_UNEXPECTED is used instead.
    ///    </td> </tr> </table>
    ///    
    HRESULT IsPathSnapshotted(ushort* pwszSharePath, BOOL* pbSnapshotsPresent, int* plSnapshotCompatibility);
    ///Requests the provider to set a property value for the specified snapshot.
    ///Params:
    ///    SnapshotId = Shadow copy identifier. This parameter is required and cannot be GUID_NULL.
    ///    eSnapshotPropertyId = A VSS_SNAPSHOT_PROPERTY_ID value that specifies the property to be set for the shadow copy.
    ///    vProperty = The value to be set for the property. See the VSS_SNAPSHOT_PROP structure for valid data types and
    ///                descriptions of the properties that can be set for a shadow copy.
    ///Returns:
    ///    The following are the valid return codes for this method. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>S_OK</b></dt> </dl> </td> <td width="60%"> The property was set
    ///    successfully. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_ACCESSDENIED</b></dt> </dl> </td> <td
    ///    width="60%"> The caller does not have sufficient backup privileges or is not an administrator. </td> </tr>
    ///    <tr> <td width="40%"> <dl> <dt><b>E_INVALIDARG</b></dt> </dl> </td> <td width="60%"> One of the parameter
    ///    values is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>E_OUTOFMEMORY</b></dt> </dl> </td> <td
    ///    width="60%"> The caller is out of memory or other system resources. </td> </tr> <tr> <td width="40%"> <dl>
    ///    <dt><b>VSS_E_OBJECT_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified shadow copy was not found.
    ///    </td> </tr> </table>
    ///    
    HRESULT SetSnapshotProperty(GUID SnapshotId, VSS_SNAPSHOT_PROPERTY_ID eSnapshotPropertyId, VARIANT vProperty);
}


// GUIDs

const GUID CLSID_VSSCoordinator  = GUIDOF!VSSCoordinator;
const GUID CLSID_VssSnapshotMgmt = GUIDOF!VssSnapshotMgmt;

const GUID IID_IEnumVdsObject                        = GUIDOF!IEnumVdsObject;
const GUID IID_IServiceProvider                      = GUIDOF!IServiceProvider;
const GUID IID_IVdsAdmin                             = GUIDOF!IVdsAdmin;
const GUID IID_IVdsAdviseSink                        = GUIDOF!IVdsAdviseSink;
const GUID IID_IVdsAsync                             = GUIDOF!IVdsAsync;
const GUID IID_IVdsController                        = GUIDOF!IVdsController;
const GUID IID_IVdsControllerControllerPort          = GUIDOF!IVdsControllerControllerPort;
const GUID IID_IVdsControllerPort                    = GUIDOF!IVdsControllerPort;
const GUID IID_IVdsDrive                             = GUIDOF!IVdsDrive;
const GUID IID_IVdsDrive2                            = GUIDOF!IVdsDrive2;
const GUID IID_IVdsHwProvider                        = GUIDOF!IVdsHwProvider;
const GUID IID_IVdsHwProviderPrivate                 = GUIDOF!IVdsHwProviderPrivate;
const GUID IID_IVdsHwProviderPrivateMpio             = GUIDOF!IVdsHwProviderPrivateMpio;
const GUID IID_IVdsHwProviderStoragePools            = GUIDOF!IVdsHwProviderStoragePools;
const GUID IID_IVdsHwProviderType                    = GUIDOF!IVdsHwProviderType;
const GUID IID_IVdsHwProviderType2                   = GUIDOF!IVdsHwProviderType2;
const GUID IID_IVdsIscsiPortal                       = GUIDOF!IVdsIscsiPortal;
const GUID IID_IVdsIscsiPortalGroup                  = GUIDOF!IVdsIscsiPortalGroup;
const GUID IID_IVdsIscsiTarget                       = GUIDOF!IVdsIscsiTarget;
const GUID IID_IVdsLun                               = GUIDOF!IVdsLun;
const GUID IID_IVdsLun2                              = GUIDOF!IVdsLun2;
const GUID IID_IVdsLunControllerPorts                = GUIDOF!IVdsLunControllerPorts;
const GUID IID_IVdsLunIscsi                          = GUIDOF!IVdsLunIscsi;
const GUID IID_IVdsLunMpio                           = GUIDOF!IVdsLunMpio;
const GUID IID_IVdsLunNaming                         = GUIDOF!IVdsLunNaming;
const GUID IID_IVdsLunNumber                         = GUIDOF!IVdsLunNumber;
const GUID IID_IVdsLunPlex                           = GUIDOF!IVdsLunPlex;
const GUID IID_IVdsMaintenance                       = GUIDOF!IVdsMaintenance;
const GUID IID_IVdsProvider                          = GUIDOF!IVdsProvider;
const GUID IID_IVdsProviderPrivate                   = GUIDOF!IVdsProviderPrivate;
const GUID IID_IVdsProviderSupport                   = GUIDOF!IVdsProviderSupport;
const GUID IID_IVdsStoragePool                       = GUIDOF!IVdsStoragePool;
const GUID IID_IVdsSubSystem                         = GUIDOF!IVdsSubSystem;
const GUID IID_IVdsSubSystem2                        = GUIDOF!IVdsSubSystem2;
const GUID IID_IVdsSubSystemInterconnect             = GUIDOF!IVdsSubSystemInterconnect;
const GUID IID_IVdsSubSystemIscsi                    = GUIDOF!IVdsSubSystemIscsi;
const GUID IID_IVdsSubSystemNaming                   = GUIDOF!IVdsSubSystemNaming;
const GUID IID_IVssAdmin                             = GUIDOF!IVssAdmin;
const GUID IID_IVssAdminEx                           = GUIDOF!IVssAdminEx;
const GUID IID_IVssAsync                             = GUIDOF!IVssAsync;
const GUID IID_IVssComponent                         = GUIDOF!IVssComponent;
const GUID IID_IVssComponentEx                       = GUIDOF!IVssComponentEx;
const GUID IID_IVssComponentEx2                      = GUIDOF!IVssComponentEx2;
const GUID IID_IVssCreateExpressWriterMetadata       = GUIDOF!IVssCreateExpressWriterMetadata;
const GUID IID_IVssCreateWriterMetadataEx            = GUIDOF!IVssCreateWriterMetadataEx;
const GUID IID_IVssDifferentialSoftwareSnapshotMgmt  = GUIDOF!IVssDifferentialSoftwareSnapshotMgmt;
const GUID IID_IVssDifferentialSoftwareSnapshotMgmt2 = GUIDOF!IVssDifferentialSoftwareSnapshotMgmt2;
const GUID IID_IVssDifferentialSoftwareSnapshotMgmt3 = GUIDOF!IVssDifferentialSoftwareSnapshotMgmt3;
const GUID IID_IVssEnumMgmtObject                    = GUIDOF!IVssEnumMgmtObject;
const GUID IID_IVssEnumObject                        = GUIDOF!IVssEnumObject;
const GUID IID_IVssExpressWriter                     = GUIDOF!IVssExpressWriter;
const GUID IID_IVssFileShareSnapshotProvider         = GUIDOF!IVssFileShareSnapshotProvider;
const GUID IID_IVssHardwareSnapshotProvider          = GUIDOF!IVssHardwareSnapshotProvider;
const GUID IID_IVssHardwareSnapshotProviderEx        = GUIDOF!IVssHardwareSnapshotProviderEx;
const GUID IID_IVssProviderCreateSnapshotSet         = GUIDOF!IVssProviderCreateSnapshotSet;
const GUID IID_IVssProviderNotifications             = GUIDOF!IVssProviderNotifications;
const GUID IID_IVssSnapshotMgmt                      = GUIDOF!IVssSnapshotMgmt;
const GUID IID_IVssSnapshotMgmt2                     = GUIDOF!IVssSnapshotMgmt2;
const GUID IID_IVssSoftwareSnapshotProvider          = GUIDOF!IVssSoftwareSnapshotProvider;
