// Written in the D programming language.

module windows.winsock;

public import windows.core;
public import windows.com : HRESULT;
public import windows.iphelper : SOCKADDR_INET;
public import windows.networkdrivers : SOCKADDR_STORAGE_LH, SOCKET_ADDRESS_LIST;
public import windows.qualityofservice : QOS;
public import windows.systemservices : BOOL, FARPROC, HANDLE, LARGE_INTEGER, OVERLAPPED,
                                       PROCESSOR_NUMBER;
public import windows.windowsandmessaging : HWND, LPARAM, WPARAM;

extern(Windows):


// Enums


alias IPPROTO = int;
enum : int
{
    IPPROTO_HOPOPTS               = 0x00000000,
    IPPROTO_ICMP                  = 0x00000001,
    IPPROTO_IGMP                  = 0x00000002,
    IPPROTO_GGP                   = 0x00000003,
    IPPROTO_IPV4                  = 0x00000004,
    IPPROTO_ST                    = 0x00000005,
    IPPROTO_TCP                   = 0x00000006,
    IPPROTO_CBT                   = 0x00000007,
    IPPROTO_EGP                   = 0x00000008,
    IPPROTO_IGP                   = 0x00000009,
    IPPROTO_PUP                   = 0x0000000c,
    IPPROTO_UDP                   = 0x00000011,
    IPPROTO_IDP                   = 0x00000016,
    IPPROTO_RDP                   = 0x0000001b,
    IPPROTO_IPV6                  = 0x00000029,
    IPPROTO_ROUTING               = 0x0000002b,
    IPPROTO_FRAGMENT              = 0x0000002c,
    IPPROTO_ESP                   = 0x00000032,
    IPPROTO_AH                    = 0x00000033,
    IPPROTO_ICMPV6                = 0x0000003a,
    IPPROTO_NONE                  = 0x0000003b,
    IPPROTO_DSTOPTS               = 0x0000003c,
    IPPROTO_ND                    = 0x0000004d,
    IPPROTO_ICLFXBM               = 0x0000004e,
    IPPROTO_PIM                   = 0x00000067,
    IPPROTO_PGM                   = 0x00000071,
    IPPROTO_L2TP                  = 0x00000073,
    IPPROTO_SCTP                  = 0x00000084,
    IPPROTO_RAW                   = 0x000000ff,
    IPPROTO_MAX                   = 0x00000100,
    IPPROTO_RESERVED_RAW          = 0x00000101,
    IPPROTO_RESERVED_IPSEC        = 0x00000102,
    IPPROTO_RESERVED_IPSECOFFLOAD = 0x00000103,
    IPPROTO_RESERVED_WNV          = 0x00000104,
    IPPROTO_RESERVED_MAX          = 0x00000105,
}

alias WSACOMPLETIONTYPE = int;
enum : int
{
    NSP_NOTIFY_IMMEDIATELY = 0x00000000,
    NSP_NOTIFY_HWND        = 0x00000001,
    NSP_NOTIFY_EVENT       = 0x00000002,
    NSP_NOTIFY_PORT        = 0x00000003,
    NSP_NOTIFY_APC         = 0x00000004,
}

///The Windows Sockets <b>WSAECOMPARATOR</b> enumeration type is used for version-comparison semantics in Windows
///Sockets 2.
alias WSAECOMPARATOR = int;
enum : int
{
    ///Used for determining whether version values are equal.
    COMP_EQUAL   = 0x00000000,
    COMP_NOTLESS = 0x00000001,
}

alias WSAESETSERVICEOP = int;
enum : int
{
    RNRSERVICE_REGISTER   = 0x00000000,
    RNRSERVICE_DEREGISTER = 0x00000001,
    RNRSERVICE_DELETE     = 0x00000002,
}

alias PMTUD_STATE = int;
enum : int
{
    IP_PMTUDISC_NOT_SET = 0x00000000,
    IP_PMTUDISC_DO      = 0x00000001,
    IP_PMTUDISC_DONT    = 0x00000002,
    IP_PMTUDISC_PROBE   = 0x00000003,
    IP_PMTUDISC_MAX     = 0x00000004,
}

///The <b>MULTICAST_MODE_TYPE</b> enumeration specifies the filter mode for multicast group addresses.
alias MULTICAST_MODE_TYPE = int;
enum : int
{
    ///The filter contains a list of IP addresses to include.
    MCAST_INCLUDE = 0x00000000,
    ///The filter contains a list of IP addresses to exclude.
    MCAST_EXCLUDE = 0x00000001,
}

///The <b>eWINDOW_ADVANCE_METHOD</b> enumeration specifies the window advance mode used for Reliable Multicast.
alias eWINDOW_ADVANCE_METHOD = int;
enum : int
{
    ///Window advances based on time. This is the default mode.
    E_WINDOW_ADVANCE_BY_TIME   = 0x00000001,
    ///Use the receive window as a data cache.
    E_WINDOW_USE_AS_DATA_CACHE = 0x00000002,
}

alias NL_BANDWIDTH_FLAG = int;
enum : int
{
    NlbwDisabled  = 0x00000000,
    NlbwEnabled   = 0x00000001,
    NlbwUnchanged = 0xffffffff,
}

alias NL_NETWORK_CATEGORY = int;
enum : int
{
    NetworkCategoryPublic              = 0x00000000,
    NetworkCategoryPrivate             = 0x00000001,
    NetworkCategoryDomainAuthenticated = 0x00000002,
    NetworkCategoryUnchanged           = 0xffffffff,
    NetworkCategoryUnknown             = 0xffffffff,
}

alias NL_INTERFACE_NETWORK_CATEGORY_STATE = int;
enum : int
{
    NlincCategoryUnknown     = 0x00000000,
    NlincPublic              = 0x00000001,
    NlincPrivate             = 0x00000002,
    NlincDomainAuthenticated = 0x00000003,
    NlincCategoryStateMax    = 0x00000004,
}

///The Windows Sockets <b>TCPSTATE</b> enumeration indicates the possible states of a Transmission Control Protocol
///(TCP) connection.
alias TCPSTATE = int;
enum : int
{
    ///The TCP connection has no connection state at all. This state represents the state when there is no Transmission
    ///Control Block (TCB), and therefore, no connection.
    TCPSTATE_CLOSED      = 0x00000000,
    ///The TCP connection is waiting for a connection request from any remote TCP and port.
    TCPSTATE_LISTEN      = 0x00000001,
    ///-The TCP connection is waiting for a matching connection request after sending a connection request.
    TCPSTATE_SYN_SENT    = 0x00000002,
    ///The TCP connection is waiting for an acknowledgment that confirms the connection request after both receiving and
    ///sending a connection request.
    TCPSTATE_SYN_RCVD    = 0x00000003,
    ///The TCP connection is an open connection, so the data received can be delivered to the user. This state is normal
    ///state for the data transfer phase of the connection.
    TCPSTATE_ESTABLISHED = 0x00000004,
    ///The TCP connection is waiting for a request to end the connection from the remote TCP, or an acknowledgment of
    ///the previously sent request to end the connection.
    TCPSTATE_FIN_WAIT_1  = 0x00000005,
    ///The TCP connection is waiting for a request to end the connection from the remote TCP.
    TCPSTATE_FIN_WAIT_2  = 0x00000006,
    ///The TCP connection is waiting for a request to end the connection from the local user.
    TCPSTATE_CLOSE_WAIT  = 0x00000007,
    ///The TCP connection is waiting for an acknowledgment of the request to end the connection from the remote TCP.
    TCPSTATE_CLOSING     = 0x00000008,
    ///The TCP connection is waiting for an acknowledgment of the request to end the connection that was previously sent
    ///to the remote TCP, which includes an acknowledgment of its request to end the connection.
    TCPSTATE_LAST_ACK    = 0x00000009,
    ///The TCP connection is waiting for enough time to pass to be sure the remote TCP received the acknowledgment of
    ///its request to end the connection.
    TCPSTATE_TIME_WAIT   = 0x0000000a,
    ///The maximum value of the TCPSTATE enumeration.
    TCPSTATE_MAX         = 0x0000000b,
}

///The CONTROL_CHANNEL_TRIGGER_STATUS enumeration specifies the status from a query for the
///<b>REAL_TIME_NOTIFICATION_CAPABILITY</b> transport setting for a TCP socket that is used with ControlChannelTrigger
///to receive background network notifications in a Windows Store app.
alias CONTROL_CHANNEL_TRIGGER_STATUS = int;
enum : int
{
    ///Status is invalid.
    CONTROL_CHANNEL_TRIGGER_STATUS_INVALID                 = 0x00000000,
    ///A software slot was allocated for the ControlChannelTrigger.
    CONTROL_CHANNEL_TRIGGER_STATUS_SOFTWARE_SLOT_ALLOCATED = 0x00000001,
    ///A hardware slot was allocated for the ControlChannelTrigger.
    CONTROL_CHANNEL_TRIGGER_STATUS_HARDWARE_SLOT_ALLOCATED = 0x00000002,
    ///A status policy error.
    CONTROL_CHANNEL_TRIGGER_STATUS_POLICY_ERROR            = 0x00000003,
    ///A status system error.
    CONTROL_CHANNEL_TRIGGER_STATUS_SYSTEM_ERROR            = 0x00000004,
    ///The TCP tranport is disconnected.
    CONTROL_CHANNEL_TRIGGER_STATUS_TRANSPORT_DISCONNECTED  = 0x00000005,
    ///Service is unavailable.
    CONTROL_CHANNEL_TRIGGER_STATUS_SERVICE_UNAVAILABLE     = 0x00000006,
}

alias RCVALL_VALUE = int;
enum : int
{
    RCVALL_OFF             = 0x00000000,
    RCVALL_ON              = 0x00000001,
    RCVALL_SOCKETLEVELONLY = 0x00000002,
    RCVALL_IPLEVEL         = 0x00000003,
}

alias TCP_ICW_LEVEL = int;
enum : int
{
    TCP_ICW_LEVEL_DEFAULT      = 0x00000000,
    TCP_ICW_LEVEL_HIGH         = 0x00000001,
    TCP_ICW_LEVEL_VERY_HIGH    = 0x00000002,
    TCP_ICW_LEVEL_AGGRESSIVE   = 0x00000003,
    TCP_ICW_LEVEL_EXPERIMENTAL = 0x00000004,
    TCP_ICW_LEVEL_COMPAT       = 0x000000fe,
    TCP_ICW_LEVEL_MAX          = 0x000000ff,
}

///The Windows Sockets <b>SOCKET_USAGE_TYPE</b> enumeration is used to specified the usage type for the socket.
alias SOCKET_USAGE_TYPE = int;
enum : int
{
    SYSTEM_CRITICAL_SOCKET = 0x00000001,
}

///The <b>SOCKET_SECURITY_PROTOCOL</b> enumeration indicates the type of security protocol to be used on a socket to
///secure network traffic.
alias SOCKET_SECURITY_PROTOCOL = int;
enum : int
{
    ///The default system security will be used.
    SOCKET_SECURITY_PROTOCOL_DEFAULT = 0x00000000,
    ///IPsec will be used.
    SOCKET_SECURITY_PROTOCOL_IPSEC   = 0x00000001,
    SOCKET_SECURITY_PROTOCOL_IPSEC2  = 0x00000002,
    ///The maximum possible value for the SOCKET_SECURITY_PROTOCOL enumeration type. This is not a legal value.
    SOCKET_SECURITY_PROTOCOL_INVALID = 0x00000003,
}

alias WSA_COMPATIBILITY_BEHAVIOR_ID = int;
enum : int
{
    WsaBehaviorAll              = 0x00000000,
    WsaBehaviorReceiveBuffering = 0x00000001,
    WsaBehaviorAutoTuning       = 0x00000002,
}

alias Q2931_IE_TYPE = int;
enum : int
{
    IE_AALParameters             = 0x00000000,
    IE_TrafficDescriptor         = 0x00000001,
    IE_BroadbandBearerCapability = 0x00000002,
    IE_BHLI                      = 0x00000003,
    IE_BLLI                      = 0x00000004,
    IE_CalledPartyNumber         = 0x00000005,
    IE_CalledPartySubaddress     = 0x00000006,
    IE_CallingPartyNumber        = 0x00000007,
    IE_CallingPartySubaddress    = 0x00000008,
    IE_Cause                     = 0x00000009,
    IE_QOSClass                  = 0x0000000a,
    IE_TransitNetworkSelection   = 0x0000000b,
}

alias AAL_TYPE = int;
enum : int
{
    AALTYPE_5    = 0x00000005,
    AALTYPE_USER = 0x00000010,
}

///The <b>NAPI_PROVIDER_TYPE</b> enumeration specifies the type of hosting expected for a namespace provider.
alias NAPI_PROVIDER_TYPE = int;
enum : int
{
    ///The namespace provider is expected to be hosted by an application. There may be multiple namespace providers of
    ///type <b>ProviderType_Application</b> running at the same time on a local system. There may also be multiple
    ///instances of the same namespace provider running at the same time on a local system as long as the following
    ///conditions are met. Only one instance of the same namespace provider application can be running in a single user
    ///session at the same time on the local system. The Windows Sockets infrastructure will select the particular
    ///target instance of a namespace provider based on the identity of the client and the user session where it is
    ///running. Clients running as user <b>MyUser</b> in a user session will only be able to contact an instance of the
    ///same namespace provider running as <b>MyUser</b> in the same session.
    ProviderType_Application = 0x00000001,
    ///The namespace provider is expected to be hosted by a service. This hosting model is not currently supported.
    ProviderType_Service     = 0x00000002,
}

///The <b>NAPI_PROVIDER_LEVEL</b> enumeration specifies the provider authority level of a NS_EMAIL namespace provider
///for a given domain.
alias NAPI_PROVIDER_LEVEL = int;
enum : int
{
    ///The namespace provider does not support the current domain. This value can be used to temporarily turn off the
    ///support for a domain without removing it from the list of supported domains. If <b>ProviderLevel_None</b> is set
    ///in the <b>AuthLevel</b> member of the NAPI_DOMAIN_DESCRIPTION_BLOB for a given domain when the provider is
    ///installed and registered, the namespace provider will not be called to resolve or register an address in that
    ///domain unless the provider registered as a wildcard provider. There may be multiple NS_EMAIL namespace providers
    ///for a domain with a value of <b>ProviderLevel_None</b>. If there are namespace providers with this value that
    ///also registered as a wildcard provider, the providers are called in the order that they appear in the Winsock
    ///catalog.
    ProviderLevel_None      = 0x00000000,
    ///The namespace provider is a secondary provider for a domain in the NS_EMAIL namespace. A namespace provider can
    ///be a secondary provider in the target domain if the provider can resolve and register NS_EMAIL names for this
    ///domain and give the same answer that a primary provider would provide. If <b>ProviderLevel_Secondary</b> is set
    ///in <b>AuthLevel</b> member of the NAPI_DOMAIN_DESCRIPTION_BLOB for a given domain when the provider is installed
    ///and registered, this provider is called when a primary provider for the domain is not currently available or the
    ///primary provider could not resolve or register the address in that domain. There may be multiple secondary
    ///NS_EMAIL namespace providers for a domain with a value of <b>ProviderLevel_Secondary</b>. If there are multiple
    ///secondary namespace providers, the providers are called in the order that they appear in the Winsock catalog.
    ProviderLevel_Secondary = 0x00000001,
    ///The namespace provider is the primary provider for a domain in the NS_EMAIL namespace. A namespace provider can
    ///claim to be the primary provider for a domain if it owns all of the NS_EMAIL names for that domain and thus has
    ///access to the master data for all such names. There should be only a single primary NS_EMAIL namespace provider
    ///for a domain registered on the local system. <div class="alert"><b>Note</b> There should never be two NS_EMAIL
    ///namespace providers that claim to be the primary provider for the same domain. If multiple providers try to
    ///register as the primary provider for the same domain, the first provider found in the Winsock namespace catalog
    ///for the domain as the primary provider will be called. All other provider claims to be the primary provider are
    ///ignored.</div> <div> </div>
    ProviderLevel_Primary   = 0x00000002,
}

alias NLA_BLOB_DATA_TYPE = int;
enum : int
{
    NLA_RAW_DATA        = 0x00000000,
    NLA_INTERFACE       = 0x00000001,
    NLA_802_1X_LOCATION = 0x00000002,
    NLA_CONNECTIVITY    = 0x00000003,
    NLA_ICS             = 0x00000004,
}

alias NLA_CONNECTIVITY_TYPE = int;
enum : int
{
    NLA_NETWORK_AD_HOC    = 0x00000000,
    NLA_NETWORK_MANAGED   = 0x00000001,
    NLA_NETWORK_UNMANAGED = 0x00000002,
    NLA_NETWORK_UNKNOWN   = 0x00000003,
}

alias NLA_INTERNET = int;
enum : int
{
    NLA_INTERNET_UNKNOWN = 0x00000000,
    NLA_INTERNET_NO      = 0x00000001,
    NLA_INTERNET_YES     = 0x00000002,
}

///The <b>RIO_NOTIFICATION_COMPLETION_TYPE</b> enumeration specifies the type of completion queue notifications to use
///with the RIONotify function when sending or receiving data using the Winsock registered I/O extensions.
alias RIO_NOTIFICATION_COMPLETION_TYPE = int;
enum : int
{
    ///An event handle is used to signal completion queue notifications. An event handle is provided as the
    ///<b>EventNotify.EventHandle</b> member in the RIO_NOTIFICATION_COMPLETION structure passed to the
    ///RIOCreateCompletionQueue function when the RIO_CQ is created. The completion of the RIONotify function for this
    ///<b>RIO_CQ</b> will signal the event. The <b>Event.NotifyReset</b> member in the
    ///<b>RIO_NOTIFICATION_COMPLETION</b> structure passed to the <b>RIOCreateCompletionQueue</b> function when the
    ///<b>RIO_CQ</b> is created indicates whether or not the event should be reset as part of a call to the
    ///<b>RIONotify</b> function.
    RIO_EVENT_COMPLETION = 0x00000001,
    ///An I/O completion port handle is used to signal completion queue notifications. An I/O completion port handle is
    ///provided as the <b>Iocp.IocpHandle</b> member in the RIO_NOTIFICATION_COMPLETION structure passed to the
    ///RIOCreateCompletionQueue function when the RIO_CQ is created. The completion of the RIONotify function for this
    ///<b>RIO_CQ</b> will queue an entry to the I/O completion port which can be retrieved using the
    ///GetQueuedCompletionStatus or GetQueuedCompletionStatusEx function. The queued entry will have the returned
    ///<i>lpCompletionKey</i> parameter value set to the value specified in the <b>Iocp.CompletionKey</b> member of the
    ///<b>RIO_NOTIFICATION_COMPLETION</b> and the returned <i>lpOverlapped</i> parameter value set to the value
    ///specified in the <b>Iocp.Overlapped</b> member in <b>RIO_NOTIFICATION_COMPLETION</b> structure. The
    ///<b>Iocp.Overlapped</b> member in the <b>RIO_NOTIFICATION_COMPLETION</b> will be a non-NULL value.
    RIO_IOCP_COMPLETION  = 0x00000002,
}

///<div class="alert">**Note** Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server
///2012, use Windows Filtering Platform.</div><div> </div>The Windows Sockets **WSC_PROVIDER_INFO_TYPE**enumeration type
///is used to specify the information class of a layered service protocol (LSP) in Windows Sockets 2.
alias WSC_PROVIDER_INFO_TYPE = int;
enum : int
{
    ///The LSP category information for a protocol entry in a layered protocol. The information class should point to a
    ///DWORD value containing the appropriate LSP category flags implemented by LSP.
    ProviderInfoLspCategories = 0x00000000,
    ///The LSP class information for audit information for the LSP entry. The information class should point to a
    ///WSC_PROVIDER_AUDIT_INFO structure containing an audit record for the LSP.
    ProviderInfoAudit         = 0x00000001,
}

// Constants


enum int LM_HB_Extension = 0x00000080;
enum int LM_HB1_PDA_Palmtop = 0x00000002;

enum : int
{
    LM_HB1_Printer   = 0x00000008,
    LM_HB1_Modem     = 0x00000010,
    LM_HB1_Fax       = 0x00000020,
    LM_HB1_LANAccess = 0x00000040,
}

enum int LM_HB2_FileServer = 0x00000002;

// Callbacks

alias LPCONDITIONPROC = int function(WSABUF* lpCallerId, WSABUF* lpCallerData, QOS* lpSQOS, QOS* lpGQOS, 
                                     WSABUF* lpCalleeId, WSABUF* lpCalleeData, uint* g, size_t dwCallbackData);
///**LPWSAOVERLAPPED_COMPLETION_ROUTINE** is a function pointer type. You implement a matching callback function in your
///app, and pass that to functions such as [WSAIoctl](./nf-winsock2-wsaioctl.md), [WSARecv](./nf-winsock2-wsarecv.md),
///and [WSASend](./nf-winsock2-wsasend.md), among others. The system calls your callback function when the asynchronous
///input and output (I/O) operation is completed or canceled, and the calling thread is in an alertable state (by using
///the SleepEx, MsgWaitForMultipleObjectsEx, WaitForSingleObjectEx, or WaitForMultipleObjectsEx function with the
///<i>fAlertable</i> parameter set to <b>TRUE</b>).
///Params:
///    dwError = Type: IN **[DWORD](/windows/win32/winprog/windows-data-types)** The I/O completion status. This parameter can be
///              one of the system error codes.
///    cbTransferred = Type: IN **[DWORD](/windows/win32/winprog/windows-data-types)** The number of bytes transferred. If an error
///                    occurs, this parameter is zero.
///    lpOverlapped = Type: IN **[LPWSAOVERLAPPED](./ns-winsock2-wsaoverlapped.md)** A pointer to the
///                   [**WSAOVERLAPPED**](./ns-winsock2-wsaoverlapped.md) structure specified by the asynchronous I/O function. The
///                   system doesn't use the [**WSAOVERLAPPED**](./ns-winsock2-wsaoverlapped.md) structure after the completion routine
///                   is called, so the completion routine can deallocate the memory used by the overlapped structure.
///    dwFlags = Type: IN **[DWORD](/windows/win32/winprog/windows-data-types)** Flags associated with the call.
alias LPWSAOVERLAPPED_COMPLETION_ROUTINE = void function(uint dwError, uint cbTransferred, 
                                                         OVERLAPPED* lpOverlapped, uint dwFlags);
alias LPFN_TRANSMITFILE = BOOL function(size_t hSocket, HANDLE hFile, uint nNumberOfBytesToWrite, 
                                        uint nNumberOfBytesPerSend, OVERLAPPED* lpOverlapped, 
                                        TRANSMIT_FILE_BUFFERS* lpTransmitBuffers, uint dwReserved);
alias LPFN_ACCEPTEX = BOOL function(size_t sListenSocket, size_t sAcceptSocket, char* lpOutputBuffer, 
                                    uint dwReceiveDataLength, uint dwLocalAddressLength, uint dwRemoteAddressLength, 
                                    uint* lpdwBytesReceived, OVERLAPPED* lpOverlapped);
alias LPFN_GETACCEPTEXSOCKADDRS = void function(char* lpOutputBuffer, uint dwReceiveDataLength, 
                                                uint dwLocalAddressLength, uint dwRemoteAddressLength, 
                                                SOCKADDR** LocalSockaddr, int* LocalSockaddrLength, 
                                                SOCKADDR** RemoteSockaddr, int* RemoteSockaddrLength);
///The <b>TransmitPackets</b> function transmits in-memory data or file data over a connected socket. The
///<b>TransmitPackets</b> function uses the operating system cache manager to retrieve file data, locking memory for the
///minimum time required to transmit and resulting in efficient, high-performance transmission.<div
///class="alert"><b>Note</b> This function is a Microsoft-specific extension to the Windows Sockets specification.</div>
///<div> </div>
///Params:
///    hSocket = A handle to the connected socket to be used in the transmission. Although the socket does not need to be a
///              connection-oriented circuit, the default destination/peer should have been established using the connect,
///              WSAConnect, accept, WSAAccept, AcceptEx, or WSAJoinLeaf function.
///    lpPacketArray = An array of type TRANSMIT_PACKETS_ELEMENT, describing the data to be transmitted.
///    nElementCount = The number of elements in <i>lpPacketArray</i>.
///    nSendSize = The size, in bytes, of the data block used in the send operation. Set <i>nSendSize</i> to zero to let the sockets
///                layer select a default <b>send</b> size. Setting <i>nSendSize</i> to 0xFFFFFFF enables the caller to control the
///                size and content of each send request, achieved by using the TP_ELEMENT_EOP flag in the TRANSMIT_PACKETS_ELEMENT
///                array pointed to in the <i>lpPacketArray</i> parameter. This capability is useful for message protocols that
///                place limitations on the size of individual <b>send</b> requests.
///    lpOverlapped = A pointer to an OVERLAPPED structure. If the socket handle specified in the <i>hSocket</i> parameter has been
///                   opened as overlapped, use this parameter to achieve asynchronous (overlapped) I/O operation. Socket handles are
///                   opened as overlapped by default.
///    dwFlags = A set of flags used to customize processing of the <b>TransmitPackets</b> function. The following table outlines
///              the use of the <i>dwFlags</i> parameter. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///              width="40%"><a id="TF_DISCONNECT"></a><a id="tf_disconnect"></a><dl> <dt><b>TF_DISCONNECT</b></dt> </dl> </td>
///              <td width="60%"> Starts a transport-level disconnect after all the file data has been queued for transmission.
///              Applies only to connection-oriented sockets. Specifying this flag for sockets that do not support disconnect
///              semantics (such as datagram sockets) results in an error. </td> </tr> <tr> <td width="40%"><a
///              id="TF_REUSE_SOCKET"></a><a id="tf_reuse_socket"></a><dl> <dt><b>TF_REUSE_SOCKET</b></dt> </dl> </td> <td
///              width="60%"> Prepares the socket handle to be reused. When the <b>TransmitPackets</b> function completes, the
///              socket handle can be passed to the AcceptEx function. Valid only when a connection-oriented socket and
///              TF_DISCONNECT are specified. <div class="alert"><b>Note</b> The socket level packet transmit is subject to the
///              behavior of the underlying transport. For example, a TCP socket may be subject to the TCP TIME_WAIT state,
///              causing the <b>TransmitPackets</b> call to be delayed.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a
///              id="TF_USE_DEFAULT_WORKER"></a><a id="tf_use_default_worker"></a><dl> <dt><b>TF_USE_DEFAULT_WORKER</b></dt> </dl>
///              </td> <td width="60%"> Directs Winsock to use the system's default thread to process long <b>TransmitPackets</b>
///              requests. Long <b>TransmitPackets</b> requests are defined as requests that require more than a single read from
///              the file or a cache; the long request definition therefore depends on the size of the file and the specified
///              length of the send packet. The system default thread can be adjusted using the following registry parameter as a
///              REG_DWORD:<b>HKEY_LOCAL_MACHINE</b>&
///Returns:
///    If the <b>TransmitPackets</b> function succeeds, the return value is <b>TRUE</b>. Otherwise, the return value is
///    <b>FALSE</b>. To get extended error information, call WSAGetLastError. An error code of WSA_IO_PENDING or
///    ERROR_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will
///    be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully
///    initiated and no completion indication will occur. Applications should handle either ERROR_IO_PENDING or
///    WSA_IO_PENDING in this case. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAECONNABORTED</b></dt> </dl> </td> <td width="60%"> An established connection was aborted by the
///    software in your host machine. This error is returned if the virtual circuit was terminated due to a time-out or
///    other failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%">
///    An existing connection was forcibly closed by the remote host. This error is returned for a stream socket when
///    the virtual circuit was reset by the remote side. The application should close the socket as it is no longer
///    usable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The system
///    detected an invalid pointer address in attempting to use a pointer argument in a call. This error is returned if
///    the <i>lpPacketArray</i> or the <i>lpOverlapped</i> parameter is not totally contained in a valid part of the
///    user address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%">
///    An invalid argument was supplied. This error is returned if the <i>dwFlags</i> parameter has the
///    <b>TF_REUSE_SOCKET</b> flag set, but the <b>TF_DISCONNECT</b> flag was not set. This error is also returned if
///    the offset specified in the OVERLAPPED structure pointed to by the <i>lpOverlapped</i> is not within the file.
///    This error is also returned if the total number of bytes to be transmitted is a value greater than 2,147,483,646,
///    the maximum value for a 32-bit integer minus 1. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> A socket operation encountered a dead network.This error
///    is returned if the network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETRESET</b></dt> </dl> </td> <td width="60%"> The connection has been broken due to keep-alive
///    activity detecting a failure while the operation was in progress. This error is returned for a stream socket
///    where the connection was broken due to keep-alive activity detecting a failure. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> An operation on a socket could not be performed
///    because the system lacked sufficient buffer space or because a queue was full. This error is also returned if the
///    Windows Sockets provider reports a buffer deadlock. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%"> A request to send or receive data was disallowed because
///    the socket is not connected. This error is returned for a stream socket. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> An operation was attempted on something that is not a
///    socket. This error is returned if the <i>hSocket</i> parameter is not a socket. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%"> A request to send or receive data was disallowed
///    because the socket had already been shut down in that direction with a previous shutdown call. This error is
///    returned if a stream socket has been shut down for sending. It is not possible to call TransmitFile on a stream
///    socket after the shutdown function has been called on the socket with the <i>how</i> parameter set to
///    <b>SD_SEND</b> or <b>SD_BOTH</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> Either the application has not called the WSAStartup function, or <b>WSAStartup</b>
///    failed. A successful <b>WSAStartup</b> call must occur before using the TransmitFile function. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dt> </dl> </td> <td width="60%"> An overlapped I/O operation is
///    in progress. This value is returned if an overlapped I/O operation was successfully initiated and indicates that
///    completion will be indicated at a later time. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_OPERATION_ABORTED</b></dt> </dl> </td> <td width="60%"> The I/O operation has been aborted because of
///    either a thread exit or an application request. This error is returned if the overlapped operation has been
///    canceled due to the closure of the socket, the execution of the "SIO_FLUSH" command in WSAIoctl, or the thread
///    that initiated the overlapped request exited before the operation completed. <div class="alert"><b>Note</b> All
///    I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous
///    operations can fail if the thread is closed before the asynchronous operations complete. For more information,
///    see ExitThread.</div> <div> </div> </td> </tr> </table>
///    
alias LPFN_TRANSMITPACKETS = BOOL function(size_t hSocket, TRANSMIT_PACKETS_ELEMENT* lpPacketArray, 
                                           uint nElementCount, uint nSendSize, OVERLAPPED* lpOverlapped, 
                                           uint dwFlags);
///The <b>ConnectEx</b> function establishes a connection to a specified socket, and optionally sends data once the
///connection is established. The <b>ConnectEx</b> function is only supported on connection-oriented sockets. <div
///class="alert"><b>Note</b> This function is a Microsoft-specific extension to the Windows Sockets specification.</div>
///<div> </div>
///Params:
///    s = A descriptor that identifies an unconnected, previously bound socket. See Remarks for more information.
///    name = A pointer to a sockaddr structure that specifies the address to which to connect. For IPv4, the <b>sockaddr</b>
///           contains <b>AF_INET</b> for the address family, the destination IPv4 address, and the destination port. For IPv6,
///           the <b>sockaddr</b> structure contains <b>AF_INET6</b> for the address family, the destination IPv6 address, the
///           destination port, and may contain additional IPv6 flow and scope-id information.
///    namelen = The length, in bytes, of the sockaddr structure pointed to by the <i>name</i> parameter.
///    lpSendBuffer = A pointer to the buffer to be transferred after a connection is established. This parameter is optional. If the
///                   TCP_FASTOPEN option is enabled on <i>s</i> before <b>ConnectEx</b> is called, then some of this data may be sent
///                   during connection establishment.
///    dwSendDataLength = The length, in bytes, of data pointed to by the <i>lpSendBuffer</i> parameter. This parameter is ignored when the
///                       <i>lpSendBuffer</i> parameter is <b>NULL</b>.
///    lpdwBytesSent = On successful return, this parameter points to a <b>DWORD</b> value that indicates the number of bytes that were
///                    sent after the connection was established. The bytes sent are from the buffer pointed to by the
///                    <i>lpSendBuffer</i> parameter. This parameter is ignored when the <i>lpSendBuffer</i> parameter is <b>NULL</b>.
///    lpOverlapped = An OVERLAPPED structure used to process the request. The <i>lpOverlapped</i> parameter must be specified, and
///                   cannot be <b>NULL</b>.
///Returns:
///    On success, the <b>ConnectEx</b> function returns <b>TRUE</b>. On failure, the function returns <b>FALSE</b>. Use
///    the WSAGetLastError function to get extended error information. If a call to the <b>WSAGetLastError</b> function
///    returns <b>ERROR_IO_PENDING</b>, the operation initiated successfully and is in progress. Under such
///    circumstances, the call may still fail when the overlapped operation completes. If the error code returned is
///    WSAECONNREFUSED, WSAENETUNREACH, or WSAETIMEDOUT, the application can call <b>ConnectEx</b>, WSAConnect, or
///    connect again on the same socket. <table> <tr> <th>Error code</th> <th>Description</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup function
///    call must occur before using ConnectEx. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl>
///    </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEADDRINUSE</b></dt> </dl> </td> <td width="60%"> The local address of the socket is already in use, and
///    the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs during a bind
///    operation, but the error could be delayed until a ConnectEx function call, if the <b>bind</b> function was called
///    with a wildcard address (<b>INADDR_ANY</b> or <b>in6addr_any</b>) specified for the local IP address. A specific
///    IP address needs to be implicitly bound by the<b>ConnectEx</b> function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEALREADY</b></dt> </dl> </td> <td width="60%"> A nonblocking connect, WSAConnect, or ConnectEx function
///    call is in progress on the specified socket. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEADDRNOTAVAIL</b></dt> </dl> </td> <td width="60%"> The remote address is not a valid address, such as
///    ADDR_ANY (the ConnectEx function is only supported for connection-oriented sockets). </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> Addresses in the specified family
///    cannot be used with this socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNREFUSED</b></dt> </dl>
///    </td> <td width="60%"> The attempt to connect was rejected. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>name</i>, <i>lpSendBuffer</i>, or
///    <i>lpOverlapped</i> parameter is not a valid part of the user address space, or <i>namelen</i> is too small.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The parameter
///    <i>s</i> is an unbound or a listening socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEISCONN</b></dt>
///    </dl> </td> <td width="60%"> The socket is already connected. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETUNREACH</b></dt> </dl> </td> <td width="60%"> The network cannot be reached from this host at this
///    time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEHOSTUNREACH</b></dt> </dl> </td> <td width="60%"> A
///    socket operation was attempted to an unreachable host. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> No buffer space is available; the socket cannot be
///    connected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The
///    descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td
///    width="60%"> The attempt to connect timed out without establishing a connection. </td> </tr> </table>
///    
alias LPFN_CONNECTEX = BOOL function(size_t s, char* name, int namelen, char* lpSendBuffer, uint dwSendDataLength, 
                                     uint* lpdwBytesSent, OVERLAPPED* lpOverlapped);
///The **DisconnectEx** function closes a connection on a socket, and allows the socket handle to be reused. > [!Note] >
///This function is a Microsoft-specific extension to the Windows Sockets specification.
///Params:
///    s = A handle to a connected, connection-oriented socket.
///    lpOverlapped = A pointer to an [**OVERLAPPED**](../minwinbase/ns-minwinbase-overlapped.md) structure. If the socket handle has
///                   been opened as overlapped, specifying this parameter results in an overlapped (asynchronous) I/O operation.
///    dwFlags = A set of flags that customizes processing of the function call. When this parameter is set to zero, no flags are
///              set. The *dwFlags* parameter can have the following value. <table><colgroup><col style="width: 50%" /><col
///              style="width: 50%" /></colgroup><thead><tr class="header"><th>Flag</th><th>Meaning</th></tr></thead><tbody><tr
///              class="odd"><td><span id="TF_REUSE_SOCKET"></span><span id="tf_reuse_socket"></span><dl>
///              <dt><strong>TF_REUSE_SOCKET</strong></dt> </dl></td><td>Prepares the socket handle to be reused. When the
///              <strong>DisconnectEx</strong> request completes, the socket handle can be passed to the
///              [<strong>AcceptEx</strong>](./nf-mswsock-acceptex.md) or
///              [<strong>ConnectEx</strong>](./nc-mswsock-lpfn_connectex.md) function.<br/><blockquote>[!Note]<br /> The socket
///              level disconnect is subject to the behavior of the underlying transport. For example, a TCP socket may be subject
///              to the TCP TIME_WAIT state, causing the <strong>DisconnectEx</strong> call to be delayed.</blockquote><br/>
///              <br/></td></tr></tbody></table>
///    dwReserved = Reserved. Must be zero. If nonzero, [WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2
///Returns:
///    On success, the **DisconnectEx** function returns **TRUE**. On failure, the function returns **FALSE**. Use the
///    [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function to get extended error information. If a
///    call to the **WSAGetLastError** function returns **ERROR\_IO\_PENDING**, the operation initiated successfully and
///    is in progress. Under such circumstances, the call may still fail when the operation completes. | Error code |
///    Description |
///    |--------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEFAULT](/windows/win32/winsock/windows-sockets-error-codes-2#wsaefault)**</dt> </dl> | The
///    system detected an invalid pointer address in attempting to use a pointer argument. This error is returned if an
///    invalid pointer value was passed in the <i>lpOverlapped</i> parameter.<br/> | | <dl>
///    <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | The invalid
///    parameter was passed. This error is returned if the *dwFlags* parameter was specified with a zero value other
///    than **TF\_REUSE\_SOCKET**.<br/> | | <dl>
///    <dt>**[WSAENOTCONN](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeisconn)**</dt> </dl> | The socket is
///    not connected. This error is returned if the socket *s* parameter was not in a connected state. This error can
///    also be returned if the socket was in the transmit closing state from a previous request and the *dwFlags*
///    parameter was not set to **TF\_REUSE\_SOCKET** to request a reuse of the socket.<br/> |
///    
alias LPFN_DISCONNECTEX = BOOL function(size_t s, OVERLAPPED* lpOverlapped, uint dwFlags, uint dwReserved);
///**LPFN_WSARECVMSG** is a function pointer type. You implement a matching **WSARecvMsg** callback function in your
///app. The system uses your callback function to transmit to you in-memory data, or file data, over a connected socket.
///Your **WSARecvMsg** callback function receives ancillary data/control information with a message, from connected and
///unconnected sockets. > [!NOTE] > This function is a Microsoft-specific extension to the Windows Sockets
///specification.
///Params:
///    s = Type: \_In\_ **SOCKET** A descriptor that identifies the socket.
///    lpMsg = Type: \_Inout\_ **[LPWSAMSG](../ws2def/ns-ws2def-wsamsg.md)** A pointer to a
///            [**WSAMSG**](../ws2def/ns-ws2def-wsamsg.md) structure based on the Posix.1g specification for the msghdr
///            structure.
///    lpdwNumberOfBytesRecvd = Type: \_Out_opt\_ **[LPDWORD](/windows/win32/winprog/windows-data-types)** A pointer to a **DWORD** containing
///                             number of bytes received by this call if the **WSARecvMsg** operation completes immediately. To avoid potentially
///                             erroneous results, pass **NULL** for this parameter if the *lpOverlapped* parameter is not **NULL** . This
///                             parameter can be **NULL** only if the *lpOverlapped* parameter is not **NULL**.
///    lpOverlapped = Type: \_Inout_opt\_ **[LPWSAOVERLAPPED](../winsock2/ns-winsock2-wsaoverlapped.md)** A pointer to a
///                   [**WSAOVERLAPPED**](../winsock2/ns-winsock2-wsaoverlapped.md) structure. Ignored for non-overlapped structures.
///    lpCompletionRoutine = Type: \_In_opt\_
///                          [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](../winsock2/nc-winsock2-lpwsaoverlapped_completion_routine.md) A pointer
///                          to the completion routine called when the receive operation completes. Ignored for non-overlapped structures.
///Returns:
///    If no error occurs and the receive operation has completed immediately, **WSARecvMsg** returns zero. In this
///    case, the completion routine will have already been scheduled to be called once the calling thread is in the
///    alertable state. Otherwise, a value of SOCKET\_ERROR is returned, and a specific error code can be retrieved by
///    calling [**WSAGetLastError**](https://msdn.microsoft.com/en-us/library/ms741580\(v=vs.85\)). The error code
///    **WSA\_IO\_PENDING** indicates that the overlapped operation has been successfully initiated and that completion
///    will be indicated at a later time. Any other error code indicates that the operation was not successfully
///    initiated and no completion indication will occur if an overlapped operation was requested. <table> <colgroup>
///    <col style="width: 50%" /> <col style="width: 50%" /> </colgroup> <thead> <tr class="header"> <th>Error code</th>
///    <th>Meaning</th> </tr> </thead> <tbody> <tr class="odd"> <td><strong>WSAECONNRESET</strong></td> <td><p>For a UDP
///    datagram socket, this error would indicate that a previous send operation resulted in an ICMP &quot;Port
///    Unreachable&quot; message.</p></td> </tr> <tr class="even"> <td><strong>WSAEFAULT</strong></td> <td><p>The
///    <em>lpBuffers</em>, <em>lpFlags</em>, <em>lpFrom</em>, <em>lpNumberOfBytesRecvd</em>, <em>lpFromlen</em>,
///    <em>lpOverlapped</em>, or <em>lpCompletionRoutine</em> parameter is not totally contained in a valid part of the
///    user address space: the <em>lpFrom</em> buffer was too small to accommodate the peer address. This error is also
///    returned if a <strong>name</strong> member of the <strong>WSAMSG</strong> structure pointed to by the
///    <em>lpMsg</em> parameter was a <strong>NULL</strong> pointer and the <strong>namelen</strong> member of the
///    <strong>WSAMSG</strong> structure was not set to zero. This error is also returned if a
///    <strong>Control.buf</strong> member of the <strong>WSAMSG</strong> structure pointed to by the <em>lpMsg</em>
///    parameter was a <strong>NULL</strong> pointer and the <strong>Control.len</strong> member of the
///    <strong>WSAMSG</strong> structure was not set to zero.</p></td> </tr> <tr class="odd">
///    <td><strong>WSAEINPROGRESS</strong></td> <td><p>A blocking Windows Sockets 1.1 call is in progress, or the
///    service provider is still processing a callback function.</p></td> </tr> <tr class="even">
///    <td><strong>WSAEINTR</strong></td> <td><p>A blocking Windows Socket 1.1 call was canceled through
///    WSACancelBlockingCall.</p></td> </tr> <tr class="odd"> <td><strong>WSAEINVAL</strong></td> <td><p>The socket has
///    not been bound (with <strong>bind</strong>, for example).</p></td> </tr> <tr class="even">
///    <td><strong>WSAEMSGSIZE</strong></td> <td><p>The message was too large to fit into the specified buffer and (for
///    unreliable protocols only) any trailing portion of the message that did not fit into the buffer has been
///    discarded.</p></td> </tr> <tr class="odd"> <td><strong>WSAENETDOWN</strong></td> <td><p>The network subsystem has
///    failed.</p></td> </tr> <tr class="even"> <td><strong>WSAENETRESET</strong></td> <td><p>For a datagram socket,
///    this error indicates that the time to live has expired.</p></td> </tr> <tr class="odd">
///    <td><strong>WSAENOTCONN</strong></td> <td><p>The socket is not connected (connection-oriented sockets
///    only).</p></td> </tr> <tr class="even"> <td><strong>WSAETIMEDOUT</strong></td> <td><p>The socket timed out. This
///    error is returned if the socket had a wait timeout specified using the <strong>SO_RCVTIMEO</strong> socket option
///    and the timeout was exceeded.</p></td> </tr> <tr class="odd"> <td><strong>WSAEOPNOTSUPP</strong></td> <td><p>The
///    socket operation is not supported. This error is returned if the <strong>dwFlags</strong> member of the
///    <strong>WSAMSG</strong> structure pointed to by the <em>lpMsg</em> parameter includes the
///    <strong>MSG_PEEK</strong> control flag on a non-datagram socket.</p></td> </tr> <tr class="even">
///    <td><strong>WSAEWOULDBLOCK</strong></td> <td><p><strong>Windows NT: </strong></p> <p>Overlapped sockets: There
///    are too many outstanding overlapped I/O requests. Non-overlapped sockets: The socket is marked as nonblocking and
///    the receive operation cannot be completed immediately.</p></td> </tr> <tr class="odd">
///    <td><strong>WSANOTINITIALISED</strong></td> <td><p>A successful <strong>WSAStartup</strong> call must occur
///    before using this function.</p></td> </tr> <tr class="even"> <td><strong>WSA_IO_PENDING</strong></td> <td><p>An
///    overlapped operation was successfully initiated and completion will be indicated at a later time.</p></td> </tr>
///    <tr class="odd"> <td><strong>WSA_OPERATION_ABORTED</strong></td> <td><p>The overlapped operation has been
///    canceled due to the closure of the socket.</p></td> </tr> </tbody> </table>
///    
alias LPFN_WSARECVMSG = int function(size_t s, WSAMSG* lpMsg, uint* lpdwNumberOfBytesRecvd, 
                                     OVERLAPPED* lpOverlapped, 
                                     LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
alias LPFN_WSASENDMSG = int function(size_t s, WSAMSG* lpMsg, uint dwFlags, uint* lpNumberOfBytesSent, 
                                     OVERLAPPED* lpOverlapped, 
                                     LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
alias LPFN_WSAPOLL = int function(WSAPOLLFD* fdarray, uint nfds, int timeout);
///The **RIOReceive** function receives network data on a connected registered I/O TCP socket or a bound registered I/O
///UDP socket for use with the Winsock registered I/O extensions.
///Params:
///    SocketQueue = A descriptor that identifies a connected registered I/O TCP socket or a bound registered I/O UDP socket.
///    pData = A description of the portion of the registered buffer in which to receive data. This parameter may be NULL for a
///            bound registered I/O UDP socket if the application does not need to receive the data payload in the UDP datagram.
///    DataBufferCount = A data buffer count parameter that indicates if data is to be received in the buffer pointed to by the *pData*
///                      parameter. This parameter should be set to zero if the *pData* is NULL. Otherwise, this parameter should be set
///                      to 1.
///    Flags = A set of flags that modify the behavior of the **RIOReceive** function. The *Flags* parameter can contain a
///            combination of the following options defined in the *Mswsockdef.h* header file: <table><colgroup><col
///            style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr
///            class="header"><th>Flag</th><th>Meaning</th></tr></thead><tbody><tr class="odd"><td><span
///            id="RIO_MSG_COMMIT_ONLY"></span><span id="rio_msg_commit_only"></span><dl>
///            <dt><strong>RIO_MSG_COMMIT_ONLY</strong></dt> </dl></td><td>Previous requests added with
///            <strong>RIO_MSG_DEFER</strong> flag will be committed. <br/> When the <strong>RIO_MSG_COMMIT_ONLY</strong> flag
///            is set, no other flags may be specified. When the <strong>RIO_MSG_COMMIT_ONLY</strong> flag is set, the
///            <em>pData</em> and <em>RequestContext</em> parameters must be NULL and the <em>DataBufferCount</em> parameter
///            must be zero. <br/> This flag would normally be used occasionally after a number of requests were issued with the
///            <strong>RIO_MSG_DEFER</strong> flag set. This eliminates the need when using the <strong>RIO_MSG_DEFER</strong>
///            flag to make the last request without the <strong>RIO_MSG_DEFER</strong> flag, which causes the last request to
///            complete much slower than other requests. <br/> Unlike other calls to the <strong>RIOReceive</strong> function,
///            when the <strong>RIO_MSG_COMMIT_ONLY</strong> flag is set calls to the <strong>RIOReceive</strong> function do
///            not need to be serialized. For a single [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue), the
///            <strong>RIOReceive</strong> function can be called with <strong>RIO_MSG_COMMIT_ONLY</strong> on one thread while
///            calling the <strong>RIOReceive</strong> function on another thread.<br/></td></tr><tr class="even"><td><span
///            id="RIO_MSG_DONT_NOTIFY"></span><span id="rio_msg_dont_notify"></span><dl>
///            <dt><strong>RIO_MSG_DONT_NOTIFY</strong></dt> </dl></td><td>The request should not trigger the
///            [<strong>RIONotify</strong>](./nc-mswsock-lpfn_rionotify.md) function when request completion is inserted into
///            its completion queue.<br/></td></tr><tr class="odd"><td><span id="RIO_MSG_DEFER"></span><span
///            id="rio_msg_defer"></span><dl> <dt><strong>RIO_MSG_DEFER</strong></dt> </dl></td><td>The request does not need to
///            be executed immediately. This will insert the request into the request queue, but it may or may not trigger the
///            execution of the request. <br/> Data reception may be delayed until a receive request is made on the
///            [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue) passed in the <em>SocketQueue</em> parameter without
///            the <strong>RIO_MSG_DEFER</strong> flag set. To trigger execution for all receives in a request queue, call the
///            <strong>RIOReceive</strong> or [<strong>RIOReceiveEx</strong>](./nc-mswsock-lpfn_rioreceiveex.md) function
///            without the <strong>RIO_MSG_DEFER</strong> flag set. <br/><blockquote>[!Note]<br /> The receive request is
///            charged against the outstanding I/O capacity on the [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue)
///            passed in the <em>SocketQueue</em> parameter regardless of whether <strong>RIO_MSG_DEFER</strong> is
///            set.</blockquote><br/></td></tr><tr class="even"><td><span id="RIO_MSG_WAITALL"></span><span
///            id="rio_msg_waitall"></span><dl> <dt><strong>RIO_MSG_WAITALL</strong></dt> </dl></td><td>The
///            <strong>RIOReceive</strong> function will not complete until one of the following events occurs:<br/><ul><li>The
///            buffer segment supplied by the caller in the <em>pData</em> parameter is completely full.</li><li>The connection
///            has been closed.</li><li>The request has been canceled or an error occurred.</li></ul><br/> This flag is not
///            supported on UDP sockets.<br/></td></tr></tbody></table>
///    RequestContext = The request context to associate with this receive operation.
///Returns:
///    If no error occurs, the **RIOReceive** function returns **TRUE**. In this case, the receive operation is
///    successfully initiated and the completion will have already been queued or the operation has been successfully
///    initiated and the completion will be queued at a later time. A value of **FALSE** indicates the function failed,
///    the operation was not successfully initiated and no completion indication will be queued. A specific error code
///    can be retrieved by calling the [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function. |
///    Return code | Description |
///    |-------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEFAULT](/windows/win32/winsock/windows-sockets-error-codes-2#wsaefault)**</dt> </dl> | The
///    system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is
///    returned if a buffer identifier is deregistered or a buffer is freed for any of the
///    [**RIO\_BUF**](../mswsockdef/ns-mswsockdef-rio_buf.md) structures passed in parameters before the operation is
///    queued or invoked.<br/> | | <dl>
///    <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | An invalid
///    parameter was passed to the function. <br/> This error is returned if the *SocketQueue* parameter is not valid,
///    the *Flags* parameter contains an value not valid for a receive operation, or the integrity of the completion
///    queue has been compromised. This error can also be returned for other issues with parameters.<br/> | | <dl>
///    <dt>**[WSAENOBUFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenobufs)**</dt> </dl> | Sufficient
///    memory could not be allocated. This error is returned if the I/O completion queue associated with the
///    *SocketQueue* parameter is full or the I/O completion queue was created with zero receive entries.<br/> | | <dl>
///    <dt>**[WSA\_OPERATION\_ABORTED](/windows/win32/winsock/windows-sockets-error-codes-2#wsa-operation-aborted)**</dt>
///    </dl> | The operation has been canceled while the receive operation was pending. This error is returned if the
///    socket is closed locally or remotely, or the **SIO\_FLUSH** command in
///    [**WSAIoctl**](../winsock2/nf-winsock2-wsaioctl.md) is executed on this socket.<br/> |
///    
alias LPFN_RIORECEIVE = BOOL function(RIO_RQ_t* SocketQueue, char* pData, uint DataBufferCount, uint Flags, 
                                      void* RequestContext);
///The **RIOReceiveEx** function receives network data on a connected registered I/O TCP socket or a bound registered
///I/O UDP socket with additional options for use with the Winsock registered I/O extensions.
///Params:
///    SocketQueue = A descriptor that identifies a connected registered I/O UDP socket or a bound registered I/O UDP socket.
///    pData = A description of the portion of the registered buffer in which to receive data. This parameter may be NULL for a
///            bound registered I/O UDP socket if the application does not need to receive a data payload in the UDP datagram.
///    DataBufferCount = A data buffer count parameter that indicates if data is to be received in the buffer pointed to by the *pData*
///                      parameter. This parameter should be set to zero if the *pData* is NULL. Otherwise, this parameter should be set
///                      to 1.
///    pLocalAddress = A buffer segment that on completion will hold the local address on which the network data was received. This
///                    parameter may be **NULL** if the application does not want to receive the local address. If this parameter is not
///                    **NULL**, then the buffer segment must be at least the size of a
///                    [**SOCKADDR\_INET**](../ws2ipdef/ns-ws2ipdef-sockaddr_inet.md) structure.
///    pRemoteAddress = A buffer segment that on completion will hold the remote address from which the network data was received. This
///                     parameter may be **NULL** if the application does not want to receive the remote address. If this parameter is
///                     not **NULL**, then the buffer segment must be at least the size of a
///                     [**SOCKADDR\_INET**](../ws2ipdef/ns-ws2ipdef-sockaddr_inet.md) structure.
///    pControlContext = A buffer slice that on completion will hold additional control information about the receive operation. This
///                      parameter may be **NULL** if the application does not want to receive the additional control information.
///    pFlags = This parameter may be **NULL** if the application does not want to receive the additional flags information.
///    Flags = A set of flags that modify the behavior of the **RIOReceiveEx** function. The *Flags* parameter can contain a
///            combination of the following options defined in the *Mswsockdef.h* header file: <table><colgroup><col
///            style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr
///            class="header"><th>Flag</th><th>Meaning</th></tr></thead><tbody><tr class="odd"><td><span
///            id="RIO_MSG_COMMIT_ONLY"></span><span id="rio_msg_commit_only"></span><dl>
///            <dt><strong>RIO_MSG_COMMIT_ONLY</strong></dt> </dl></td><td>Previous requests added with
///            <strong>RIO_MSG_DEFER</strong> flag will be committed. <br/> When the <strong>RIO_MSG_COMMIT_ONLY</strong> flag
///            is set, no other flags may be specified. When the <strong>RIO_MSG_COMMIT_ONLY</strong> flag is set, the
///            <em>pData</em>, <em>pLocalAddress</em>, <em>pRemoteAddress</em>, <em>pControlContext</em>, <em>pFlags</em>, and
///            <em>RequestContext</em> parameters must be NULL and the <em>DataBufferCount</em> parameter must be zero. <br/>
///            This flag would normally be used occasionally after a number of requests were issued with the
///            <strong>RIO_MSG_DEFER</strong> flag set. This eliminates the need when using the <strong>RIO_MSG_DEFER</strong>
///            flag to make the last request without the <strong>RIO_MSG_DEFER</strong> flag, which causes the last request to
///            complete much slower than other requests. <br/> Unlike other calls to the <strong>RIOReceiveEx</strong> function,
///            when the <strong>RIO_MSG_COMMIT_ONLY</strong> flag is set calls to the <strong>RIOReceiveEx</strong> function do
///            not need to be serialized. For a single [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue), the
///            <strong>RIOReceiveEx</strong> function can be called with <strong>RIO_MSG_COMMIT_ONLY</strong> on one thread
///            while calling the <strong>RIOReceiveEx</strong> function on another thread.<br/></td></tr><tr
///            class="even"><td><span id="RIO_MSG_DONT_NOTIFY"></span><span id="rio_msg_dont_notify"></span><dl>
///            <dt><strong>RIO_MSG_DONT_NOTIFY</strong></dt> </dl></td><td>The request should not trigger the
///            [<strong>RIONotify</strong>](./nc-mswsock-lpfn_rionotify.md) function when request completion is inserted into
///            its completion queue.<br/></td></tr><tr class="odd"><td><span id="RIO_MSG_DEFER"></span><span
///            id="rio_msg_defer"></span><dl> <dt><strong>RIO_MSG_DEFER</strong></dt> </dl></td><td>The request does not need to
///            be executed immediately. This will insert the request into the request queue, but it may or may not trigger the
///            execution of the request. <br/> Data reception may be delayed until a receive request is made on the
///            [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue) passed in the <em>SocketQueue</em> parameter without
///            the <strong>RIO_MSG_DEFER</strong> flag set. To trigger execution for all receives in a request queue, call the
///            [<strong>RIOReceive</strong>](./nc-mswsock-lpfn_rioreceive.md) or <strong>RIOReceiveEx</strong> function without
///            the <strong>RIO_MSG_DEFER</strong> flag set. <br/><blockquote>[!Note]<br /> The receive request is charged
///            against the outstanding I/O capacity on the [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue) passed in
///            the <em>SocketQueue</em> parameter regardless of whether <strong>RIO_MSG_DEFER</strong> is
///            set.</blockquote><br/></td></tr><tr class="even"><td><span id="RIO_MSG_WAITALL"></span><span
///            id="rio_msg_waitall"></span><dl> <dt><strong>RIO_MSG_WAITALL</strong></dt> </dl></td><td>The
///            <strong>RIOReceiveEx</strong> function will not complete until one of the following events
///            occurs:<br/><ul><li>The buffer slice supplied by the caller in the <em>pData</em> parameter is completely
///            full.</li><li>The connection has been closed.</li><li>The request has been canceled or an error
///            occurred.</li></ul><br/> This flag is not supported on datagram sockets or on message-oriented connectionless
///            sockets.<br/></td></tr></tbody></table>
///    RequestContext = The request context to associate with this receive operation.
///Returns:
///    If no error occurs, the **RIOReceiveEx** function returns **TRUE**. In this case, the receive operation is
///    successfully initiated and the completion will have already been queued or the operation has been successfully
///    initiated and the completion will be queued at a later time. A value of **FALSE** indicates the function failed,
///    the operation was not successfully initiated and no completion indication will be queued. A specific error code
///    can be retrieved by calling the [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function. |
///    Return code | Description |
///    |-------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEFAULT](/windows/win32/winsock/windows-sockets-error-codes-2#wsaefault)**</dt> </dl> | The
///    system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is
///    returned if a buffer identifier is deregistered or a buffer is freed for any of the
///    [**RIO\_BUF**](../mswsockdef/ns-mswsockdef-rio_buf.md) structures passed in parameters before the operation is
///    queued or invoked.<br/> | | <dl>
///    <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | An invalid
///    parameter was passed to the function. <br/> This error is returned if the *SocketQueue* parameter is not valid,
///    the *dwFlags* parameter contains an value not valid for a receive operation, or the integrity of the completion
///    queue has been compromised. This error can also be returned for other issues with parameters.<br/> | | <dl>
///    <dt>**[WSAENOBUFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenobufs)**</dt> </dl> | Sufficient
///    memory could not be allocated. This error is returned if the I/O completion queue associated with the
///    *SocketQueue* parameter is full or the I/O completion queue was created with zero receive entries.<br/> | | <dl>
///    <dt>**[WSA\_OPERATION\_ABORTED](/windows/win32/winsock/windows-sockets-error-codes-2#wsa-operation-aborted)**</dt>
///    </dl> | The operation has been canceled while the receive operation was pending. This error is returned if the
///    socket is closed locally or remotely, or the the SIO\_FLUSH command in
///    [**WSAIoctl**](../winsock2/nf-winsock2-wsaioctl.md) is executed.<br/> |
///    
alias LPFN_RIORECEIVEEX = int function(RIO_RQ_t* SocketQueue, char* pData, uint DataBufferCount, 
                                       RIO_BUF* pLocalAddress, RIO_BUF* pRemoteAddress, RIO_BUF* pControlContext, 
                                       RIO_BUF* pFlags, uint Flags, void* RequestContext);
///The **RIOSend** function sends network data on a connected registered I/O TCP socket or a bound registered I/O UDP
///socket for use with the Winsock registered I/O extensions.
///Params:
///    SocketQueue = A descriptor that identifies a connected registered I/O TCP socket or a bound registered I/O UDP socket.
///    pData = A description of the portion of the registered buffer from which to send data. This parameter may be NULL for a
///            bound registered I/O UDP socket if the application does not need to send a data payload in the UDP datagram.
///    DataBufferCount = A data buffer count parameter that indicates if data is to be sent in the buffer pointed to by the *pData*
///                      parameter. This parameter should be set to zero if the *pData* is NULL. Otherwise, this parameter should be set
///                      to 1.
///    Flags = A set of flags that modify the behavior of the **RIOSend** function. The *Flags* parameter can contain a
///            combination of the following options defined in the *Mswsockdef.h* header file: <table><colgroup><col
///            style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr
///            class="header"><th>Flag</th><th>Meaning</th></tr></thead><tbody><tr class="odd"><td><span
///            id="RIO_MSG_COMMIT_ONLY"></span><span id="rio_msg_commit_only"></span><dl>
///            <dt><strong>RIO_MSG_COMMIT_ONLY</strong></dt> </dl></td><td>Previous requests added with
///            <strong>RIO_MSG_DEFER</strong> flag will be committed. <br/> When the <strong>RIO_MSG_COMMIT_ONLY</strong> flag
///            is set, no other flags may be specified. When the <strong>RIO_MSG_COMMIT_ONLY</strong> flag is set, the
///            <em>pData</em> and <em>RequestContext</em> parameters must be NULL and the <em>DataBufferCount</em> parameter
///            must be zero. <br/> This flag would normally be used occasionally after a number of requests were issued with the
///            <strong>RIO_MSG_DEFER</strong> flag set. This eliminates the need when using the <strong>RIO_MSG_DEFER</strong>
///            flag to make the last request without the <strong>RIO_MSG_DEFER</strong> flag, which causes the last request to
///            complete much slower than other requests. <br/> Unlike other calls to the <strong>RIOSend</strong> function, when
///            the <strong>RIO_MSG_COMMIT_ONLY</strong> flag is set calls to the <strong>RIOSend</strong> function do not need
///            to be serialized. For a single [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue), the
///            <strong>RIOSend</strong> function can be called with <strong>RIO_MSG_COMMIT_ONLY</strong> on one thread while
///            calling the <strong>RIOSend</strong> function on another thread.<br/></td></tr><tr class="even"><td><span
///            id="RIO_MSG_DONT_NOTIFY"></span><span id="rio_msg_dont_notify"></span><dl>
///            <dt><strong>RIO_MSG_DONT_NOTIFY</strong></dt> </dl></td><td>The request should not trigger the
///            [<strong>RIONotify</strong>](./nc-mswsock-lpfn_rionotify.md) function when request completion is inserted into
///            its completion queue.<br/></td></tr><tr class="odd"><td><span id="RIO_MSG_DEFER"></span><span
///            id="rio_msg_defer"></span><dl> <dt><strong>RIO_MSG_DEFER</strong></dt> </dl></td><td>The request does not need to
///            be executed immediately. This will insert the request into the request queue, but it may or may not trigger the
///            execution of the request. <br/> Sending data may be delayed until a send request is made on the
///            [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue) passed in the <em>SocketQueue</em> parameter without
///            the <strong>RIO_MSG_DEFER</strong> flag set. To trigger execution for all sends in a send queue, call the
///            <strong>RIOSend</strong> or [<strong>RIOSendEx</strong>](./nc-mswsock-lpfn_riosendex.md) function without the
///            <strong>RIO_MSG_DEFER</strong> flag set. <br/><blockquote>[!Note]<br /> The send request is charged against the
///            outstanding I/O capacity on the [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue) passed in the
///            <em>SocketQueue</em> parameter regardless of whether <strong>RIO_MSG_DEFER</strong> is
///            set.</blockquote><br/></td></tr></tbody></table>
///    RequestContext = The request context to associate with this send operation.
///Returns:
///    If no error occurs, the **RIOSend** function returns **TRUE**. In this case, the send operation is successfully
///    initiated and the completion will have already been queued or the operation has been successfully initiated and
///    the completion will be queued at a later time. A value of **FALSE** indicates the function failed, the operation
///    was not successfully initiated and no completion indication will be queued. A specific error code can be
///    retrieved by calling the [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function. | Return code
///    | Description |
///    |-----------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEFAULT](/windows/win32/winsock/windows-sockets-error-codes-2#wsaefault)**</dt> </dl> | The
///    system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is
///    returned if a buffer identifier is deregistered or a buffer is freed for any of the
///    [**RIO\_BUF**](../mswsockdef/ns-mswsockdef-rio_buf.md) structures passed in parameters before the operation is
///    queued or invoked.<br/> | | <dl>
///    <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | An invalid
///    parameter was passed to the function. <br/> This error is returned if the *SocketQueue* parameter is not valid,
///    the *Flags* parameter contains an value not valid for a send operation, or the integrity of the completion queue
///    has been compromised. This error can also be returned for other issues with parameters.<br/> | | <dl>
///    <dt>**[WSAENOBUFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenobufs)**</dt> </dl> | Sufficient
///    memory could not be allocated. This error is returned if the I/O completion queue associated with the
///    *SocketQueue* parameter is full or the I/O completion queue was created with zero send entries.<br/> | | <dl>
///    <dt>**[WSA\_IO\_PENDING](/windows/win32/winsock/windows-sockets-error-codes-2#wsa-io-pending)**</dt> </dl> | The
///    operation has been successfully initiated and the completion will be queued at a later time.<br/> |
///    
alias LPFN_RIOSEND = BOOL function(RIO_RQ_t* SocketQueue, char* pData, uint DataBufferCount, uint Flags, 
                                   void* RequestContext);
///The **RIOSendEx** function sends network data on a connected registered I/O TCP socket or a bound registered I/O UDP
///socket with additional options for use with the Winsock registered I/O extensions.
///Params:
///    SocketQueue = A descriptor that identifies a connected registered I/O TCP socket or a bound registered I/O UDP socket.
///    pData = A buffer segment from a registered buffer from which to send data. The
///            [**RIO\_BUF**](../mswsockdef/ns-mswsockdef-rio_buf.md) structure pointed to by this parameter can represent a
///            portion of a registered buffer or a complete registered buffer. This parameter may be NULL for a bound registered
///            I/O UDP socket if the application does not need to send a data payload in the UDP datagram.
///    DataBufferCount = A data buffer count parameter that indicates if data is to be sent in the buffer pointed to by the *pData*
///                      parameter. This parameter should be set to zero if the *pData* is NULL. Otherwise, this parameter should be set
///                      to 1.
///    pLocalAddress = This parameter is reserved and must be **NULL**.
///    pRemoteAddress = A buffer segment from a registered buffer that on input holds the remote address to which the network data is to
///                     be sent. This parameter may be **NULL** if the socket is connected.
///    pControlContext = A buffer slice that on completion will hold additional control information about the send operation. This
///                      parameter may be **NULL** if the application does not want to receive the additional control information.
///    pFlags = A buffer slice that on completion will hold additional information about the set of flags for the send operation.
///             This parameter may be **NULL** if the application does not want to receive the additional flags information.
///    Flags = A set of flags that modify the behavior of the **RIOSendEx** function. The *Flags* parameter can contain a
///            combination of the following options defined in the *Mswsockdef.h* header file: <table><colgroup><col
///            style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr
///            class="header"><th>Flag</th><th>Meaning</th></tr></thead><tbody><tr class="odd"><td><span
///            id="RIO_MSG_COMMIT_ONLY"></span><span id="rio_msg_commit_only"></span><dl>
///            <dt><strong>RIO_MSG_COMMIT_ONLY</strong></dt> </dl></td><td>Previous requests added with
///            <strong>RIO_MSG_DEFER</strong> flag will be committed. <br/> When the <strong>RIO_MSG_COMMIT_ONLY</strong> flag
///            is set, no other flags may be specified. When the <strong>RIO_MSG_COMMIT_ONLY</strong> flag is set, the
///            <em>pData</em>, <em>pLocalAddress</em>, <em>pRemoteAddress</em>, <em>pControlContext</em>, <em>pFlags</em>, and
///            <em>RequestContext</em> parameters must be NULL and the <em>DataBufferCount</em> parameter must be zero. <br/>
///            This flag would normally be used occasionally after a number of requests were issued with the
///            <strong>RIO_MSG_DEFER</strong> flag set. This eliminates the need when using the <strong>RIO_MSG_DEFER</strong>
///            flag to make the last request without the <strong>RIO_MSG_DEFER</strong> flag, which causes the last request to
///            complete much slower than other requests. <br/> Unlike other calls to the <strong>RIOSendEx</strong> function,
///            when the <strong>RIO_MSG_COMMIT_ONLY</strong> flag is set calls to the <strong>RIOSendEx</strong> function do not
///            need to be serialized. For a single [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue), the
///            <strong>RIOSendEx</strong> function can be called with <strong>RIO_MSG_COMMIT_ONLY</strong> on one thread while
///            calling the <strong>RIOSendEx</strong> function on another thread.<br/></td></tr><tr class="even"><td><span
///            id="RIO_MSG_DONT_NOTIFY"></span><span id="rio_msg_dont_notify"></span><dl>
///            <dt><strong>RIO_MSG_DONT_NOTIFY</strong></dt> </dl></td><td>The request should not trigger the
///            [<strong>RIONotify</strong>](./nc-mswsock-lpfn_rionotify.md) function when request completion is inserted into
///            its completion queue.<br/></td></tr><tr class="odd"><td><span id="RIO_MSG_DEFER"></span><span
///            id="rio_msg_defer"></span><dl> <dt><strong>RIO_MSG_DEFER</strong></dt> </dl></td><td>The request does not need to
///            be executed immediately. This will insert the request into the request queue, but it may or may not trigger the
///            execution of the request. <br/> Sending data may be delayed until a send request is made on the
///            [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue) passed in the <em>SocketQueue</em> parameter without
///            the <strong>RIO_MSG_DEFER</strong> flag set. To trigger execution for all sends in a send queue, call the
///            [<strong>RIOSend</strong>](./nc-mswsock-lpfn_riosend.md) or <strong>RIOSendEx</strong> function without the
///            <strong>RIO_MSG_DEFER</strong> flag set. <br/><blockquote>[!Note]<br /> The send request is charged against the
///            outstanding I/O capacity on the [<strong>RIO_RQ</strong>](/windows/win32/winsock/riorqueue) passed in the
///            <em>SocketQueue</em> parameter regardless of whether <strong>RIO_MSG_DEFER</strong> is
///            set.</blockquote><br/></td></tr></tbody></table>
///    RequestContext = The request context to associate with this send operation.
///Returns:
///    If no error occurs, the **RIOSendEx** function returns **TRUE**. In this case, the send operation is successfully
///    initiated and the completion will have already been queued or the operation has been successfully initiated and
///    the completion will be queued at a later time. A value of **FALSE** indicates the function failed, the operation
///    was not successfully initiated and no completion indication will be queued. A specific error code can be
///    retrieved by calling the [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function. | Return code
///    | Description |
///    |-----------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEFAULT](/windows/win32/winsock/windows-sockets-error-codes-2#wsaefault)**</dt> </dl> | The
///    system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is
///    returned if a buffer identifier is deregistered or a buffer is freed for any of the
///    [**RIO\_BUF**](../mswsockdef/ns-mswsockdef-rio_buf.md) structures passed in parameters before the operation is
///    queued or invoked.<br/> | | <dl>
///    <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | An invalid
///    parameter was passed to the function. <br/> This error is returned if the *SocketQueue* parameter is not valid,
///    the *Flags* parameter contains an value not valid for a send operation, or the integrity of the completion queue
///    has been compromised. This error can also be returned for other issues with parameters.<br/> | | <dl>
///    <dt>**[WSAENOBUFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenobufs)**</dt> </dl> | Sufficient
///    memory could not be allocated. This error is returned if the I/O completion queue associated with the
///    *SocketQueue* parameter is full or the I/O completion queue was created with zero send entries.<br/> | | <dl>
///    <dt>**[WSA\_IO\_PENDING](/windows/win32/winsock/windows-sockets-error-codes-2#wsa-io-pending)**</dt> </dl> | The
///    operation has been successfully initiated and the completion will be queued at a later time.<br/> |
///    
alias LPFN_RIOSENDEX = BOOL function(RIO_RQ_t* SocketQueue, char* pData, uint DataBufferCount, 
                                     RIO_BUF* pLocalAddress, RIO_BUF* pRemoteAddress, RIO_BUF* pControlContext, 
                                     RIO_BUF* pFlags, uint Flags, void* RequestContext);
///The **RIOCloseCompletionQueue** function closes an existing completion queue used for I/O completion notification by
///send and receive requests with the Winsock registered I/O extensions.
///Params:
///    CQ = A descriptor identifying an existing completion queue.
alias LPFN_RIOCLOSECOMPLETIONQUEUE = void function(RIO_CQ_t* CQ);
///The **RIOCreateCompletionQueue** function creates an I/O completion queue of a specific size for use with the Winsock
///registered I/O extensions.
///Params:
///    QueueSize = The size, in number of entries, of the completion queue to create.
///    NotificationCompletion = The type of notification completion to use based on the **Type** member of the
///                             [**RIO\_NOTIFICATION\_COMPLETION**](./ns-mswsock-rio_notification_completion.md) structure (I/O completion or
///                             event notification). If the **Type** member is set to **RIO\_EVENT\_COMPLETION**, then the **Event** member of
///                             the [**RIO\_NOTIFICATION\_COMPLETION**](./ns-mswsock-rio_notification_completion.md) structure must be set. If
///                             the **Type** member is set to **RIO\_IOCP\_COMPLETION**, then the **Iocp** member of the
///                             [**RIO\_NOTIFICATION\_COMPLETION**](./ns-mswsock-rio_notification_completion.md) structure must be set and the
///                             **Iocp.Overlapped** member of the **RIO\_NOTIFICATION\_COMPLETION** structure must not be NULL. If the
///                             *NotificationCompletion* parameter is NULL, this specifies no notification completion is used and that polling
///                             must be used to determine completion.
///Returns:
///    If no error occurs, the **RIOCreateCompletionQueue** function returns a descriptor referencing a new completion
///    queue. Otherwise, a value of **RIO\_INVALID\_CQ** is returned, and a specific error code can be retrieved by
///    calling the [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function. | Return code | Description
///    |
///    |-------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEFAULT](/windows/win32/winsock/windows-sockets-error-codes-2#wsaefault)**</dt> </dl> | The
///    system detected an invalid pointer address in attempting to use a pointer argument in a call.<br/> | | <dl>
///    <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | An invalid
///    parameter was passed to the function. <br/> This error is returned if the *QueueSize* parameter is less than 1 or
///    greater than **RIO\_MAX\_CQ\_SIZE** defined in the <i>Mswsockdef.h</i> header file.<br/> | | <dl>
///    <dt>**[WSAENOBUFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenobufs)**</dt> </dl> | Sufficient
///    memory could not be allocated. This error is returned if there was insufficient memory to allocate the completion
///    queue requested based on the *QueueSize* parameter. <br/> |
///    
alias LPFN_RIOCREATECOMPLETIONQUEUE = RIO_CQ_t* function(uint QueueSize, 
                                                         RIO_NOTIFICATION_COMPLETION* NotificationCompletion);
///The **RIOCreateRequestQueue** function creates a registered I/O socket descriptor using a specified socket and I/O
///completion queues for use with the Winsock registered I/O extensions.
///Params:
///    Socket = A descriptor that identifies the socket.
///    MaxOutstandingReceive = The maximum number of outstanding receives allowed on the socket. This parameter is usually a small number for
///                            most applications.
///    MaxReceiveDataBuffers = The maximum number of receive data buffers on the socket. > [!Note] > For Windows 8 and Windows Server 2012 ,
///                            this parameter must be **1**.
///    MaxOutstandingSend = The maximum number of outstanding sends allowed on the socket.
///    MaxSendDataBuffers = The maximum number of send data buffers on the socket. > [!Note] > For Windows 8 and Windows Server 2012 , this
///                         parameter must be **1**.
///    ReceiveCQ = A descriptor that identifies the I/O completion queue to use for receive request completions.
///    SendCQ = A descriptor that identifies the I/O completion queue to use for send request completions. This parameter may
///             have the same value as the *ReceiveCQ* parameter.
///    SocketContext = The socket context to associate with this request queue.
///Returns:
///    If no error occurs, the **RIOCreateRequestQueue** function returns a descriptor referencing a new request queue.
///    Otherwise, a value of **RIO\_INVALID\_RQ** is returned, and a specific error code can be retrieved by calling the
///    [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function. | Return code | Description |
///    |-------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | An
///    invalid parameter was passed to the function. <br/> This error is returned if the *ReceiveCQ* or *SendCQ*
///    parameters contained **RIO\_INVALID\_CQ**. This error is returned if both the *MaxOutstandingReceive* and
///    *MaxOutstandingSend* parameters are zero. This error is also returned if the socket passed in the *Socket*
///    parameter is in the process of initializing or closing.<br/> | | <dl>
///    <dt>**[WSAENOBUFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenobufs)**</dt> </dl> | Sufficient
///    memory could not be allocated. This error is returned if there was insufficient memory to allocate the request
///    queue based on the parameters. This error is also returned if the network session limit was exceeded. <br/> | |
///    <dl> <dt>**[WSAENOTSOCK](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenotsock)**</dt> </dl> | The
///    descriptor is not a socket. This error is returned if the *Socket* parameter is not a valid socket.<br/> | | <dl>
///    <dt>**[WSAEOPNOTSUPP](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeopnotsupp)**</dt> </dl> | The
///    attempted operation is not supported for the type of object referenced. This error is returned for a socket in
///    the *Socket* parameter for an unsupported socket type (**SOCK\_RAW**, for example)<br/> |
///    
alias LPFN_RIOCREATEREQUESTQUEUE = RIO_RQ_t* function(size_t Socket, uint MaxOutstandingReceive, 
                                                      uint MaxReceiveDataBuffers, uint MaxOutstandingSend, 
                                                      uint MaxSendDataBuffers, RIO_CQ_t* ReceiveCQ, RIO_CQ_t* SendCQ, 
                                                      void* SocketContext);
///The **RIODequeueCompletion** function removes entries from an I/O completion queue for use with the Winsock
///registered I/O extensions.
///Params:
///    CQ = A descriptor that identifies an I/O completion queue.
///    Array = An array of [**RIORESULT**](../mswsockdef/ns-mswsockdef-rioresult.md) structures to receive the description of
///            the completions dequeued.
///    ArraySize = The maximum number of entries in the *Array* to write.
///Returns:
///    If no error occurs, the **RIODequeueCompletion** function returns the number of completion entries removed from
///    the specified completion queue. Otherwise, a value of **RIO\_CORRUPT\_CQ** is returned to indicate that the state
///    of the [**RIO\_CQ**](/windows/win32/winsock/riocqueue) passed in the *CQ* parameter has become corrupt due to
///    memory corruption or misuse of the RIO functions.
///    
alias LPFN_RIODEQUEUECOMPLETION = uint function(RIO_CQ_t* CQ, char* Array, uint ArraySize);
///The **RIODeregisterBuffer** function deregisters a registered buffer used with the Winsock registered I/O extensions.
///Params:
///    BufferId = A descriptor identifying a registered buffer.
alias LPFN_RIODEREGISTERBUFFER = void function(RIO_BUFFERID_t* BufferId);
///The **RIONotify** function registers the method to use for notification behavior with an I/O completion queue for use
///with the Winsock registered I/O extensions.
///Params:
///    CQ = A descriptor that identifies an I/O completion queue.
///Returns:
///    If no error occurs, the **RIONotify** function returns **ERROR\_SUCCESS**. Otherwise, the function failed and a
///    specific error code is returned. | Return code | Description |
///    |---------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2)**</dt> </dl> | An invalid
///    parameter was passed to the function. <br/> This error is returned if invalid completion queue is passed in the
///    *CQ* parameter (**RIO\_INVALID\_CQ**, for example). This error can also be returned when an internal error
///    occurs.<br/> | | <dl> <dt>**[WSAEALREADY](/windows/win32/winsock/windows-sockets-error-codes-2)**</dt> </dl> | An
///    operation was attempted on a non-blocking socket that already had an operation in progress.<br/> This error is
///    returned if a previous [**RIONotify**]() request has not yet completed.<br/> |
///    
alias LPFN_RIONOTIFY = int function(RIO_CQ_t* CQ);
///The **RIORegisterBuffer** function registers a [**RIO\_BUFFERID**](/windows/win32/winsock/rio-bufferid), a registered
///buffer descriptor, with a specified buffer for use with the Winsock registered I/O extensions.
///Params:
///    DataBuffer = A pointer to the beginning of the memory buffer to register.
///    DataLength = The length, in bytes, in the buffer to register.
///Returns:
///    If no error occurs, the **RIORegisterBuffer** function returns a registered buffer descriptor. Otherwise, a value
///    of **RIO\_INVALID\_BUFFERID** is returned, and a specific error code can be retrieved by calling the
///    [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function. | Return code | Description |
///    |-----------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEFAULT](/windows/win32/winsock/windows-sockets-error-codes-2#wsaefault)**</dt> </dl> | The
///    system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is
///    returned if an invalid buffer pointer is passed in *DataBuffer* parameter.<br/> | | <dl>
///    <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | An invalid
///    parameter was passed to the function. <br/> This error is returned if the *DataLength* parameter is zero.<br/> |
///    
alias LPFN_RIOREGISTERBUFFER = RIO_BUFFERID_t* function(const(char)* DataBuffer, uint DataLength);
///The **RIOResizeCompletionQueue** function resizes an I/O completion queue to be either larger or smaller for use with
///the Winsock registered I/O extensions.
///Params:
///    CQ = A descriptor that identifies an existing I/O completion queue to resize.
///    QueueSize = 
///Returns:
///    If no error occurs, the **RIOResizeCompletionQueue** function returns **TRUE**. Otherwise, a value of **FALSE**
///    is returned, and a specific error code can be retrieved by calling the
///    [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function. | Return code | Description |
///    |-----------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEFAULT](/windows/win32/winsock/windows-sockets-error-codes-2#wsaefault)**</dt> </dl> | The
///    system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is
///    returned if the completion queue specified in the *CQ* parameter contains an invalid pointer.<br/> | | <dl>
///    <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | An invalid
///    parameter was passed to the function. This error is returned if the *CQ* parameter is not valid
///    (RIO\_INVALID\_CQ, for example). This error is also returned if the size of the queue specified in the
///    *QueueSize* parameter is greater than **RIO\_CQ\_MAX\_SIZE**.<br/> | | <dl>
///    <dt>**[WSAENOBUFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenobufs)**</dt> </dl> | Sufficient
///    memory could not be allocated. This error is returned if memory could not be allocated for the queue specified in
///    the *QueueSize* parameter.<br/> | | <dl>
///    <dt>**[WSAETOOMANYREFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaetoomanyrefs)**</dt> </dl> |
///    There are too many operations that still reference the I/O completion queue. Resizing of this I/O completion
///    queue to be smaller is not possible at this time.<br/> | The **RIOResizeCompletionQueue** function resizes an I/O
///    completion queue to be either larger or smaller. If the I/O completion queue already contains completions, those
///    completions will be copied over to the new completion queue. I/O completion queues have a required minimum size
///    that is dependent on the number of request queues associated with the completion queue and the number of sends
///    and receives on the request queues. If an application calls the **RIOResizeCompletionQueue** function and tries
///    to set the queue too small for the number of existing completions in the I/O completion queue, the call will fail
///    and the queue will not be resized. > [!Note] > The function pointer to the **RIOResizeCompletionQueue** function
///    must be obtained at run time by making a call to the [**WSAIoctl**](../winsock2/nf-winsock2-wsaioctl.md) function
///    with the **SIO\_GET\_MULTIPLE\_EXTENSION\_FUNCTION\_POINTER** opcode specified. The input buffer passed to the
///    **WSAIoctl** function must contain **WSAID\_MULTIPLE\_RIO**, a globally unique identifier (GUID) whose value
///    identifies the Winsock registered I/O extension functions. On success, the output returned by the **WSAIoctl**
///    function contains a pointer to the
///    [**RIO\_EXTENSION\_FUNCTION\_TABLE**](./ns-mswsock-rio_extension_function_table.md) structure that contains
///    pointers to the Winsock registered I/O extension functions. The
///    **SIO\_GET\_MULTIPLE\_EXTENSION\_FUNCTION\_POINTER** IOCTL is defined in the *Ws2def.h* header file. The
///    **WSAID\_MULTIPLE\_RIO** GUID is defined in the *Mswsock.h* header file. **Windows Phone 8:** This function is
///    supported for Windows Phone Store apps on Windows Phone 8 and later. **Windows 8.1** and **Windows Server 2012
///    R2**: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
///    
alias LPFN_RIORESIZECOMPLETIONQUEUE = BOOL function(RIO_CQ_t* CQ, uint QueueSize);
///The **RIOResizeRequestQueue** function resizes a request queue to be either larger or smaller for use with the
///Winsock registered I/O extensions.
///Params:
///    RQ = A descriptor that identifies an existing registered I/O socket descriptor (request queue) to resize.
///    MaxOutstandingReceive = The maximum number of outstanding sends allowed on the socket. This value can be larger or smaller than the
///                            original number. This parameter is usually a small number for most applications.
///    MaxOutstandingSend = The maximum number of outstanding receives allowed on the socket. This value can be larger or smaller than the
///                         original number.
///Returns:
///    If no error occurs, the **RIOResizeRequestQueue** function returns **TRUE**. Otherwise, a value of **FALSE** is
///    returned, and a specific error code can be retrieved by calling the
///    [**WSAGetLastError**](../winsock/nf-winsock-wsagetlasterror.md) function. | Return code | Description |
///    |-----------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>**[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval)**</dt> </dl> | An
///    invalid parameter was passed to the function. This error is returned if the *RQ* parameter is not valid
///    (RIO\_INVALID\_RQ, for example). This error is also returned if both the *MaxOutstandingReceive* and
///    *MaxOutstandingSend* parameters are zero. <br/> | | <dl>
///    <dt>**[WSAENOBUFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenobufs)**</dt> </dl> | Sufficient
///    memory could not be allocated. This error is returned if memory could not be allocated for the resized request
///    queue.<br/> | | <dl>
///    <dt>**[WSAETOOMANYREFS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaetoomanyrefs)**</dt> </dl> |
///    There are too many operations that still reference the request queue. Resizing of this request queue to be
///    smaller is not possible at this time.<br/> |
///    
alias LPFN_RIORESIZEREQUESTQUEUE = BOOL function(RIO_RQ_t* RQ, uint MaxOutstandingReceive, uint MaxOutstandingSend);
alias LPBLOCKINGCALLBACK = BOOL function(size_t dwContext);
alias LPWSAUSERAPC = void function(size_t dwContext);
///The **LPWSPAccept** function conditionally accepts a connection based on the return value of a condition function.
///Params:
///    s = Descriptor identifying a socket that is listening for connections after a LPWSPListen.
///    addr = Optional pointer to a buffer that receives the address of the connecting entity, as known to the service
///           provider. The exact format of the <i>addr</i> parameter is determined by the address family established when the
///           socket in the sockaddr structure was created.
///    addrlen = Optional pointer to an integer that contains the length of the <i>addr</i> parameter, in bytes.
///    lpfnCondition = Procedure instance address of an optional-condition function furnished by Windows Sockets. This function is used
///                    in the accept or reject decision based on the caller information passed in as parameters.
///    dwCallbackData = Callback data to be passed back to the Windows Socket 2 client as the value of the <i>dwCallbackData</i>
///                     parameter of the condition function. This parameter is not interpreted by the service provider.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPAccept** returns a value of type SOCKET that is a descriptor for the accepted socket.
///    Otherwise, a value of INVALID_SOCKET is returned, and a specific error code is available in <i>lpErrno</i>.
///    <table> <tr> <th> Error Code </th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAECONNREFUSED</b></dl> </dl> </td> <td width="60%"> The connection request was forcefully rejected as
///    indicated in the return value of the condition function (CF_REJECT). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAECONNRESET</b></dl> </dl> </td> <td width="60%"> An incoming connection was indicated, but was
///    subsequently terminated by the remote peer prior to accepting the call. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The <i>addrlen</i> parameter is too
///    small or the <i>lpfnCondition</i> parameter is not part of the user address space. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINTR</b></dl> </dl> </td> <td width="60%"> A (blocking) call was canceled through
///    LPWSPCancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td
///    width="60%"> A blocking Windows Sockets call is in progress. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> LPWSPListen was not invoked prior to LPWSPAccept,
///    parameter <i>g</i> specified in the condition function is not a valid value, the return value of the condition
///    function is not a valid one, or any case where the specified socket is in an invalid state. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEMFILE</b></dl> </dl> </td> <td width="60%"> Queue is nonempty upon entry to
///    LPWSPAccept and there are no socket descriptors available. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dl> </dl> </td> <td width="60%"> No buffer space is available. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is not a socket. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> Referenced socket is
///    not a type that supports connection-oriented service. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSATRY_AGAIN</b></dl> </dl> </td> <td width="60%"> Acceptance of the connection request was deferred as
///    indicated in the return value of the condition function (CF_DEFER). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEWOULDBLOCK</b></dl> </dl> </td> <td width="60%"> Socket is marked as nonblocking and no connections
///    are present to be accepted. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dl> </dl> </td> <td
///    width="60%"> The connection request that was offered has timed out or been withdrawn. </td> </tr> </table>
///    
alias LPWSPACCEPT = size_t function(size_t s, char* addr, int* addrlen, LPCONDITIONPROC lpfnCondition, 
                                    size_t dwCallbackData, int* lpErrno);
///The **LPWSPAddressToString** function converts all components of a sockaddr structure into a human
///readableâ€“numeric string representation of the address. This is used mainly for display purposes.
///Params:
///    lpsaAddress = Pointer to a sockaddr structure to translate into a string.
///    dwAddressLength = Length of the address of sockaddr, in bytes.
///    lpProtocolInfo = (required) WSAProtocol_Info structure associated with the provider that will do the translation.
///    lpszAddressString = Buffer that receives the human readableâ€“address string..
///    lpdwAddressStringLength = Length of the <i>AddressString</i> buffer, in bytes. Returns the length of the string actually copied into the
///                              buffer. If the supplied buffer is not large enough, the function fails with a specific error of WSAEFAULT and
///                              this parameter is updated with the required size, in bytes.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPAddressToString** returns zero. Otherwise, it returns SOCKET_ERROR, and a specific
///    error code is available in <i>lpErrno</i>. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The specified AddressString buffer is
///    too small. Pass in a larger buffer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td>
///    <td width="60%"> The specified address is not a valid socket address, or its address family is not supported by
///    the provider, or the specified <i>lpProtocolInfo</i> did not refer to a WSAProtocol_Info structure supported by
///    the provider. </td> </tr> </table> <div> </div>
///    
alias LPWSPADDRESSTOSTRING = int function(char* lpsaAddress, uint dwAddressLength, 
                                          WSAPROTOCOL_INFOW* lpProtocolInfo, const(wchar)* lpszAddressString, 
                                          uint* lpdwAddressStringLength, int* lpErrno);
///The **LPWSPAsyncSelect** function requests Windows message-based event notification of network events for a socket.
///Params:
///    s = Descriptor identifying the socket for which event notification is required.
///    hWnd = Handle identifying the window that should receive a message when a network event occurs.
///    wMsg = Message to be sent when a network event occurs.
///    lEvent = Bitmask that specifies a combination of network events in which the Windows Sockets service provider interface
///             (SPI) client is interested. Constructed by using the bitwise OR operator with any of these values. <table> <tr>
///             <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt> FD_READ </dt> </dl> </td> <td width="60%">
///             Issues notification of readiness for reading. </td> </tr> <tr> <td width="40%"> <dl> <dt> FD_WRITE </dt> </dl>
///             </td> <td width="60%"> Issues notification of readiness for writing. </td> </tr> <tr> <td width="40%"> <dl> <dt>
///             FD_OOB </dt> </dl> </td> <td width="60%"> Issues notification of the arrival of OOB data. </td> </tr> <tr> <td
///             width="40%"> <dl> <dt> FD_ACCEPT </dt> </dl> </td> <td width="60%"> Issues notification of incoming connections.
///             </td> </tr> <tr> <td width="40%"> <dl> <dt> FD_CONNECT </dt> </dl> </td> <td width="60%"> Issues notification of
///             completed connections. </td> </tr> <tr> <td width="40%"> <dl> <dt> FD_CLOSE </dt> </dl> </td> <td width="60%">
///             Issues notification of socket closure. </td> </tr> <tr> <td width="40%"> <dl> <dt> FD_QOS </dt> </dl> </td> <td
///             width="60%"> Issues notification of socket quality of service (QoS) changes. </td> </tr> <tr> <td width="40%">
///             <dl> <dt> FD_GROUP_QOS </dt> </dl> </td> <td width="60%"> Reserved. </td> </tr> <tr> <td width="40%"> <dl> <dt>
///             FD_ROUTING_INTERFACE_CHANGE </dt> </dl> </td> <td width="60%"> Issues notification of routing interface change
///             for the specified destination. </td> </tr> <tr> <td width="40%"> <dl> <dt> FD_ADDRESS_ LIST_CHANGE </dt> </dl>
///             </td> <td width="60%"> Issues notification of local address list change for the socket's protocol family. </td>
///             </tr> </table>
///    lpErrno = Pointer to the error code. See the **Return value** section for more info.
///Returns:
///    The return value is zero if the Windows Sockets SPI client's declaration of interest in the network event set was
///    successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error code is available in
///    <i>lpErrno</i>. <table> <tr> <th>Error Code </th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> Indicates that one of the specified
///    parameters was invalid such as the window handle not referring to an existing window, or the specified socket is
///    in an invalid state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td
///    width="60%"> A blocking Windows Sockets call is in progress, or the service provider is still processing a
///    callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td
///    width="60%"> The descriptor is not a socket. </td> </tr> </table> See **Remarks** for info about additional error
///    codes that can be set (in the high word of *lParam* within the message) when an application window receives a
///    message.
///    
alias LPWSPASYNCSELECT = int function(size_t s, HWND hWnd, uint wMsg, int lEvent, int* lpErrno);
///The **LPWSPBind** function associates a local address (that is, name) with a socket.
///Params:
///    s = A descriptor identifying an unbound socket.
///    name = The address to assign to the socket, in the form of a **sockaddr** structure. Except for the **sa_family**
///           member, **sockaddr** contents are expressed in network byte order. In Windows Sockets 2, the <i>name</i>
///           parameter is not strictly interpreted as a pointer to a **sockaddr** structure. It is cast this way for Winsock
///           compatibility. The actual structure is interpreted differently in the context of different address families. The
///           only requirements are that the first **u_short** is the address family and the total size of the memory buffer,
///           in bytes, is <i>namelen</i>.
///    namelen = The length, in bytes, of structure pointed to by the <i>name</i> parameter.
///    lpErrno = A pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPBind** returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code is
///    available in <i>lpErrno</i>. <table> <tr> <th> Error Code </th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEADDRINUSE</b></dl> </dl> </td> <td width="60%"> Some process on the local computer
///    has already bound to the same fully qualified address (for example, IP address and port in the **AF_INET** case)
///    and the socket has not been marked to allow address reuse with SO_REUSEADDR. (See the SO_REUSEADDR socket option
///    under LPWSPSetSockOpt.) </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRNOTAVAIL</b></dl> </dl> </td> <td
///    width="60%"> The specified address is not a valid address for this computer. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The <i>name</i> or the <i>namelen</i> parameter is
///    not a valid part of the user address space, the <i>namelen</i> parameter is too small, the <i>name</i> parameter
///    contains incorrect address format for the associated address family, or the first two bytes of the memory block
///    specified by <i>name</i> do not match the address family associated with the socket descriptor <i>s</i>. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td width="60%"> Function is invoked
///    when a callback is in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> The socket is already bound to an address. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dl> </dl> </td> <td width="60%"> There are not enough buffers available, there are too
///    many connections. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%">
///    The descriptor is not a socket. </td> </tr> </table>
///    
alias LPWSPBIND = int function(size_t s, char* name, int namelen, int* lpErrno);
///The **LPWSPCancelBlockingCall** function cancels a blocking call that is currently in progress.
///Params:
///    lpErrno = Pointer to the error code.
///Returns:
///    The value returned by **LPWSPCancelBlockingCall** is zero if the operation was successfully canceled. Otherwise,
///    the value SOCKET_ERROR is returned, and a specific error code is available in <i>lpErrno</i>. <table> <tr> <th>
///    Error Code </th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td
///    width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl>
///    </dl> </td> <td width="60%"> Indicates there is no outstanding blocking call. </td> </tr> </table>
///    
alias LPWSPCANCELBLOCKINGCALL = int function(int* lpErrno);
///The **LPWSPCleanup** function terminates use of the Windows Sockets service provider.
///Params:
///    lpErrno = Pointer to the error code.
///Returns:
///    The return value is zero if the operation has been successfully initiated. Otherwise, the value SOCKET_ERROR is
///    returned, and a specific error number is available in <i>lpErrno</i>. <table> <tr> <th> Error Code </th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dl> </dl> </td> <td width="60%">
///    A successful **WSPStartup** call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> Provider identifier given to the
///    name-space provider is not managed by the name-space provider. </td> </tr> </table>
///    
alias LPWSPCLEANUP = int function(int* lpErrno);
///The **LPWSPCloseSocket** function closes a socket.
///Params:
///    s = Descriptor identifying a socket.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPCloseSocket** returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code is available in <i>lpErrno</i>. <table> <tr> <th> Error Code </th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has
///    failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td width="60%">
///    Blocking Windows Sockets call is in progress, or the service provider is still processing a callback function.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is
///    not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dl> </dl> </td> <td width="60%">
///    Socket is marked as nonblocking and SO_LINGER is set to a nonzero time-out value. </td> </tr> </table>
///    
alias LPWSPCLOSESOCKET = int function(size_t s, int* lpErrno);
///The **LPWSPConnect** function establishes a connection to a peer, exchanges connect data, and specifies needed
///quality of service based on the supplied flow specification.
///Params:
///    s = Descriptor identifying an unconnected socket.
///    name = Name of the peer to which the socket in the <b>sockaddr</b> is to be connected.
///    namelen = Length of the <i>name</i>, in bytes.
///    lpCallerData = Pointer to the user data that is to be transferred to the peer during connection establishment.
///    lpCalleeData = Pointer to a buffer into which any user data received from the peer during connection establishment can be
///                   copied.
///    lpSQOS = Pointer to the flow specifications for socket <i>s</i>, one for each direction.
///    lpGQOS = Reserved.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPConnect** returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code
///    is available in <i>lpErrno</i>. On a blocking socket, the return value indicates success or failure of the
///    connection attempt. If the return error code indicates the connection attempt failed (that is, WSAECONNREFUSED,
///    WSAENETUNREACH, WSAETIMEDOUT) the Winsock SPI client can call **LPWSPConnect** again for the same socket. <table>
///    <tr> <th> Error Code </th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl>
///    </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEADDRINUSE</b></dl> </dl> </td> <td width="60%"> Local address of the socket is already in use and the
///    socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs at the time of bind,
///    but could be delayed until this function if the bind was to a partially wildcard address (involving ADDR_ANY) and
///    if a specific address needs to be committed at the time of this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINTR</b></dl> </dl> </td> <td width="60%"> (Blocking) call was canceled through
///    <b>LPWSPCancelBlockingCall</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dl> </dl> </td>
///    <td width="60%"> Blocking Winsock call is in progress or the service provider is still processing a callback
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEALREADY</b></dl> </dl> </td> <td width="60%">
///    Nonblocking <b>LPWSPConnect</b> call is in progress on the specified socket. <br/> In order to preserve backward
///    compatibility, this error is reported as WSAEINVAL to Windows Sockets 1.1 applications that link to either
///    Winsock.dll or Wsock32.dll. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRNOTAVAIL</b></dl> </dl> </td>
///    <td width="60%"> Remote address is not a valid address (for example, ADDR_ANY). </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEAFNOSUPPORT</b></dl> </dl> </td> <td width="60%"> Addresses in the specified family cannot be
///    used with this socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNREFUSED</b></dl> </dl> </td> <td
///    width="60%"> An attempt to connect was rejected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl>
///    </dl> </td> <td width="60%"> The <i>name</i> or the <i>namelen</i> parameter is not a valid part of the user
///    address space, the <i>namelen</i> parameter is too small, the buffer length for <i>lpCalleeData</i>,
///    <i>lpSQOS</i>, and <i>lpGQOS</i> is too small, or the buffer length for <i>lpCallerData</i> is too large. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> Parameter <i>s</i> is a
///    listening socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEISCONN</b></dl> </dl> </td> <td width="60%">
///    Socket is already connected (connection-oriented sockets only). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETUNREACH</b></dl> </dl> </td> <td width="60%"> The network cannot be reached from this host at this
///    time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dl> </dl> </td> <td width="60%"> No buffer
///    space is available. The socket cannot be connected. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> Flow specifications specified in
///    <i>lpSQOS</i> cannot be satisfied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEPROTONOSUPPORT</b></dl>
///    </dl> </td> <td width="60%"> The <i>lpCallerData</i> augment is not supported by the service provider. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAETIMEDOUT</b></dl> </dl> </td> <td width="60%"> An attempt to connect
///    timed out without establishing a connection. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEWOULDBLOCK</b></dl> </dl> </td> <td width="60%"> Socket is marked as nonblocking and the connection
///    cannot be completed immediately. It is possible to select the socket using the <b>LPWSPSelect</b> function while
///    it is connecting by using the **WSPSelect** function to select it for writing. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEACCES</b></dl> </dl> </td> <td width="60%"> An attempt to connect datagram socket to broadcast
///    address failed because <b>WSPSetSockOpt</b> SO_BROADCAST is not enabled. </td> </tr> </table>
///    
alias LPWSPCONNECT = int function(size_t s, char* name, int namelen, WSABUF* lpCallerData, WSABUF* lpCalleeData, 
                                  QOS* lpSQOS, QOS* lpGQOS, int* lpErrno);
///The **LPWSPDuplicateSocket** function returns a <b>WSAPROTOCOL_INFO</b> structure that can be used to create a new
///socket descriptor for a shared socket.
///Params:
///    s = Local socket descriptor.
///    dwProcessId = Identifier of the target process for which the shared socket will be used.
///    lpProtocolInfo = Pointer to a buffer allocated by the client that is large enough to contain a <b>WSAPROTOCOL_INFO</b> structure.
///                     The service provider copies the protocol information structure contents to this buffer.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPDuplicateSocket** returns zero. Otherwise, the value of SOCKET_ERROR is returned, and
///    a specific error number is available in <i>lpErrno</i>. <table> <tr> <th> Error Code </th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has
///    failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> Indicates
///    that one of the specified parameters was invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td width="60%"> Blocking Windows Sockets call is in progress or the
///    service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEMFILE</b></dl> </dl> </td> <td width="60%"> No more socket descriptors are available. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dl> </dl> </td> <td width="60%"> No buffer space is available. The
///    socket cannot be created. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td
///    width="60%"> The descriptor is not a socket. </td> </tr> </table>
///    
alias LPWSPDUPLICATESOCKET = int function(size_t s, uint dwProcessId, WSAPROTOCOL_INFOW* lpProtocolInfo, 
                                          int* lpErrno);
///The **LPWSPEnumNetworkEvents** function reports occurrences of network events for the indicated socket.
///Params:
///    s = Descriptor identifying the socket.
///    hEventObject = Optional handle identifying an associated event object to be reset.
///    lpNetworkEvents = Pointer to a WSANETWORKEVENTS structure that is filled with a record of occurred network events and any
///                      associated error codes. The **WSANETWORKEVENTS** structure is defined in the following text.
///    lpErrno = Pointer to the error code.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has
///    failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> Indicates
///    that one of the specified parameters was invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td width="60%"> A blocking Windows Sockets call is in progress, or
///    the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> </table>
///    
alias LPWSPENUMNETWORKEVENTS = int function(size_t s, HANDLE hEventObject, WSANETWORKEVENTS* lpNetworkEvents, 
                                            int* lpErrno);
///The **LPWSPEventSelect** function specifies an event object to be associated with the supplied set of network events.
///Params:
///    s = A descriptor identifying the socket.
///    hEventObject = The handle identifying the event object to be associated with the supplied set of network events.
///    lNetworkEvents = A bitmask that specifies the combination of network events in which the Windows Sockets SPI client has interest.
///                     Constructed by using the bitwise OR operator with any of these values. <table> <tr> <th>Value</th>
///                     <th>Meaning</th> </tr> <tr> <td width="60%"> <dl> <dt> FD_READ </dt> </dl> </td> <td width="40%"> Issues
///                     notification of readiness for reading. </td> </tr> <tr> <td width="60%"> <dl> <dt> FD_WRITE </dt> </dl> </td> <td
///                     width="40%"> Issues notification of readiness for writing. </td> </tr> <tr> <td width="60%"> <dl> <dt> FD_OOB
///                     </dt> </dl> </td> <td width="40%"> Issues notification of the arrival of OOB data. </td> </tr> <tr> <td
///                     width="60%"> <dl> <dt> FD_ACCEPT </dt> </dl> </td> <td width="40%"> Issues notification of incoming connections.
///                     </td> </tr> <tr> <td width="60%"> <dl> <dt> FD_CONNECT </dt> </dl> </td> <td width="40%"> Issues notification of
///                     completed connection. </td> </tr> <tr> <td width="60%"> <dl> <dt> FD_CLOSE </dt> </dl> </td> <td width="40%">
///                     Issues notification of socket closure. </td> </tr> <tr> <td width="60%"> <dl> <dt> FD_QOS </dt> </dl> </td> <td
///                     width="40%"> Issues notification of socket (QoS) changes. </td> </tr> <tr> <td width="60%"> <dl> <dt>
///                     FD_GROUP_QOS </dt> </dl> </td> <td width="40%"> Reserved. </td> </tr> <tr> <td width="60%"> <dl> <dt>
///                     FD_ROUTING_INTERFACE_CHANGE </dt> </dl> </td> <td width="40%"> Issues notification of routing interface changes
///                     for the specified destination(s). </td> </tr> <tr> <td width="60%"> <dl> <dt> FD_ADDRESS_LIST_CHANGE </dt> </dl>
///                     </td> <td width="40%"> Issues notification of local address list changes for the socket's address family. </td>
///                     </tr> </table>
///    lpErrno = A pointer to the error code. See the **Return value** section for more info.
///Returns:
///    The return value is zero if the Windows Sockets SPI client's specification of the network events and the
///    associated event object was successful. Otherwise, the value **SOCKET_ERROR** is returned, and a specific error
///    number is available in *lpErrno*. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> Indicates that one of the specified
///    parameters was invalid, or the specified socket is in an invalid state. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td width="60%"> Blocking Windows Sockets call is in progress or the
///    service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> </table>
///    
alias LPWSPEVENTSELECT = int function(size_t s, HANDLE hEventObject, int lNetworkEvents, int* lpErrno);
///The **LPWSPGetOverlappedResult** function returns the results of an overlapped operation on the specified socket.
///Params:
///    s = Identifies the socket. This is the same socket that was specified when the overlapped operation was started by a
///        call to <b>LPWSPRecv</b>, <b>LPWSPRecvFrom</b>, <b>LPWSPSend</b>, <b>LPWSPSendTo</b>, or <b>LPWSPIoctl</b>.
///    lpOverlapped = Pointer to a <b>WSAOverlapped</b> structure that was specified when the overlapped operation was started.
///    lpcbTransfer = Pointer to a 32-bit variable that receives the number of bytes that were actually transferred by a send or
///                   receive operation, or by <b>LPWSPIoctl</b>.
///    fWait = Specifies whether the function should wait for the pending overlapped operation to complete. If **TRUE**, the
///            function does not return until the operation has been completed. If **FALSE** and the operation is still pending,
///            the function returns **FALSE** and <i>lpErrno</i> is WSA_IO_INCOMPLETE. The <i>fWait</i> parameter may be set to
///            **TRUE** only if the overlapped operation selected event-based completion notification.
///    lpdwFlags = Pointer to a 32-bit variable that will receive one or more flags that supplement the completion status. If the
///                overlapped operation was initiated through <b>LPWSPRecv</b> or <b>LPWSPRecvFrom</b>, this parameter will contain
///                the results value for <i>lpFlags</i> parameter.
///    lpErrno = Pointer to the error code.
///Returns:
///    If **LPWSPGetOverlappedResult** succeeds, the return value is **TRUE**. This means the overlapped operation has
///    completed successfully and the value pointed to by <i>lpcbTransfer</i> has been updated. If
///    **LPWSPGetOverlappedResult** returns **FALSE**, this means that the overlapped operation has not completed or the
///    overlapped operation completed but with errors, or completion status could not be determined due to errors in one
///    or more parameters to **LPWSPGetOverlappedResult**. On failure, the value pointed to by <i>lpcbTransfer</i> will
///    not be updated. The <i>lpErrno</i> parameter indicates the cause of the failure (either of
///    **LPWSPGetOverlappedResult** or of the associated overlapped operation). <table> <tr> <th>Error Code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>WSAENETDOWN</dt> </dl> </td> <td width="60%"> The network
///    subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENOTSOCK</dt> </dl> </td> <td width="60%">
///    The descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSA_INVALID_HANDLE</dt> </dl> </td>
///    <td width="60%"> The **hEvent** member of the <b>WSAOverlapped</b> structure does not contain a valid event
///    object handle. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINVAL</dt> </dl> </td> <td width="60%"> One of the
///    parameters is unacceptable. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSA_IO_INCOMPLETE</dt> </dl> </td> <td
///    width="60%"> The <i>fWait</i> parameter is **FALSE** and the I/O operation has not yet completed. </td> </tr>
///    </table>
///    
alias LPWSPGETOVERLAPPEDRESULT = BOOL function(size_t s, OVERLAPPED* lpOverlapped, uint* lpcbTransfer, BOOL fWait, 
                                               uint* lpdwFlags, int* lpErrno);
///The **LPWSPGetPeerName** function gets the address of the peer to which a socket is connected.
///Params:
///    s = Descriptor identifying a connected socket.
///    name = Pointer to the <b>sockaddr</b> structure to receive the name of the peer.
///    namelen = On input, pointer to an integer that indicates the size of the structure pointed to by <i>name</i>, in bytes. On
///              output, indicates the size of the returned name, in bytes.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPGetPeerName** returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The <i>name</i> or
///    the <i>namelen</i> parameter is not a valid part of the user address space, or the <i>namelen</i> parameter is
///    too small. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td width="60%">
///    Function is invoked when a callback is in progress. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTCONN</b></dl> </dl> </td> <td width="60%"> Socket is not connected. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is not a
///    socket. </td> </tr> </table>
///    
alias LPWSPGETPEERNAME = int function(size_t s, char* name, int* namelen, int* lpErrno);
///The **LPWSPGetSockName** function gets the local name for a socket.
///Params:
///    s = Descriptor identifying a bound socket.
///    name = Pointer to a <b>sockaddr</b> structure used to supply the address (name) of the socket.
///    namelen = On input, pointer to an integer that indicates the size of the structure pointed to by <i>name</i>, in bytes. On
///              output indicates the size of the returned name, in bytes.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPGetSockName** returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The <i>name</i> or
///    the <i>namelen</i> parameter is not a valid part of the user address space, or the <i>namelen</i> parameter is
///    too small. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td width="60%">
///    Function is invoked when a callback is in progress. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> Socket has not been bound to an address
///    with <b>LPWSPBind</b>, or ADDR_ANY is specified in **LPWSPBind** but connection has not yet occurred. </td> </tr>
///    </table>
///    
alias LPWSPGETSOCKNAME = int function(size_t s, char* name, int* namelen, int* lpErrno);
///The **LPWSPGetSockOpt** function retrieves a socket option.
///Params:
///    s = A descriptor identifying a socket.
///    level = The level at which the option is defined; the supported levels include <b>SOL_SOCKET</b>. (See annex for more
///            protocol-specific levels.)
///    optname = The socket option for which the value is to be retrieved.
///    optval = A pointer to the buffer in which the value for the requested option is to be returned.
///    optlen = A pointer to the size, in bytes, of the <i>optval</i> buffer.
///    lpErrno = A pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPGetSockOpt** returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt>WSAENETDOWN</dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt>WSAEFAULT</dt> </dl> </td> <td width="60%"> One of the <i>optval</i> or the
///    <i>optlen</i> parameters is not a valid part of the user address space, or the <i>optlen</i> parameter is too
///    small. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINVAL</dt> </dl> </td> <td width="60%"> The <i>level</i> is
///    unknown or invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%">
///    Function is invoked when a callback is in progress. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAENOPROTOOPT</dt> </dl> </td> <td width="60%"> Option is unknown or unsupported by the indicated protocol
///    family. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENOTSOCK</dt> </dl> </td> <td width="60%"> The descriptor
///    is not a socket. </td> </tr> </table>
///    
alias LPWSPGETSOCKOPT = int function(size_t s, int level, int optname, char* optval, int* optlen, int* lpErrno);
///The **WSPGetQOSByName** function initializes a <b>QOS</b> structure based on a named template, or retrieves an
///enumeration of the available template names.
///Params:
///    s = Descriptor identifying a socket.
///    lpQOSName = Specifies the QOS template name, or supplies a buffer to retrieve an enumeration of the available template names.
///    lpQOS = Pointer to the <b>QOS</b> structure to be filled.
///    lpErrno = Pointer to the error code.
///Returns:
///    If the function succeeds, the return value is **TRUE**. If the function fails, the return value is **FALSE**, and
///    a specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has
///    failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The
///    descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td
///    width="60%"> The <i>lpQOS</i> argument is not a valid part of the user address space, or the buffer length for
///    <i>lpQOS</i> is too small. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> The specified QOS template name is invalid. </td> </tr> </table>
///    
alias LPWSPGETQOSBYNAME = BOOL function(size_t s, WSABUF* lpQOSName, QOS* lpQOS, int* lpErrno);
///The **LPWSPIoctl** function controls the mode of a socket.
///Params:
///    s = A descriptor identifying a socket.
///    dwIoControlCode = The control code of the operation to perform.
///    lpvInBuffer = A pointer to the input buffer.
///    cbInBuffer = The size, in bytes, of the input buffer.
///    lpvOutBuffer = A pointer to the output buffer.
///    cbOutBuffer = The size, in bytes, of the output buffer.
///    lpcbBytesReturned = A pointer to actual number of bytes of output.
///    lpOverlapped = A pointer to a <b>WSAOverlapped</b> structure (ignored for non-overlapped sockets).
///    lpCompletionRoutine = Type: \_In_opt\_
///                          [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](../winsock2/nc-winsock2-lpwsaoverlapped_completion_routine.md) A pointer
///                          to the completion routine called when the operation has been completed (ignored for non-overlapped sockets). See
///                          Remarks.
///    lpThreadId = A pointer to a <b>WSATHREADID</b> structure to be used by the provider in a subsequent call to
///                 <b>WPUQueueApc</b>. The provider should store the referenced **WSATHREADID** structure (not the pointer) until
///                 after the **WPUQueueApc** function returns.
///    lpErrno = A pointer to the error code.
///Returns:
///    If no error occurs and the operation has completed immediately, **LPWSPIoctl** returns zero. Note that in this
///    case the completion routine, if specified, will have already been queued. Otherwise, a value of SOCKET_ERROR is
///    returned, and a specific error code is available in <i>lpErrno</i>. The error code WSA_IO_PENDING indicates that
///    an overlapped operation has been successfully initiated and that completion will be indicated at a later time.
///    Any other error code indicates that no overlapped operation was initiated and no completion indication will
///    occur. | Error code | Meaning |
///    |-----------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
///    | <dl> <dt>[WSA_IO_PENDING](/windows/win32/winsock/windows-sockets-error-codes-2#wsa-io-pending) | An overlapped
///    operation was successfully initiated and completion will be indicated at a later time.<br/> | | <dl>
///    <dt>[WSAEFAULT](/windows/win32/winsock/windows-sockets-error-codes-2#wsaefault) | The <i>lpvInBuffer</i>,
///    <i>lpvOutBuffer</i> or <i>lpcbBytesReturned</i> parameter is not totally contained in a valid part of the user
///    address space, or the *cbInBuffer* or <i>cbOutBuffer</i> parameter is too small.<br/> | | <dl>
///    <dt>[WSAEINVAL](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinval) | The <i>dwIoControlCode</i> is
///    not a valid command, or a supplied input parameter is not acceptable, or the command is not applicable to the
///    type of socket supplied.<br/> | | <dl>
///    <dt>[WSAEINPROGRESS](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeinprogress) | The function is
///    invoked when a callback is in progress.<br/> | | <dl>
///    <dt>[WSAENETDOWN](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenetdown) | The network subsystem has
///    failed.<br/> | | <dl> <dt>[WSAENOTSOCK](/windows/win32/winsock/windows-sockets-error-codes-2#wsaenotsock) | The
///    descriptor <i>s</i> is not a socket.<br/> | | <dl>
///    <dt>[WSAEOPNOTSUPP](/windows/win32/winsock/windows-sockets-error-codes-2#wsaeopnotsupp) | The specified IOCTL
///    command cannot be realized. For example, the flow specifications specified in **SIO_SET_QOS** cannot be
///    satisfied.<br/> | | <dl>
///    <dt>[WSAEWOULDBLOCK](/windows/win32/winsock/windows-sockets-error-codes-2#wsaewouldblock) | The socket is marked
///    as nonblocking and the requested operation would block.<br/>
///    
alias LPWSPIOCTL = int function(size_t s, uint dwIoControlCode, char* lpvInBuffer, uint cbInBuffer, 
                                char* lpvOutBuffer, uint cbOutBuffer, uint* lpcbBytesReturned, 
                                OVERLAPPED* lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, 
                                WSATHREADID* lpThreadId, int* lpErrno);
///The **WSPJoinLeaf** function joins a leaf node into a multipoint session, exchanges connect data, and specifies
///needed quality of service based on the supplied flow specifications.
///Params:
///    s = Descriptor identifying a multipoint socket.
///    name = Name of the peer to which the socket in the sockaddr structure is to be joined.
///    namelen = Length of the <i>name</i>, in bytes.
///    lpCallerData = Pointer to the user data that is to be transferred to the peer during multipoint session establishment.
///    lpCalleeData = Pointer to the user data that is to be transferred back from the peer during multipoint session establishment.
///    lpSQOS = Pointer to the flow specifications for socket <i>s</i>, one for each direction.
///    lpGQOS = Reserved.
///    dwFlags = Flags to indicate that the socket is acting as a sender, receiver, or both.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **WSPJoinLeaf** returns a value of type **SOCKET** that is a descriptor for the newly created
///    multipoint socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code is available in
///    <i>lpErrno</i>. On a blocking socket, the return value indicates success or failure of the join operation. With a
///    nonblocking socket, successful initiation of a join operation is indicated by a return value of a valid socket
///    descriptor. Subsequently, an FD_CONNECT indication is given when the join operation completes, either
///    successfully or otherwise. The error code associated with the FD_CONNECT indicates the success or failure of the
///    **WSPJoinLeaf**. Also, until the multipoint session join attempt completes all subsequent calls to
///    **WSPJoinLeaf** on the same socket will fail with the error code WSAEALREADY. After the **WSPJoinLeaf** completes
///    successfully a subsequent attempt will usually fail with the error code WSAEISCONN. An exception to the
///    WSAEISCONN rule occurs for a c_root socket that allows root-initiated joins. In such a case another join may be
///    initiated after a prior **WSPJoinLeaf** completes. If the return error code indicates the multipoint session join
///    attempt failed (that is, WSAECONNREFUSED, WSAENETUNREACH, WSAETIMEDOUT) the Windows Sockets SPI client can call
///    **WSPJoinLeaf** again for the same socket. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRINUSE</b></dl> </dl> </td> <td width="60%"> Socket's local
///    address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error
///    usually occurs at the time of bind, but could be delayed until this function if the **bind** was to a partially
///    wild-card address (involving ADDR_ANY) and if a specific address needs to be "committed" at the time of this
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dl> </dl> </td> <td width="60%"> (Blocking)
///    call was canceled through WSPCancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td width="60%"> Blocking Windows Sockets call is in progress, or the
///    service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEALREADY</b></dl> </dl> </td> <td width="60%"> Nonblocking WSPJoinLeaf call is in progress on the
///    specified socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRNOTAVAIL</b></dl> </dl> </td> <td
///    width="60%"> Remote address is not a valid address (for example, ADDR_ANY). </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEAFNOSUPPORT</b></dl> </dl> </td> <td width="60%"> Addresses in the specified family cannot be
///    used with this socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNREFUSED</b></dl> </dl> </td> <td
///    width="60%"> The attempt to join was forcefully rejected. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The <i>name</i> or the <i>namelen</i> parameter is not a
///    valid part of the user address space, the <i>namelen</i> parameter is too small, the buffer length for
///    <i>lpCalleeData</i>, <i>lpSQOS</i>, and <i>lpGQOS</i> are too small, or the buffer length for <i>lpCallerData</i>
///    is too large. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEISCONN</b></dl> </dl> </td> <td width="60%">
///    Socket is already member of the multipoint session. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETUNREACH</b></dl> </dl> </td> <td width="60%"> The network cannot be reached from this host at this
///    time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dl> </dl> </td> <td width="60%"> No buffer
///    space is available. The socket cannot be joined. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> Flow specifications specified in
///    <i>lpSQOS</i> cannot be satisfied. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEPROTONOSUPPORT</b></dl>
///    </dl> </td> <td width="60%"> The <i>lpCallerData</i> augment is not supported by the service provider. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAETIMEDOUT</b></dl> </dl> </td> <td width="60%"> An attempt to join
///    timed out without establishing a multipoint session. </td> </tr> </table> <div> </div>
///    
alias LPWSPJOINLEAF = size_t function(size_t s, char* name, int namelen, WSABUF* lpCallerData, 
                                      WSABUF* lpCalleeData, QOS* lpSQOS, QOS* lpGQOS, uint dwFlags, int* lpErrno);
///The **LPWSPListen** function establishes a socket to listen for incoming connections.
///Params:
///    s = Descriptor identifying a bound, unconnected socket.
///    backlog = Maximum length to which the queue of pending connections can grow. If this value is SOMAXCONN, then the service
///              provider should set the backlog to a maximum "reasonable" value. There is no standard provision to find out the
///              actual backlog value.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPListen** returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific
///    error code is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAENETDOWN</dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt>WSAEADDRINUSE</dt> </dl> </td> <td width="60%"> Socket's local address is already
///    in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs at the
///    time of <b>Bind</b>, but could be delayed until this function if the **bind** was to a partially wildcard address
///    (involving ADDR_ANY) and if a specific address needs to be committed at the time of this function. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%"> Function is invoked when a
///    callback is in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINVAL</dt> </dl> </td> <td width="60%">
///    Socket has not been bound with <b>LPWSPBind</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEISCONN</dt> </dl>
///    </td> <td width="60%"> Socket is already connected. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEMFILE</dt>
///    </dl> </td> <td width="60%"> No more socket descriptors are available. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAENOBUFS</dt> </dl> </td> <td width="60%"> No buffer space is available. </td> </tr> <tr> <td width="40%">
///    <dl> <dt>WSAENOTSOCK</dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAEOPNOTSUPP</dt> </dl> </td> <td width="60%"> Referenced socket is not of a type that
///    supports the <b>LPWSPListen</b> operation. </td> </tr> </table>
///    
alias LPWSPLISTEN = int function(size_t s, int backlog, int* lpErrno);
///The **LPWSPRecv** function receives data on a socket.
///Params:
///    s = A descriptor identifying a connected socket.
///    lpBuffers = A pointer to an array of WSABUF structures. Each **WSABUF** structure contains a pointer to a buffer and the
///                length of the buffer, in bytes.
///    dwBufferCount = The number of WSABUF structures in the <i>lpBuffers</i> array.
///    lpNumberOfBytesRecvd = A pointer to the number of bytes received by this call.
///    lpFlags = A pointer to flags that specify the way in which the call is made.
///    lpOverlapped = A pointer to a <b>WSAOverlapped</b> structure (ignored for nonoverlapped structures).
///    lpCompletionRoutine = Type: \_In_opt\_
///                          [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](../winsock2/nc-winsock2-lpwsaoverlapped_completion_routine.md) A pointer
///                          to the completion routine called when the receive operation has been completed (ignored for nonoverlapped
///                          structures).
///    lpThreadId = A pointer to a <b>WSATHREADID</b> structure to be used by the provider in a subsequent call to
///                 <b>WPUQueueApc</b>. The provider should store the referenced **WSATHREADID** structure (not the pointer to same)
///                 until after the **WPUQueueApc** function returns.
///    lpErrno = A pointer to the error code.
///Returns:
///    If no error occurs and the receive operation has completed immediately, **LPWSPRecv** returns zero. Note that in
///    this case the completion routine, if specified, will have already been queued. Otherwise, a value of SOCKET_ERROR
///    is returned, and a specific error code is available in <i>lpErrno</i>. The error code WSA_IO_PENDING indicates
///    that the overlapped operation has been successfully initiated and that completion will be indicated at a later
///    time. Any other error code indicates that no overlapped operations was initiated and no completion indication
///    will occur. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAENETDOWN</dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAENOTCONN</dt> </dl> </td> <td width="60%"> Socket is not connected. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAEINTR</dt> </dl> </td> <td width="60%"> (Blocking) call was canceled through
///    <b>LPWSPCancelBlockingCall</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td
///    width="60%"> Blocking Windows Sockets call is in progress, or the service provider is still processing a callback
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENETRESET</dt> </dl> </td> <td width="60%"> The
///    connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEFAULT</dt> </dl> </td> <td width="60%"> The <i>lpBuffers</i>
///    parameter is not totally contained in a valid part of the user address space. </td> </tr> <tr> <td width="40%">
///    <dl> <dt>WSAENOTSOCK</dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAEOPNOTSUPP</dt> </dl> </td> <td width="60%"> MSG_OOB was specified, but the socket is
///    not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with
///    this socket, or the socket is unidirectional and supports only send operations. </td> </tr> <tr> <td width="40%">
///    <dl> <dt>WSAESHUTDOWN</dt> </dl> </td> <td width="60%"> Socket has been shut down; it is not possible to receive
///    through <b>LPWSPRecv</b> on a socket after <b>LPWSPShutdown</b> has been invoked with <i>how</i> set to
///    SD_RECEIVE or SD_BOTH. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEWOULDBLOCK</dt> </dl> </td> <td
///    width="60%"> Windows NT: Overlapped sockets: there are too many outstanding overlapped I/O requests.
///    Nonoverlapped sockets: The socket is marked as nonblocking and the receive operation cannot be completed
///    immediately. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEMSGSIZE</dt> </dl> </td> <td width="60%"> Message was
///    too large to fit into the specified buffer and (for unreliable protocols only) any trailing portion of the
///    message that did not fit into the buffer has been discarded. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEINVAL</dt> </dl> </td> <td width="60%"> Socket has not been bound (for example, with <b>LPWSPBind</b>) or
///    the socket is not created with the overlapped flag. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAECONNABORTED</dt> </dl> </td> <td width="60%"> Virtual circuit was terminated due to a time-out or other
///    failure. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAECONNRESET</dt> </dl> </td> <td width="60%"> Virtual
///    circuit was reset by the remote side. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEDISCON</dt> </dl> </td> <td
///    width="60%"> Socket <i>s</i> is message oriented and the virtual circuit was gracefully closed by the remote
///    side. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSA_IO_PENDING</dt> </dl> </td> <td width="60%"> An overlapped
///    operation was successfully initiated and completion will be indicated at a later time. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSA_OPERATION_ABORTED</dt> </dl> </td> <td width="60%"> Overlapped operation has been
///    canceled due to the closure of the socket. </td> </tr> </table>
///    
alias LPWSPRECV = int function(size_t s, char* lpBuffers, uint dwBufferCount, uint* lpNumberOfBytesRecvd, 
                               uint* lpFlags, OVERLAPPED* lpOverlapped, 
                               LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, WSATHREADID* lpThreadId, 
                               int* lpErrno);
///The **LPWSPRecvDisconnect** function terminates reception on a socket and retrieves the disconnect data, if the
///socket is connection oriented.
///Params:
///    s = Descriptor identifying a socket.
///    lpInboundDisconnectData = Pointer to a buffer into which disconnect data is to be copied.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPRecvDisconnect** returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt>WSAENETDOWN</dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt>WSAEFAULT</dt> </dl> </td> <td width="60%"> Buffer referenced by the
///    parameter <i>lpInboundDisconnectData</i> is too small. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAENOPROTOOPT</dt> </dl> </td> <td width="60%"> Disconnect data is not supported by the indicated protocol
///    family. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%"> Blocking
///    Windows Sockets call is in progress, or the service provider is still processing a callback function. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt>WSAENOTCONN</dt> </dl> </td> <td width="60%"> Socket is not connected
///    (connection-oriented sockets only). </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENOTSOCK</dt> </dl> </td> <td
///    width="60%"> The descriptor is not a socket. </td> </tr> </table>
///    
alias LPWSPRECVDISCONNECT = int function(size_t s, WSABUF* lpInboundDisconnectData, int* lpErrno);
///The **LPWSPRecvFrom** function receives a datagram and stores the source address.
///Params:
///    s = Descriptor identifying a socket.
///    lpBuffers = Pointer to an array of WSABUF structures. Each **WSABUF** structure contains a pointer to a buffer and the length
///                of the buffer, in bytes.
///    dwBufferCount = Number of WSABUF structures in the <i>lpBuffers</i> array.
///    lpNumberOfBytesRecvd = Pointer to the number of bytes received by this call.
///    lpFlags = Pointer to flags.
///    lpFrom = Optional pointer to a buffer in the <b>sockaddr</b> structure that will hold the source address upon the
///             completion of the overlapped operation.
///    lpFromlen = Pointer to the size of the <i>lpFrom</i> buffer, in bytes, required only if <i>lpFrom</i> is specified.
///    lpOverlapped = Pointer to a <b>WSAOverlapped</b> structure (ignored for nonoverlapped sockets).
///    lpCompletionRoutine = Type: \_In_opt\_
///                          [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](../winsock2/nc-winsock2-lpwsaoverlapped_completion_routine.md) Pointer
///                          to the completion routine called when the receive operation has been completed (ignored for nonoverlapped
///                          sockets).
///    lpThreadId = Pointer to a <b>WSATHREADID</b> structure to be used by the provider in a subsequent call to <b>WPUQueueApc</b>.
///                 The provider should store the referenced **WSATHREADID** structure (not the pointer to same) until after the
///                 **WPUQueueApc** function returns.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs and the receive operation has completed immediately, **LPWSPRecvFrom** returns zero. Note that
///    in this case the completion routine, if specified will have already been queued. Otherwise, a value of
///    SOCKET_ERROR is returned, and a specific error code is available in <i>lpErrno</i>. The error code WSA_IO_PENDING
///    indicates that the overlapped operation has been successfully initiated and that completion will be indicated at
///    a later time. Any other error code indicates that no overlapped operations was initiated and no completion
///    indication will occur. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAENETDOWN</dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAEFAULT</dt> </dl> </td> <td width="60%"> The <i>lpFromlen</i> parameter was invalid: the
///    <i>lpFrom</i> buffer was too small to accommodate the peer address or <i>lpbuffers</i> is not totally contained
///    within a valid part of the user address space. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINTR</dt> </dl>
///    </td> <td width="60%"> (Blocking) call was canceled through <b>LPWSPCancelBlockingCall</b>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%"> Blocking Windows Sockets call is in
///    progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEINVAL</dt> </dl> </td> <td width="60%"> Socket has not been bound (for example, with <b>LPWSPBind</b>) or
///    the socket is not created with the overlapped flag. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEISCONN</dt>
///    </dl> </td> <td width="60%"> Socket is connected. This function is not permitted with a connected socket, whether
///    the socket is connection-oriented or connectionless. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENETRESET</dt>
///    </dl> </td> <td width="60%"> The connection has been broken due to keep-alive activity detecting a failure while
///    the operation was in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENOTSOCK</dt> </dl> </td> <td
///    width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEOPNOTSUPP</dt> </dl>
///    </td> <td width="60%"> MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB
///    data is not supported in the communication domain associated with this socket, or the socket is unidirectional
///    and supports only send operations. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAESHUTDOWN</dt> </dl> </td> <td
///    width="60%"> Socket has been shut down; it is not possible to run <b>LPWSPRecvFrom</b> on a socket after
///    <b>LPWSPShutdown</b> has been invoked with <i>how</i> set to SD_RECEIVE or SD_BOTH. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAEWOULDBLOCK</dt> </dl> </td> <td width="60%"> **Windows NT:**<br/> Overlapped sockets:
///    There are too many outstanding overlapped I/O requests.Nonoverlapped sockets: The socket is marked as nonblocking
///    and the receive operation cannot be completed immediately. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEMSGSIZE</dt> </dl> </td> <td width="60%"> Message was too large to fit into the specified buffer and (for
///    unreliable protocols only) any trailing portion of the message that did not fit into the buffer has been
///    discarded. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAECONNRESET</dt> </dl> </td> <td width="60%"> The virtual
///    circuit was reset by the remote side executing a hard or abortive close. The application should close the socket
///    as it is no longer usable. On a UDP datagram socket this error would indicate that a previous send operation
///    resulted in an ICMP "Port Unreachable" message. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEDISCON</dt> </dl>
///    </td> <td width="60%"> Socket <i>s</i> is message oriented and the virtual circuit was gracefully closed by the
///    remote side. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSA_IO_PENDING</dt> </dl> </td> <td width="60%"> An
///    overlapped operation was successfully initiated and completion will be indicated at a later time. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt>WSA_OPERATION_ABORTED</dt> </dl> </td> <td width="60%"> Overlapped operation has
///    been canceled due to the closure of the socket. </td> </tr> </table>
///    
alias LPWSPRECVFROM = int function(size_t s, char* lpBuffers, uint dwBufferCount, uint* lpNumberOfBytesRecvd, 
                                   uint* lpFlags, char* lpFrom, int* lpFromlen, OVERLAPPED* lpOverlapped, 
                                   LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, WSATHREADID* lpThreadId, 
                                   int* lpErrno);
///The **LPWSPSelect** function determines the status of one or more sockets.
///Params:
///    nfds = Ignored and included only for the sake of compatibility.
///    readfds = Optional pointer to a set of sockets to be checked for readability.
///    writefds = Optional pointer to a set of sockets to be checked for writability.
///    exceptfds = Optional pointer to a set of sockets to be checked for errors.
///    timeout = Maximum time for **LPWSPSelect** to wait, or **null** for a blocking operation, in the form of a
///              [**timeval**](../winsock2/ns-winsock2-timeval.md) structure.
///    lpErrno = Pointer to the error code.
///Returns:
///    The **LPWSPSelect** function returns the total number of descriptors that are ready and contained in the fd_set
///    structures, or SOCKET_ERROR if an error occurred. If the return value is SOCKET_ERROR, a specific error code is
///    available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEFAULT</dt> </dl> </td> <td width="60%"> Windows Sockets service provider was unable to allocated needed
///    resources for its internal operations, or the <i>readfds</i>, <i>writefds</i>, <i>exceptfds</i> or <i>timeval</i>
///    parameters are not part of the user address space. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENETDOWN</dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEINVAL</dt> </dl> </td> <td width="60%"> The <i>timeout</i> value is not valid, or all three descriptor
///    parameters were <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINTR</dt> </dl> </td> <td
///    width="60%"> (Blocking) call was canceled through <b>LPWSPCancelBlockingCall</b>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%"> Blocking Windows Sockets call is in
///    progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAENOTSOCK</dt> </dl> </td> <td width="60%"> One of the descriptor sets contains an entry that is not a
///    socket. </td> </tr> </table>
///    
alias LPWSPSELECT = int function(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, 
                                 const(timeval)* timeout, int* lpErrno);
///The **LPWSPSend** function sends data on a connected socket.
///Params:
///    s = A descriptor identifying a connected socket.
///    lpBuffers = A pointer to an array of WSABUF structures. Each **WSABUF** structure contains a pointer to a buffer and the
///                length of the buffer, in bytes. For a Winsock application, once the **LPWSPSend** function is called, the system
///                owns these buffers and the application may not access them. Data buffers referenced in each WSABUF structure are
///                owned by the system and your application may not access them for the lifetime of the call.
///    dwBufferCount = The number of WSABUF structures in the <i>lpBuffers</i> array.
///    lpNumberOfBytesSent = A pointer to the number of bytes sent by this call.
///    dwFlags = A set of flags that specifies the way in which the call is made.
///    lpOverlapped = A pointer to a <b>WSAOverlapped</b> structure (ignored for nonoverlapped sockets).
///    lpCompletionRoutine = Type: \_In_opt\_
///                          [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](../winsock2/nc-winsock2-lpwsaoverlapped_completion_routine.md) A pointer
///                          to the completion routine called when the send operation has been completed (ignored for nonoverlapped sockets).
///    lpThreadId = A pointer to a <b>WSATHREADID</b> structure to be used by the provider in a subsequent call to
///                 <b>WPUQueueApc</b>. The provider should store the referenced **WSATHREADID** structure (not the pointer to same)
///                 until after the **WPUQueueApc** function returns.
///    lpErrno = A pointer to the error code.
///Returns:
///    If no error occurs and the send operation has completed immediately, **LPWSPSend** returns zero. Note that in
///    this case the completion routine, if specified, will have already been queued. Otherwise, a value of SOCKET_ERROR
///    is returned, and a specific error code is available in <i>lpErrno</i>. The error code
///    [WSA_IO_PENDING](/windows/win32/winsock/windows-sockets-error-codes-2#wsa-io-pending) indicates that the
///    overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any
///    other error code indicates that no overlapped operation was initiated and no completion indication will occur.
///    <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>WSAENETDOWN</dt> </dl>
///    </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEACCES</dt> </dl> </td> <td width="60%"> Requested address is a broadcast address, but the appropriate
///    flag was not set. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%">
///    Blocking Windows Sockets call is in progress, or the service provider is still processing a callback function.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEFAULT</dt> </dl> </td> <td width="60%"> The <i>lpBuffers</i>
///    parameter is not totally contained in a valid part of the user address space. </td> </tr> <tr> <td width="40%">
///    <dl> <dt>WSAENETRESET</dt> </dl> </td> <td width="60%"> The connection has been broken due to the remote host
///    resetting. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENOBUFS</dt> </dl> </td> <td width="60%"> The connection
///    has been broken due to keep-alive activity detecting a failure while the operation was in progress. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt>WSAENOTCONN</dt> </dl> </td> <td width="60%"> Socket is not connected. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt>WSAENOTSOCK</dt> </dl> </td> <td width="60%"> The descriptor is not a socket.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEOPNOTSUPP</dt> </dl> </td> <td width="60%"> MSG_OOB was specified,
///    but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication
///    domain associated with this socket, MSG_PARTIAL is not supported, or the socket is unidirectional and supports
///    only receive operations. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAESHUTDOWN</dt> </dl> </td> <td
///    width="60%"> Socket has been shut down; it is not possible to <b>LPWSPSend</b> on a socket after
///    <b>LPWSPShutdown</b> has been invoked with how set to SD_SEND or SD_BOTH. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEWOULDBLOCK</dt> </dl> </td> <td width="60%"> **Windows NT:** Overlapped sockets: There are too many
///    outstanding overlapped I/O requests.Nonoverlapped sockets: The socket is marked as nonblocking and the send
///    operation cannot be completed immediately. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEMSGSIZE</dt> </dl>
///    </td> <td width="60%"> Socket is message oriented, and the message is larger than the maximum supported by the
///    underlying transport. </tr> <tr> <td width="40%"> <dl> <dt>WSAEINVAL</dt> </dl> </td> <td width="60%"> Socket has
///    not been bound with <b>LPWSPBind</b>, or the socket is not created with the overlapped flag. </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAECONNABORTED</dt> </dl> </td> <td width="60%"> Virtual circuit was terminated due to a
///    time-out or other failure. </tr> <tr> <td width="40%"> <dl> <dt>WSAECONNRESET</dt> </dl> </td> <td width="60%">
///    Virtual circuit was reset by the remote side. </tr> <tr> <td width="40%"> <dl> <dt>WSA_OPERATION_ABORTED</dt>
///    </dl> </td> <td width="60%"> Overlapped operation has been canceled due to the closure of the socket, or the
///    execution of the SIO_FLUSH command in <b>LPWSPIoctl</b>. </tr> </table>
///    
alias LPWSPSEND = int function(size_t s, char* lpBuffers, uint dwBufferCount, uint* lpNumberOfBytesSent, 
                               uint dwFlags, OVERLAPPED* lpOverlapped, 
                               LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, WSATHREADID* lpThreadId, 
                               int* lpErrno);
///The **LPWSPSendDisconnect** function initiates termination of the connection for the socket and sends disconnect
///data.
///Params:
///    s = Descriptor identifying a socket.
///    lpOutboundDisconnectData = Pointer to the outgoing disconnect data.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPSendDisconnect** returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt>WSAENETDOWN</dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt>WSAENOPROTOOPT</dt> </dl> </td> <td width="60%"> Parameter
///    <i>lpOutboundDisconnectData</i> is not null, and the disconnect data is not supported by the service provider.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%"> Blocking Windows
///    Sockets call is in progress, or the service provider is still processing a callback function. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt>WSAENOTCONN</dt> </dl> </td> <td width="60%"> Socket is not connected
///    (connection-oriented sockets only). </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENOTSOCK</dt> </dl> </td> <td
///    width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEFAULT</dt> </dl>
///    </td> <td width="60%"> The <i>lpOutboundDisconnectData</i> parameter is not totally contained in a valid part of
///    the user address space. </td> </tr> </table>
///    
alias LPWSPSENDDISCONNECT = int function(size_t s, WSABUF* lpOutboundDisconnectData, int* lpErrno);
///The **LPWSPSendTo** function sends data to a specific destination using overlapped I/O.
///Params:
///    s = A descriptor identifying a socket.
///    lpBuffers = A pointer to an array of WSABUF structures. Each **WSABUF** structure contains a pointer to a buffer and the
///                length of the buffer, in bytes. For a Winsock application, once the **LPWSPSendTo** function is called, the
///                system owns these buffers and the application may not access them. Data buffers referenced in each WSABUF
///                structure are owned by the system and your application may not access them for the lifetime of the call.
///    dwBufferCount = The number of WSABUF structures in the <i>lpBuffers</i> array.
///    lpNumberOfBytesSent = A pointer to the number of bytes sent by this call.
///    dwFlags = A set of flags that specifies the way in which the call is made.
///    lpTo = An optional pointer to the address of the target socket in the <b>sockaddr</b> structure.
///    iTolen = The size, in bytes, of the address pointed to by the <i>lpTo</i> parameter.
///    lpOverlapped = A pointer to a <b>WSAOverlapped</b> structure (ignored for nonoverlapped sockets).
///    lpCompletionRoutine = Type: \_In_opt\_
///                          [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](../winsock2/nc-winsock2-lpwsaoverlapped_completion_routine.md) A pointer
///                          to the completion routine called when the send operation has been completed (ignored for nonoverlapped sockets).
///    lpThreadId = A pointer to a <b>WSATHREADID</b> structure to be used by the provider in a subsequent call to
///                 <b>WPUQueueApc</b>. The provider should store the referenced **WSATHREADID** structure (not the pointer to same)
///                 until after the **WPUQueueApc** function returns.
///    lpErrno = A pointer to the error code.
///Returns:
///    If no error occurs and the receive operation has completed immediately, **LPWSPSendTo** returns zero. Note that
///    in this case the completion routine, if specified, will have already been queued. Otherwise, a value of
///    SOCKET_ERROR is returned, and a specific error code is available in <i>lpErrno</i>. The error code
///    [WSA_IO_PENDING](/windows/win32/winsock/windows-sockets-error-codes-2#wsa-io-pending) indicates that the
///    overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any
///    other error code indicates that no overlapped operation was initiated and no completion indication will occur.
///    <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>WSAENETDOWN</dt> </dl>
///    </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEACCES</dt> </dl> </td> <td width="60%"> Requested address is a broadcast address, but the appropriate
///    flag was not set. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINTR</dt> </dl> </td> <td width="60%">
///    (Blocking) call was canceled through <b>LPWSPCancelBlockingCall</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%"> Blocking Windows Sockets call is in progress, or the service
///    provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEFAULT</dt> </dl>
///    </td> <td width="60%"> The <i>lpBuffers</i> or <i>lpTo</i> parameters are not part of the user address space, or
///    the <i>lpTo</i> parameter is too small. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENETRESET</dt> </dl> </td>
///    <td width="60%"> The connection has been broken due to keep-alive activity detecting a failure while the
///    operation was in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENOBUFS</dt> </dl> </td> <td
///    width="60%"> Windows Sockets provider reports a buffer deadlock. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAENOTCONN</dt> </dl> </td> <td width="60%"> Socket is not connected (connection-oriented sockets only).
///    </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENOTSOCK</dt> </dl> </td> <td width="60%"> The descriptor is not a
///    socket. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEOPNOTSUPP</dt> </dl> </td> <td width="60%"> MSG_OOB was
///    specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the
///    communication domain associated with this socket, MSG_PARTIAL is not supported, or the socket is unidirectional
///    and supports only receive operations. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAESHUTDOWN</b></dl> </dl>
///    </td> <td width="60%"> Socket has been shut down; it is not possible to use <b>LPWSPSendTo</b> on a socket after
///    <b>LPWSPShutdown</b> has been invoked with <i>how</i> set to SD_SEND or SD_BOTH. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAEWOULDBLOCK</b></dl> </dl> </td> <td width="60%"> Windows NT: Overlapped sockets: there
///    are too many outstanding overlapped I/O requests.Nonoverlapped sockets: The socket is marked as nonblocking and
///    the send operation cannot be completed immediately. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAEMSGSIZE</b></dl> </dl> </td> <td width="60%"> Socket is message oriented, and the message is larger than
///    the maximum supported by the underlying transport. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINVAL</b></dl>
///    </dl> </td> <td width="60%"> Socket has not been bound with <b>LPWSPBind</b>, or the socket is not created with
///    the overlapped flag. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAECONNABORTED</b></dl> </dl> </td> <td
///    width="60%"> Virtual circuit was terminated due to a time-out or other failure. </td> </tr> <tr> <td width="40%">
///    <dl> <dt>WSAECONNRESET</b></dl> </dl> </td> <td width="60%"> Virtual circuit was reset by the remote side. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt>WSAEADDRNOTAVAIL</b></dl> </dl> </td> <td width="60%"> Remote address is not
///    a valid address (for example, ADDR_ANY). </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEAFNOSUPPORT</b></dl>
///    </dl> </td> <td width="60%"> Addresses in the specified family cannot be used with this socket. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt>WSAEDESTADDRREQ</b></dl> </dl> </td> <td width="60%"> Destination address is required.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENETUNREACH</b></dl> </dl> </td> <td width="60%"> The network
///    cannot be reached from this host at this time. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSA_OPERATION_ABORTED</b></dl> </dl> </td> <td width="60%"> Overlapped operation has been canceled due to the
///    closure of the socket, or the execution of the SIO_FLUSH command in <b>LPWSPIoctl</b>. </td> </tr> </table>
///    
alias LPWSPSENDTO = int function(size_t s, char* lpBuffers, uint dwBufferCount, uint* lpNumberOfBytesSent, 
                                 uint dwFlags, char* lpTo, int iTolen, OVERLAPPED* lpOverlapped, 
                                 LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, WSATHREADID* lpThreadId, 
                                 int* lpErrno);
///The **LPWSPSetSockOpt** function sets a socket option.
///Params:
///    s = The descriptor that identifies a socket.
///    level = The level at which the option is defined; the supported levels include <b>SOL_SOCKET</b>. For more information,
///            see [Winsock Annexes](/windows/win32/winsock/winsock-annexes).
///    optname = The socket option for which the value is to be set.
///    optval = A pointer to the buffer in which the value for the requested option is supplied.
///    optlen = The size, in bytes, of the <i>optval</i> buffer.
///    lpErrno = A pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPSetSockOpt** returns zero. Otherwise, a value of **SOCKET_ERROR** is returned, and a
///    specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt>WSAENETDOWN</dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt>WSAEFAULT</dt> </dl> </td> <td width="60%"> The <i>optval</i> is not in a
///    valid part of the process address space or <i>optlen</i> parameter is too small. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%"> Function is invoked when a callback is in
///    progress. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%"> Blocking
///    Windows Sockets call is in progress, or the service provider is still processing a callback function. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt>WSAEINVAL</dt> </dl> </td> <td width="60%"> The <i>level</i> is not valid, or the
///    information in <i>optval</i> is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENETRESET</dt> </dl>
///    </td> <td width="60%"> The connection has been broken due to keep-alive activity detecting a failure while the
///    operation was in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOPROTOOPT</b></dl> </dl> </td> <td
///    width="60%"> Option is unknown or unsupported for the specified provider. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTCONN</b></dl> </dl> </td> <td width="60%"> The connection has been reset when SO_KEEPALIVE is set.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dl> </dl> </td> <td width="60%"> The descriptor is
///    not a socket. </td> </tr> </table>
///    
alias LPWSPSETSOCKOPT = int function(size_t s, int level, int optname, char* optval, int optlen, int* lpErrno);
///The **LPWSPShutdown** function disables sends and/or receives on a socket.
///Params:
///    s = Descriptor identifying a socket.
///    how = Flag that describes what types of operation will no longer be allowed.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPShutdown** returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error Code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt>WSAENETDOWN</dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt>WSAEINVAL</dt> </dl> </td> <td width="60%"> The <i>how</i> is not valid, or
///    is not consistent with the socket type. For example, SD_SEND is used with a UNI_RECV socket type. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt>WSAEINPROGRESS</dt> </dl> </td> <td width="60%"> Function is invoked when a
///    callback is in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt>WSAENOTCONN</dt> </dl> </td> <td width="60%">
///    Socket is not connected (connection-oriented sockets only). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt>WSAENOTSOCK</dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> </table>
///    
alias LPWSPSHUTDOWN = int function(size_t s, int how, int* lpErrno);
///The **LPWSPSocket** function creates a socket. For info about the part played by **LPWSPSocket** in creating a shared
///socket, see [Shared sockets](/windows/win32/winsock/shared-sockets-2) and [Shared sockets in the
///SPI](/windows/win32/winsock/shared-sockets-in-the-spi-2).
///Params:
///    af = Address family specification.
///    type = Type specification for the new socket.
///    protocol = Protocol to be used with the socket that is specific to the indicated address family.
///    lpProtocolInfo = Pointer to a WSAProtocol_Info structure that defines the characteristics of the socket to be created.
///    g = Reserved.
///    dwFlags = Socket attribute specification.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **LPWSPSocket** returns a descriptor referencing the new socket. Otherwise, a value of
///    INVALID_SOCKET is returned, and a specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td
///    width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEAFNOSUPPORT</b></dl> </dl> </td> <td width="60%"> The specified address family is not supported. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dl> </dl> </td> <td width="60%"> Blocking Windows
///    Sockets call is in progress, or the service provider is still processing a callback function. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEMFILE</b></dl> </dl> </td> <td width="60%"> No more socket descriptors are
///    available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dl> </dl> </td> <td width="60%"> No
///    buffer space is available. The socket cannot be created. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEPROTONOSUPPORT</b></dl> </dl> </td> <td width="60%"> The specified protocol is not supported. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEPROTOTYPE</b></dl> </dl> </td> <td width="60%"> The specified
///    protocol is the wrong type for this socket. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAESOCKTNOSUPPORT</b></dl> </dl> </td> <td width="60%"> The specified socket type is not supported in
///    this address family. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> Parameter <i>g</i> specified is not valid. </td> </tr> </table> <div> </div>
///    
alias LPWSPSOCKET = size_t function(int af, int type, int protocol, WSAPROTOCOL_INFOW* lpProtocolInfo, uint g, 
                                    uint dwFlags, int* lpErrno);
///The **WSPStringToAddress** function converts a human-readable numeric string to a socket address structure (sockaddr)
///suitable to passing to Windows Sockets routines that take such a structure. Any missing components of the address are
///defaulted to a reasonable value, if possible. For example, a missing port number defaults to zero.
///Params:
///    AddressString = Pointer to the zero-terminated, human-readable string to convert.
///    AddressFamily = Address family to which the string belongs, or AF_UNSPEC if it is unknown.
///    lpProtocolInfo = (required) Provider's WSAProtocol_Info structure.
///    lpAddress = Buffer that is filled with a single sockaddr structure.
///    lpAddressLength = Length of the Address buffer, in bytes. Returns the size of the resultant sockaddr structure. If the supplied
///                      buffer is not large enough, the function fails with a specific error of WSAEFAULT and this parameter is updated
///                      with the required size in bytes.
///    lpErrno = Pointer to the error code.
///Returns:
///    If no error occurs, **WSPStringToAddress** returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The specified address buffer is too
///    small, pass in a larger buffer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> Unable to translate the string into a sockaddr, or the provider was unable to support the indicated
///    address family, or the specified <i>lpProtocolInfo</i> did not refer to a WSAProtocol_Info structure supported by
///    the provider. </td> </tr> </table> <div> </div>
///    
alias LPWSPSTRINGTOADDRESS = int function(const(wchar)* AddressString, int AddressFamily, 
                                          WSAPROTOCOL_INFOW* lpProtocolInfo, char* lpAddress, int* lpAddressLength, 
                                          int* lpErrno);
alias LPWPUCLOSEEVENT = BOOL function(HANDLE hEvent, int* lpErrno);
alias LPWPUCLOSESOCKETHANDLE = int function(size_t s, int* lpErrno);
alias LPWPUCREATEEVENT = HANDLE function(int* lpErrno);
alias LPWPUCREATESOCKETHANDLE = size_t function(uint dwCatalogEntryId, size_t dwContext, int* lpErrno);
alias LPWPUFDISSET = int function(size_t s, fd_set* fdset);
alias LPWPUGETPROVIDERPATH = int function(GUID* lpProviderId, char* lpszProviderDllPath, int* lpProviderDllPathLen, 
                                          int* lpErrno);
alias LPWPUMODIFYIFSHANDLE = size_t function(uint dwCatalogEntryId, size_t ProposedHandle, int* lpErrno);
alias LPWPUPOSTMESSAGE = BOOL function(HWND hWnd, uint Msg, WPARAM wParam, LPARAM lParam);
alias LPWPUQUERYBLOCKINGCALLBACK = int function(uint dwCatalogEntryId, LPBLOCKINGCALLBACK* lplpfnCallback, 
                                                size_t* lpdwContext, int* lpErrno);
alias LPWPUQUERYSOCKETHANDLECONTEXT = int function(size_t s, size_t* lpContext, int* lpErrno);
alias LPWPUQUEUEAPC = int function(WSATHREADID* lpThreadId, LPWSAUSERAPC lpfnUserApc, size_t dwContext, 
                                   int* lpErrno);
alias LPWPURESETEVENT = BOOL function(HANDLE hEvent, int* lpErrno);
alias LPWPUSETEVENT = BOOL function(HANDLE hEvent, int* lpErrno);
alias LPWPUOPENCURRENTTHREAD = int function(WSATHREADID* lpThreadId, int* lpErrno);
alias LPWPUCLOSETHREAD = int function(WSATHREADID* lpThreadId, int* lpErrno);
alias LPWPUCOMPLETEOVERLAPPEDREQUEST = int function(size_t s, OVERLAPPED* lpOverlapped, uint dwError, 
                                                    uint cbTransferred, int* lpErrno);
alias LPWSPSTARTUP = int function(ushort wVersionRequested, WSPData* lpWSPData, WSAPROTOCOL_INFOW* lpProtocolInfo, 
                                  WSPUPCALLTABLE UpcallTable, WSPPROC_TABLE* lpProcTable);
alias LPWSCENUMPROTOCOLS = int function(int* lpiProtocols, char* lpProtocolBuffer, uint* lpdwBufferLength, 
                                        int* lpErrno);
alias LPWSCDEINSTALLPROVIDER = int function(GUID* lpProviderId, int* lpErrno);
alias LPWSCINSTALLPROVIDER = int function(GUID* lpProviderId, const(wchar)* lpszProviderDllPath, 
                                          char* lpProtocolInfoList, uint dwNumberOfEntries, int* lpErrno);
alias LPWSCGETPROVIDERPATH = int function(GUID* lpProviderId, char* lpszProviderDllPath, int* lpProviderDllPathLen, 
                                          int* lpErrno);
alias LPWSCUPDATEPROVIDER = int function(GUID* lpProviderId, const(wchar)* lpszProviderDllPath, 
                                         char* lpProtocolInfoList, uint dwNumberOfEntries, int* lpErrno);
alias LPWSCINSTALLNAMESPACE = int function(const(wchar)* lpszIdentifier, const(wchar)* lpszPathName, 
                                           uint dwNameSpace, uint dwVersion, GUID* lpProviderId);
alias LPWSCUNINSTALLNAMESPACE = int function(GUID* lpProviderId);
alias LPWSCENABLENSPROVIDER = int function(GUID* lpProviderId, BOOL fEnable);
///The **NSPCleanup** function terminates the use of a particular Windows Sockets namespace service provider.
///Params:
///    lpProviderId = A pointer to the [GUID](../guiddef/ns-guiddef-guid.md) of the namespace provider to be terminated.
///Returns:
///    If no error occurs, then **NSPCleanup** returns a value of **NO_ERROR** (zero). Otherwise, **SOCKET_ERROR**
///    (–1) is returned, and the provider must set the appropriate error code using WSASetLastError. |Error
///    code|Meaning| |-|-| |<b>WSA_NOT_ENOUGH_MEMORY</b>|There is not enough memory available to perform this
///    operation.| |<b>WSAEINVAL</b>|The <i>lpProviderId</i> parameter doesn't specify a valid provider.|
///    |<b>WSAEOPNOTSUPP</b>|The operation is not supported. This error is returned if the namespace provider does not
///    implement this function.|
///    
alias LPNSPCLEANUP = int function(GUID* lpProviderId);
///The **NSPLookupServiceBegin** function initiates a client query of a name service provider that is constrained by the
///information contained within a WSAQUERYSET structure. **NSPLookupServiceBegin** only returns a handle, which should
///be used by subsequent calls to NSPLookupServiceNext to get the actual results. Because this operation cannot be
///canceled, it should be implemented to execute quickly. While it is acceptable to initiate a network query, this
///function should not require a response to return successfully.
///Params:
///    lpProviderId = A pointer to the name service provider identifier to query.
///    lpqsRestrictions = A pointer to the search criteria. See Remarks.
///    lpServiceClassInfo = A pointer to the WSASERVICECLASSINFO structure that contains schema information for the service.
///    dwControlFlags = A value that controls the depth of the search. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///                     width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl> <dt><b>LUP_DEEP</b></dl> <dt>0x0001</dt> </dl> </td>
///                     <td width="60%"> Queries down the hierarchy of a provider as opposed to just the first level. </td> </tr> <tr>
///                     <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl> <dt><b>LUP_CONTAINERS</b></dl>
///                     <dt>0x0002</dt> </dl> </td> <td width="60%"> Returns containers only. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl> <dt><b>LUP_NOCONTAINERS</b></dl> <dt>0x0004</dt>
///                     </dl> </td> <td width="60%"> Returns no containers. </td> </tr> <tr> <td width="40%"><a id="LUP_NEAREST"></a><a
///                     id="lup_nearest"></a><dl> <dt><b>LUP_NEAREST</b></dl> <dt>0x0008</dt> </dl> </td> <td width="60%"> If possible,
///                     returns results in the order of distance. The measure of distance is provider specific. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl> <dt><b>LUP_RETURN_NAME</b></dl>
///                     <dt>0x0010</dt> </dl> </td> <td width="60%"> Retrieves the name as **lpszServiceInstanceName**. </td> </tr> <tr>
///                     <td width="40%"><a id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl> <dt><b>LUP_RETURN_TYPE</b></dl>
///                     <dt>0x0020</dt> </dl> </td> <td width="60%"> Retrieves the type as **lpServiceClassId**. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl> <dt><b>LUP_RETURN_VERSION</b></dl>
///                     <dt>0x0040</dt> </dl> </td> <td width="60%"> Retrieves the version as **lpVersion**. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl> <dt><b>LUP_RETURN_COMMENT</b></dl>
///                     <dt>0x0080</dt> </dl> </td> <td width="60%"> Retrieves the comment as **lpszComment**. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl> <dt><b>LUP_RETURN_ADDR</b></dl>
///                     <dt>0x0100</dt> </dl> </td> <td width="60%"> Retrieves the addresses as **lpcsaBuffer**. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl> <dt><b>LUP_RETURN_BLOB</b></dl>
///                     <dt>0x0200</dt> </dl> </td> <td width="60%"> Retrieves the private data as **lpBlob**. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl> <dt><b>LUP_RETURN_ALIASES</b></dl>
///                     <dt>0x0400</dt> </dl> </td> <td width="60%"> Any available alias information is to be returned in successive
///                     calls to NSPLookupServiceNext, and each alias returned will have the **RESULT_IS_ALIAS** flag set. </td> </tr>
///                     <tr> <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
///                     <dt><b>LUP_RETURN_QUERY_STRING</b></dl> <dt>0x0800</dt> </dl> </td> <td width="60%"> Retrieves the query string
///                     as **lpszQueryString**. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_ALL"></a><a
///                     id="lup_return_all"></a><dl> <dt><b>LUP_RETURN_ALL</b></dl> <dt>0x0ff0</dt> </dl> </td> <td width="60%">
///                     Retrieves information including the name, type, version, comment, address, blob, aliases, and query string. </td>
///                     </tr> <tr> <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
///                     <dt><b>LUP_FLUSHCACHE</b></dl> <dt>0x1000</dt> </dl> </td> <td width="60%"> If the provider has cached
///                     information, ignore the cache and query the namespace itself. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl> <dt><b>LUP_FLUSHPREVIOUS</b></dl> <dt>0x2000</dt>
///                     </dl> </td> <td width="60%"> Used as a value for the <i>dwControlFlags</i> parameter in NSPLookupServiceNext.
///                     Setting this flag instructs the provider to discard the last result set, which was too large for the supplied
///                     buffer, and move on to the next result set. </td> </tr> <tr> <td width="40%"><a id="LUP_NON_AUTHORITATIVE"></a><a
///                     id="lup_non_authoritative"></a><dl> <dt><b>LUP_NON_AUTHORITATIVE</b></dl> <dt>0x4000</dt> </dl> </td> <td
///                     width="60%"> Indicates that the namespace provider should included non-authoritative results for names. </td>
///                     </tr> <tr> <td width="40%"><a id="LUP_RES_RESERVICE"></a><a id="lup_res_reservice"></a><dl>
///                     <dt><b>LUP_RES_RESERVICE</b></dl> <dt>0x8000</dt> </dl> </td> <td width="60%"> Indicates whether prime response
///                     is in the remote or local part of CSADDR_INFO structure. The other part must be usable in either case. This
///                     option applies only to service instance requests. </td> </tr> <tr> <td width="40%"><a id="LUP_SECURE"></a><a
///                     id="lup_secure"></a><dl> <dt><b>LUP_SECURE</b></dl> <dt>0x8000</dt> </dl> </td> <td width="60%"> Indicates that
///                     the namespace provider should use a secure query. This option only applies to name query requests. </td> </tr>
///                     <tr> <td width="40%"><a id="LUP_RETURN_PREFERRED_NAMES"></a><a id="lup_return_preferred_names"></a><dl>
///                     <dt><b>LUP_RETURN_PREFERRED_NAMES</b></dl> <dt>0x10000</dt> </dl> </td> <td width="60%"> Indicates that the
///                     namespace provider should return only preferred names. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_ADDRCONFIG"></a><a id="lup_addrconfig"></a><dl> <dt><b>LUP_ADDRCONFIG</b></dl> <dt>0x100000</dt> </dl>
///                     </td> <td width="60%"> Indicates that the namespace provider should return the address configuration. </td> </tr>
///                     <tr> <td width="40%"><a id="LUP_DUAL_ADDR"></a><a id="lup_dual_addr"></a><dl> <dt><b>LUP_DUAL_ADDR</b></dl>
///                     <dt>0x200000</dt> </dl> </td> <td width="60%"> Indicates that the namespace provider should return the dual
///                     addresses. This option only applies to dual-mode sockets (IPv6 and IPv4 mapped addresses). </td> </tr> </table>
///    lphLookup = A pointer to the handle to be used in subsequent calls to NSPLookupServiceNext in order to retrieve the results
///                set.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (–1)
///    if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td
///    width="60%"> There is not enough memory available to perform this operation. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> One or more parameters were invalid, or missing, for
///    this provider. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%">
///    The operation is not supported. This error is returned if the namespace provider does not implement this
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dl> </dl> </td> <td width="60%"> The name
///    was found in the database, but it does not have the correct associated data that is resolved for. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSASERVICE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> Service is unknown.
///    The service cannot be found in the specified namespace. </td> </tr> </table>
///    
alias LPNSPLOOKUPSERVICEBEGIN = int function(GUID* lpProviderId, WSAQUERYSETW* lpqsRestrictions, 
                                             WSASERVICECLASSINFOW* lpServiceClassInfo, uint dwControlFlags, 
                                             ptrdiff_t* lphLookup);
///The **NSPLookupServiceNext** function is called after obtaining a handle from a previous call to
///NSPLookupServiceBegin in order to retrieve the requested service information. The provider will pass a WSAQUERYSET
///structure in the <i>lpqsResults</i> buffer. The client should call this function until it returns **WSA_E_NOMORE**,
///indicating that all the **WSAQUERYSET** have been returned.
///Params:
///    hLookup = A handle returned from the previous call to WSALookupServiceBegin.
///    dwControlFlags = The flags used to control the next operation. Currently, only **LUP_FLUSHPREVIOUS** is defined as a means to
///                     handle a result set that is too large. If an application cannot supply a large enough buffer, setting
///                     **LUP_FLUSHPREVIOUS** instructs the provider to discard the last result set, which was too large, and move to the
///                     next set for this call.
///    lpdwBufferLength = The size, in bytes, on input, that is contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the
///                       function fails and the error is WSAEFAULT, then it contains the minimum size, in bytes to pass for the
///                       <i>lpqsResults</i> to retrieve the record.
///    lpqsResults = A pointer to a memory block that will contain, on return, one result set in a WSAQUERYSET structure.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (–1)
///    if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_E_CANCELLED</b></dl> </dl> </td> <td
///    width="60%"> A call to NSPLookupServiceEnd was made while this call was still processing. The call has been
///    canceled. The data in the <i>lpqsResults</i> buffer is undefined. In Windows Sockets 2, conflicting error codes
///    are defined for **WSAECANCELLED** (10103) and **WSA_E_CANCELLED** (10111).The error code **WSAECANCELLED** will
///    be removed in a future version and only WSA_E_CANCELLED will remain. Namespace providers should use the
///    **WSA_E_CANCELLED** error code to maintain compatibility with the widest possible range of applications. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_E_NO_MORE</b></dl> </dl> </td> <td width="60%"> There is no more data
///    available. In Windows Sockets 2, conflicting error codes are defined for **WSAENOMORE** (10102) and
///    **WSA_E_NO_MORE** (10110).The error code **WSAENOMORE** will be removed in a future version and only
///    WSA_E_NO_MORE will remain. Namespace providers should use the **WSA_E_NO_MORE** error code to maintain
///    compatibility with the widest possible range of applications. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_INVALID_HANDLE</b></dl> </dl> </td> <td width="60%"> The specified lookup handle is invalid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> There is not
///    enough memory available to perform this operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The <i>lpqsResults</i> buffer was too small to contain a
///    WSAQUERYSET set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%">
///    One or more parameters are invalid, or missing, for this provider. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> The operation is not supported. This error is returned
///    if the namespace provider does not implement this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_DATA</b></dl> </dl> </td> <td width="60%"> The name was found in the database, but no data, matching
///    the given restrictions, was located. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSASERVICE_NOT_FOUND</b></dl>
///    </dl> </td> <td width="60%"> The service is unknown. The service cannot be found in the specified namespace.
///    </td> </tr> </table>
///    
alias LPNSPLOOKUPSERVICENEXT = int function(HANDLE hLookup, uint dwControlFlags, uint* lpdwBufferLength, 
                                            char* lpqsResults);
///The **NSPIoctl** function sends an IOCTL to a namespace service provider.
///Params:
///    hLookup = The lookup handle returned from a previous call to the NSPLookupServiceBegin function.
///    dwControlCode = The control code of the operation to perform. The values that may be used for the <i>dwControlCode</i> parameter
///                    are determined by the namespace provider. The following value is supported by several Microsoft namespace
///                    providers including the Network Location Awareness (NS_NLA) namespace provider. This IOCTL is defined in the
///                    Winsock2.h header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                    id="SIO_NSP_NOTIFY_CHANGE"></a><a id="sio_nsp_notify_change"></a><dl> <dt><b>SIO_NSP_NOTIFY_CHANGE</b></dl> </dl>
///                    </td> <td width="60%"> This operation checks if the results returned with previous calls using the <i>hLookup</i>
///                    parameter are still valid. These previous calls include the initial call to the NSPLookupServiceBegin function to
///                    retrieve the <i>hLookup</i> parameter. These previous calls may also include calls to the NSPLookupServiceNext
///                    function using the <i>hLookup</i> parameter. </td> </tr> </table>
///    lpvInBuffer = A pointer to the input buffer.
///    cbInBuffer = The size, in bytes, of the input buffer.
///    lpvOutBuffer = A pointer to the output buffer.
///    cbOutBuffer = The size, in bytes, of the output buffer.
///    lpcbBytesReturned = A pointer to the number of bytes returned.
///    lpCompletion = A pointer to a WSACOMPLETION structure, used for asynchronous processing. Set <i>lpCompletion</i> to **NULL** to
///                   force blocking (synchronous) execution.
///    lpThreadId = A pointer to a WSATHREADID structure to be used by the provider in a subsequent call to WPUQueueApc. The provider
///                 should store the referenced **WSATHREADID** structure (not the pointer) until after the **WPUQueueApc** function
///                 returns.
///Returns:
///    If no error occurs and the operation has completed immediately, the **NSPIoctl** function should return
///    **NO_ERROR** (zero). Note that in this case the completion routine, if specified, will have already been queued.
///    The **NSPIoctl** function should return **SOCKET_ERROR** (that is, 1) if the routine fails and it must set the
///    appropriate error code using WSASetLastError. The error code WSA_IO_PENDING indicates that an overlapped
///    operation has been successfully initiated and that completion will be indicated at a later time. Any other error
///    code indicates that no overlapped operation was initiated and no completion indication will occur. <table> <tr>
///    <th>Error code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dl>
///    </dl> </td> <td width="60%"> The <i>hLookup</i> parameter was not a valid query handle returned by
///    NSPLookupServiceBegin. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dl> </dl> </td> <td
///    width="60%"> An overlapped operation was successfully initiated and completion will be indicated at a later time.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The
///    <i>lpvInBuffer</i>, <i>cbInBuffer</i>, <i>lpvOutBuffer</i>, <i>cbOutBuffer</i>, or <i>lpCompletion</i> argument
///    is not totally contained in a valid part of the user address space. Alternatively, the <i>cbInBuffer</i> or
///    <i>cbOutBuffer</i> argument is too small, and the argument is modified to reflect the required allocation size.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> A supplied
///    parameter is not acceptable, or the operation inappropriately returns results from multiple namespaces when it
///    does not make sense for the specified operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dl> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> The operation is not supported. This
///    error is returned if the namespace provider does not implement this function. This error can also be returned if
///    the specified <i>dwControlCode</i> is an unrecognized command. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEWOULDBLOCK</b></dl> </dl> </td> <td width="60%"> The resource is temporarily unavailable. The socket
///    is not using overlapped I/O (asynchronous processing), yet the <i>lpCompletion</i> parameter is non-**NULL**.
///    This error is used as a special notification for the SIO_NSP_NOTIFY_CHANGE IOCTL when the <i>lpCompletion</i>
///    parameter is **NULL** (a poll) to indicate that a query set remains valid. </td> </tr> </table>
///    
alias LPNSPIOCTL = int function(HANDLE hLookup, uint dwControlCode, char* lpvInBuffer, uint cbInBuffer, 
                                char* lpvOutBuffer, uint cbOutBuffer, uint* lpcbBytesReturned, 
                                WSACOMPLETION* lpCompletion, WSATHREADID* lpThreadId);
///The **NSPLookupServiceEnd** function is called to free the handle after previous calls to NSPLookupServiceBegin and
///NSPLookupServiceNext. It is possible to receive an **NSPLookupServiceEnd** call on another thread while processing an
///NSPLookupServiceNext. This indicates that the client has canceled the request and the provider should close the
///handle and return from the **NSPLookupServiceNext** call as well, setting the last error to **WSA_E_CANCELLED**.
///Params:
///    hLookup = The handle obtained previously by a call to NSPLookupServiceBegin.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (–1)
///    if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dl> </dl> </td> <td
///    width="60%"> The handle is not valid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> There is not enough memory available to
///    perform this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td
///    width="60%"> The operation is not supported. This error is returned if the namespace provider does not implement
///    this function. </td> </tr> </table>
///    
alias LPNSPLOOKUPSERVICEEND = int function(HANDLE hLookup);
///The **NSPSetService** function registers or deregisters a service instance within a namespace.
///Params:
///    lpProviderId = A pointer to the GUID of the specific namespace provider in which the service is registered.
///    lpServiceClassInfo = The service class schema information.
///    lpqsRegInfo = The property information to be updated upon registration.
///    essOperation = The type of operation requested. This parameter can be one of the values from the **WSAESETSERVICEOP**
///                   enumeration type defined in the <i>Winsock2.h</i> header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                   <tr> <td width="40%"><a id="RNRSERVICE_REGISTER"></a><a id="rnrservice_register"></a><dl>
///                   <dt><b>RNRSERVICE_REGISTER</b></dl> <dt>0</dt> </dl> </td> <td width="60%"> Register the service. For the Service
///                   Advertising Protocol (SAP) namespace used within a NetWare environment, this means sending a periodic broadcast.
///                   This is an NOP for the Domain Name System (DNS) namespace. For persistent data stores this means updating the
///                   address information. </td> </tr> <tr> <td width="40%"><a id="RNRSERVICE_DEREGISTER"></a><a
///                   id="rnrservice_deregister"></a><dl> <dt><b>RNRSERVICE_DEREGISTER</b></dl> <dt>1</dt> </dl> </td> <td width="60%">
///                   Deregister the service. For the SAP namespace, this means stop sending the periodic broadcast. This is a NOP for
///                   the DNS namespace. For persistent data stores this means deleting address information. </td> </tr> <tr> <td
///                   width="40%"><a id="RNRSERVICE_DELETE"></a><a id="rnrservice_delete"></a><dl> <dt><b>RNRSERVICE_DELETE</b></dl>
///                   <dt>2</dt> </dl> </td> <td width="60%"> Delete the service from dynamic name and persistent spaces. For services
///                   represented by multiple CSADDR_INFO structures (using the SERVICE_MULTIPLE flag), only the supplied address will
///                   be deleted, and this must match exactly the corresponding **CSADDR_INFO** structure supplied when the service was
///                   registered. </td> </tr> </table>
///    dwControlFlags = A set of flags that controls the service operation requested. The possible values for this parameter are defined
///                     in the <i>Winsock2.h</i> header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                     id="SERVICE_MULTIPLE"></a><a id="service_multiple"></a><dl> <dt><b>SERVICE_MULTIPLE</b></dl> <dt>0x00000001</dt>
///                     </dl> </td> <td width="60%"> Control the scope of the operation. When this value is set, the action is only
///                     performed on the given address set. A register operation does not invalidate existing addresses and a deregister
///                     operation only invalidates the given set of addresses. When this value is absent, service addresses are managed
///                     as a group. A register or deregister invalidates all existing addresses before adding the given address set.
///                     </td> </tr> </table>
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (–1)
///    if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dl> </dl> </td> <td
///    width="60%"> The calling routine does not have sufficient privileges to install the service. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> There is not enough memory
///    available to perform this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td>
///    <td width="60%"> One or more parameters were invalid, or missing, for this provider. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> The operation is not supported. This
///    error is returned if the namespace provider does not implement this function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSASERVICE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> Service is unknown. The service cannot be
///    found in the specified namespace. </td> </tr> </table>
///    
alias LPNSPSETSERVICE = int function(GUID* lpProviderId, WSASERVICECLASSINFOW* lpServiceClassInfo, 
                                     WSAQUERYSETW* lpqsRegInfo, WSAESETSERVICEOP essOperation, uint dwControlFlags);
///The **NSPInstallServiceClass** function registers service class schema within the namespace providers. The schema
///includes the class name, class identifier, and any namespace-specific type information that is common to all
///instances of the service, such as SAP identifier or object identifier. A dynamic namespace provider is expected to
///store any class information associated with that namespace.
///Params:
///    lpProviderId = A pointer to the GUID of the specific namespace provider that this service class schema is registered in.
///    lpServiceClassInfo = A pointer to the service class schema information.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (–1)
///    if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_PARAMETER</b></dl> </dl> </td> <td
///    width="60%"> The namespace provider cannot supply the requested class information. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> There is not enough memory
///    available to perform this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dl> </dl> </td>
///    <td width="60%"> The calling routine does not have sufficient privileges to perform this operation. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEALREADY</b></dl> </dl> </td> <td width="60%"> The service class information
///    has already been registered for this service class identifier. To modify service class information, first call
///    NSPRemoveServiceClass, then reinstall with updated class information data. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> The service class identifier was invalid or improperly
///    structured. This error is returned if the <i>lpServiceClassInfo</i> parameter is **NULL**. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> The operation is not supported. This
///    error is returned if the namespace provider does not implement this function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSANO_DATA</b></dl> </dl> </td> <td width="60%"> The requested name is valid, but no data of the
///    requested type was found. </td> </tr> </table>
///    
alias LPNSPINSTALLSERVICECLASS = int function(GUID* lpProviderId, WSASERVICECLASSINFOW* lpServiceClassInfo);
///The **NSPRemoveServiceClass** function permanently removes a specified service class from the namespace.
///Params:
///    lpProviderId = A pointer to the GUID of the specific namespace provider that this service class schema is to be removed from.
///    lpServiceClassId = A pointer to the GUID for the service class to remove.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (–1)
///    if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td
///    width="60%"> There is not enough memory available to perform this operation. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSA_INVALID_PARAMETER</b></dl> </dl> </td> <td width="60%"> The specified GUID was not valid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dl> </dl> </td> <td width="60%"> The calling routine does
///    not have sufficient privileges to remove the Service. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> The specified service class identifier GUID was not valid.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> The operation
///    is not supported. This error is returned if the namespace provider does not implement this function. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSATYPE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> The specified class was
///    not found in any of the namespaces. </td> </tr> </table>
///    
alias LPNSPREMOVESERVICECLASS = int function(GUID* lpProviderId, GUID* lpServiceClassId);
///The **NSPGetServiceClassInfo** function retrieves all the pertinent class information (schema) pertaining to the
///namespace provider. This call retrieves any namespace-specific information that is common to all instances of the
///service, including connection information for SAP, or port information for SAP or TCP.
///Params:
///    lpProviderId = A pointer to the [GUID](../guiddef/ns-guiddef-guid.md) of the specific namespace provider from which the service
///                   class schema is to be retrieved.
///    lpdwBufSize = On input, the size, in bytes, of the buffer pointed to by <i>lpServiceClassInfo</i> parameter. On output, if the
///                  function fails and the error is WSAEFAULT, this parameter specifies the minimum size, in bytes, of the buffer
///                  pointed to the <i>lpServiceClassInfo</i> parameter needed to retrieve the record.
///    lpServiceClassInfo = Returns a pointer to WSASERVICECLASSINFOW structure that contains the service class to namespace-specific mapping
///                         information. The <i>lpServiceClassId</i> parameter must be filled to indicate which **WSASERVICECLASSINFOW**
///                         record should be returned.
///Returns:
///    If no error occurs, the **NSPGetServiceClassInfo** function returns **NO_ERROR** (zero). Otherwise,
///    **SOCKET_ERROR** (–1) is returned and the namespace provider must set the appropriate error code using
///    WSASetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> There is not enough memory available to
///    perform this operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dl> </dl> </td> <td
///    width="60%"> The calling routine does not have sufficient privileges to access the information. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The buffer pointed to by the
///    <i>lpServiceClass</i> parameter was too small to contain a WSASERVICECLASSINFOW structure. The application needs
///    to pass in a larger buffer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> The specified service class identifier or namespace provider identifier is not valid. This error is
///    returned if the <i>lpProviderId</i>, <i>lpServiceClassId</i>, <i>lpdwBufSize</i>, or <i>lpServiceClassInfo</i>
///    parameters are **NULL**. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td
///    width="60%"> The operation is not supported. This error is returned if the namespace provider does not implement
///    this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dl> </dl> </td> <td width="60%"> The
///    requested name is valid, but no data of the requested type was found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSATYPE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> The specified class was not found. </td> </tr>
///    </table>
///    
alias LPNSPGETSERVICECLASSINFO = int function(GUID* lpProviderId, uint* lpdwBufSize, 
                                              WSASERVICECLASSINFOW* lpServiceClassInfo);
alias LPNSPSTARTUP = int function(GUID* lpProviderId, NSP_ROUTINE* lpnspRoutines);
///The **NSPv2Startup** function notifies a namespace service provider version-2 (NSPv2) provider that a new client
///process is to begin using the provider.
///Params:
///    lpProviderId = A pointer to the GUID of the specific namespace provider to notify.
///    ppvClientSessionArg = A pointer to the client session.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (that
///    is, 1) if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl>
///    </td> <td width="60%"> There is not enough memory available to perform this operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEACCES</b></dl> </dl> </td> <td width="60%"> The calling routine does not have
///    sufficient privileges to initialize the service. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl>
///    </dl> </td> <td width="60%"> One or more parameters were invalid, or missing, for this provider. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> The operation is not supported.
///    This error is returned if the namespace provider does not implement this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSASERVICE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> Service is unknown. The
///    service cannot be found in the specified namespace. </td> </tr> </table>
///    
alias LPNSPV2STARTUP = int function(GUID* lpProviderId, void** ppvClientSessionArg);
///The **NSPv2Cleanup** function notifies a namespace service provider version-2 (NSPv2) provider that a client session
///has terminated.
///Params:
///    lpProviderId = A pointer to the GUID of the namespace provider to be notified.
///    pvClientSessionArg = A pointer to the client session.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (that
///    is, 1) if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl>
///    </td> <td width="60%"> There is not enough memory available to perform this operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEACCES</b></dl> </dl> </td> <td width="60%"> The calling routine does not have
///    sufficient privileges to initialize the service. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl>
///    </dl> </td> <td width="60%"> One or more parameters were invalid, or missing, for this provider. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> The operation is not supported.
///    This error is returned if the namespace provider does not implement this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSASERVICE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> Service is unknown. The
///    service cannot be found in the specified namespace. </td> </tr> </table>
///    
alias LPNSPV2CLEANUP = int function(GUID* lpProviderId, void* pvClientSessionArg);
///The NSPv2LookupServiceBegin function initiates a client query of a namespace version-2 service provider that is
///constrained by the information contained within a WSAQUERYSET2 structure.
///Params:
///    lpProviderId = A pointer to the identifier for the namespace service provider to query.
///    lpqsRestrictions = A pointer to the search criteria. See Remarks.
///    dwControlFlags = A set of flags that affect the search. This parameter can be a combination of the following values defined in the
///                     <i>Winsock2.h</i> header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                     id="LUP_DEEP"></a><a id="lup_deep"></a><dl> <dt><b>LUP_DEEP</b></dl> <dt>0x0001</dt> </dl> </td> <td width="60%">
///                     Queries down the hierarchy of a provider as opposed to just the first level. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl> <dt><b>LUP_CONTAINERS</b></dl> <dt>0x0002</dt> </dl>
///                     </td> <td width="60%"> Returns containers only. </td> </tr> <tr> <td width="40%"><a id="LUP_NOCONTAINERS"></a><a
///                     id="lup_nocontainers"></a><dl> <dt><b>LUP_NOCONTAINERS</b></dl> <dt>0x0004</dt> </dl> </td> <td width="60%">
///                     Returns no containers. </td> </tr> <tr> <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl>
///                     <dt><b>LUP_NEAREST</b></dl> <dt>0x0008</dt> </dl> </td> <td width="60%"> If possible, returns results in the
///                     order of distance. The measure of distance is provider specific. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl> <dt><b>LUP_RETURN_NAME</b></dl> <dt>0x0010</dt> </dl>
///                     </td> <td width="60%"> Retrieves the name as **lpszServiceInstanceName**. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl> <dt><b>LUP_RETURN_TYPE</b></dl> <dt>0x0020</dt> </dl>
///                     </td> <td width="60%"> Retrieves the type as **lpServiceClassId**. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl> <dt><b>LUP_RETURN_VERSION</b></dl>
///                     <dt>0x0040</dt> </dl> </td> <td width="60%"> Retrieves the version as **lpVersion**. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl> <dt><b>LUP_RETURN_COMMENT</b></dl>
///                     <dt>0x0080</dt> </dl> </td> <td width="60%"> Retrieves the comment as **lpszComment**. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl> <dt><b>LUP_RETURN_ADDR</b></dl>
///                     <dt>0x0100</dt> </dl> </td> <td width="60%"> Retrieves the addresses as **lpcsaBuffer**. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl> <dt><b>LUP_RETURN_BLOB</b></dl>
///                     <dt>0x0200</dt> </dl> </td> <td width="60%"> Retrieves the private data as **lpBlob**. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl> <dt><b>LUP_RETURN_ALIASES</b></dl>
///                     <dt>0x0400</dt> </dl> </td> <td width="60%"> Any available alias information is to be returned in successive
///                     calls to NSPv2LookupServiceNextEx, and each alias returned will have the **RESULT_IS_ALIAS** flag set. </td>
///                     </tr> <tr> <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
///                     <dt><b>LUP_RETURN_QUERY_STRING</b></dl> <dt>0x0800</dt> </dl> </td> <td width="60%"> Retrieves the query string
///                     as **lpszQueryString**. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_ALL"></a><a
///                     id="lup_return_all"></a><dl> <dt><b>LUP_RETURN_ALL</b></dl> <dt>0x0ff0</dt> </dl> </td> <td width="60%">
///                     Retrieves information including the name, type, version, comment, address, blob, aliases, and query string. </td>
///                     </tr> <tr> <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
///                     <dt><b>LUP_FLUSHCACHE</b></dl> <dt>0x1000</dt> </dl> </td> <td width="60%"> If the provider has cached
///                     information, ignore the cache and query the namespace itself. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl> <dt><b>LUP_FLUSHPREVIOUS</b></dl> <dt>0x2000</dt>
///                     </dl> </td> <td width="60%"> Used as a value for the <i>dwControlFlags</i> parameter in NSPv2LookupServiceNextEx.
///                     Setting this flag instructs the provider to discard the last result set, which was too large for the supplied
///                     buffer, and move on to the next result set. </td> </tr> <tr> <td width="40%"><a id="LUP_NON_AUTHORITATIVE"></a><a
///                     id="lup_non_authoritative"></a><dl> <dt><b>LUP_NON_AUTHORITATIVE</b></dl> <dt>0x4000</dt> </dl> </td> <td
///                     width="60%"> Indicates that the namespace provider should included non-authoritative results for names. </td>
///                     </tr> <tr> <td width="40%"><a id="LUP_RES_RESERVICE"></a><a id="lup_res_reservice"></a><dl>
///                     <dt><b>LUP_RES_RESERVICE</b></dl> <dt>0x8000</dt> </dl> </td> <td width="60%"> Indicates whether prime response
///                     is in the remote or local part of CSADDR_INFO structure. The other part must be usable in either case. This
///                     option applies only to service instance requests. </td> </tr> <tr> <td width="40%"><a id="LUP_SECURE"></a><a
///                     id="lup_secure"></a><dl> <dt><b>LUP_SECURE</b></dl> <dt>0x8000</dt> </dl> </td> <td width="60%"> Indicates that
///                     the namespace provider should use a secure query. This option only applies to name query requests. </td> </tr>
///                     <tr> <td width="40%"><a id="LUP_RETURN_PREFERRED_NAMES"></a><a id="lup_return_preferred_names"></a><dl>
///                     <dt><b>LUP_RETURN_PREFERRED_NAMES</b></dl> <dt>0x10000</dt> </dl> </td> <td width="60%"> Indicates that the
///                     namespace provider should return only preferred names. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_ADDRCONFIG"></a><a id="lup_addrconfig"></a><dl> <dt><b>LUP_ADDRCONFIG</b></dl> <dt>0x100000</dt> </dl>
///                     </td> <td width="60%"> Indicates that the namespace provider should return the address configuration. </td> </tr>
///                     <tr> <td width="40%"><a id="LUP_DUAL_ADDR"></a><a id="lup_dual_addr"></a><dl> <dt><b>LUP_DUAL_ADDR</b></dl>
///                     <dt>0x200000</dt> </dl> </td> <td width="60%"> Indicates that the namespace provider should return the dual
///                     addresses. This option only applies to dual-mode sockets (IPv6 and IPv4 mapped addresses). </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_DISABLE_IDN_ENCODING"></a><a id="lup_disable_idn_encoding"></a><dl>
///                     <dt><b>LUP_DISABLE_IDN_ENCODING</b></dl> <dt>0x800000</dt> </dl> </td> <td width="60%"> Indicates that the
///                     namespace provider should disable automatic International Domain Names encoding. This value is supported on
///                     Windows 8 and Windows Server 2012 </td> </tr> </table>
///    lpvClientSessionArg = A pointer to the client session.
///    lphLookup = A pointer to the handle to be used in subsequent calls to NSPv2LookupServiceNextEx in order to retrieve the
///                results set.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (that
///    is, 1) if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> One or more parameters were invalid, or missing, for this provider. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANO_DATA</b></dl> </dl> </td> <td width="60%"> The name was found in the database, but
///    it does not have the correct associated data that is resolved for. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSASERVICE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> The service is unknown. The service cannot be
///    found in the specified namespace. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl>
///    </dl> </td> <td width="60%"> There is not enough memory available to perform this operation. </td> </tr> </table>
///    
alias LPNSPV2LOOKUPSERVICEBEGIN = int function(GUID* lpProviderId, WSAQUERYSET2W* lpqsRestrictions, 
                                               uint dwControlFlags, void* lpvClientSessionArg, ptrdiff_t* lphLookup);
///The **NSPv2LookupServiceNextEx** function is called after obtaining a handle from a previous call to
///NSPv2LookupServiceBegin in order to retrieve the requested information from a namespace version-2 service provider.
///Params:
///    hAsyncCall = A handle returned from the previous call to NSPv2LookupServiceBegin used for asynchronous calls.
///    hLookup = A handle returned from the previous call to NSPv2LookupServiceBegin.
///    dwControlFlags = The flags used to control the next operation. Currently, only **LUP_FLUSHPREVIOUS** is defined as a means to
///                     handle a result set that is too large. If an application cannot supply a large enough buffer, setting
///                     **LUP_FLUSHPREVIOUS** instructs the provider to discard the last result set, which was too large, and move to the
///                     next set for this call.
///    lpdwBufferLength = The size, in bytes, on input, that is contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the
///                       function fails and the error is WSAEFAULT, then it contains the minimum size, in bytes to pass for the
///                       <i>lpqsResults</i> to retrieve the record.
///    lpqsResults = A pointer to a memory block that will contain, on return, one result set in a WSAQUERYSET2 structure.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (that
///    is, 1) if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_E_CANCELLED</b></dl> </dl> </td>
///    <td width="60%"> A call to NSPv2LookupServiceEnd was made while this call was still processing. The call has been
///    canceled. The data in the <i>lpqsResults</i> buffer is undefined. In Windows Sockets 2, conflicting error codes
///    are defined for **WSAECANCELLED** (10103) and **WSA_E_CANCELLED** (10111).The error code **WSAECANCELLED** will
///    be removed in a future version and only WSA_E_CANCELLED will remain. Namespace providers should use the
///    **WSA_E_CANCELLED** error code to maintain compatibility with the widest possible range of applications. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_E_NO_MORE</b></dl> </dl> </td> <td width="60%"> There is no more data
///    available. In Windows Sockets 2, conflicting error codes are defined for **WSAENOMORE** (10102) and
///    **WSA_E_NO_MORE** (10110).The error code **WSAENOMORE** will be removed in a future version and only
///    WSA_E_NO_MORE will remain. Namespace providers should use the **WSA_E_NO_MORE** error code to maintain
///    compatibility with the widest possible range of applications. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The <i>lpqsResults</i> buffer was too small to contain a
///    WSAQUERYSET set. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%">
///    One or more parameters are invalid, or missing, for this provider. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_INVALID_HANDLE</b></dl> </dl> </td> <td width="60%"> The specified lookup handle is invalid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dl> </dl> </td> <td width="60%"> The name was found in
///    the database, but no data, matching the given restrictions, was located. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSASERVICE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> The service is unknown. The service cannot be
///    found in the specified namespace. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl>
///    </dl> </td> <td width="60%"> There is not enough memory available to perform this operation. </td> </tr> </table>
///    
alias LPNSPV2LOOKUPSERVICENEXTEX = void function(HANDLE hAsyncCall, HANDLE hLookup, uint dwControlFlags, 
                                                 uint* lpdwBufferLength, WSAQUERYSET2W* lpqsResults);
///The **NSPv2LookupServiceEnd** function is called to free the handle after previous calls to NSPv2LookupServiceBegin
///and NSPv2LookupServiceNextEx.
///Params:
///    hLookup = The handle obtained previously by a call to NSPv2LookupServiceBegin.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (that
///    is, 1) if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dl> </dl>
///    </td> <td width="60%"> The handle is not valid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> There is not enough memory available to
///    perform this operation. </td> </tr> </table>
///    
alias LPNSPV2LOOKUPSERVICEEND = int function(HANDLE hLookup);
///The **NSPv2SetServiceEx** function registers or deregisters a name or service instance within a namespace of a
///namespace service provider version-2 (NSPv2) provider.
///Params:
///    hAsyncCall = A handle returned from the previous call to NSPv2LookupServiceBegin used for asynchronous calls.
///    lpProviderId = A pointer to the GUID of the specific namespace provider in which the name or service is registered.
///    lpqsRegInfo = The property information to be updated upon registration.
///    essOperation = The type of operation requested. This parameter can be one of the values from the **WSAESETSERVICEOP**
///                   enumeration type defined in the <i>Winsock2.h</i> header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr>
///                   <tr> <td width="40%"><a id="RNRSERVICE_REGISTER"></a><a id="rnrservice_register"></a><dl>
///                   <dt><b>RNRSERVICE_REGISTER</b></dl> <dt>0</dt> </dl> </td> <td width="60%"> Register the service. For the Service
///                   Advertising Protocol (SAP) namespace used within a NetWare environment, this means sending a periodic broadcast.
///                   This is an NOP for the Domain Name System (DNS) namespace. For persistent data stores this means updating the
///                   address information. </td> </tr> <tr> <td width="40%"><a id="RNRSERVICE_DEREGISTER"></a><a
///                   id="rnrservice_deregister"></a><dl> <dt><b>RNRSERVICE_DEREGISTER</b></dl> <dt>1</dt> </dl> </td> <td width="60%">
///                   Deregister the service. For the SAP namespace, this means stop sending the periodic broadcast. This is a NOP for
///                   the DNS namespace. For persistent data stores this means deleting address information. </td> </tr> <tr> <td
///                   width="40%"><a id="RNRSERVICE_DELETE"></a><a id="rnrservice_delete"></a><dl> <dt><b>RNRSERVICE_DELETE</b></dl>
///                   <dt>2</dt> </dl> </td> <td width="60%"> Delete the service from dynamic name and persistent spaces. For services
///                   represented by multiple CSADDR_INFO structures (using the SERVICE_MULTIPLE flag), only the supplied address will
///                   be deleted, and this must match exactly the corresponding **CSADDR_INFO** structure supplied when the service was
///                   registered. </td> </tr> </table>
///    dwControlFlags = A set of flags that controls the operation requested. The possible values for this parameter are defined in the
///                     <i>Winsock2.h</i> header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                     id="SERVICE_MULTIPLE"></a><a id="service_multiple"></a><dl> <dt><b>SERVICE_MULTIPLE</b></dl> <dt>0x00000001</dt>
///                     </dl> </td> <td width="60%"> Control the scope of the operation. When this value is set, the action is only
///                     performed on the given address set. A register operation does not invalidate existing addresses and a deregister
///                     operation only invalidates the given set of addresses. When this value is absent, service addresses are managed
///                     as a group. A register or deregister invalidates all existing addresses before adding the given address set.
///                     </td> </tr> </table>
///    lpvClientSessionArg = A pointer to the client session.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (that
///    is, 1) if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl>
///    </td> <td width="60%"> There is not enough memory available to perform this operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEACCES</b></dl> </dl> </td> <td width="60%"> The calling routine does not have
///    sufficient privileges to install the service. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl>
///    </dl> </td> <td width="60%"> One or more parameters were invalid, or missing, for this provider. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> The operation is not supported.
///    This error is returned if the namespace provider does not implement this function. This error can also be
///    returned if the specified <i>dwControlCode</i> is an unrecognized command. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSASERVICE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> Service is unknown. The service cannot be found
///    in the specified namespace. </td> </tr> </table>
///    
alias LPNSPV2SETSERVICEEX = void function(HANDLE hAsyncCall, GUID* lpProviderId, WSAQUERYSET2W* lpqsRegInfo, 
                                          WSAESETSERVICEOP essOperation, uint dwControlFlags, 
                                          void* lpvClientSessionArg);
///The **NSPv2ClientSessionRundown** function notifies a namespace service provider version-2 (NSPv2) provider that the
///client session is terminating.
///Params:
///    lpProviderId = A pointer to the GUID of the specific namespace provider to notify.
///    pvClientSessionArg = A pointer to the client session that is terminating.
///Returns:
///    The function should return **NO_ERROR** (zero) if the routine succeeds. It should return **SOCKET_ERROR** (that
///    is, 1) if the routine fails and it must set the appropriate error code using WSASetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl>
///    </td> <td width="60%"> There is not enough memory available to perform this operation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEACCES</b></dl> </dl> </td> <td width="60%"> The calling routine does not have
///    sufficient privileges to install the service. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl>
///    </dl> </td> <td width="60%"> One or more parameters were invalid, or missing, for this provider. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dl> </dl> </td> <td width="60%"> The operation is not supported.
///    This error is returned if the namespace provider does not implement this function. This error can also be
///    returned if the specified <i>dwControlCode</i> is an unrecognized command. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSASERVICE_NOT_FOUND</b></dl> </dl> </td> <td width="60%"> Service is unknown. The service cannot be found
///    in the specified namespace. </td> </tr> </table>
///    
alias LPNSPV2CLIENTSESSIONRUNDOWN = void function(GUID* lpProviderId, void* pvClientSessionArg);
alias LPFN_NSPAPI = uint function();
alias LPSERVICE_CALLBACK_PROC = void function(LPARAM lParam, HANDLE hAsyncTaskHandle);
alias LPLOOKUPSERVICE_COMPLETION_ROUTINE = void function(uint dwError, uint dwBytes, OVERLAPPED* lpOverlapped);
alias LPWSCWRITEPROVIDERORDER = int function(uint* lpwdCatalogEntryId, uint dwNumberOfEntries);
alias LPWSCWRITENAMESPACEORDER = int function(GUID* lpProviderId, uint dwNumberOfEntries);

// Structs


///The <b>BLOB</b> structure, derived from Binary Large Object, contains information about a block of data.
struct BLOB
{
    ///Size of the block of data pointed to by <b>pBlobData</b>, in bytes.
    uint   cbSize;
    ///Pointer to a block of data.
    ubyte* pBlobData;
}

alias HWSAEVENT = ptrdiff_t;

///The <b>in_addr</b> structure represents an IPv4 Internet address.
struct in_addr
{
    union S_un
    {
        struct S_un_b
        {
            ubyte s_b1;
            ubyte s_b2;
            ubyte s_b3;
            ubyte s_b4;
        }
        struct S_un_w
        {
            ushort s_w1;
            ushort s_w2;
        }
        uint S_addr;
    }
}

///The SOCKADDR structure is a generic structure that specifies a transport address.
struct SOCKADDR
{
    ///The address family for the transport address. For more information about supported address families, see WSK
    ///Address Families.
    ushort   sa_family;
    ///An array of 14 bytes that contains the transport address data.
    byte[14] sa_data;
}

///The <b>SOCKET_ADDRESS</b> structure stores protocol-specific address information.
struct SOCKET_ADDRESS
{
    ///A pointer to a socket address represented as a SOCKADDR structure.
    SOCKADDR* lpSockaddr;
    ///The length, in bytes, of the socket address.
    int       iSockaddrLength;
}

///The <b>CSADDR_INFO</b> structure contains Windows Sockets address information for a socket, network service, or
///namespace provider.
struct CSADDR_INFO
{
    ///Type: <b>SOCKET_ADDRESS</b> The Windows Sockets local address. In a client application, pass this address to the
    ///<b>bind</b> function to obtain access to a network service. In a network service, pass this address to the
    ///<b>bind</b> function so that the service is bound to the appropriate local address.
    SOCKET_ADDRESS LocalAddr;
    ///Type: <b>SOCKET_ADDRESS</b> Windows Sockets remote address. There are several uses for this remote address:<ul>
    ///<li>You can use this remote address to connect to the service through the connect function. This is useful if an
    ///application performs send/receive operations that involve connection-oriented protocols.</li> <li>You can use
    ///this remote address with the sendto function when you are communicating over a connectionless (datagram)
    ///protocol. If you are using a connectionless protocol, such as UDP, <b>sendto</b> is typically the way you pass
    ///data to the remote system.</li> </ul>
    SOCKET_ADDRESS RemoteAddr;
    ///Type: <b>INT</b> The type of Windows socket. Possible values for the socket type are defined in the
    ///<i>Winsock2.h</i> header file. The following table lists the possible values supported for Windows Sockets 2:
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCK_STREAM"></a><a
    ///id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> </dl> </td> <td width="60%"> A stream socket. This is a
    ///protocol that sends data as a stream of bytes, with no message boundaries. This socket type provides sequenced,
    ///reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket type uses
    ///the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6). </td> </tr> <tr>
    ///<td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> </dl> </td> <td
    ///width="60%"> A datagram socket. This socket type supports datagrams, which are connectionless, unreliable buffers
    ///of a fixed (typically small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the
    ///Internet address family (AF_INET or AF_INET6). Services use recvfrom function to obtain datagrams. The listen and
    ///accept functions do not work with datagrams. </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a
    ///id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt> </dl> </td> <td width="60%"> A reliable message datagram socket.
    ///This socket type preserves message boundaries in data. An example of this type is the Pragmatic General Multicast
    ///(PGM) multicast protocol implementation in Windows, often referred to as reliable multicast programming. </td>
    ///</tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
    ///<dt><b>SOCK_SEQPACKET</b></dt> </dl> </td> <td width="60%"> A sequenced packet stream socket. This socket type
    ///provides a pseudo-stream packet based on datagrams. </td> </tr> </table>
    int            iSocketType;
    ///Type: <b>INT</b> The protocol used. The possible options for the <i>protocol</i> parameter are specific to the
    ///address family and socket type specified. Possible values are defined in the <i>Winsock2.h</i> and <i>Wsrm.h</i>
    ///header files. On the Windows SDK released for Windows Vista and later, the organization of header files has
    ///changed and this parameter can be one of the values from the <b>IPPROTO</b> enumeration type defined in the
    ///<i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in
    ///<i>Winsock2.h</i>, and should never be used directly. The table below lists common values for the <i>protocol</i>
    ///although many other values are possible. <table> <tr> <th>protocol</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl>
    ///</td> <td width="60%"> The Transmission Control Protocol (TCP). This is a possible value when the address family
    ///is <b>AF_INET</b> or <b>AF_INET6</b> and the <b>iSocketType</b> member is <b>SOCK_STREAM</b>. </td> </tr> <tr>
    ///<td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt>
    ///</dl> </td> <td width="60%"> The User Datagram Protocol (UDP). This is a possible value when the address family
    ///is <b>AF_INET</b> or <b>AF_INET6</b> and the <b>iSocketType</b> member is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td
    ///width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl>
    ///</td> <td width="60%"> The PGM protocol for reliable multicast. This is a possible value when the address family
    ///is <b>AF_INET</b> and the <b>iSocketType</b> member is <b>SOCK_RDM</b>. On the Windows SDK released for Windows
    ///Vista and later, this value is also called <b>IPPROTO_PGM</b>. </td> </tr> </table>
    int            iProtocol;
}

///The SOCKADDR_STORAGE structure is a generic structure that specifies a transport address.
struct sockaddr_storage_xp
{
    ///The address family for the transport address. For more information about supported address families, see WSK
    ///Address Families.
    short     ss_family;
    ///A padding of 6 bytes that puts the <b>__ss_align</b> member on an eight-byte boundary within the structure.
    byte[6]   __ss_pad1;
    ///A 64-bit value that forces the structure to be 8-byte aligned.
    long      __ss_align;
    ///A padding of an additional 112 bytes that brings the total size of the SOCKADDR_STORAGE structure to 128 bytes.
    byte[112] __ss_pad2;
}

///The <b>SOCKET_PROCESSOR_AFFINITY</b> structure contains the association between a socket and an RSS processor core
///and NUMA node..
struct SOCKET_PROCESSOR_AFFINITY
{
    ///A structure to represent a system wide processor number. This PROCESSOR_NUMBER structure contains a group number
    ///and relative processor number within the group.
    PROCESSOR_NUMBER Processor;
    ///The NUMA node ID.
    ushort           NumaNodeId;
    ///A value reserved for future use.
    ushort           Reserved;
}

struct SCOPE_ID
{
    union
    {
        struct
        {
            uint _bitfield199;
        }
        uint Value;
    }
}

///The SOCKADDR_IN structure specifies a transport address and port for the AF_INET address family.
struct sockaddr_in
{
    ///The address family for the transport address. This member should always be set to AF_INET.
    ushort  sin_family;
    ///A transport protocol port number.
    ushort  sin_port;
    ///An IN_ADDR structure that contains an IPv4 transport address.
    in_addr sin_addr;
    ///Reserved for system use. A WSK application should set the contents of this array to zero.
    byte[8] sin_zero;
}

struct sockaddr_dl
{
    ushort   sdl_family;
    ubyte[8] sdl_data;
    ubyte[4] sdl_zero;
}

///The <b>WSABUF</b> structure enables the creation or manipulation of a data buffer used by some Winsock functions.
struct WSABUF
{
    ///The length of the buffer, in bytes.
    uint  len;
    byte* buf;
}

///The <b>WSAMSG</b> structure is used with the LPFN_WSARECVMSG (WSARecvMsg) and WSASendMsg functions to store address
///and optional control information about connected and unconnected sockets as well as an array of buffers used to store
///message data.
struct WSAMSG
{
    ///Type: <b>LPSOCKADDR</b> A pointer to a SOCKET_ADDRESS structure that stores information about the remote address.
    ///Used only with unconnected sockets.
    SOCKADDR* name;
    ///Type: <b>INT</b> The length, in bytes, of the SOCKET_ADDRESS structure pointed to in the <b>pAddr</b> member.
    ///Used only with unconnected sockets.
    int       namelen;
    ///Type: <b>LPWSABUF</b> An array of WSABUF structures used to receive the message data. The capability of the
    ///<b>lpBuffers</b> member to contain multiple buffers enables the use of scatter/gather I/O.
    WSABUF*   lpBuffers;
    ///Type: <b>DWORD</b> The number of buffers pointed to in the <b>lpBuffers</b> member.
    uint      dwBufferCount;
    ///Type: <b>WSABUF</b> A structure of WSABUF type used to specify optional control data. See Remarks.
    WSABUF    Control;
    ///Type: <b>DWORD</b> One or more control flags, specified as the logical <b>OR</b> of values. The possible values
    ///for <b>dwFlags</b> member on input are defined in the Winsock2.h header file. The possible values for
    ///<b>dwFlags</b> member on output are defined in the Ws2def.h header file which is automatically included by the
    ///Winsock2.h header file. <table> <tr> <th>Flags on input</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="MSG_PEEK"></a><a id="msg_peek"></a><dl> <dt><b>MSG_PEEK</b></dt> </dl> </td> <td width="60%"> Peek at the
    ///incoming data. The data is copied into the buffer, but is not removed from the input queue. This flag is valid
    ///only for non-overlapped sockets. </td> </tr> </table> <table> <tr> <th>Flag returned</th> <th>Meaning</th> </tr>
    ///<tr> <td width="40%"><a id="MSG_BCAST"></a><a id="msg_bcast"></a><dl> <dt><b>MSG_BCAST</b></dt> </dl> </td> <td
    ///width="60%"> The datagram was received as a link-layer broadcast or with a destination IP address that is a
    ///broadcast address. </td> </tr> <tr> <td width="40%"><a id="MSG_MCAST"></a><a id="msg_mcast"></a><dl>
    ///<dt><b>MSG_MCAST</b></dt> </dl> </td> <td width="60%"> The datagram was received with a destination IP address
    ///that is a multicast address. </td> </tr> <tr> <td width="40%"><a id="MSG_TRUNC"></a><a id="msg_trunc"></a><dl>
    ///<dt><b>MSG_TRUNC</b></dt> </dl> </td> <td width="60%"> The datagram was truncated. More data was present than the
    ///process allocated room for. </td> </tr> <tr> <td width="40%"><a id="MSG_CTRUNC"></a><a id="msg_ctrunc"></a><dl>
    ///<dt><b>MSG_CTRUNC</b></dt> </dl> </td> <td width="60%"> The control (ancillary) data was truncated. More control
    ///data was present than the process allocated room for. </td> </tr> </table>
    uint      dwFlags;
}

struct cmsghdr
{
    size_t cmsg_len;
    int    cmsg_level;
    int    cmsg_type;
}

///The <b>addrinfo</b> structure is used by the getaddrinfo function to hold host address information.
struct ADDRINFOA
{
    ///Type: <b>int</b> Flags that indicate options used in the getaddrinfo function. Supported values for the
    ///<b>ai_flags</b> member are defined in the <i>Ws2def.h</i> header file on the Windows SDK for Windows 7 and later.
    ///These values are defined in the <i>Ws2tcpip.h</i> header file on the Windows SDK for Windows Server 2008 and
    ///Windows Vista. These values are defined in the <i>Ws2tcpip.h</i> header file on the Platform SDK for Windows
    ///Server 2003, and Windows XP. Supported values for the <b>ai_flags</b> member can be a combination of the
    ///following options. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="AI_PASSIVE"></a><a id="ai_passive"></a><dl> <dt><b>AI_PASSIVE</b></dt> <dt>0x01</dt> </dl> </td> <td
    ///width="60%"> The socket address will be used in a call to the bindfunction. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_CANONNAME"></a><a id="ai_canonname"></a><dl> <dt><b>AI_CANONNAME</b></dt> <dt>0x02</dt> </dl> </td> <td
    ///width="60%"> The canonical name is returned in the first <b>ai_canonname</b> member. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_NUMERICHOST"></a><a id="ai_numerichost"></a><dl> <dt><b>AI_NUMERICHOST</b></dt>
    ///<dt>0x04</dt> </dl> </td> <td width="60%"> The <i>nodename</i> parameter passed to the getaddrinfo function must
    ///be a numeric string. </td> </tr> <tr> <td width="40%"><a id="AI_ALL"></a><a id="ai_all"></a><dl>
    ///<dt><b>AI_ALL</b></dt> <dt>0x0100</dt> </dl> </td> <td width="60%"> If this bit is set, a request is made for
    ///IPv6 addresses and IPv4 addresses with <b>AI_V4MAPPED</b>. This option is supported on Windows Vista and later.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_ADDRCONFIG"></a><a id="ai_addrconfig"></a><dl>
    ///<dt><b>AI_ADDRCONFIG</b></dt> <dt>0x0400</dt> </dl> </td> <td width="60%"> The getaddrinfo will resolve only if a
    ///global address is configured. The IPv6 and IPv4 loopback address is not considered a valid global address. This
    ///option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="AI_V4MAPPED"></a><a
    ///id="ai_v4mapped"></a><dl> <dt><b>AI_V4MAPPED</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> If the
    ///getaddrinfo request for IPv6 addresses fails, a name service request is made for IPv4 addresses and these
    ///addresses are converted to IPv4-mapped IPv6 address format. This option is supported on Windows Vista and later.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_NON_AUTHORITATIVE"></a><a id="ai_non_authoritative"></a><dl>
    ///<dt><b>AI_NON_AUTHORITATIVE</b></dt> <dt>0x04000</dt> </dl> </td> <td width="60%"> The address information can be
    ///from a non-authoritative namespace provider. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_SECURE"></a><a id="ai_secure"></a><dl>
    ///<dt><b>AI_SECURE</b></dt> <dt>0x08000</dt> </dl> </td> <td width="60%"> The address information is from a secure
    ///channel. This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace. </td> </tr>
    ///<tr> <td width="40%"><a id="AI_RETURN_PREFERRED_NAMES"></a><a id="ai_return_preferred_names"></a><dl>
    ///<dt><b>AI_RETURN_PREFERRED_NAMES</b></dt> <dt>0x010000</dt> </dl> </td> <td width="60%"> The address information
    ///is for a preferred name for a user. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_FQDN"></a><a id="ai_fqdn"></a><dl>
    ///<dt><b>AI_FQDN</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> If a flat name (single label) is
    ///specified, getaddrinfo will return the fully qualified domain name that the name eventually resolved to. The
    ///fully qualified domain name is returned in the <b>ai_canonname</b> member. This is different than
    ///<b>AI_CANONNAME</b> bit flag that returns the canonical name registered in DNS which may be different than the
    ///fully qualified domain name that the flat name resolved to. Only one of the <b>AI_FQDN</b> and
    ///<b>AI_CANONNAME</b> bits can be set. The getaddrinfo function will fail if both flags are present with
    ///<b>EAI_BADFLAGS</b>. This option is supported on Windows 7, Windows Server 2008 R2, and later. </td> </tr> <tr>
    ///<td width="40%"><a id="AI_FILESERVER"></a><a id="ai_fileserver"></a><dl> <dt><b>AI_FILESERVER</b></dt>
    ///<dt>0x00040000</dt> </dl> </td> <td width="60%"> A hint to the namespace provider that the hostname being queried
    ///is being used in a file share scenario. The namespace provider may ignore this hint. This option is supported on
    ///Windows 7, Windows Server 2008 R2, and later. </td> </tr> </table>
    int        ai_flags;
    ///Type: <b>int</b> The address family. Possible values for the address family are defined in the <i>Winsock2.h</i>
    ///header file. On the Windows SDK released for Windows Vista and later, the organization of header files has
    ///changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that
    ///the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
    ///directly. The values currently supported are <b>AF_INET</b> or <b>AF_INET6</b>, which are the Internet address
    ///family formats for IPv4 and IPv6. Other options for address family (<b>AF_NETBIOS</b> for use with NetBIOS, for
    ///example) are supported if a Windows Sockets service provider for the address family is installed. Note that the
    ///values for the AF_ address family and PF_ protocol family constants are identical (for example, <b>AF_UNSPEC</b>
    ///and <b>PF_UNSPEC</b>), so either constant can be used. The following table lists common values for the address
    ///family although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td> <td
    ///width="60%"> The address family is unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a
    ///id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a
    ///id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address
    ///family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed. </td> </tr>
    ///<tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl>
    ///</td> <td width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
    ///Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
    ///infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
    ///<dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
    ///is only supported if a Bluetooth adapter is installed on Windows Server 2003 or later. </td> </tr> </table>
    int        ai_family;
    ///Type: <b>int</b> The socket type. Possible values for the socket type are defined in the <i>Winsock2.h</i> header
    ///file. The following table lists the possible values for the socket type supported for Windows Sockets 2: <table>
    ///<tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCK_STREAM"></a><a
    ///id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Provides sequenced,
    ///reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. Uses the Transmission
    ///Control Protocol (TCP) for the Internet address family (<b>AF_INET</b> or <b>AF_INET6</b>). If the
    ///<b>ai_family</b> member is <b>AF_IRDA</b>, then <b>SOCK_STREAM</b> is the only supported socket type. </td> </tr>
    ///<tr> <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt>
    ///</dl> </td> <td width="60%"> Supports datagrams, which are connectionless, unreliable buffers of a fixed
    ///(typically small) maximum length. Uses the User Datagram Protocol (UDP) for the Internet address family
    ///(<b>AF_INET</b> or <b>AF_INET6</b>). </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a
    ///id="sock_raw"></a><dl> <dt><b>SOCK_RAW</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Provides a raw socket
    ///that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the
    ///IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option
    ///must be set on the socket. </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
    ///<dt><b>SOCK_RDM</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Provides a reliable message datagram. An example
    ///of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often
    ///referred to as reliable multicast programming. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a
    ///id="sock_seqpacket"></a><dl> <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
    ///introduced. An application can dynamically discover the attributes of each available transport protocol through
    ///the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
    ///an address family and use this information when specifying this parameter. Socket type definitions in the
    ///<i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
    ///families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are
    ///<b>SOCK_DATAGRAM</b> and <b>SOCK_STREAM</b>.
    int        ai_socktype;
    ///Type: <b>int</b> The protocol type. The possible options are specific to the address family and socket type
    ///specified. Possible values for the <b>ai_protocol</b> are defined in the <i>Winsock2.h</i> and <i>Wsrm.h</i>
    ///header files. On the Windows SDK released for Windows Vista and later, the organization of header files has
    ///changed and this member can be one of the values from the <b>IPPROTO</b> enumeration type defined in the
    ///<i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in
    ///<i>Winsock2.h</i>, and should never be used directly. If a value of 0 is specified for <b>ai_protocol</b>, the
    ///caller does not wish to specify a protocol and the service provider will choose the <b>ai_protocol</b> to use.
    ///For protocols other than IPv4 and IPv6, set <b>ai_protocol</b> to zero. The following table lists common values
    ///for the <b>ai_protocol</b> member although many other values are possible. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
    ///<dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The Transmission Control Protocol (TCP). This
    ///is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_STREAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_UDP"></a><a
    ///id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The User Datagram
    ///Protocol (UDP). This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b>
    ///and the <i>type</i> parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a
    ///id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol
    ///for reliable multicast. This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later, this value
    ///is also called <b>IPPROTO_PGM</b>. </td> </tr> </table> If the <b>ai_family</b> member is <b>AF_IRDA</b>, then
    ///the <b>ai_protocol</b> must be 0.
    int        ai_protocol;
    ///Type: <b>size_t</b> The length, in bytes, of the buffer pointed to by the <b>ai_addr</b> member.
    size_t     ai_addrlen;
    ///Type: <b>char*</b> The canonical name for the host.
    byte*      ai_canonname;
    ///Type: <b>struct sockaddr*</b> A pointer to a sockaddr structure. The <b>ai_addr</b> member in each returned
    ///<b>addrinfo</b> structure points to a filled-in socket address structure. The length, in bytes, of each returned
    ///<b>addrinfo</b> structure is specified in the <b>ai_addrlen</b> member.
    SOCKADDR*  ai_addr;
    ///Type: <b>struct addrinfo*</b> A pointer to the next structure in a linked list. This parameter is set to
    ///<b>NULL</b> in the last <b>addrinfo</b> structure of a linked list.
    ADDRINFOA* ai_next;
}

///The <b>addrinfoW</b> structure is used by the GetAddrInfoW function to hold host address information.
struct addrinfoW
{
    ///Type: <b>int</b> Flags that indicate options used in the GetAddrInfoW function. Supported values for the
    ///<b>ai_flags</b> member are defined in the <i>Winsock2.h</i> header file and can be a combination of the options
    ///listed in the following table. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="AI_PASSIVE"></a><a id="ai_passive"></a><dl> <dt><b>AI_PASSIVE</b></dt> <dt>0x01</dt> </dl> </td> <td
    ///width="60%"> The socket address will be used in a call to the bindfunction. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_CANONNAME"></a><a id="ai_canonname"></a><dl> <dt><b>AI_CANONNAME</b></dt> <dt>0x02</dt> </dl> </td> <td
    ///width="60%"> The canonical name is returned in the first <b>ai_canonname</b> member. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_NUMERICHOST"></a><a id="ai_numerichost"></a><dl> <dt><b>AI_NUMERICHOST</b></dt>
    ///<dt>0x04</dt> </dl> </td> <td width="60%"> The <i>nodename</i> parameter passed to the GetAddrInfoW function must
    ///be a numeric string. </td> </tr> <tr> <td width="40%"><a id="AI_ALL"></a><a id="ai_all"></a><dl>
    ///<dt><b>AI_ALL</b></dt> <dt>0x0100</dt> </dl> </td> <td width="60%"> If this bit is set, a request is made for
    ///IPv6 addresses and IPv4 addresses with <b>AI_V4MAPPED</b>. This option is supported on Windows Vista and later.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_ADDRCONFIG"></a><a id="ai_addrconfig"></a><dl>
    ///<dt><b>AI_ADDRCONFIG</b></dt> <dt>0x0400</dt> </dl> </td> <td width="60%"> The GetAddrInfoW will resolve only if
    ///a global address is configured. The IPv6 and IPv4 loopback address is not considered a valid global address. This
    ///option is only supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="AI_V4MAPPED"></a><a
    ///id="ai_v4mapped"></a><dl> <dt><b>AI_V4MAPPED</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> If the
    ///GetAddrInfoW request for an IPv6 addresses fails, a name service request is made for IPv4 addresses and these
    ///addresses are converted to IPv4-mapped IPv6 address format. This option is supported on Windows Vista and later.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_NON_AUTHORITATIVE"></a><a id="ai_non_authoritative"></a><dl>
    ///<dt><b>AI_NON_AUTHORITATIVE</b></dt> <dt>0x04000</dt> </dl> </td> <td width="60%"> The address information can be
    ///from a non-authoritative namespace provider. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_SECURE"></a><a id="ai_secure"></a><dl>
    ///<dt><b>AI_SECURE</b></dt> <dt>0x08000</dt> </dl> </td> <td width="60%"> The address information is from a secure
    ///channel. This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace. </td> </tr>
    ///<tr> <td width="40%"><a id="AI_RETURN_PREFERRED_NAMES"></a><a id="ai_return_preferred_names"></a><dl>
    ///<dt><b>AI_RETURN_PREFERRED_NAMES</b></dt> <dt>0x010000</dt> </dl> </td> <td width="60%"> The address information
    ///is for a preferred name for a user. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_FQDN"></a><a id="ai_fqdn"></a><dl>
    ///<dt><b>AI_FQDN</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%"> If a flat name (single label) is
    ///specified, GetAddrInfoW will return the fully qualified domain name that the name eventually resolved to. The
    ///fully qualified domain name is returned in the <b>ai_canonname</b> member. This is different than
    ///<b>AI_CANONNAME</b> bit flag that returns the canonical name registered in DNS which may be different than the
    ///fully qualified domain name that the flat name resolved to. Only one of the <b>AI_FQDN</b> and
    ///<b>AI_CANONNAME</b> bits can be set. The GetAddrInfoW function will fail if both flags are present with
    ///<b>EAI_BADFLAGS</b>. This option is supported on Windows 7, Windows Server 2008 R2, and later. </td> </tr> <tr>
    ///<td width="40%"><a id="AI_FILESERVER"></a><a id="ai_fileserver"></a><dl> <dt><b>AI_FILESERVER</b></dt>
    ///<dt>0x00040000</dt> </dl> </td> <td width="60%"> A hint to the namespace provider that the hostname being queried
    ///is being used in a file share scenario. The namespace provider may ignore this hint. This option is supported on
    ///Windows 7, Windows Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_DISABLE_IDN_ENCODING"></a><a id="ai_disable_idn_encoding"></a><dl> <dt><b>AI_DISABLE_IDN_ENCODING</b></dt>
    ///<dt>0x00080000</dt> </dl> </td> <td width="60%"> Disable the automatic International Domain Name encoding using
    ///Punycode in the name resolution functions called by the GetAddrInfoW function. This option is supported on
    ///Windows 8, Windows Server 2012, and later. </td> </tr> </table>
    int           ai_flags;
    ///Type: <b>int</b> The address family. Possible values for the address family are defined in the <i>Winsock2.h</i>
    ///header file. On the Windows SDK released for Windows Vista and later,, the organization of header files has
    ///changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that
    ///the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
    ///directly. The values currently supported are <b>AF_INET</b> or <b>AF_INET6</b>, which are the Internet address
    ///family formats for IPv4 and IPv6. Other options for address family (<b>AF_NETBIOS</b> for use with NetBIOS, for
    ///example) are supported if a Windows Sockets service provider for the address family is installed. Note that the
    ///values for the AF_ address family and PF_ protocol family constants are identical (for example, <b>AF_UNSPEC</b>
    ///and <b>PF_UNSPEC</b>), so either constant can be used. The following table lists common values for the address
    ///family although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td> <td
    ///width="60%"> The address family is unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a
    ///id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a
    ///id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address
    ///family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed. </td> </tr>
    ///<tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl>
    ///</td> <td width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
    ///Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
    ///infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
    ///<dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
    ///is only supported if a Bluetooth adapter is installed on Windows Server 2003 or later. </td> </tr> </table>
    int           ai_family;
    ///Type: <b>int</b> The socket type. Possible values for the socket type are defined in the <i>Winsock2.h</i>
    ///include file. The following table lists the possible values for the socket type supported for Windows Sockets 2.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCK_STREAM"></a><a
    ///id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Provides sequenced,
    ///reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. Uses the Transmission
    ///Control Protocol (TCP) for the Internet address family (<b>AF_INET</b> or <b>AF_INET6</b>). If the
    ///<b>ai_family</b> member is <b>AF_IRDA</b>, then <b>SOCK_STREAM</b> is the only supported socket type. </td> </tr>
    ///<tr> <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt>
    ///</dl> </td> <td width="60%"> Supports datagrams, which are connectionless, unreliable buffers of a fixed
    ///(typically small) maximum length. Uses the User Datagram Protocol (UDP) for the Internet address family
    ///(<b>AF_INET</b> or <b>AF_INET6</b>). </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a
    ///id="sock_raw"></a><dl> <dt><b>SOCK_RAW</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Provides a raw socket
    ///that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the
    ///IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option
    ///must be set on the socket. </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
    ///<dt><b>SOCK_RDM</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Provides a reliable message datagram. An example
    ///of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often
    ///referred to as reliable multicast programming. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a
    ///id="sock_seqpacket"></a><dl> <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
    ///introduced. An application can dynamically discover the attributes of each available transport protocol through
    ///the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
    ///an address family and use this information when specifying this parameter. Socket type definitions in the
    ///<i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
    ///families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are
    ///<b>SOCK_DATAGRAM</b> and <b>SOCK_STREAM</b>.
    int           ai_socktype;
    ///Type: <b>int</b> The protocol type. The possible options are specific to the address family and socket type
    ///specified. Possible values for the <b>ai_protocol</b> are defined in <i>Winsock2.h</i> and the <i>Wsrm.h</i>
    ///header files. On the Windows SDK released for Windows Vista and later,, the organization of header files has
    ///changed and this member can be one of the values from the <b>IPPROTO</b> enumeration type defined in the
    ///<i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in
    ///<i>Winsock2.h</i>, and should never be used directly. If a value of 0 is specified for <b>ai_protocol</b>, the
    ///caller does not wish to specify a protocol and the service provider will choose the <b>ai_protocol</b> to use.
    ///For protocols other than IPv4 and IPv6, set <b>ai_protocol</b> to zero. The following table lists common values
    ///for the <b>ai_protocol</b> member although many other values are possible. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
    ///<dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The Transmission Control Protocol (TCP). This
    ///is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_STREAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_UDP"></a><a
    ///id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The User Datagram
    ///Protocol (UDP). This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b>
    ///and the <i>type</i> parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a
    ///id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol
    ///for reliable multicast. This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later, this value
    ///is also called <b>IPPROTO_PGM</b>. </td> </tr> </table> If the <b>ai_family</b> member is <b>AF_IRDA</b>, then
    ///the <b>ai_protocol</b> must be 0.
    int           ai_protocol;
    ///Type: <b>size_t</b> The length, in bytes, of the buffer pointed to by the <b>ai_addr</b> member.
    size_t        ai_addrlen;
    ///Type: <b>PWSTR</b> The canonical name for the host.
    const(wchar)* ai_canonname;
    ///Type: <b>struct sockaddr*</b> A pointer to a sockaddr structure. The <b>ai_addr</b> member in each returned
    ///ADDRINFOW structure points to a filled-in socket address structure. The length, in bytes, of each returned
    ///<b>ADDRINFOW</b> structure is specified in the <b>ai_addrlen</b> member.
    SOCKADDR*     ai_addr;
    ///Type: <b>struct addrinfoW*</b> A pointer to the next structure in a linked list. This parameter is set to
    ///<b>NULL</b> in the last <b>addrinfoW</b> structure of a linked list.
    addrinfoW*    ai_next;
}

///The <b>addrinfoex</b> structure is used by the GetAddrInfoEx function to hold host address information.
struct addrinfoexA
{
    ///Type: <b>int</b> Flags that indicate options used in the GetAddrInfoEx function. Supported values for the
    ///<b>ai_flags</b> member are defined in the <i>Winsock2.h</i> include file and can be a combination of the
    ///following options. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="AI_PASSIVE"></a><a id="ai_passive"></a><dl> <dt><b>AI_PASSIVE</b></dt> <dt>0x01</dt> </dl> </td> <td
    ///width="60%"> The socket address will be used in a call to the bindfunction. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_CANONNAME"></a><a id="ai_canonname"></a><dl> <dt><b>AI_CANONNAME</b></dt> <dt>0x02</dt> </dl> </td> <td
    ///width="60%"> The canonical name is returned in the first <b>ai_canonname</b> member. When both the
    ///<b>AI_CANONNAME</b> and <b>AI_FQDN</b> bits are set, an addrinfoex2 structure is returned not the
    ///<b>addrinfoex</b> structure. </td> </tr> <tr> <td width="40%"><a id="AI_NUMERICHOST"></a><a
    ///id="ai_numerichost"></a><dl> <dt><b>AI_NUMERICHOST</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> The
    ///<i>nodename</i> parameter passed to the GetAddrInfoEx function must be a numeric string. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_ALL"></a><a id="ai_all"></a><dl> <dt><b>AI_ALL</b></dt> <dt>0x0100</dt> </dl> </td> <td
    ///width="60%"> If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with <b>AI_V4MAPPED</b>.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_ADDRCONFIG"></a><a id="ai_addrconfig"></a><dl> <dt><b>AI_ADDRCONFIG</b></dt> <dt>0x0400</dt> </dl> </td>
    ///<td width="60%"> The GetAddrInfoEx will resolve only if a global address is configured. The IPv6 and IPv4
    ///loopback address is not considered a valid global address. This option is only supported on Windows Vista and
    ///later. </td> </tr> <tr> <td width="40%"><a id="AI_V4MAPPED"></a><a id="ai_v4mapped"></a><dl>
    ///<dt><b>AI_V4MAPPED</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> If the GetAddrInfoEx request for an IPv6
    ///addresses fails, a name service request is made for IPv4 addresses and these addresses are converted to
    ///IPv4-mapped IPv6 address format. This option is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_NON_AUTHORITATIVE"></a><a id="ai_non_authoritative"></a><dl>
    ///<dt><b>AI_NON_AUTHORITATIVE</b></dt> <dt>0x04000</dt> </dl> </td> <td width="60%"> The address information is
    ///from non-authoritative results. When this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, the
    ///<b>NS_EMAIL</b> namespace provider returns both authoritative and non-authoritative results. If this option is
    ///not set, then only authoritative results are returned. In the <i>ppResults</i> parameter returned by
    ///GetAddrInfoEx, this flag is set in the <b>ai_flags</b> member of the <b>addrinfoex</b> structure for
    ///non-authoritative results. This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b>
    ///namespace. </td> </tr> <tr> <td width="40%"><a id="AI_SECURE"></a><a id="ai_secure"></a><dl>
    ///<dt><b>AI_SECURE</b></dt> <dt>0x08000</dt> </dl> </td> <td width="60%"> The address information is from a secure
    ///channel. If the <b>AI_SECURE</b> bit is set, the <b>NS_EMAIL</b> namespace provider will return results that were
    ///obtained with enhanced security to minimize possible spoofing. When this option is set in the <i>pHints</i>
    ///parameter of GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider returns only results that were obtained with
    ///enhanced security to minimize possible spoofing. In the <i>ppResults</i> parameter returned by GetAddrInfoEx,
    ///this flag is set in the <b>ai_flags</b> member of the <b>addrinfoex</b> structure for results returned with
    ///enhanced security to minimize possible spoofing. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_RETURN_PREFERRED_NAMES"></a><a
    ///id="ai_return_preferred_names"></a><dl> <dt><b>AI_RETURN_PREFERRED_NAMES</b></dt> <dt>0x010000</dt> </dl> </td>
    ///<td width="60%"> The address information is for a preferred names for publication with a specific namespace. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, no name should be provided in the
    ///<i>pName</i> parameter and the <b>NS_EMAIL</b> namespace provider will return preferred names for publication. In
    ///the <i>ppResults</i> parameter returned by GetAddrInfoEx, this flag is set in the <b>ai_flags</b> member of the
    ///<b>addrinfoex</b> structure for results returned for preferred names for publication. This option is only
    ///supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_FQDN"></a><a id="ai_fqdn"></a><dl> <dt><b>AI_FQDN</b></dt> <dt>0x00020000</dt> </dl> </td> <td
    ///width="60%"> The fully qualified domain name is returned in the first <b>ai_canonicalname</b> member. When this
    ///option is set in the <i>pHints</i> parameter of GetAddrInfoEx and a flat name (single label) is specified in the
    ///<i>pName</i> parameter, the fully qualified domain name that the name eventually resolved to will be returned.
    ///When both the <b>AI_CANONNAME</b> and <b>AI_FQDN</b> bits are set, an addrinfoex2 structure is returned not the
    ///<b>addrinfoex</b> structure. This option is supported on Windows 7, Windows Server 2008 R2, and later. </td>
    ///</tr> <tr> <td width="40%"><a id="AI_FILESERVER"></a><a id="ai_fileserver"></a><dl> <dt><b>AI_FILESERVER</b></dt>
    ///<dt>0x00040000</dt> </dl> </td> <td width="60%"> A hint to the namespace provider that the hostname being queried
    ///is being used in a file share scenario. The namespace provider may ignore this hint. This option is supported on
    ///Windows 7, Windows Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_DISABLE_IDN_ENCODING"></a><a id="ai_disable_idn_encoding"></a><dl> <dt><b>AI_DISABLE_IDN_ENCODING</b></dt>
    ///<dt>0x00080000</dt> </dl> </td> <td width="60%"> Disable the automatic International Domain Name encoding using
    ///Punycode in the name resolution functions called by the GetAddrInfoEx function. This option is supported on
    ///Windows 8, Windows Server 2012, and later. </td> </tr> </table>
    int          ai_flags;
    ///Type: <b>int</b> The address family. Possible values for the address family are defined in the <i>Winsock2.h</i>
    ///include file. On the Windows SDK released for Windows Vista and later,, the organization of header files has
    ///changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that
    ///the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
    ///directly. The values currently supported are <b>AF_INET</b> or <b>AF_INET6</b>, which are the Internet address
    ///family formats for IPv4 and IPv6. Other options for address family (<b>AF_NETBIOS</b> for use with NetBIOS, for
    ///example) are supported if a Windows Sockets service provider for the address family is installed. Note that the
    ///values for the AF_ address family and PF_ protocol family constants are identical (for example, <b>AF_UNSPEC</b>
    ///and <b>PF_UNSPEC</b>), so either constant can be used. The table below lists common values for the address family
    ///although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td> <td
    ///width="60%"> The address family is unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a
    ///id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a
    ///id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address
    ///family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed. </td> </tr>
    ///<tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl>
    ///</td> <td width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
    ///Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
    ///infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
    ///<dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
    ///is only supported if a Bluetooth adapter is installed on Windows Server 2003 or later. </td> </tr> </table>
    int          ai_family;
    ///Type: <b>int</b> The socket type. Possible values for the socket type are defined in the <i>Winsock2.h</i>
    ///include file. The following table lists the possible values for the socket type supported for Windows Sockets 2:
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCK_STREAM"></a><a
    ///id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Provides sequenced,
    ///reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. Uses the Transmission
    ///Control Protocol (TCP) for the Internet address family (<b>AF_INET</b> or <b>AF_INET6</b>). If the
    ///<b>ai_family</b> member is <b>AF_IRDA</b>, then <b>SOCK_STREAM</b> is the only supported socket type. </td> </tr>
    ///<tr> <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt>
    ///</dl> </td> <td width="60%"> Supports datagrams, which are connectionless, unreliable buffers of a fixed
    ///(typically small) maximum length. Uses the User Datagram Protocol (UDP) for the Internet address family
    ///(<b>AF_INET</b> or <b>AF_INET6</b>). </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a
    ///id="sock_raw"></a><dl> <dt><b>SOCK_RAW</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Provides a raw socket
    ///that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the
    ///IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option
    ///must be set on the socket. </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
    ///<dt><b>SOCK_RDM</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Provides a reliable message datagram. An example
    ///of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often
    ///referred to as reliable multicast programming. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a
    ///id="sock_seqpacket"></a><dl> <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
    ///introduced. An application can dynamically discover the attributes of each available transport protocol through
    ///the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
    ///an address family and use this information when specifying this parameter. Socket type definitions in the
    ///<i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
    ///families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are
    ///<b>SOCK_DATAGRAM</b> and <b>SOCK_STREAM</b>.
    int          ai_socktype;
    ///Type: <b>int</b> The protocol type. The possible options are specific to the address family and socket type
    ///specified. Possible values for the <b>ai_protocol</b> are defined in <i>Winsock2.h</i> and the <i>Wsrm.h</i>
    ///header files. On the Windows SDK released for Windows Vista and later,, the organization of header files has
    ///changed and this member can be one of the values from the <b>IPPROTO</b> enumeration type defined in the
    ///<i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in
    ///<i>Winsock2.h</i>, and should never be used directly. If a value of 0 is specified for <b>ai_protocol</b>, the
    ///caller does not wish to specify a protocol and the service provider will choose the <b>ai_protocol</b> to use.
    ///For protocols other than IPv4 and IPv6, set <b>ai_protocol</b> to zero. The following table lists common values
    ///for the <b>ai_protocol</b> member although many other values are possible. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
    ///<dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The Transmission Control Protocol (TCP). This
    ///is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_STREAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_UDP"></a><a
    ///id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The User Datagram
    ///Protocol (UDP). This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b>
    ///and the <i>type</i> parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a
    ///id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol
    ///for reliable multicast. This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later, this value
    ///is also called <b>IPPROTO_PGM</b>. </td> </tr> </table> If the <b>ai_family</b> member is <b>AF_IRDA</b>, then
    ///the <b>ai_protocol</b> must be 0.
    int          ai_protocol;
    ///Type: <b>size_t</b> The length, in bytes, of the buffer pointed to by the <b>ai_addr</b> member.
    size_t       ai_addrlen;
    ///Type: <b>PCTSTR</b> The canonical name for the host.
    byte*        ai_canonname;
    ///Type: <b>struct sockaddr*</b> A pointer to a sockaddr structure. The <b>ai_addr</b> member in each returned
    ///<b>addrinfoex</b> structure points to a filled-in socket address structure. The length, in bytes, of each
    ///returned <b>addrinfoex</b> structure is specified in the <b>ai_addrlen</b> member.
    SOCKADDR*    ai_addr;
    ///Type: <b>void*</b> A pointer to data that is used to return provider-specific namespace information that is
    ///associated with the name beyond a list of addresses. The length, in bytes, of the buffer pointed to by
    ///<b>ai_blob</b> must be specified in the <b>ai_bloblen</b> member.
    void*        ai_blob;
    ///Type: <b>size_t</b> The length, in bytes, of the <b>ai_blob</b> member.
    size_t       ai_bloblen;
    ///Type: <b>LPGUID</b> A pointer to the GUID of a specific namespace provider.
    GUID*        ai_provider;
    ///Type: <b>struct addrinfoex*</b> A pointer to the next structure in a linked list. This parameter is set to
    ///<b>NULL</b> in the last <b>addrinfoex</b> structure of a linked list.
    addrinfoexA* ai_next;
}

///The <b>addrinfoex</b> structure is used by the GetAddrInfoEx function to hold host address information.
struct addrinfoexW
{
    ///Type: <b>int</b> Flags that indicate options used in the GetAddrInfoEx function. Supported values for the
    ///<b>ai_flags</b> member are defined in the <i>Winsock2.h</i> include file and can be a combination of the
    ///following options. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="AI_PASSIVE"></a><a id="ai_passive"></a><dl> <dt><b>AI_PASSIVE</b></dt> <dt>0x01</dt> </dl> </td> <td
    ///width="60%"> The socket address will be used in a call to the bindfunction. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_CANONNAME"></a><a id="ai_canonname"></a><dl> <dt><b>AI_CANONNAME</b></dt> <dt>0x02</dt> </dl> </td> <td
    ///width="60%"> The canonical name is returned in the first <b>ai_canonname</b> member. When both the
    ///<b>AI_CANONNAME</b> and <b>AI_FQDN</b> bits are set, an addrinfoex2 structure is returned not the
    ///<b>addrinfoex</b> structure. </td> </tr> <tr> <td width="40%"><a id="AI_NUMERICHOST"></a><a
    ///id="ai_numerichost"></a><dl> <dt><b>AI_NUMERICHOST</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> The
    ///<i>nodename</i> parameter passed to the GetAddrInfoEx function must be a numeric string. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_ALL"></a><a id="ai_all"></a><dl> <dt><b>AI_ALL</b></dt> <dt>0x0100</dt> </dl> </td> <td
    ///width="60%"> If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with <b>AI_V4MAPPED</b>.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_ADDRCONFIG"></a><a id="ai_addrconfig"></a><dl> <dt><b>AI_ADDRCONFIG</b></dt> <dt>0x0400</dt> </dl> </td>
    ///<td width="60%"> The GetAddrInfoEx will resolve only if a global address is configured. The IPv6 and IPv4
    ///loopback address is not considered a valid global address. This option is only supported on Windows Vista and
    ///later. </td> </tr> <tr> <td width="40%"><a id="AI_V4MAPPED"></a><a id="ai_v4mapped"></a><dl>
    ///<dt><b>AI_V4MAPPED</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> If the GetAddrInfoEx request for an IPv6
    ///addresses fails, a name service request is made for IPv4 addresses and these addresses are converted to
    ///IPv4-mapped IPv6 address format. This option is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_NON_AUTHORITATIVE"></a><a id="ai_non_authoritative"></a><dl>
    ///<dt><b>AI_NON_AUTHORITATIVE</b></dt> <dt>0x04000</dt> </dl> </td> <td width="60%"> The address information is
    ///from non-authoritative results. When this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, the
    ///<b>NS_EMAIL</b> namespace provider returns both authoritative and non-authoritative results. If this option is
    ///not set, then only authoritative results are returned. In the <i>ppResults</i> parameter returned by
    ///GetAddrInfoEx, this flag is set in the <b>ai_flags</b> member of the <b>addrinfoex</b> structure for
    ///non-authoritative results. This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b>
    ///namespace. </td> </tr> <tr> <td width="40%"><a id="AI_SECURE"></a><a id="ai_secure"></a><dl>
    ///<dt><b>AI_SECURE</b></dt> <dt>0x08000</dt> </dl> </td> <td width="60%"> The address information is from a secure
    ///channel. If the <b>AI_SECURE</b> bit is set, the <b>NS_EMAIL</b> namespace provider will return results that were
    ///obtained with enhanced security to minimize possible spoofing. When this option is set in the <i>pHints</i>
    ///parameter of GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider returns only results that were obtained with
    ///enhanced security to minimize possible spoofing. In the <i>ppResults</i> parameter returned by GetAddrInfoEx,
    ///this flag is set in the <b>ai_flags</b> member of the <b>addrinfoex</b> structure for results returned with
    ///enhanced security to minimize possible spoofing. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_RETURN_PREFERRED_NAMES"></a><a
    ///id="ai_return_preferred_names"></a><dl> <dt><b>AI_RETURN_PREFERRED_NAMES</b></dt> <dt>0x010000</dt> </dl> </td>
    ///<td width="60%"> The address information is for a preferred names for publication with a specific namespace. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, no name should be provided in the
    ///<i>pName</i> parameter and the <b>NS_EMAIL</b> namespace provider will return preferred names for publication. In
    ///the <i>ppResults</i> parameter returned by GetAddrInfoEx, this flag is set in the <b>ai_flags</b> member of the
    ///<b>addrinfoex</b> structure for results returned for preferred names for publication. This option is only
    ///supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_FQDN"></a><a id="ai_fqdn"></a><dl> <dt><b>AI_FQDN</b></dt> <dt>0x00020000</dt> </dl> </td> <td
    ///width="60%"> The fully qualified domain name is returned in the first <b>ai_canonicalname</b> member. When this
    ///option is set in the <i>pHints</i> parameter of GetAddrInfoEx and a flat name (single label) is specified in the
    ///<i>pName</i> parameter, the fully qualified domain name that the name eventually resolved to will be returned.
    ///When both the <b>AI_CANONNAME</b> and <b>AI_FQDN</b> bits are set, an addrinfoex2 structure is returned not the
    ///<b>addrinfoex</b> structure. This option is supported on Windows 7, Windows Server 2008 R2, and later. </td>
    ///</tr> <tr> <td width="40%"><a id="AI_FILESERVER"></a><a id="ai_fileserver"></a><dl> <dt><b>AI_FILESERVER</b></dt>
    ///<dt>0x00040000</dt> </dl> </td> <td width="60%"> A hint to the namespace provider that the hostname being queried
    ///is being used in a file share scenario. The namespace provider may ignore this hint. This option is supported on
    ///Windows 7, Windows Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_DISABLE_IDN_ENCODING"></a><a id="ai_disable_idn_encoding"></a><dl> <dt><b>AI_DISABLE_IDN_ENCODING</b></dt>
    ///<dt>0x00080000</dt> </dl> </td> <td width="60%"> Disable the automatic International Domain Name encoding using
    ///Punycode in the name resolution functions called by the GetAddrInfoEx function. This option is supported on
    ///Windows 8, Windows Server 2012, and later. </td> </tr> </table>
    int           ai_flags;
    ///Type: <b>int</b> The address family. Possible values for the address family are defined in the <i>Winsock2.h</i>
    ///include file. On the Windows SDK released for Windows Vista and later,, the organization of header files has
    ///changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that
    ///the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
    ///directly. The values currently supported are <b>AF_INET</b> or <b>AF_INET6</b>, which are the Internet address
    ///family formats for IPv4 and IPv6. Other options for address family (<b>AF_NETBIOS</b> for use with NetBIOS, for
    ///example) are supported if a Windows Sockets service provider for the address family is installed. Note that the
    ///values for the AF_ address family and PF_ protocol family constants are identical (for example, <b>AF_UNSPEC</b>
    ///and <b>PF_UNSPEC</b>), so either constant can be used. The table below lists common values for the address family
    ///although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td> <td
    ///width="60%"> The address family is unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a
    ///id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a
    ///id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address
    ///family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed. </td> </tr>
    ///<tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl>
    ///</td> <td width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
    ///Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
    ///infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
    ///<dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
    ///is only supported if a Bluetooth adapter is installed on Windows Server 2003 or later. </td> </tr> </table>
    int           ai_family;
    ///Type: <b>int</b> The socket type. Possible values for the socket type are defined in the <i>Winsock2.h</i>
    ///include file. The following table lists the possible values for the socket type supported for Windows Sockets 2:
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCK_STREAM"></a><a
    ///id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Provides sequenced,
    ///reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. Uses the Transmission
    ///Control Protocol (TCP) for the Internet address family (<b>AF_INET</b> or <b>AF_INET6</b>). If the
    ///<b>ai_family</b> member is <b>AF_IRDA</b>, then <b>SOCK_STREAM</b> is the only supported socket type. </td> </tr>
    ///<tr> <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt>
    ///</dl> </td> <td width="60%"> Supports datagrams, which are connectionless, unreliable buffers of a fixed
    ///(typically small) maximum length. Uses the User Datagram Protocol (UDP) for the Internet address family
    ///(<b>AF_INET</b> or <b>AF_INET6</b>). </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a
    ///id="sock_raw"></a><dl> <dt><b>SOCK_RAW</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Provides a raw socket
    ///that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the
    ///IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option
    ///must be set on the socket. </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
    ///<dt><b>SOCK_RDM</b></dt> <dt>4</dt> </dl> </td> <td width="60%"> Provides a reliable message datagram. An example
    ///of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often
    ///referred to as reliable multicast programming. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a
    ///id="sock_seqpacket"></a><dl> <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
    ///introduced. An application can dynamically discover the attributes of each available transport protocol through
    ///the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
    ///an address family and use this information when specifying this parameter. Socket type definitions in the
    ///<i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
    ///families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are
    ///<b>SOCK_DATAGRAM</b> and <b>SOCK_STREAM</b>.
    int           ai_socktype;
    ///Type: <b>int</b> The protocol type. The possible options are specific to the address family and socket type
    ///specified. Possible values for the <b>ai_protocol</b> are defined in <i>Winsock2.h</i> and the <i>Wsrm.h</i>
    ///header files. On the Windows SDK released for Windows Vista and later,, the organization of header files has
    ///changed and this member can be one of the values from the <b>IPPROTO</b> enumeration type defined in the
    ///<i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in
    ///<i>Winsock2.h</i>, and should never be used directly. If a value of 0 is specified for <b>ai_protocol</b>, the
    ///caller does not wish to specify a protocol and the service provider will choose the <b>ai_protocol</b> to use.
    ///For protocols other than IPv4 and IPv6, set <b>ai_protocol</b> to zero. The following table lists common values
    ///for the <b>ai_protocol</b> member although many other values are possible. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
    ///<dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The Transmission Control Protocol (TCP). This
    ///is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_STREAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_UDP"></a><a
    ///id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The User Datagram
    ///Protocol (UDP). This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b>
    ///and the <i>type</i> parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a
    ///id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol
    ///for reliable multicast. This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later, this value
    ///is also called <b>IPPROTO_PGM</b>. </td> </tr> </table> If the <b>ai_family</b> member is <b>AF_IRDA</b>, then
    ///the <b>ai_protocol</b> must be 0.
    int           ai_protocol;
    ///Type: <b>size_t</b> The length, in bytes, of the buffer pointed to by the <b>ai_addr</b> member.
    size_t        ai_addrlen;
    ///Type: <b>PCTSTR</b> The canonical name for the host.
    const(wchar)* ai_canonname;
    ///Type: <b>struct sockaddr*</b> A pointer to a sockaddr structure. The <b>ai_addr</b> member in each returned
    ///<b>addrinfoex</b> structure points to a filled-in socket address structure. The length, in bytes, of each
    ///returned <b>addrinfoex</b> structure is specified in the <b>ai_addrlen</b> member.
    SOCKADDR*     ai_addr;
    ///Type: <b>void*</b> A pointer to data that is used to return provider-specific namespace information that is
    ///associated with the name beyond a list of addresses. The length, in bytes, of the buffer pointed to by
    ///<b>ai_blob</b> must be specified in the <b>ai_bloblen</b> member.
    void*         ai_blob;
    ///Type: <b>size_t</b> The length, in bytes, of the <b>ai_blob</b> member.
    size_t        ai_bloblen;
    ///Type: <b>LPGUID</b> A pointer to the GUID of a specific namespace provider.
    GUID*         ai_provider;
    ///Type: <b>struct addrinfoex*</b> A pointer to the next structure in a linked list. This parameter is set to
    ///<b>NULL</b> in the last <b>addrinfoex</b> structure of a linked list.
    addrinfoexW*  ai_next;
}

///The <b>addrinfoex2</b> structure is used by the GetAddrInfoEx function to hold host address information when both a
///canonical name and a fully qualified domain name have been requested.
struct addrinfoex2A
{
    ///Flags that indicate options used in the GetAddrInfoEx function. Supported values for the <b>ai_flags</b> member
    ///are defined in the <i>Winsock2.h</i> include file and can be a combination of the following options. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AI_PASSIVE"></a><a id="ai_passive"></a><dl>
    ///<dt><b>AI_PASSIVE</b></dt> <dt>0x01</dt> </dl> </td> <td width="60%"> The socket address will be used in a call
    ///to the bindfunction. </td> </tr> <tr> <td width="40%"><a id="AI_CANONNAME"></a><a id="ai_canonname"></a><dl>
    ///<dt><b>AI_CANONNAME</b></dt> <dt>0x02</dt> </dl> </td> <td width="60%"> The canonical name is returned in the
    ///first <b>ai_canonname</b> member. </td> </tr> <tr> <td width="40%"><a id="AI_NUMERICHOST"></a><a
    ///id="ai_numerichost"></a><dl> <dt><b>AI_NUMERICHOST</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> The
    ///<i>nodename</i> parameter passed to the GetAddrInfoEx function must be a numeric string. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_ALL"></a><a id="ai_all"></a><dl> <dt><b>AI_ALL</b></dt> <dt>0x0100</dt> </dl> </td> <td
    ///width="60%"> If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with <b>AI_V4MAPPED</b>.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_ADDRCONFIG"></a><a id="ai_addrconfig"></a><dl> <dt><b>AI_ADDRCONFIG</b></dt> <dt>0x0400</dt> </dl> </td>
    ///<td width="60%"> The GetAddrInfoEx will resolve only if a global address is configured. The IPv6 and IPv4
    ///loopback address is not considered a valid global address. This option is supported on Windows Vista and later.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_V4MAPPED"></a><a id="ai_v4mapped"></a><dl> <dt><b>AI_V4MAPPED</b></dt>
    ///<dt>0x0800</dt> </dl> </td> <td width="60%"> If the GetAddrInfoEx request for an IPv6 addresses fails, a name
    ///service request is made for IPv4 addresses and these addresses are converted to IPv4-mapped IPv6 address format.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_NON_AUTHORITATIVE"></a><a id="ai_non_authoritative"></a><dl> <dt><b>AI_NON_AUTHORITATIVE</b></dt>
    ///<dt>0x04000</dt> </dl> </td> <td width="60%"> The address information is from non-authoritative results. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider
    ///returns both authoritative and non-authoritative results. If this option is not set, then only authoritative
    ///results are returned. This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_SECURE"></a><a id="ai_secure"></a><dl> <dt><b>AI_SECURE</b></dt>
    ///<dt>0x08000</dt> </dl> </td> <td width="60%"> The address information is from a secure channel. If the
    ///<b>AI_SECURE</b> bit is set, the <b>NS_EMAIL</b> namespace provider will return results that were obtained with
    ///enhanced security to minimize possible spoofing. When this option is set in the <i>pHints</i> parameter of
    ///GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider returns only results that were obtained with enhanced
    ///security to minimize possible spoofing. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_RETURN_PREFERRED_NAMES"></a><a
    ///id="ai_return_preferred_names"></a><dl> <dt><b>AI_RETURN_PREFERRED_NAMES</b></dt> <dt>0x010000</dt> </dl> </td>
    ///<td width="60%"> The address information is for a preferred names for publication with a specific namespace. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, no name should be provided in the
    ///<i>pName</i> parameter and the <b>NS_EMAIL</b> namespace provider will return preferred names for publication.
    ///This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_FQDN"></a><a id="ai_fqdn"></a><dl> <dt><b>AI_FQDN</b></dt> <dt>0x00020000</dt> </dl> </td>
    ///<td width="60%"> The fully qualified domain name is returned in the first <b>ai_fqdn</b> member. When this option
    ///is set in the <i>pHints</i> parameter of GetAddrInfoEx and a flat name (single label) is specified in the
    ///<i>pName</i> parameter, the fully qualified domain name that the name eventually resolved to will be returned.
    ///This option is supported on Windows 7, Windows Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_FILESERVER"></a><a id="ai_fileserver"></a><dl> <dt><b>AI_FILESERVER</b></dt> <dt>0x00040000</dt> </dl>
    ///</td> <td width="60%"> A hint to the namespace provider that the hostname being queried is being used in a file
    ///share scenario. The namespace provider may ignore this hint. This option is supported on Windows 7, Windows
    ///Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a id="AI_DISABLE_IDN_ENCODING"></a><a
    ///id="ai_disable_idn_encoding"></a><dl> <dt><b>AI_DISABLE_IDN_ENCODING</b></dt> <dt>0x00080000</dt> </dl> </td> <td
    ///width="60%"> Disable the automatic International Domain Name encoding using Punycode in the name resolution
    ///functions called by the GetAddrInfoEx function. This option is supported on Windows 8, Windows Server 2012, and
    ///later. </td> </tr> </table>
    int           ai_flags;
    ///The address family. The possible values for the address family are defined in the <i>Ws2def.h</i> header file.
    ///Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be
    ///used directly. The values currently supported are <b>AF_INET</b> or <b>AF_INET6</b>, which are the Internet
    ///address family formats for IPv4 and IPv6. Other options for address family (<b>AF_NETBIOS</b> for use with
    ///NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed.
    ///Note that the values for the AF_ address family and PF_ protocol family constants are identical (for example,
    ///<b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used. The table below lists common values for the
    ///address family although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td>
    ///<td width="60%"> The address family is unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a
    ///id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a
    ///id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address
    ///family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed. </td> </tr>
    ///<tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl>
    ///</td> <td width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
    ///Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
    ///infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
    ///<dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
    ///is only supported if a Bluetooth adapter is installed. </td> </tr> </table>
    int           ai_family;
    ///The socket type. Possible values for the socket type are defined in the <i>Winsock2.h</i> include file. The
    ///following table lists the possible values for the socket type supported for Windows Sockets 2: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
    ///<dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Provides sequenced, reliable, two-way,
    ///connection-based byte streams with an OOB data transmission mechanism. Uses the Transmission Control Protocol
    ///(TCP) for the Internet address family (<b>AF_INET</b> or <b>AF_INET6</b>). If the <b>ai_family</b> member is
    ///<b>AF_IRDA</b>, then <b>SOCK_STREAM</b> is the only supported socket type. </td> </tr> <tr> <td width="40%"><a
    ///id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small)
    ///maximum length. Uses the User Datagram Protocol (UDP) for the Internet address family (<b>AF_INET</b> or
    ///<b>AF_INET6</b>). </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
    ///<dt><b>SOCK_RAW</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Provides a raw socket that allows an application
    ///to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option
    ///must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the
    ///socket. </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt>
    ///<dt>4</dt> </dl> </td> <td width="60%"> Provides a reliable message datagram. An example of this type is the
    ///Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as reliable
    ///multicast programming. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a
    ///id="sock_seqpacket"></a><dl> <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
    ///introduced. An application can dynamically discover the attributes of each available transport protocol through
    ///the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
    ///an address family and use this information when specifying this parameter. Socket type definitions in the
    ///<i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
    ///families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are
    ///<b>SOCK_DATAGRAM</b> and <b>SOCK_STREAM</b>.
    int           ai_socktype;
    ///The protocol type. The possible options are specific to the address family and socket type specified. Possible
    ///values for the <b>ai_protocol</b> are defined in <i>Winsock2.h</i> and the <i>Wsrm.h</i> header files. On the
    ///Windows SDK released for Windows Vista and later,, the organization of header files has changed and this member
    ///can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file.
    ///Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be
    ///used directly. If a value of 0 is specified for <b>ai_protocol</b>, the caller does not wish to specify a
    ///protocol and the service provider will choose the <b>ai_protocol</b> to use. For protocols other than IPv4 and
    ///IPv6, set <b>ai_protocol</b> to zero. The following table lists common values for the <b>ai_protocol</b> member
    ///although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl>
    ///</td> <td width="60%"> The Transmission Control Protocol (TCP). This is a possible value when the
    ///<b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the <b>ai_socktype</b> member is
    ///<b>SOCK_STREAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
    ///<dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The User Datagram Protocol (UDP). This is a
    ///possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i>
    ///parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a
    ///id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol
    ///for reliable multicast. This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later, this value
    ///is also called <b>IPPROTO_PGM</b>. </td> </tr> </table> If the <b>ai_family</b> member is <b>AF_IRDA</b>, then
    ///the <b>ai_protocol</b> must be 0.
    int           ai_protocol;
    ///The length, in bytes, of the buffer pointed to by the <b>ai_addr</b> member.
    size_t        ai_addrlen;
    ///The canonical name for the host.
    byte*         ai_canonname;
    ///A pointer to a sockaddr structure. The <b>ai_addr</b> member in each returned <b>addrinfoex2</b> structure points
    ///to a filled-in socket address structure. The length, in bytes, of each returned <b>addrinfoex2</b> structure is
    ///specified in the <b>ai_addrlen</b> member.
    SOCKADDR*     ai_addr;
    ///A pointer to data that is used to return provider-specific namespace information that is associated with the name
    ///beyond a list of addresses. The length, in bytes, of the buffer pointed to by <b>ai_blob</b> must be specified in
    ///the <b>ai_bloblen</b> member.
    void*         ai_blob;
    ///The length, in bytes, of the <b>ai_blob</b> member.
    size_t        ai_bloblen;
    ///A pointer to the GUID of a specific namespace provider.
    GUID*         ai_provider;
    ///A pointer to the next structure in a linked list. This parameter is set to <b>NULL</b> in the last
    ///<b>addrinfoex2</b> structure of a linked list.
    addrinfoex2A* ai_next;
    ///The version number of this structure. The value currently used for this version of the structure is 2.
    int           ai_version;
    ///The fully qualified domain name for the host.
    byte*         ai_fqdn;
}

///The <b>addrinfoex2</b> structure is used by the GetAddrInfoEx function to hold host address information when both a
///canonical name and a fully qualified domain name have been requested.
struct addrinfoex2W
{
    ///Flags that indicate options used in the GetAddrInfoEx function. Supported values for the <b>ai_flags</b> member
    ///are defined in the <i>Winsock2.h</i> include file and can be a combination of the following options. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AI_PASSIVE"></a><a id="ai_passive"></a><dl>
    ///<dt><b>AI_PASSIVE</b></dt> <dt>0x01</dt> </dl> </td> <td width="60%"> The socket address will be used in a call
    ///to the bindfunction. </td> </tr> <tr> <td width="40%"><a id="AI_CANONNAME"></a><a id="ai_canonname"></a><dl>
    ///<dt><b>AI_CANONNAME</b></dt> <dt>0x02</dt> </dl> </td> <td width="60%"> The canonical name is returned in the
    ///first <b>ai_canonname</b> member. </td> </tr> <tr> <td width="40%"><a id="AI_NUMERICHOST"></a><a
    ///id="ai_numerichost"></a><dl> <dt><b>AI_NUMERICHOST</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> The
    ///<i>nodename</i> parameter passed to the GetAddrInfoEx function must be a numeric string. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_ALL"></a><a id="ai_all"></a><dl> <dt><b>AI_ALL</b></dt> <dt>0x0100</dt> </dl> </td> <td
    ///width="60%"> If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with <b>AI_V4MAPPED</b>.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_ADDRCONFIG"></a><a id="ai_addrconfig"></a><dl> <dt><b>AI_ADDRCONFIG</b></dt> <dt>0x0400</dt> </dl> </td>
    ///<td width="60%"> The GetAddrInfoEx will resolve only if a global address is configured. The IPv6 and IPv4
    ///loopback address is not considered a valid global address. This option is supported on Windows Vista and later.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_V4MAPPED"></a><a id="ai_v4mapped"></a><dl> <dt><b>AI_V4MAPPED</b></dt>
    ///<dt>0x0800</dt> </dl> </td> <td width="60%"> If the GetAddrInfoEx request for an IPv6 addresses fails, a name
    ///service request is made for IPv4 addresses and these addresses are converted to IPv4-mapped IPv6 address format.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_NON_AUTHORITATIVE"></a><a id="ai_non_authoritative"></a><dl> <dt><b>AI_NON_AUTHORITATIVE</b></dt>
    ///<dt>0x04000</dt> </dl> </td> <td width="60%"> The address information is from non-authoritative results. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider
    ///returns both authoritative and non-authoritative results. If this option is not set, then only authoritative
    ///results are returned. This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_SECURE"></a><a id="ai_secure"></a><dl> <dt><b>AI_SECURE</b></dt>
    ///<dt>0x08000</dt> </dl> </td> <td width="60%"> The address information is from a secure channel. If the
    ///<b>AI_SECURE</b> bit is set, the <b>NS_EMAIL</b> namespace provider will return results that were obtained with
    ///enhanced security to minimize possible spoofing. When this option is set in the <i>pHints</i> parameter of
    ///GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider returns only results that were obtained with enhanced
    ///security to minimize possible spoofing. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_RETURN_PREFERRED_NAMES"></a><a
    ///id="ai_return_preferred_names"></a><dl> <dt><b>AI_RETURN_PREFERRED_NAMES</b></dt> <dt>0x010000</dt> </dl> </td>
    ///<td width="60%"> The address information is for a preferred names for publication with a specific namespace. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, no name should be provided in the
    ///<i>pName</i> parameter and the <b>NS_EMAIL</b> namespace provider will return preferred names for publication.
    ///This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_FQDN"></a><a id="ai_fqdn"></a><dl> <dt><b>AI_FQDN</b></dt> <dt>0x00020000</dt> </dl> </td>
    ///<td width="60%"> The fully qualified domain name is returned in the first <b>ai_fqdn</b> member. When this option
    ///is set in the <i>pHints</i> parameter of GetAddrInfoEx and a flat name (single label) is specified in the
    ///<i>pName</i> parameter, the fully qualified domain name that the name eventually resolved to will be returned.
    ///This option is supported on Windows 7, Windows Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_FILESERVER"></a><a id="ai_fileserver"></a><dl> <dt><b>AI_FILESERVER</b></dt> <dt>0x00040000</dt> </dl>
    ///</td> <td width="60%"> A hint to the namespace provider that the hostname being queried is being used in a file
    ///share scenario. The namespace provider may ignore this hint. This option is supported on Windows 7, Windows
    ///Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a id="AI_DISABLE_IDN_ENCODING"></a><a
    ///id="ai_disable_idn_encoding"></a><dl> <dt><b>AI_DISABLE_IDN_ENCODING</b></dt> <dt>0x00080000</dt> </dl> </td> <td
    ///width="60%"> Disable the automatic International Domain Name encoding using Punycode in the name resolution
    ///functions called by the GetAddrInfoEx function. This option is supported on Windows 8, Windows Server 2012, and
    ///later. </td> </tr> </table>
    int           ai_flags;
    ///The address family. The possible values for the address family are defined in the <i>Ws2def.h</i> header file.
    ///Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be
    ///used directly. The values currently supported are <b>AF_INET</b> or <b>AF_INET6</b>, which are the Internet
    ///address family formats for IPv4 and IPv6. Other options for address family (<b>AF_NETBIOS</b> for use with
    ///NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed.
    ///Note that the values for the AF_ address family and PF_ protocol family constants are identical (for example,
    ///<b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used. The table below lists common values for the
    ///address family although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td>
    ///<td width="60%"> The address family is unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a
    ///id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a
    ///id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address
    ///family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed. </td> </tr>
    ///<tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl>
    ///</td> <td width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
    ///Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
    ///infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
    ///<dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
    ///is only supported if a Bluetooth adapter is installed. </td> </tr> </table>
    int           ai_family;
    ///The socket type. Possible values for the socket type are defined in the <i>Winsock2.h</i> include file. The
    ///following table lists the possible values for the socket type supported for Windows Sockets 2: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
    ///<dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Provides sequenced, reliable, two-way,
    ///connection-based byte streams with an OOB data transmission mechanism. Uses the Transmission Control Protocol
    ///(TCP) for the Internet address family (<b>AF_INET</b> or <b>AF_INET6</b>). If the <b>ai_family</b> member is
    ///<b>AF_IRDA</b>, then <b>SOCK_STREAM</b> is the only supported socket type. </td> </tr> <tr> <td width="40%"><a
    ///id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small)
    ///maximum length. Uses the User Datagram Protocol (UDP) for the Internet address family (<b>AF_INET</b> or
    ///<b>AF_INET6</b>). </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
    ///<dt><b>SOCK_RAW</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Provides a raw socket that allows an application
    ///to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option
    ///must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the
    ///socket. </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt>
    ///<dt>4</dt> </dl> </td> <td width="60%"> Provides a reliable message datagram. An example of this type is the
    ///Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as reliable
    ///multicast programming. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a
    ///id="sock_seqpacket"></a><dl> <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
    ///introduced. An application can dynamically discover the attributes of each available transport protocol through
    ///the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
    ///an address family and use this information when specifying this parameter. Socket type definitions in the
    ///<i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
    ///families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are
    ///<b>SOCK_DATAGRAM</b> and <b>SOCK_STREAM</b>.
    int           ai_socktype;
    ///The protocol type. The possible options are specific to the address family and socket type specified. Possible
    ///values for the <b>ai_protocol</b> are defined in <i>Winsock2.h</i> and the <i>Wsrm.h</i> header files. On the
    ///Windows SDK released for Windows Vista and later,, the organization of header files has changed and this member
    ///can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file.
    ///Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be
    ///used directly. If a value of 0 is specified for <b>ai_protocol</b>, the caller does not wish to specify a
    ///protocol and the service provider will choose the <b>ai_protocol</b> to use. For protocols other than IPv4 and
    ///IPv6, set <b>ai_protocol</b> to zero. The following table lists common values for the <b>ai_protocol</b> member
    ///although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl>
    ///</td> <td width="60%"> The Transmission Control Protocol (TCP). This is a possible value when the
    ///<b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the <b>ai_socktype</b> member is
    ///<b>SOCK_STREAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
    ///<dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The User Datagram Protocol (UDP). This is a
    ///possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i>
    ///parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a
    ///id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol
    ///for reliable multicast. This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later, this value
    ///is also called <b>IPPROTO_PGM</b>. </td> </tr> </table> If the <b>ai_family</b> member is <b>AF_IRDA</b>, then
    ///the <b>ai_protocol</b> must be 0.
    int           ai_protocol;
    ///The length, in bytes, of the buffer pointed to by the <b>ai_addr</b> member.
    size_t        ai_addrlen;
    ///The canonical name for the host.
    const(wchar)* ai_canonname;
    ///A pointer to a sockaddr structure. The <b>ai_addr</b> member in each returned <b>addrinfoex2</b> structure points
    ///to a filled-in socket address structure. The length, in bytes, of each returned <b>addrinfoex2</b> structure is
    ///specified in the <b>ai_addrlen</b> member.
    SOCKADDR*     ai_addr;
    ///A pointer to data that is used to return provider-specific namespace information that is associated with the name
    ///beyond a list of addresses. The length, in bytes, of the buffer pointed to by <b>ai_blob</b> must be specified in
    ///the <b>ai_bloblen</b> member.
    void*         ai_blob;
    ///The length, in bytes, of the <b>ai_blob</b> member.
    size_t        ai_bloblen;
    ///A pointer to the GUID of a specific namespace provider.
    GUID*         ai_provider;
    ///A pointer to the next structure in a linked list. This parameter is set to <b>NULL</b> in the last
    ///<b>addrinfoex2</b> structure of a linked list.
    addrinfoex2W* ai_next;
    ///The version number of this structure. The value currently used for this version of the structure is 2.
    int           ai_version;
    ///The fully qualified domain name for the host.
    const(wchar)* ai_fqdn;
}

///The <b>addrinfoex3</b> structure is used by the GetAddrInfoEx function to hold host address information when a
///specific network interface has been requested.
struct addrinfoex3
{
    ///Flags that indicate options used in the GetAddrInfoEx function. Supported values for the <b>ai_flags</b> member
    ///are defined in the <i>Winsock2.h</i> include file and can be a combination of the following options. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AI_PASSIVE"></a><a id="ai_passive"></a><dl>
    ///<dt><b>AI_PASSIVE</b></dt> <dt>0x01</dt> </dl> </td> <td width="60%"> The socket address will be used in a call
    ///to the bindfunction. </td> </tr> <tr> <td width="40%"><a id="AI_CANONNAME"></a><a id="ai_canonname"></a><dl>
    ///<dt><b>AI_CANONNAME</b></dt> <dt>0x02</dt> </dl> </td> <td width="60%"> The canonical name is returned in the
    ///first <b>ai_canonname</b> member. </td> </tr> <tr> <td width="40%"><a id="AI_NUMERICHOST"></a><a
    ///id="ai_numerichost"></a><dl> <dt><b>AI_NUMERICHOST</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> The
    ///<i>nodename</i> parameter passed to the GetAddrInfoEx function must be a numeric string. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_ALL"></a><a id="ai_all"></a><dl> <dt><b>AI_ALL</b></dt> <dt>0x0100</dt> </dl> </td> <td
    ///width="60%"> If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with <b>AI_V4MAPPED</b>.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_ADDRCONFIG"></a><a id="ai_addrconfig"></a><dl> <dt><b>AI_ADDRCONFIG</b></dt> <dt>0x0400</dt> </dl> </td>
    ///<td width="60%"> The GetAddrInfoEx will resolve only if a global address is configured. The IPv6 and IPv4
    ///loopback address is not considered a valid global address. This option is supported on Windows Vista and later.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_V4MAPPED"></a><a id="ai_v4mapped"></a><dl> <dt><b>AI_V4MAPPED</b></dt>
    ///<dt>0x0800</dt> </dl> </td> <td width="60%"> If the GetAddrInfoEx request for an IPv6 addresses fails, a name
    ///service request is made for IPv4 addresses and these addresses are converted to IPv4-mapped IPv6 address format.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_NON_AUTHORITATIVE"></a><a id="ai_non_authoritative"></a><dl> <dt><b>AI_NON_AUTHORITATIVE</b></dt>
    ///<dt>0x04000</dt> </dl> </td> <td width="60%"> The address information is from non-authoritative results. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider
    ///returns both authoritative and non-authoritative results. If this option is not set, then only authoritative
    ///results are returned. This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_SECURE"></a><a id="ai_secure"></a><dl> <dt><b>AI_SECURE</b></dt>
    ///<dt>0x08000</dt> </dl> </td> <td width="60%"> The address information is from a secure channel. If the
    ///<b>AI_SECURE</b> bit is set, the <b>NS_EMAIL</b> namespace provider will return results that were obtained with
    ///enhanced security to minimize possible spoofing. When this option is set in the <i>pHints</i> parameter of
    ///GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider returns only results that were obtained with enhanced
    ///security to minimize possible spoofing. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_RETURN_PREFERRED_NAMES"></a><a
    ///id="ai_return_preferred_names"></a><dl> <dt><b>AI_RETURN_PREFERRED_NAMES</b></dt> <dt>0x010000</dt> </dl> </td>
    ///<td width="60%"> The address information is for a preferred names for publication with a specific namespace. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, no name should be provided in the
    ///<i>pName</i> parameter and the <b>NS_EMAIL</b> namespace provider will return preferred names for publication.
    ///This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_FQDN"></a><a id="ai_fqdn"></a><dl> <dt><b>AI_FQDN</b></dt> <dt>0x00020000</dt> </dl> </td>
    ///<td width="60%"> The fully qualified domain name is returned in the first <b>ai_fqdn</b> member. When this option
    ///is set in the <i>pHints</i> parameter of GetAddrInfoEx and a flat name (single label) is specified in the
    ///<i>pName</i> parameter, the fully qualified domain name that the name eventually resolved to will be returned.
    ///This option is supported on Windows 7, Windows Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_FILESERVER"></a><a id="ai_fileserver"></a><dl> <dt><b>AI_FILESERVER</b></dt> <dt>0x00040000</dt> </dl>
    ///</td> <td width="60%"> A hint to the namespace provider that the hostname being queried is being used in a file
    ///share scenario. The namespace provider may ignore this hint. This option is supported on Windows 7, Windows
    ///Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a id="AI_DISABLE_IDN_ENCODING"></a><a
    ///id="ai_disable_idn_encoding"></a><dl> <dt><b>AI_DISABLE_IDN_ENCODING</b></dt> <dt>0x00080000</dt> </dl> </td> <td
    ///width="60%"> Disable the automatic International Domain Name encoding using Punycode in the name resolution
    ///functions called by the GetAddrInfoEx function. This option is supported on Windows 8, Windows Server 2012, and
    ///later. </td> </tr> <tr> <td width="40%"><a id="AI_EXTENDED"></a><a id="ai_extended"></a><dl>
    ///<dt><b>AI_EXTENDED</b></dt> <dt>0x80000000</dt> </dl> </td> <td width="60%"> Indicates that the current object is
    ///extended: that is, an addrinfoex2 or greater. This option is supported on Windows 8.1, Windows Server 2012 R2,
    ///and later. </td> </tr> </table>
    int           ai_flags;
    ///The address family. The possible values for the address family are defined in the <i>Ws2def.h</i> header file.
    ///Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be
    ///used directly. The values currently supported are <b>AF_INET</b> or <b>AF_INET6</b>, which are the Internet
    ///address family formats for IPv4 and IPv6. Other options for address family (<b>AF_NETBIOS</b> for use with
    ///NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed.
    ///Note that the values for the AF_ address family and PF_ protocol family constants are identical (for example,
    ///<b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used. The table below lists common values for the
    ///address family although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td>
    ///<td width="60%"> The address family is unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a
    ///id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a
    ///id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address
    ///family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed. </td> </tr>
    ///<tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl>
    ///</td> <td width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
    ///Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
    ///infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
    ///<dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
    ///is only supported if a Bluetooth adapter is installed. </td> </tr> </table>
    int           ai_family;
    ///The socket type. Possible values for the socket type are defined in the <i>Winsock2.h</i> include file. The
    ///following table lists the possible values for the socket type supported for Windows Sockets 2: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
    ///<dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Provides sequenced, reliable, two-way,
    ///connection-based byte streams with an OOB data transmission mechanism. Uses the Transmission Control Protocol
    ///(TCP) for the Internet address family (<b>AF_INET</b> or <b>AF_INET6</b>). If the <b>ai_family</b> member is
    ///<b>AF_IRDA</b>, then <b>SOCK_STREAM</b> is the only supported socket type. </td> </tr> <tr> <td width="40%"><a
    ///id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small)
    ///maximum length. Uses the User Datagram Protocol (UDP) for the Internet address family (<b>AF_INET</b> or
    ///<b>AF_INET6</b>). </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
    ///<dt><b>SOCK_RAW</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Provides a raw socket that allows an application
    ///to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option
    ///must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the
    ///socket. </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt>
    ///<dt>4</dt> </dl> </td> <td width="60%"> Provides a reliable message datagram. An example of this type is the
    ///Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as reliable
    ///multicast programming. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a
    ///id="sock_seqpacket"></a><dl> <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
    ///introduced. An application can dynamically discover the attributes of each available transport protocol through
    ///the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
    ///an address family and use this information when specifying this parameter. Socket type definitions in the
    ///<i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
    ///families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are
    ///<b>SOCK_DATAGRAM</b> and <b>SOCK_STREAM</b>.
    int           ai_socktype;
    ///The protocol type. The possible options are specific to the address family and socket type specified. Possible
    ///values for the <b>ai_protocol</b> are defined in <i>Winsock2.h</i> and the <i>Wsrm.h</i> header files. On the
    ///Windows SDK released for Windows Vista and later,, the organization of header files has changed and this member
    ///can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file.
    ///Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be
    ///used directly. If a value of 0 is specified for <b>ai_protocol</b>, the caller does not wish to specify a
    ///protocol and the service provider will choose the <b>ai_protocol</b> to use. For protocols other than IPv4 and
    ///IPv6, set <b>ai_protocol</b> to zero. The following table lists common values for the <b>ai_protocol</b> member
    ///although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl>
    ///</td> <td width="60%"> The Transmission Control Protocol (TCP). This is a possible value when the
    ///<b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the <b>ai_socktype</b> member is
    ///<b>SOCK_STREAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
    ///<dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The User Datagram Protocol (UDP). This is a
    ///possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i>
    ///parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a
    ///id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol
    ///for reliable multicast. This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later, this value
    ///is also called <b>IPPROTO_PGM</b>. </td> </tr> </table> If the <b>ai_family</b> member is <b>AF_IRDA</b>, then
    ///the <b>ai_protocol</b> must be 0.
    int           ai_protocol;
    ///The length, in bytes, of the buffer pointed to by the <b>ai_addr</b> member.
    size_t        ai_addrlen;
    ///The canonical name for the host.
    const(wchar)* ai_canonname;
    ///A pointer to a sockaddr structure. The <b>ai_addr</b> member in each returned <b>addrinfoex3</b> structure points
    ///to a filled-in socket address structure. The length, in bytes, of each returned <b>addrinfoex3</b> structure is
    ///specified in the <b>ai_addrlen</b> member.
    SOCKADDR*     ai_addr;
    ///A pointer to data that is used to return provider-specific namespace information that is associated with the name
    ///beyond a list of addresses. The length, in bytes, of the buffer pointed to by <b>ai_blob</b> must be specified in
    ///the <b>ai_bloblen</b> member.
    void*         ai_blob;
    ///The length, in bytes, of the <b>ai_blob</b> member.
    size_t        ai_bloblen;
    ///A pointer to the GUID of a specific namespace provider.
    GUID*         ai_provider;
    ///A pointer to the next structure in a linked list. This parameter is set to <b>NULL</b> in the last
    ///<b>addrinfoex3</b> structure of a linked list.
    addrinfoex3*  ai_next;
    ///The version number of this structure. The value currently used for this version of the structure is 3.
    int           ai_version;
    ///The fully qualified domain name for the host.
    const(wchar)* ai_fqdn;
    ///The interface index, as defined by the IP_ADAPTER_ADDRESSES.<i>IfIndex</i> property returned in
    ///GetAdaptersAddresses.
    int           ai_interfaceindex;
}

///The <b>addrinfoex4</b> structure is used by the GetAddrInfoEx function to hold host address information when a
///specific network interface has been requested.
struct addrinfoex4
{
    ///Flags that indicate options used in the GetAddrInfoEx function. Supported values for the <b>ai_flags</b> member
    ///are defined in the <i>Winsock2.h</i> include file and can be a combination of the following options. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AI_PASSIVE"></a><a id="ai_passive"></a><dl>
    ///<dt><b>AI_PASSIVE</b></dt> <dt>0x01</dt> </dl> </td> <td width="60%"> The socket address will be used in a call
    ///to the bindfunction. </td> </tr> <tr> <td width="40%"><a id="AI_CANONNAME"></a><a id="ai_canonname"></a><dl>
    ///<dt><b>AI_CANONNAME</b></dt> <dt>0x02</dt> </dl> </td> <td width="60%"> The canonical name is returned in the
    ///first <b>ai_canonname</b> member. </td> </tr> <tr> <td width="40%"><a id="AI_NUMERICHOST"></a><a
    ///id="ai_numerichost"></a><dl> <dt><b>AI_NUMERICHOST</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> The
    ///<i>nodename</i> parameter passed to the GetAddrInfoEx function must be a numeric string. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_ALL"></a><a id="ai_all"></a><dl> <dt><b>AI_ALL</b></dt> <dt>0x0100</dt> </dl> </td> <td
    ///width="60%"> If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with <b>AI_V4MAPPED</b>.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_ADDRCONFIG"></a><a id="ai_addrconfig"></a><dl> <dt><b>AI_ADDRCONFIG</b></dt> <dt>0x0400</dt> </dl> </td>
    ///<td width="60%"> The GetAddrInfoEx will resolve only if a global address is configured. The IPv6 and IPv4
    ///loopback address is not considered a valid global address. This option is supported on Windows Vista and later.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_V4MAPPED"></a><a id="ai_v4mapped"></a><dl> <dt><b>AI_V4MAPPED</b></dt>
    ///<dt>0x0800</dt> </dl> </td> <td width="60%"> If the GetAddrInfoEx request for an IPv6 addresses fails, a name
    ///service request is made for IPv4 addresses and these addresses are converted to IPv4-mapped IPv6 address format.
    ///This option is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_NON_AUTHORITATIVE"></a><a id="ai_non_authoritative"></a><dl> <dt><b>AI_NON_AUTHORITATIVE</b></dt>
    ///<dt>0x04000</dt> </dl> </td> <td width="60%"> The address information is from non-authoritative results. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider
    ///returns both authoritative and non-authoritative results. If this option is not set, then only authoritative
    ///results are returned. This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace.
    ///</td> </tr> <tr> <td width="40%"><a id="AI_SECURE"></a><a id="ai_secure"></a><dl> <dt><b>AI_SECURE</b></dt>
    ///<dt>0x08000</dt> </dl> </td> <td width="60%"> The address information is from a secure channel. If the
    ///<b>AI_SECURE</b> bit is set, the <b>NS_EMAIL</b> namespace provider will return results that were obtained with
    ///enhanced security to minimize possible spoofing. When this option is set in the <i>pHints</i> parameter of
    ///GetAddrInfoEx, the <b>NS_EMAIL</b> namespace provider returns only results that were obtained with enhanced
    ///security to minimize possible spoofing. This option is only supported on Windows Vista and later for the
    ///<b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td width="40%"><a id="AI_RETURN_PREFERRED_NAMES"></a><a
    ///id="ai_return_preferred_names"></a><dl> <dt><b>AI_RETURN_PREFERRED_NAMES</b></dt> <dt>0x010000</dt> </dl> </td>
    ///<td width="60%"> The address information is for a preferred names for publication with a specific namespace. When
    ///this option is set in the <i>pHints</i> parameter of GetAddrInfoEx, no name should be provided in the
    ///<i>pName</i> parameter and the <b>NS_EMAIL</b> namespace provider will return preferred names for publication.
    ///This option is only supported on Windows Vista and later for the <b>NS_EMAIL</b> namespace. </td> </tr> <tr> <td
    ///width="40%"><a id="AI_FQDN"></a><a id="ai_fqdn"></a><dl> <dt><b>AI_FQDN</b></dt> <dt>0x00020000</dt> </dl> </td>
    ///<td width="60%"> The fully qualified domain name is returned in the first <b>ai_fqdn</b> member. When this option
    ///is set in the <i>pHints</i> parameter of GetAddrInfoEx and a flat name (single label) is specified in the
    ///<i>pName</i> parameter, the fully qualified domain name that the name eventually resolved to will be returned.
    ///This option is supported on Windows 7, Windows Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a
    ///id="AI_FILESERVER"></a><a id="ai_fileserver"></a><dl> <dt><b>AI_FILESERVER</b></dt> <dt>0x00040000</dt> </dl>
    ///</td> <td width="60%"> A hint to the namespace provider that the hostname being queried is being used in a file
    ///share scenario. The namespace provider may ignore this hint. This option is supported on Windows 7, Windows
    ///Server 2008 R2, and later. </td> </tr> <tr> <td width="40%"><a id="AI_DISABLE_IDN_ENCODING"></a><a
    ///id="ai_disable_idn_encoding"></a><dl> <dt><b>AI_DISABLE_IDN_ENCODING</b></dt> <dt>0x00080000</dt> </dl> </td> <td
    ///width="60%"> Disable the automatic International Domain Name encoding using Punycode in the name resolution
    ///functions called by the GetAddrInfoEx function. This option is supported on Windows 8, Windows Server 2012, and
    ///later. </td> </tr> <tr> <td width="40%"><a id="AI_EXTENDED"></a><a id="ai_extended"></a><dl>
    ///<dt><b>AI_EXTENDED</b></dt> <dt>0x80000000</dt> </dl> </td> <td width="60%"> Indicates that the current object is
    ///extended: that is, an addrinfoex2 or greater. This option is supported on Windows 8.1, Windows Server 2012 R2,
    ///and later. </td> </tr> <tr> <td width="40%"><a id="AI_RESOLUTION_HANDLE"></a><a
    ///id="ai_resolution_handle"></a><dl> <dt><b>AI_RESOLUTION_HANDLE</b></dt> <dt>0x40000000</dt> </dl> </td> <td
    ///width="60%"> A resolution handle is returned in the <b>ai_resolutionhandle</b> member. This option is supported
    ///on Windows 10, Windows Server 2016, and later. </td> </tr> </table>
    int           ai_flags;
    ///The address family. The possible values for the address family are defined in the <i>Ws2def.h</i> header file.
    ///Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be
    ///used directly. The values currently supported are <b>AF_INET</b> or <b>AF_INET6</b>, which are the Internet
    ///address family formats for IPv4 and IPv6. Other options for address family (<b>AF_NETBIOS</b> for use with
    ///NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed.
    ///Note that the values for the AF_ address family and PF_ protocol family constants are identical (for example,
    ///<b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used. The table below lists common values for the
    ///address family although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td>
    ///<td width="60%"> The address family is unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a
    ///id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a
    ///id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address
    ///family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed. </td> </tr>
    ///<tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl>
    ///</td> <td width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
    ///Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
    ///infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
    ///<dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
    ///is only supported if a Bluetooth adapter is installed. </td> </tr> </table>
    int           ai_family;
    ///The socket type. Possible values for the socket type are defined in the <i>Winsock2.h</i> include file. The
    ///following table lists the possible values for the socket type supported for Windows Sockets 2: <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
    ///<dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Provides sequenced, reliable, two-way,
    ///connection-based byte streams with an OOB data transmission mechanism. Uses the Transmission Control Protocol
    ///(TCP) for the Internet address family (<b>AF_INET</b> or <b>AF_INET6</b>). If the <b>ai_family</b> member is
    ///<b>AF_IRDA</b>, then <b>SOCK_STREAM</b> is the only supported socket type. </td> </tr> <tr> <td width="40%"><a
    ///id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small)
    ///maximum length. Uses the User Datagram Protocol (UDP) for the Internet address family (<b>AF_INET</b> or
    ///<b>AF_INET6</b>). </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
    ///<dt><b>SOCK_RAW</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> Provides a raw socket that allows an application
    ///to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option
    ///must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the
    ///socket. </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt>
    ///<dt>4</dt> </dl> </td> <td width="60%"> Provides a reliable message datagram. An example of this type is the
    ///Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as reliable
    ///multicast programming. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a
    ///id="sock_seqpacket"></a><dl> <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> Provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
    ///introduced. An application can dynamically discover the attributes of each available transport protocol through
    ///the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
    ///an address family and use this information when specifying this parameter. Socket type definitions in the
    ///<i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
    ///families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are
    ///<b>SOCK_DATAGRAM</b> and <b>SOCK_STREAM</b>.
    int           ai_socktype;
    ///The protocol type. The possible options are specific to the address family and socket type specified. Possible
    ///values for the <b>ai_protocol</b> are defined in <i>Winsock2.h</i> and the <i>Wsrm.h</i> header files. On the
    ///Windows SDK released for Windows Vista and later,, the organization of header files has changed and this member
    ///can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file.
    ///Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be
    ///used directly. If a value of 0 is specified for <b>ai_protocol</b>, the caller does not wish to specify a
    ///protocol and the service provider will choose the <b>ai_protocol</b> to use. For protocols other than IPv4 and
    ///IPv6, set <b>ai_protocol</b> to zero. The following table lists common values for the <b>ai_protocol</b> member
    ///although many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl>
    ///</td> <td width="60%"> The Transmission Control Protocol (TCP). This is a possible value when the
    ///<b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the <b>ai_socktype</b> member is
    ///<b>SOCK_STREAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
    ///<dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The User Datagram Protocol (UDP). This is a
    ///possible value when the <b>ai_family</b> member is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i>
    ///parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a
    ///id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol
    ///for reliable multicast. This is a possible value when the <b>ai_family</b> member is <b>AF_INET</b> and the
    ///<b>ai_socktype</b> member is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later, this value
    ///is also called <b>IPPROTO_PGM</b>. </td> </tr> </table> If the <b>ai_family</b> member is <b>AF_IRDA</b>, then
    ///the <b>ai_protocol</b> must be 0.
    int           ai_protocol;
    ///The length, in bytes, of the buffer pointed to by the <b>ai_addr</b> member.
    size_t        ai_addrlen;
    ///The canonical name for the host.
    const(wchar)* ai_canonname;
    ///A pointer to a sockaddr structure. The <b>ai_addr</b> member in each returned <b>addrinfoex4</b> structure points
    ///to a filled-in socket address structure. The length, in bytes, of each returned <b>addrinfoex4</b> structure is
    ///specified in the <b>ai_addrlen</b> member.
    SOCKADDR*     ai_addr;
    ///A pointer to data that is used to return provider-specific namespace information that is associated with the name
    ///beyond a list of addresses. The length, in bytes, of the buffer pointed to by <b>ai_blob</b> must be specified in
    ///the <b>ai_bloblen</b> member.
    void*         ai_blob;
    ///The length, in bytes, of the <b>ai_blob</b> member.
    size_t        ai_bloblen;
    ///A pointer to the GUID of a specific namespace provider.
    GUID*         ai_provider;
    ///A pointer to the next structure in a linked list. This parameter is set to <b>NULL</b> in the last
    ///<b>addrinfoex4</b> structure of a linked list.
    addrinfoex4*  ai_next;
    ///The version number of this structure. The value currently used for this version of the structure is 4.
    int           ai_version;
    ///The fully qualified domain name for the host.
    const(wchar)* ai_fqdn;
    ///The interface index, as defined by the IP_ADAPTER_ADDRESSES.<i>IfIndex</i> property returned in
    ///GetAdaptersAddresses.
    int           ai_interfaceindex;
    ///Handle pointing to the fully qualified domain name for the host.
    HANDLE        ai_resolutionhandle;
}

///The <b>fd_set</b> structure is used by various Windows Sockets functions and service providers, such as the select
///function, to place sockets into a "set" for various purposes, such as testing a given socket for readability using
///the <i>readfds</i> parameter of the <b>select</b> function.
struct fd_set
{
    ///The number of sockets in the set.
    uint       fd_count;
    ///An array of sockets that are in the set.
    size_t[64] fd_array;
}

///The <b>timeval</b> structure is used to specify a time interval. It is associated with the Berkeley Software
///Distribution (BSD) <i>Time.h</i> header file.
struct timeval
{
    ///Time interval, in seconds.
    int tv_sec;
    ///Time interval, in microseconds. This value is used in combination with the <b>tv_sec</b> member to represent time
    ///interval values that are not a multiple of seconds.
    int tv_usec;
}

///The <b>hostent</b> structure is used by functions to store information about a given host, such as host name, IPv4
///address, and so forth. An application should never attempt to modify this structure or to free any of its components.
///Furthermore, only one copy of the <b>hostent</b> structure is allocated per thread, and an application should
///therefore copy any information that it needs before issuing any other Windows Sockets API calls.
struct hostent
{
    ///The official name of the host (PC). If using the DNS or similar resolution system, it is the Fully Qualified
    ///Domain Name (FQDN) that caused the server to return a reply. If using a local hosts file, it is the first entry
    ///after the IPv4 address.
    byte*  h_name;
    ///A <b>NULL</b>-terminated array of alternate names.
    byte** h_aliases;
    ///The type of address being returned.
    short  h_addrtype;
    ///The length, in bytes, of each address.
    short  h_length;
    ///A <b>NULL</b>-terminated list of addresses for the host. Addresses are returned in network byte order. The macro
    ///<b>h_addr</b> is defined to be <code>h_addr_list[0]</code> for compatibility with older software.
    byte** h_addr_list;
}

struct netent
{
    byte*  n_name;
    byte** n_aliases;
    short  n_addrtype;
    uint   n_net;
}

///The <b>servent</b> structure is used to store or return the name and service number for a given service name.
struct servent
{
    ///The official name of the service.
    byte*  s_name;
    ///A <b>NULL</b>-terminated array of alternate names.
    byte** s_aliases;
    ///The port number at which the service can be contacted. Port numbers are returned in network byte order.
    short  s_port;
    ///The name of the protocol to use when contacting the service.
    byte*  s_proto;
}

///The <b>protoent</b> structure contains the name and protocol numbers that correspond to a given protocol name.
///Applications must never attempt to modify this structure or to free any of its components. Furthermore, only one copy
///of this structure is allocated per thread, and therefore, the application should copy any information it needs before
///issuing any other Windows Sockets function calls.
struct protoent
{
    ///Official name of the protocol.
    byte*  p_name;
    ///Null-terminated array of alternate names.
    byte** p_aliases;
    short  p_proto;
}

///The <b>WSADATA</b> structure contains information about the Windows Sockets implementation.
struct WSAData
{
    ///Type: <b>WORD</b> The version of the Windows Sockets specification that the <i>Ws2_32.dll</i> expects the caller
    ///to use. The high-order byte specifies the minor version number; the low-order byte specifies the major version
    ///number.
    ushort    wVersion;
    ///Type: <b>WORD</b> The highest version of the Windows Sockets specification that the <i>Ws2_32.dll</i> can
    ///support. The high-order byte specifies the minor version number; the low-order byte specifies the major version
    ///number. This is the same value as the <b>wVersion</b> member when the version requested in the
    ///<i>wVersionRequested</i> parameter passed to the WSAStartup function is the highest version of the Windows
    ///Sockets specification that the <i>Ws2_32.dll</i> can support.
    ushort    wHighVersion;
    ///Type: <b>char[WSADESCRIPTION_LEN+1]</b> A <b>NULL</b>-terminated ASCII string into which the <i>Ws2_32.dll</i>
    ///copies a description of the Windows Sockets implementation. The text (up to 256 characters in length) can contain
    ///any characters except control and formatting characters. The most likely use that an application would have for
    ///this member is to display it (possibly truncated) in a status message.
    byte[257] szDescription;
    ///Type: <b>char[WSASYS_STATUS_LEN+1]</b> A <b>NULL</b>-terminated ASCII string into which the <i>Ws2_32.dll</i>
    ///copies relevant status or configuration information. The <i>Ws2_32.dll</i> should use this parameter only if the
    ///information might be useful to the user or support staff. This member should not be considered as an extension of
    ///the <b>szDescription</b> parameter.
    byte[129] szSystemStatus;
    ///Type: <b>unsigned short</b> The maximum number of sockets that may be opened. This member should be ignored for
    ///Windows Sockets version 2 and later. The <b>iMaxSockets</b> member is retained for compatibility with Windows
    ///Sockets specification 1.1, but should not be used when developing new applications. No single value can be
    ///appropriate for all underlying service providers. The architecture of Windows Sockets changed in version 2 to
    ///support multiple providers, and the <b>WSADATA</b> structure no longer applies to a single vendor's stack.
    ushort    iMaxSockets;
    ///Type: <b>unsigned short</b> The maximum datagram message size. This member is ignored for Windows Sockets version
    ///2 and later. The <b>iMaxUdpDg</b> member is retained for compatibility with Windows Sockets specification 1.1,
    ///but should not be used when developing new applications. The architecture of Windows Sockets changed in version 2
    ///to support multiple providers, and the <b>WSADATA</b> structure no longer applies to a single vendor's stack. For
    ///the actual maximum message size specific to a particular Windows Sockets service provider and socket type,
    ///applications should use getsockopt to retrieve the value of option SO_MAX_MSG_SIZE after a socket has been
    ///created.
    ushort    iMaxUdpDg;
    ///Type: <b>char FAR*</b> A pointer to vendor-specific information. This member should be ignored for Windows
    ///Sockets version 2 and later. The <b>lpVendorInfo</b> member is retained for compatibility with Windows Sockets
    ///specification 1.1. The architecture of Windows Sockets changed in version 2 to support multiple providers, and
    ///the <b>WSADATA</b> structure no longer applies to a single vendor's stack. Applications needing to access
    ///vendor-specific configuration information should use getsockopt to retrieve the value of option PVD_CONFIG for
    ///vendor-specific information.
    byte*     lpVendorInfo;
}

struct sockproto
{
    ushort sp_family;
    ushort sp_protocol;
}

///The <b>linger</b> structure maintains information about a specific socket that specifies how that socket should
///behave when data is queued to be sent and the closesocket function is called on the socket.
struct linger
{
    ///Type: <b>u_short</b> Specifies whether a socket should remain open for a specified amount of time after a
    ///closesocket function call to enable queued data to be sent. This member can have one of the following values.
    ///<table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td
    ///width="60%"> The socket will not remain open. This is the value set if the setsockopt function is called with the
    ///<i>optname</i> parameter set to <b>SO_DONTLINGER</b> and the <i>optval</i> parameter is zero. This value is also
    ///set if the setsockopt function is called with the <i>optname</i> parameter set to <b>SO_LINGER</b> and the
    ///<b>linger</b> structure passed in the <i>optval</i> parameter has the <b>l_onoff</b> member set to 0. </td> </tr>
    ///<tr> <td width="40%"> <dl> <dt>nonzero</dt> </dl> </td> <td width="60%"> The socket will remain open for a
    ///specified amount of time. This value is set if the setsockopt function is called with the <i>optname</i>
    ///parameter set to <b>SO_DONTLINGER</b> and the <i>optval</i> parameter is nonzero. This value is also set if the
    ///setsockopt function is called with the <i>optname</i> parameter set to <b>SO_LINGER</b> and the <b>linger</b>
    ///structure passed in the <i>optval</i> parameter has the <b>l_onoff</b> member set to a nonzero value. </td> </tr>
    ///</table>
    ushort l_onoff;
    ///Type: <b>u_short</b> The linger time in seconds. This member specifies how long to remain open after a
    ///closesocket function call to enable queued data to be sent. This member is only applicable if the <b>l_onoff</b>
    ///member of the <b>linger</b> structure is set to a nonzero value. This value is set if the setsockopt function is
    ///called with the <i>optname</i> parameter set to <b>SO_LINGER</b>. The <i>optval</i> parameter passed to the
    ///<b>setsockopt</b> function must contain a <b>linger</b> structure that is copied to the internal <b>linger</b>
    ///structure maintained for the socket.
    ushort l_linger;
}

///The <b>WSANETWORKEVENTS</b> structure is used to store a socket's internal information about network events.
struct WSANETWORKEVENTS
{
    ///Indicates which of the FD_XXX network events have occurred.
    int     lNetworkEvents;
    ///Array that contains any associated error codes, with an array index that corresponds to the position of event
    ///bits in <b>lNetworkEvents</b>. The identifiers FD_READ_BIT, FD_WRITE_BIT and others can be used to index the
    ///<b>iErrorCode</b> array.
    int[10] iErrorCode;
}

///The <b>WSAPROTOCOLCHAIN</b> structure contains a counted list of Catalog Entry identifiers that comprise a protocol
///chain.
struct WSAPROTOCOLCHAIN
{
    ///Length of the chain, in bytes. The following settings apply: Setting <b>ChainLen</b> to zero indicates a layered
    ///protocol Setting <b>ChainLen</b> to one indicates a base protocol Setting <b>ChainLen</b> to greater than one
    ///indicates a protocol chain
    int     ChainLen;
    ///Array of protocol chain entries.
    uint[7] ChainEntries;
}

///The <b>WSAPROTOCOL_INFO</b> structure is used to store or retrieve complete information for a given protocol.
struct WSAPROTOCOL_INFOA
{
    ///Type: <b>DWORD</b> A bitmask that describes the services provided by the protocol. The possible values for this
    ///member are defined in the <i>Winsock2.h</i> header file. The following values are possible. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="XP1_CONNECTIONLESS"></a><a
    ///id="xp1_connectionless"></a><dl> <dt><b>XP1_CONNECTIONLESS</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> Provides connectionless (datagram) service. If not set, the protocol supports connection-oriented
    ///data transfer. </td> </tr> <tr> <td width="40%"><a id="XP1_GUARANTEED_DELIVERY"></a><a
    ///id="xp1_guaranteed_delivery"></a><dl> <dt><b>XP1_GUARANTEED_DELIVERY</b></dt> <dt>0x00000002</dt> </dl> </td> <td
    ///width="60%"> Guarantees that all data sent will reach the intended destination. </td> </tr> <tr> <td
    ///width="40%"><a id="XP1_GUARANTEED_ORDER"></a><a id="xp1_guaranteed_order"></a><dl>
    ///<dt><b>XP1_GUARANTEED_ORDER</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Guarantees that data only
    ///arrives in the order in which it was sent and that it is not duplicated. This characteristic does not necessarily
    ///mean that the data is always delivered, but that any data that is delivered is delivered in the order in which it
    ///was sent. </td> </tr> <tr> <td width="40%"><a id="XP1_MESSAGE_ORIENTED"></a><a id="xp1_message_oriented"></a><dl>
    ///<dt><b>XP1_MESSAGE_ORIENTED</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Honors message
    ///boundaries—as opposed to a stream-oriented protocol where there is no concept of message boundaries. </td>
    ///</tr> <tr> <td width="40%"><a id="XP1_PSEUDO_STREAM"></a><a id="xp1_pseudo_stream"></a><dl>
    ///<dt><b>XP1_PSEUDO_STREAM</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> A message-oriented protocol,
    ///but message boundaries are ignored for all receipts. This is convenient when an application does not desire
    ///message framing to be done by the protocol. </td> </tr> <tr> <td width="40%"><a id="XP1_GRACEFUL_CLOSE"></a><a
    ///id="xp1_graceful_close"></a><dl> <dt><b>XP1_GRACEFUL_CLOSE</b></dt> <dt>0x00000020</dt> </dl> </td> <td
    ///width="60%"> Supports two-phase (graceful) close. If not set, only abortive closes are performed. </td> </tr>
    ///<tr> <td width="40%"><a id="XP1_EXPEDITED_DATA"></a><a id="xp1_expedited_data"></a><dl>
    ///<dt><b>XP1_EXPEDITED_DATA</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> Supports expedited (urgent)
    ///data. </td> </tr> <tr> <td width="40%"><a id="XP1_CONNECT_DATA"></a><a id="xp1_connect_data"></a><dl>
    ///<dt><b>XP1_CONNECT_DATA</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> Supports connect data. </td>
    ///</tr> <tr> <td width="40%"><a id="XP1_DISCONNECT_DATA"></a><a id="xp1_disconnect_data"></a><dl>
    ///<dt><b>XP1_DISCONNECT_DATA</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Supports disconnect data.
    ///</td> </tr> <tr> <td width="40%"><a id="XP1_SUPPORT_BROADCAST"></a><a id="xp1_support_broadcast"></a><dl>
    ///<dt><b>XP1_SUPPORT_BROADCAST</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> Supports a broadcast
    ///mechanism. </td> </tr> <tr> <td width="40%"><a id="XP1_SUPPORT_MULTIPOINT"></a><a
    ///id="xp1_support_multipoint"></a><dl> <dt><b>XP1_SUPPORT_MULTIPOINT</b></dt> <dt>0x00000400</dt> </dl> </td> <td
    ///width="60%"> Supports a multipoint or multicast mechanism. Control and data plane attributes are indicated below.
    ///</td> </tr> <tr> <td width="40%"><a id="XP1_MULTIPOINT_CONTROL_PLANE"></a><a
    ///id="xp1_multipoint_control_plane"></a><dl> <dt><b>XP1_MULTIPOINT_CONTROL_PLANE</b></dt> <dt>0x00000800</dt> </dl>
    ///</td> <td width="60%"> Indicates whether the control plane is rooted (value = 1) or nonrooted (value = 0). </td>
    ///</tr> <tr> <td width="40%"><a id="XP1_MULTIPOINT_DATA_PLANE"></a><a id="xp1_multipoint_data_plane"></a><dl>
    ///<dt><b>XP1_MULTIPOINT_DATA_PLANE</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> Indicates whether the
    ///data plane is rooted (value = 1) or nonrooted (value = 0). </td> </tr> <tr> <td width="40%"><a
    ///id="XP1_QOS_SUPPORTED"></a><a id="xp1_qos_supported"></a><dl> <dt><b>XP1_QOS_SUPPORTED</b></dt>
    ///<dt>0x00002000</dt> </dl> </td> <td width="60%"> Supports quality of service requests. </td> </tr> <tr> <td
    ///width="40%"><a id="XP1_INTERRUPT"></a><a id="xp1_interrupt"></a><dl> <dt><b>XP1_INTERRUPT</b></dt> </dl> </td>
    ///<td width="60%"> Bit is reserved. </td> </tr> <tr> <td width="40%"><a id="XP1_UNI_SEND"></a><a
    ///id="xp1_uni_send"></a><dl> <dt><b>XP1_UNI_SEND</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> Protocol
    ///is unidirectional in the send direction. </td> </tr> <tr> <td width="40%"><a id="XP1_UNI_RECV"></a><a
    ///id="xp1_uni_recv"></a><dl> <dt><b>XP1_UNI_RECV</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> Protocol
    ///is unidirectional in the recv direction. </td> </tr> <tr> <td width="40%"><a id="XP1_IFS_HANDLES"></a><a
    ///id="xp1_ifs_handles"></a><dl> <dt><b>XP1_IFS_HANDLES</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%">
    ///Socket descriptors returned by the provider are operating system Installable File System (IFS) handles. </td>
    ///</tr> <tr> <td width="40%"><a id="XP1_PARTIAL_MESSAGE"></a><a id="xp1_partial_message"></a><dl>
    ///<dt><b>XP1_PARTIAL_MESSAGE</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The MSG_PARTIAL flag is
    ///supported in WSASend and WSASendTo. </td> </tr> <tr> <td width="40%"><a id="XP1_SAN_SUPPORT_SDP"></a><a
    ///id="xp1_san_support_sdp"></a><dl> <dt><b>XP1_SAN_SUPPORT_SDP</b></dt> <dt>0x00080000</dt> </dl> </td> <td
    ///width="60%"> The protocol provides support for SAN. This value is supported on Windows 7 and Windows Server 2008
    ///R2. </td> </tr> </table> <div class="alert"><b>Note</b> Only one of XP1_UNI_SEND or XP1_UNI_RECV values may be
    ///set. If a protocol can be unidirectional in either direction, two WSAPROTOCOL_INFOW structures should be used.
    ///When neither bit is set, the protocol is considered to be bidirectional.</div> <div> </div>
    uint             dwServiceFlags1;
    ///Type: <b>DWORD</b> Reserved for additional protocol-attribute definitions.
    uint             dwServiceFlags2;
    ///Type: <b>DWORD</b> Reserved for additional protocol-attribute definitions.
    uint             dwServiceFlags3;
    ///Type: <b>DWORD</b> Reserved for additional protocol-attribute definitions.
    uint             dwServiceFlags4;
    ///Type: <b>DWORD</b> A set of flags that provides information on how this protocol is represented in the Winsock
    ///catalog. The possible values for this member are defined in the <i>Winsock2.h</i> header file. The following flag
    ///values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="PFL_MULTIPLE_PROTO_ENTRIES"></a><a id="pfl_multiple_proto_entries"></a><dl>
    ///<dt><b>PFL_MULTIPLE_PROTO_ENTRIES</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Indicates that this
    ///is one of two or more entries for a single protocol (from a given provider) which is capable of implementing
    ///multiple behaviors. An example of this is SPX which, on the receiving side, can behave either as a
    ///message-oriented or a stream-oriented protocol. </td> </tr> <tr> <td width="40%"><a
    ///id="PFL_RECOMMENDED_PROTO_ENTRY"></a><a id="pfl_recommended_proto_entry"></a><dl>
    ///<dt><b>PFL_RECOMMENDED_PROTO_ENTRY</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Indicates that this
    ///is the recommended or most frequently used entry for a protocol that is capable of implementing multiple
    ///behaviors. </td> </tr> <tr> <td width="40%"><a id="PFL_HIDDEN"></a><a id="pfl_hidden"></a><dl>
    ///<dt><b>PFL_HIDDEN</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Set by a provider to indicate to the
    ///Ws2_32.dll that this protocol should not be returned in the result buffer generated by WSAEnumProtocols.
    ///Obviously, a Windows Sockets 2 application should never see an entry with this bit set. </td> </tr> <tr> <td
    ///width="40%"><a id="PFL_MATCHES_PROTOCOL_ZERO"></a><a id="pfl_matches_protocol_zero"></a><dl>
    ///<dt><b>PFL_MATCHES_PROTOCOL_ZERO</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Indicates that a value
    ///of zero in the <i>protocol</i> parameter of socket or WSASocket matches this protocol entry. </td> </tr> <tr> <td
    ///width="40%"><a id="PFL_NETWORKDIRECT_PROVIDER"></a><a id="pfl_networkdirect_provider"></a><dl>
    ///<dt><b>PFL_NETWORKDIRECT_PROVIDER</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Set by a provider to
    ///indicate support for network direct access. This value is supported on Windows 7 and Windows Server 2008 R2.
    ///</td> </tr> </table>
    uint             dwProviderFlags;
    ///Type: <b>GUID</b> A globally unique identifier (GUID) assigned to the provider by the service provider vendor.
    ///This value is useful for instances where more than one service provider is able to implement a particular
    ///protocol. An application can use the <b>ProviderId</b> member to distinguish between providers that might
    ///otherwise be indistinguishable.
    GUID             ProviderId;
    ///Type: <b>DWORD</b> A unique identifier assigned by the WS2_32.DLL for each <b>WSAPROTOCOL_INFO</b> structure.
    uint             dwCatalogEntryId;
    ///Type: <b>WSAPROTOCOLCHAIN</b> The WSAPROTOCOLCHAIN structure associated with the protocol. If the length of the
    ///chain is 0, this <b>WSAPROTOCOL_INFO</b> entry represents a layered protocol which has Windows Sockets 2 SPI as
    ///both its top and bottom edges. If the length of the chain equals 1, this entry represents a base protocol whose
    ///Catalog Entry identifier is in the <b>dwCatalogEntryId</b> member of the <b>WSAPROTOCOL_INFO</b> structure. If
    ///the length of the chain is larger than 1, this entry represents a protocol chain which consists of one or more
    ///layered protocols on top of a base protocol. The corresponding Catalog Entry identifiers are in the
    ///ProtocolChain.ChainEntries array starting with the layered protocol at the top (the zero element in the
    ///ProtocolChain.ChainEntries array) and ending with the base protocol. Refer to the Windows Sockets 2 Service
    ///Provider Interface specification for more information on protocol chains.
    WSAPROTOCOLCHAIN ProtocolChain;
    ///Type: <b>int</b> The protocol version identifier.
    int              iVersion;
    ///Type: <b>int</b> A value to pass as the address family parameter to the socket or WSASocket function in order to
    ///open a socket for this protocol. This value also uniquely defines the structure of a protocol address for a
    ///sockaddr used by the protocol. On the Windows SDK released for Windows Vista and later, the possible values for
    ///the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is
    ///automatically included in <i>Winsock2.h</i>, and should never be used directly. On versions of the Platform SDK
    ///for Windows Server 2003 and older, the possible values for the address family are defined in the
    ///<i>Winsock2.h</i> header file. The values currently supported are AF_INET or AF_INET6, which are the Internet
    ///address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for
    ///example) are supported if a Windows Sockets service provider for the address family is installed. Note that the
    ///values for the AF_ address family and PF_ protocol family constants are identical (for example, <b>AF_INET</b>
    ///and <b>PF_INET</b>), so either constant can be used. The table below lists common values for address family
    ///although many other values are possible. <table> <tr> <th>iAddressFamily</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> The Internet Protocol version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IPX"></a><a id="af_ipx"></a><dl> <dt><b>AF_IPX</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The
    ///IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport
    ///protocol is installed. This address family is not supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl> <dt><b>AF_APPLETALK</b></dt> <dt>16</dt> </dl>
    ///</td> <td width="60%"> The AppleTalk address family. This address family is only supported if the AppleTalk
    ///protocol is installed. This address family is not supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td>
    ///<td width="60%"> The NetBIOS address family. This address family is only supported if the Windows Sockets
    ///provider for NetBIOS is installed. The Windows Sockets provider for NetBIOS is supported on 32-bit versions of
    ///Windows. This provider is installed by default on 32-bit versions of Windows. The Windows Sockets provider for
    ///NetBIOS is not supported on 64-bit versions of windows including Windows 7, Windows Server 2008, Windows Vista,
    ///Windows Server 2003, or Windows XP. The Windows Sockets provider for NetBIOS only supports sockets where the
    ///<i>type</i> parameter is set to <b>SOCK_DGRAM</b>. The Windows Sockets provider for NetBIOS is not directly
    ///related to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows
    ///Vista, Windows Server 2008, and later. </td> </tr> <tr> <td width="40%"><a id="AF_INET6"></a><a
    ///id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a id="AF_IRDA"></a><a id="af_irda"></a><dl>
    ///<dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The Infrared Data Association (IrDA) address
    ///family. This address family is only supported if the computer has an infrared port and driver installed. </td>
    ///</tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl> <dt><b>AF_BTH</b></dt> <dt>32</dt> </dl>
    ///</td> <td width="60%"> The Bluetooth address family. This address family is supported on Windows XP with SP2 or
    ///later if the computer has a Bluetooth adapter and driver installed. </td> </tr> </table>
    int              iAddressFamily;
    ///Type: <b>int</b> The maximum address length, in bytes.
    int              iMaxSockAddr;
    ///Type: <b>int</b> The minimum address length, in bytes.
    int              iMinSockAddr;
    ///Type: <b>int</b> A value to pass as the socket type parameter to the socket or WSASocket function in order to
    ///open a socket for this protocol. Possible values for the socket type are defined in the <i>Winsock2.h</i> header
    ///file. The following table lists the possible values for the <b>iSocketType</b> member supported for Windows
    ///Sockets 2: <table> <tr> <th>iSocketType</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SOCK_STREAM"></a><a id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td
    ///width="60%"> A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB
    ///data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet
    ///address family (AF_INET or AF_INET6). </td> </tr> <tr> <td width="40%"><a id="SOCK_DGRAM"></a><a
    ///id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> A socket type that
    ///supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.
    ///This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
    ///</td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl> <dt><b>SOCK_RAW</b></dt>
    ///<dt>3</dt> </dl> </td> <td width="60%"> A socket type that provides a raw socket that allows an application to
    ///manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option must
    ///be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the socket.
    ///</td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt>
    ///<dt>4</dt> </dl> </td> <td width="60%"> A socket type that provides a reliable message datagram. An example of
    ///this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred
    ///to as reliable multicast programming. This value is only supported if the Reliable Multicast Protocol is
    ///installed. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
    ///<dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> A socket type that provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table>
    int              iSocketType;
    ///Type: <b>int</b> A value to pass as the <i>protocol</i> parameter to the socket or WSASocket function in order to
    ///open a socket for this protocol. The possible options for the <b>iProtocol</b> member are specific to the address
    ///family and socket type specified. On the Windows SDK released for Windows Vista and later, this member can be one
    ///of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file. Note that the
    ///<i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly. On
    ///versions of the Platform SDK for Windows Server 2003 and earlier, the possible values for the <b>iProtocol</b>
    ///member are defined in the <i>Winsock2.h</i> and <i>Wsrm.h</i> header files. The table below lists common values
    ///for the <b>iProtocol</b> although many other values are possible. <table> <tr> <th>iProtocol</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
    ///<dt><b>IPPROTO_ICMP</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The Internet Control Message Protocol
    ///(ICMP). This value is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="IPPROTO_IGMP"></a><a id="ipproto_igmp"></a><dl> <dt><b>IPPROTO_IGMP</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> The Internet Group Management Protocol (IGMP). This value is supported on Windows XP and later.
    ///</td> </tr> <tr> <td width="40%"><a id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl>
    ///<dt><b>BTHPROTO_RFCOMM</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The Bluetooth Radio Frequency
    ///Communications (Bluetooth RFCOMM) protocol. This value is supported on Windows XP with SP2 or later. </td> </tr>
    ///<tr> <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt>
    ///</dl> </td> <td width="60%"> The Transmission Control Protocol (TCP). </td> </tr> <tr> <td width="40%"><a
    ///id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td
    ///width="60%"> The User Datagram Protocol (UDP). </td> </tr> <tr> <td width="40%"><a id="IPPROTO_ICMPV6"></a><a
    ///id="ipproto_icmpv6"></a><dl> <dt><b>IPPROTO_ICMPV6</b></dt> <dt>58</dt> </dl> </td> <td width="60%"> The Internet
    ///Control Message Protocol Version 6 (ICMPv6). This value is supported on Windows XP and later. </td> </tr> <tr>
    ///<td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl>
    ///</td> <td width="60%"> The PGM protocol for reliable multicast. On the Windows SDK released for Windows Vista and
    ///later, this protocol is also called <b>IPPROTO_PGM</b>. This value is only supported if the Reliable Multicast
    ///Protocol is installed. </td> </tr> </table>
    int              iProtocol;
    ///Type: <b>int</b> The maximum value that may be added to <b>iProtocol</b> when supplying a value for the
    ///<i>protocol</i> parameter to socket or WSASocket function. Not all protocols allow a range of values. When this
    ///is the case <b>iProtocolMaxOffset</b> is zero.
    int              iProtocolMaxOffset;
    ///Type: <b>int</b> Currently these values are manifest constants (BIGENDIAN and LITTLEENDIAN) that indicate either
    ///big-endian or little-endian with the values 0 and 1 respectively.
    int              iNetworkByteOrder;
    ///Type: <b>int</b> The type of security scheme employed (if any). A value of SECURITY_PROTOCOL_NONE (0) is used for
    ///protocols that do not incorporate security provisions.
    int              iSecurityScheme;
    ///Type: <b>DWORD</b> The maximum message size, in bytes, supported by the protocol. This is the maximum size that
    ///can be sent from any of the host's local interfaces. For protocols that do not support message framing, the
    ///actual maximum that can be sent to a given address may be less. There is no standard provision to determine the
    ///maximum inbound message size. The following special values are defined. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The protocol is
    ///stream-oriented and hence the concept of message size is not relevant. </td> </tr> <tr> <td width="40%"> <dl>
    ///<dt>0x1</dt> </dl> </td> <td width="60%"> The maximum outbound (send) message size is dependent on the underlying
    ///network MTU (maximum sized transmission unit) and hence cannot be known until after a socket is bound.
    ///Applications should use getsockopt to retrieve the value of SO_MAX_MSG_SIZE after the socket has been bound to a
    ///local address. </td> </tr> <tr> <td width="40%"> <dl> <dt>0xFFFFFFFF</dt> </dl> </td> <td width="60%"> The
    ///protocol is message-oriented, but there is no maximum limit to the size of messages that may be transmitted.
    ///</td> </tr> </table>
    uint             dwMessageSize;
    ///Type: <b>DWORD</b> Reserved for use by service providers.
    uint             dwProviderReserved;
    ///Type: <b>TCHAR[WSAPROTOCOL_LEN+1]</b> An array of characters that contains a human-readable name identifying the
    ///protocol, for example "MSAFD Tcpip [UDP/IP]". The maximum number of characters allowed is WSAPROTOCOL_LEN, which
    ///is defined to be 255.
    byte[256]        szProtocol;
}

///The <b>WSAPROTOCOL_INFOW</b> structure is used to store or retrieve complete information for a given protocol. The
///protocol name is represented as an array of Unicode characters.
struct WSAPROTOCOL_INFOW
{
    ///Type: <b>DWORD</b> A bitmask that describes the services provided by the protocol. The possible values for this
    ///member are defined in the <i>Winsock2.h</i> header file. The following values are possible. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="XP1_CONNECTIONLESS"></a><a
    ///id="xp1_connectionless"></a><dl> <dt><b>XP1_CONNECTIONLESS</b></dt> <dt>0x00000001</dt> </dl> </td> <td
    ///width="60%"> Provides connectionless (datagram) service. If not set, the protocol supports connection-oriented
    ///data transfer. </td> </tr> <tr> <td width="40%"><a id="XP1_GUARANTEED_DELIVERY"></a><a
    ///id="xp1_guaranteed_delivery"></a><dl> <dt><b>XP1_GUARANTEED_DELIVERY</b></dt> <dt>0x00000002</dt> </dl> </td> <td
    ///width="60%"> Guarantees that all data sent will reach the intended destination. </td> </tr> <tr> <td
    ///width="40%"><a id="XP1_GUARANTEED_ORDER"></a><a id="xp1_guaranteed_order"></a><dl>
    ///<dt><b>XP1_GUARANTEED_ORDER</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Guarantees that data only
    ///arrives in the order in which it was sent and that it is not duplicated. This characteristic does not necessarily
    ///mean that the data is always delivered, but that any data that is delivered is delivered in the order in which it
    ///was sent. </td> </tr> <tr> <td width="40%"><a id="XP1_MESSAGE_ORIENTED"></a><a id="xp1_message_oriented"></a><dl>
    ///<dt><b>XP1_MESSAGE_ORIENTED</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Honors message
    ///boundaries—as opposed to a stream-oriented protocol where there is no concept of message boundaries. </td>
    ///</tr> <tr> <td width="40%"><a id="XP1_PSEUDO_STREAM"></a><a id="xp1_pseudo_stream"></a><dl>
    ///<dt><b>XP1_PSEUDO_STREAM</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> A message-oriented protocol,
    ///but message boundaries are ignored for all receipts. This is convenient when an application does not desire
    ///message framing to be done by the protocol. </td> </tr> <tr> <td width="40%"><a id="XP1_GRACEFUL_CLOSE"></a><a
    ///id="xp1_graceful_close"></a><dl> <dt><b>XP1_GRACEFUL_CLOSE</b></dt> <dt>0x00000020</dt> </dl> </td> <td
    ///width="60%"> Supports two-phase (graceful) close. If not set, only abortive closes are performed. </td> </tr>
    ///<tr> <td width="40%"><a id="XP1_EXPEDITED_DATA"></a><a id="xp1_expedited_data"></a><dl>
    ///<dt><b>XP1_EXPEDITED_DATA</b></dt> <dt>0x00000040</dt> </dl> </td> <td width="60%"> Supports expedited (urgent)
    ///data. </td> </tr> <tr> <td width="40%"><a id="XP1_CONNECT_DATA"></a><a id="xp1_connect_data"></a><dl>
    ///<dt><b>XP1_CONNECT_DATA</b></dt> <dt>0x00000080</dt> </dl> </td> <td width="60%"> Supports connect data. </td>
    ///</tr> <tr> <td width="40%"><a id="XP1_DISCONNECT_DATA"></a><a id="xp1_disconnect_data"></a><dl>
    ///<dt><b>XP1_DISCONNECT_DATA</b></dt> <dt>0x00000100</dt> </dl> </td> <td width="60%"> Supports disconnect data.
    ///</td> </tr> <tr> <td width="40%"><a id="XP1_SUPPORT_BROADCAST"></a><a id="xp1_support_broadcast"></a><dl>
    ///<dt><b>XP1_SUPPORT_BROADCAST</b></dt> <dt>0x00000200</dt> </dl> </td> <td width="60%"> Supports a broadcast
    ///mechanism. </td> </tr> <tr> <td width="40%"><a id="XP1_SUPPORT_MULTIPOINT"></a><a
    ///id="xp1_support_multipoint"></a><dl> <dt><b>XP1_SUPPORT_MULTIPOINT</b></dt> <dt>0x00000400</dt> </dl> </td> <td
    ///width="60%"> Supports a multipoint or multicast mechanism. Control and data plane attributes are indicated below.
    ///</td> </tr> <tr> <td width="40%"><a id="XP1_MULTIPOINT_CONTROL_PLANE"></a><a
    ///id="xp1_multipoint_control_plane"></a><dl> <dt><b>XP1_MULTIPOINT_CONTROL_PLANE</b></dt> <dt>0x00000800</dt> </dl>
    ///</td> <td width="60%"> Indicates whether the control plane is rooted (value = 1) or nonrooted (value = 0). </td>
    ///</tr> <tr> <td width="40%"><a id="XP1_MULTIPOINT_DATA_PLANE"></a><a id="xp1_multipoint_data_plane"></a><dl>
    ///<dt><b>XP1_MULTIPOINT_DATA_PLANE</b></dt> <dt>0x00001000</dt> </dl> </td> <td width="60%"> Indicates whether the
    ///data plane is rooted (value = 1) or nonrooted (value = 0). </td> </tr> <tr> <td width="40%"><a
    ///id="XP1_QOS_SUPPORTED"></a><a id="xp1_qos_supported"></a><dl> <dt><b>XP1_QOS_SUPPORTED</b></dt>
    ///<dt>0x00002000</dt> </dl> </td> <td width="60%"> Supports quality of service requests. </td> </tr> <tr> <td
    ///width="40%"><a id="XP1_INTERRUPT"></a><a id="xp1_interrupt"></a><dl> <dt><b>XP1_INTERRUPT</b></dt> </dl> </td>
    ///<td width="60%"> Bit is reserved. </td> </tr> <tr> <td width="40%"><a id="XP1_UNI_SEND"></a><a
    ///id="xp1_uni_send"></a><dl> <dt><b>XP1_UNI_SEND</b></dt> <dt>0x00008000</dt> </dl> </td> <td width="60%"> Protocol
    ///is unidirectional in the send direction. </td> </tr> <tr> <td width="40%"><a id="XP1_UNI_RECV"></a><a
    ///id="xp1_uni_recv"></a><dl> <dt><b>XP1_UNI_RECV</b></dt> <dt>0x00010000</dt> </dl> </td> <td width="60%"> Protocol
    ///is unidirectional in the recv direction. </td> </tr> <tr> <td width="40%"><a id="XP1_IFS_HANDLES"></a><a
    ///id="xp1_ifs_handles"></a><dl> <dt><b>XP1_IFS_HANDLES</b></dt> <dt>0x00020000</dt> </dl> </td> <td width="60%">
    ///Socket descriptors returned by the provider are operating system Installable File System (IFS) handles. </td>
    ///</tr> <tr> <td width="40%"><a id="XP1_PARTIAL_MESSAGE"></a><a id="xp1_partial_message"></a><dl>
    ///<dt><b>XP1_PARTIAL_MESSAGE</b></dt> <dt>0x00040000</dt> </dl> </td> <td width="60%"> The MSG_PARTIAL flag is
    ///supported in WSASend and WSASendTo. </td> </tr> <tr> <td width="40%"><a id="XP1_SAN_SUPPORT_SDP"></a><a
    ///id="xp1_san_support_sdp"></a><dl> <dt><b>XP1_SAN_SUPPORT_SDP</b></dt> <dt>0x00080000</dt> </dl> </td> <td
    ///width="60%"> The protocol provides support for SAN. This value is supported on Windows 7 and Windows Server 2008
    ///R2. </td> </tr> </table> <div class="alert"><b>Note</b> Only one of XP1_UNI_SEND or XP1_UNI_RECV values may be
    ///set. If a protocol can be unidirectional in either direction, two <b>WSAPROTOCOL_INFOW</b> structures should be
    ///used. When neither bit is set, the protocol is considered to be bidirectional.</div> <div> </div>
    uint             dwServiceFlags1;
    ///Type: <b>DWORD</b> Reserved for additional protocol-attribute definitions.
    uint             dwServiceFlags2;
    ///Type: <b>DWORD</b> Reserved for additional protocol-attribute definitions.
    uint             dwServiceFlags3;
    ///Type: <b>DWORD</b> Reserved for additional protocol-attribute definitions.
    uint             dwServiceFlags4;
    ///Type: <b>DWORD</b> A set of flags that provides information on how this protocol is represented in the Winsock
    ///catalog. The possible values for this member are defined in the <i>Winsock2.h</i> header file. The following
    ///values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="PFL_MULTIPLE_PROTO_ENTRIES"></a><a id="pfl_multiple_proto_entries"></a><dl>
    ///<dt><b>PFL_MULTIPLE_PROTO_ENTRIES</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%"> Indicates that this
    ///is one of two or more entries for a single protocol (from a given provider) which is capable of implementing
    ///multiple behaviors. An example of this is SPX which, on the receiving side, can behave either as a
    ///message-oriented or a stream-oriented protocol. </td> </tr> <tr> <td width="40%"><a
    ///id="PFL_RECOMMENDED_PROTO_ENTRY"></a><a id="pfl_recommended_proto_entry"></a><dl>
    ///<dt><b>PFL_RECOMMENDED_PROTO_ENTRY</b></dt> <dt>0x00000002</dt> </dl> </td> <td width="60%"> Indicates that this
    ///is the recommended or most frequently used entry for a protocol that is capable of implementing multiple
    ///behaviors. </td> </tr> <tr> <td width="40%"><a id="PFL_HIDDEN"></a><a id="pfl_hidden"></a><dl>
    ///<dt><b>PFL_HIDDEN</b></dt> <dt>0x00000004</dt> </dl> </td> <td width="60%"> Set by a provider to indicate to the
    ///Ws2_32.dll that this protocol should not be returned in the result buffer generated by WSAEnumProtocols.
    ///Obviously, a Windows Sockets 2 application should never see an entry with this bit set. </td> </tr> <tr> <td
    ///width="40%"><a id="PFL_MATCHES_PROTOCOL_ZERO"></a><a id="pfl_matches_protocol_zero"></a><dl>
    ///<dt><b>PFL_MATCHES_PROTOCOL_ZERO</b></dt> <dt>0x00000008</dt> </dl> </td> <td width="60%"> Indicates that a value
    ///of zero in the <i>protocol</i> parameter of socket or WSASocket matches this protocol entry. </td> </tr> <tr> <td
    ///width="40%"><a id="PFL_NETWORKDIRECT_PROVIDER"></a><a id="pfl_networkdirect_provider"></a><dl>
    ///<dt><b>PFL_NETWORKDIRECT_PROVIDER</b></dt> <dt>0x00000010</dt> </dl> </td> <td width="60%"> Set by a provider to
    ///indicate support for network direct access. This value is supported on Windows 7 and Windows Server 2008 R2.
    ///</td> </tr> </table>
    uint             dwProviderFlags;
    ///Type: <b>GUID</b> A globally unique identifier (GUID) assigned to the provider by the service provider vendor.
    ///This value is useful for instances where more than one service provider is able to implement a particular
    ///protocol. An application can use the <b>ProviderId</b> member to distinguish between providers that might
    ///otherwise be indistinguishable.
    GUID             ProviderId;
    ///Type: <b>DWORD</b> A unique identifier assigned by the WS2_32.DLL for each WSAPROTOCOL_INFO structure.
    uint             dwCatalogEntryId;
    ///Type: <b>WSAPROTOCOLCHAIN</b> The WSAPROTOCOLCHAIN structure associated with the protocol. If the length of the
    ///chain is 0, this WSAPROTOCOL_INFO entry represents a layered protocol which has Windows Sockets 2 SPI as both its
    ///top and bottom edges. If the length of the chain equals 1, this entry represents a base protocol whose Catalog
    ///Entry identifier is in the <b>dwCatalogEntryId</b> member of the <b>WSAPROTOCOL_INFO</b> structure. If the length
    ///of the chain is larger than 1, this entry represents a protocol chain which consists of one or more layered
    ///protocols on top of a base protocol. The corresponding Catalog Entry identifiers are in the
    ///ProtocolChain.ChainEntries array starting with the layered protocol at the top (the zero element in the
    ///ProtocolChain.ChainEntries array) and ending with the base protocol. Refer to the Windows Sockets 2 Service
    ///Provider Interface specification for more information on protocol chains.
    WSAPROTOCOLCHAIN ProtocolChain;
    ///Type: <b>int</b> The protocol version identifier.
    int              iVersion;
    ///Type: <b>int</b> A value to pass as the address family parameter to the socket or WSASocket function in order to
    ///open a socket for this protocol. This value also uniquely defines the structure of a protocol address for a
    ///sockaddr used by the protocol. On the Windows SDK released for Windows Vista and later, the possible values for
    ///the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is
    ///automatically included in <i>Winsock2.h</i>, and should never be used directly. On versions of the Platform SDK
    ///for Windows Server 2003 and older, the possible values for the address family are defined in the
    ///<i>Winsock2.h</i> header file. The values currently supported are AF_INET or AF_INET6, which are the Internet
    ///address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for
    ///example) are supported if a Windows Sockets service provider for the address family is installed. Note that the
    ///values for the AF_ address family and PF_ protocol family constants are identical (for example, <b>AF_INET</b>
    ///and <b>PF_INET</b>), so either constant can be used. The table below lists common values for address family
    ///although many other values are possible. <table> <tr> <th>iAddressFamily</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> The Internet Protocol version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a
    ///id="AF_IPX"></a><a id="af_ipx"></a><dl> <dt><b>AF_IPX</b></dt> <dt>6</dt> </dl> </td> <td width="60%"> The
    ///IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport
    ///protocol is installed. This address family is not supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl> <dt><b>AF_APPLETALK</b></dt> <dt>16</dt> </dl>
    ///</td> <td width="60%"> The AppleTalk address family. This address family is only supported if the AppleTalk
    ///protocol is installed. This address family is not supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td>
    ///<td width="60%"> The NetBIOS address family. This address family is only supported if the Windows Sockets
    ///provider for NetBIOS is installed. The Windows Sockets provider for NetBIOS is supported on 32-bit versions of
    ///Windows. This provider is installed by default on 32-bit versions of Windows. The Windows Sockets provider for
    ///NetBIOS is not supported on 64-bit versions of windows including Windows 7, Windows Server 2008, Windows Vista,
    ///Windows Server 2003, or Windows XP. The Windows Sockets provider for NetBIOS only supports sockets where the
    ///<i>type</i> parameter is set to <b>SOCK_DGRAM</b>. The Windows Sockets provider for NetBIOS is not directly
    ///related to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows
    ///Vista, Windows Server 2008, and later. </td> </tr> <tr> <td width="40%"><a id="AF_INET6"></a><a
    ///id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl> </td> <td width="60%"> The Internet Protocol
    ///version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a id="AF_IRDA"></a><a id="af_irda"></a><dl>
    ///<dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The Infrared Data Association (IrDA) address
    ///family. This address family is only supported if the computer has an infrared port and driver installed. </td>
    ///</tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl> <dt><b>AF_BTH</b></dt> <dt>32</dt> </dl>
    ///</td> <td width="60%"> The Bluetooth address family. This address family is supported on Windows XP with SP2 or
    ///later if the computer has a Bluetooth adapter and driver installed. </td> </tr> </table>
    int              iAddressFamily;
    ///Type: <b>int</b> The maximum address length, in bytes.
    int              iMaxSockAddr;
    ///Type: <b>int</b> The minimum address length, in bytes.
    int              iMinSockAddr;
    ///Type: <b>int</b> A value to pass as the socket type parameter to the socket or WSASocket function in order to
    ///open a socket for this protocol. Possible values for the socket type are defined in the <i>Winsock2.h</i> header
    ///file. The following table lists the possible values for the <b>iSocketType</b> member supported for Windows
    ///Sockets 2: <table> <tr> <th>iSocketType</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SOCK_STREAM"></a><a id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td
    ///width="60%"> A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB
    ///data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet
    ///address family (AF_INET or AF_INET6). </td> </tr> <tr> <td width="40%"><a id="SOCK_DGRAM"></a><a
    ///id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> A socket type that
    ///supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.
    ///This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
    ///</td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl> <dt><b>SOCK_RAW</b></dt>
    ///<dt>3</dt> </dl> </td> <td width="60%"> A socket type that provides a raw socket that allows an application to
    ///manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option must
    ///be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the socket.
    ///</td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt>
    ///<dt>4</dt> </dl> </td> <td width="60%"> A socket type that provides a reliable message datagram. An example of
    ///this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred
    ///to as reliable multicast programming. This value is only supported if the Reliable Multicast Protocol is
    ///installed. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
    ///<dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> A socket type that provides a
    ///pseudo-stream packet based on datagrams. </td> </tr> </table>
    int              iSocketType;
    ///Type: <b>int</b> A value to pass as the <i>protocol</i> parameter to the socket or WSASocket function in order to
    ///open a socket for this protocol. The possible options for the <b>iProtocol</b> member are specific to the address
    ///family and socket type specified. On the Windows SDK released for Windows Vista and later, this member can be one
    ///of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file. Note that the
    ///<i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly. On
    ///versions of the Platform SDK for Windows Server 2003 and earlier, the possible values for the <b>iProtocol</b>
    ///member are defined in the <i>Winsock2.h</i> and <i>Wsrm.h</i> header files. The table below lists common values
    ///for the <b>iProtocol</b> although many other values are possible. <table> <tr> <th>iProtocol</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
    ///<dt><b>IPPROTO_ICMP</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The Internet Control Message Protocol
    ///(ICMP). This value is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="IPPROTO_IGMP"></a><a id="ipproto_igmp"></a><dl> <dt><b>IPPROTO_IGMP</b></dt> <dt>2</dt> </dl> </td> <td
    ///width="60%"> The Internet Group Management Protocol (IGMP). This value is supported on Windows XP and later.
    ///</td> </tr> <tr> <td width="40%"><a id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl>
    ///<dt><b>BTHPROTO_RFCOMM</b></dt> <dt>3</dt> </dl> </td> <td width="60%"> The Bluetooth Radio Frequency
    ///Communications (Bluetooth RFCOMM) protocol. This value is supported on Windows XP with SP2 or later. </td> </tr>
    ///<tr> <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt>
    ///</dl> </td> <td width="60%"> The Transmission Control Protocol (TCP). </td> </tr> <tr> <td width="40%"><a
    ///id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl> </td> <td
    ///width="60%"> The User Datagram Protocol (UDP). </td> </tr> <tr> <td width="40%"><a id="IPPROTO_ICMPV6"></a><a
    ///id="ipproto_icmpv6"></a><dl> <dt><b>IPPROTO_ICMPV6</b></dt> <dt>58</dt> </dl> </td> <td width="60%"> The Internet
    ///Control Message Protocol Version 6 (ICMPv6). This value is supported on Windows XP and later. </td> </tr> <tr>
    ///<td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt> <dt>113</dt> </dl>
    ///</td> <td width="60%"> The PGM protocol for reliable multicast. On the Windows SDK released for Windows Vista and
    ///later, this protocol is also called <b>IPPROTO_PGM</b>. This value is only supported if the Reliable Multicast
    ///Protocol is installed. </td> </tr> </table>
    int              iProtocol;
    ///Type: <b>int</b> The maximum value that may be added to <b>iProtocol</b> member when supplying a value for the
    ///<i>protocol</i> parameter to socket and WSASocket. Not all protocols allow a range of values. When this is the
    ///case <b>iProtocolMaxOffset</b> is zero.
    int              iProtocolMaxOffset;
    ///Type: <b>int</b> Currently these values are manifest constants (BIGENDIAN and LITTLEENDIAN) that indicate either
    ///big-endian or little-endian with the values 0 and 1 respectively.
    int              iNetworkByteOrder;
    ///Type: <b>int</b> The type of security scheme employed (if any). A value of SECURITY_PROTOCOL_NONE (0) is used for
    ///protocols that do not incorporate security provisions.
    int              iSecurityScheme;
    ///Type: <b>DWORD</b> The maximum message size, in bytes, supported by the protocol. This is the maximum size that
    ///can be sent from any of the host's local interfaces. For protocols that do not support message framing, the
    ///actual maximum that can be sent to a given address may be less. There is no standard provision to determine the
    ///maximum inbound message size. The following special values are defined. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt>0</dt> </dl> </td> <td width="60%"> The protocol is
    ///stream-oriented and hence the concept of message size is not relevant. </td> </tr> <tr> <td width="40%"> <dl>
    ///<dt>0x1</dt> </dl> </td> <td width="60%"> The maximum outbound (send) message size is dependent on the underlying
    ///network MTU (maximum sized transmission unit) and hence cannot be known until after a socket is bound.
    ///Applications should use getsockopt to retrieve the value of SO_MAX_MSG_SIZE after the socket has been bound to a
    ///local address. </td> </tr> <tr> <td width="40%"> <dl> <dt>0xFFFFFFFF</dt> </dl> </td> <td width="60%"> The
    ///protocol is message-oriented, but there is no maximum limit to the size of messages that may be transmitted.
    ///</td> </tr> </table>
    uint             dwMessageSize;
    ///Type: <b>DWORD</b> Reserved for use by service providers.
    uint             dwProviderReserved;
    ///Type: <b>WCHAR[WSAPROTOCOL_LEN+1]</b> An array of Unicode characters that contains a human-readable name
    ///identifying the protocol, for example "MSAFD Tcpip [UDP/IP]". The maximum number of characters allowed is
    ///WSAPROTOCOL_LEN, which is defined to be 255.
    ushort[256]      szProtocol;
}

///The <b>WSACOMPLETION</b> structure specifies completion notification settings for I/O control calls made to a
///registered namespace.
struct WSACOMPLETION
{
    ///Type: <b>WSACOMPLETIONTYPE</b> The type of completion notification required. See Remarks.
    WSACOMPLETIONTYPE Type;
    union Parameters
    {
        struct WindowMessage
        {
            HWND   hWnd;
            uint   uMsg;
            WPARAM context;
        }
        struct Event
        {
            OVERLAPPED* lpOverlapped;
        }
        struct Apc
        {
            OVERLAPPED* lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        }
        struct Port
        {
            OVERLAPPED* lpOverlapped;
            HANDLE      hPort;
            size_t      Key;
        }
    }
}

///The <b>AFPROTOCOLS</b> structure supplies a list of protocols to which application programmers can constrain queries.
///The <b>AFPROTOCOLS</b> structure is used for query purposes only.
struct AFPROTOCOLS
{
    ///Address family to which the query is to be constrained.
    int iAddressFamily;
    ///Protocol to which the query is to be constrained.
    int iProtocol;
}

///The <b>WSAVERSION</b> structure provides version comparison in Windows Sockets.
struct WSAVERSION
{
    ///Version of Windows Sockets.
    uint           dwVersion;
    ///WSAECOMPARATOR enumeration, used in the comparison.
    WSAECOMPARATOR ecHow;
}

///The <b>WSAQUERYSET</b> structure provides relevant information about a given service, including service class ID,
///service name, applicable namespace identifier and protocol information, as well as a set of transport addresses at
///which the service listens.
struct WSAQUERYSETA
{
    ///Type: <b>DWORD</b> The size, in bytes, of the <b>WSAQUERYSET</b> structure. This member is used as a versioning
    ///mechanism since the size of the <b>WSAQUERYSET</b> structure has changed on later versions of Windows.
    uint         dwSize;
    ///Type: <b>LPTSTR</b> A pointer to an optional NULL-terminated string that contains service name. The semantics for
    ///using wildcards within the string are not defined, but can be supported by certain namespace providers.
    const(char)* lpszServiceInstanceName;
    ///Type: <b>LPGUID</b> The GUID corresponding to the service class. This member is required to be set.
    GUID*        lpServiceClassId;
    ///Type: <b>LPWSAVERSION</b> A pointer to an optional desired version number of the namespace provider. This member
    ///provides version comparison semantics (that is, the version requested must match exactly, or version must be not
    ///less than the value supplied).
    WSAVERSION*  lpVersion;
    ///Type: <b>LPTSTR</b> This member is ignored for queries.
    const(char)* lpszComment;
    ///Type: <b>DWORD</b> A namespace identifier that determines which namespace providers are queried. Passing a
    ///specific namespace identifier will result in only namespace providers that support the specified namespace being
    ///queried. Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried.
    ///Options for the <b>dwNameSpace</b> member are listed in the <i>Winsock2.h</i> include file. Several new namespace
    ///providers are included with Windows Vista and later. Other namespace providers can be installed, so the following
    ///possible values are only those commonly available. Many other values are possible. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl> <dt><b>NS_ALL</b></dt>
    ///</dl> </td> <td width="60%"> All installed and active namespaces. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td> <td width="60%"> The Bluetooth
    ///namespace. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The domain name
    ///system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
    ///<dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace identifier is supported
    ///on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
    ///<dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA) namespace. This
    ///namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The
    ///peer-to-peer name space for a specific peer name. This namespace identifier is supported on Windows Vista and
    ///later. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
    ///<dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td width="60%"> The peer-to-peer name space for a collection of peer
    ///names. This namespace identifier is supported on Windows Vista and later. </td> </tr> </table>
    uint         dwNameSpace;
    ///Type: <b>LPGUID</b> A pointer to an optional GUID of a specific namespace provider to query in the case where
    ///multiple namespace providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for
    ///a specific namespace provider will result in only the specified namespace provider being queried. The
    ///WSAEnumNameSpaceProviders and WSAEnumNameSpaceProvidersEx functions can be called to retrieve the GUID for a
    ///namespace provider.
    GUID*        lpNSProviderId;
    ///Type: <b>LPTSTR</b> A pointer to an optional starting point of the query in a hierarchical namespace.
    const(char)* lpszContext;
    ///Type: <b>DWORD</b> The size, in bytes, of the protocol constraint array. This member can be zero.
    uint         dwNumberOfProtocols;
    ///Type: <b>LPAFPROTOCOLS</b> A pointer to an optional array of AFPROTOCOLS structures. Only services that utilize
    ///these protocols will be returned.
    AFPROTOCOLS* lpafpProtocols;
    ///Type: <b>LPTSTR</b> A pointer to an optional NULL-terminated query string. Some namespaces, such as Whois++,
    ///support enriched SQL-like queries that are contained in a simple text string. This parameter is used to specify
    ///that string.
    const(char)* lpszQueryString;
    ///Type: <b>DWORD</b> This member is ignored for queries.
    uint         dwNumberOfCsAddrs;
    ///Type: <b>LPCSADDR_INFO</b> This member is ignored for queries.
    CSADDR_INFO* lpcsaBuffer;
    ///Type: <b>DWORD</b> This member is ignored for queries.
    uint         dwOutputFlags;
    ///Type: <b>LPBLOB</b> An optional pointer to data that is used to query or set provider-specific namespace
    ///information. The format of this information is specific to the namespace provider.
    BLOB*        lpBlob;
}

///The <b>WSAQUERYSET</b> structure provides relevant information about a given service, including service class ID,
///service name, applicable namespace identifier and protocol information, as well as a set of transport addresses at
///which the service listens.
struct WSAQUERYSETW
{
    ///Type: <b>DWORD</b> The size, in bytes, of the <b>WSAQUERYSET</b> structure. This member is used as a versioning
    ///mechanism since the size of the <b>WSAQUERYSET</b> structure has changed on later versions of Windows.
    uint          dwSize;
    ///Type: <b>LPTSTR</b> A pointer to an optional NULL-terminated string that contains service name. The semantics for
    ///using wildcards within the string are not defined, but can be supported by certain namespace providers.
    const(wchar)* lpszServiceInstanceName;
    ///Type: <b>LPGUID</b> The GUID corresponding to the service class. This member is required to be set.
    GUID*         lpServiceClassId;
    ///Type: <b>LPWSAVERSION</b> A pointer to an optional desired version number of the namespace provider. This member
    ///provides version comparison semantics (that is, the version requested must match exactly, or version must be not
    ///less than the value supplied).
    WSAVERSION*   lpVersion;
    ///Type: <b>LPTSTR</b> This member is ignored for queries.
    const(wchar)* lpszComment;
    ///Type: <b>DWORD</b> A namespace identifier that determines which namespace providers are queried. Passing a
    ///specific namespace identifier will result in only namespace providers that support the specified namespace being
    ///queried. Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried.
    ///Options for the <b>dwNameSpace</b> member are listed in the <i>Winsock2.h</i> include file. Several new namespace
    ///providers are included with Windows Vista and later. Other namespace providers can be installed, so the following
    ///possible values are only those commonly available. Many other values are possible. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl> <dt><b>NS_ALL</b></dt>
    ///</dl> </td> <td width="60%"> All installed and active namespaces. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td> <td width="60%"> The Bluetooth
    ///namespace. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The domain name
    ///system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
    ///<dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace identifier is supported
    ///on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
    ///<dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA) namespace. This
    ///namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The
    ///peer-to-peer name space for a specific peer name. This namespace identifier is supported on Windows Vista and
    ///later. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
    ///<dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td width="60%"> The peer-to-peer name space for a collection of peer
    ///names. This namespace identifier is supported on Windows Vista and later. </td> </tr> </table>
    uint          dwNameSpace;
    ///Type: <b>LPGUID</b> A pointer to an optional GUID of a specific namespace provider to query in the case where
    ///multiple namespace providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for
    ///a specific namespace provider will result in only the specified namespace provider being queried. The
    ///WSAEnumNameSpaceProviders and WSAEnumNameSpaceProvidersEx functions can be called to retrieve the GUID for a
    ///namespace provider.
    GUID*         lpNSProviderId;
    ///Type: <b>LPTSTR</b> A pointer to an optional starting point of the query in a hierarchical namespace.
    const(wchar)* lpszContext;
    ///Type: <b>DWORD</b> The size, in bytes, of the protocol constraint array. This member can be zero.
    uint          dwNumberOfProtocols;
    ///Type: <b>LPAFPROTOCOLS</b> A pointer to an optional array of AFPROTOCOLS structures. Only services that utilize
    ///these protocols will be returned.
    AFPROTOCOLS*  lpafpProtocols;
    ///Type: <b>LPTSTR</b> A pointer to an optional NULL-terminated query string. Some namespaces, such as Whois++,
    ///support enriched SQL-like queries that are contained in a simple text string. This parameter is used to specify
    ///that string.
    const(wchar)* lpszQueryString;
    ///Type: <b>DWORD</b> This member is ignored for queries.
    uint          dwNumberOfCsAddrs;
    ///Type: <b>LPCSADDR_INFO</b> This member is ignored for queries.
    CSADDR_INFO*  lpcsaBuffer;
    ///Type: <b>DWORD</b> This member is ignored for queries.
    uint          dwOutputFlags;
    ///Type: <b>LPBLOB</b> An optional pointer to data that is used to query or set provider-specific namespace
    ///information. The format of this information is specific to the namespace provider.
    BLOB*         lpBlob;
}

///The <b>WSAQUERYSET2</b> structure provides relevant information about a given service, including service class ID,
///service name , applicable namespace identifier and protocol information, as well as a set of transport addresses at
///which the service listens.
struct WSAQUERYSET2A
{
    ///Type: <b>DWORD</b> The size, in bytes, of the <b>WSAQUERYSET2</b> structure. This member is used as a versioning
    ///mechanism since the size of the <b>WSAQUERYSET2</b> structure may change on later versions of Windows.
    uint         dwSize;
    ///Type: <b>LPTSTR</b> A pointer to an optional <b>NULL</b>-terminated string that contains service name. The
    ///semantics for using wildcards within the string are not defined, but can be supported by certain namespace
    ///providers.
    const(char)* lpszServiceInstanceName;
    ///Type: <b>LPWSAVERSION</b> A pointer to an optional desired version number of the namespace provider. This member
    ///provides version comparison semantics (that is, the version requested must match exactly, or version must be not
    ///less than the value supplied).
    WSAVERSION*  lpVersion;
    ///Type: <b>LPTSTR</b> This member is ignored for queries.
    const(char)* lpszComment;
    ///Type: <b>DWORD</b> A namespace identifier that determines which namespace providers are queried. Passing a
    ///specific namespace identifier will result in only namespace providers that support the specified namespace being
    ///queried. Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried.
    ///Options for the <b>dwNameSpace</b> member are listed in the <i>Winsock2.h</i> include file. Several new namespace
    ///providers are included with Windows Vista and later. Other namespace providers can be installed, so the following
    ///possible values are only those commonly available. Many other values are possible. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl> <dt><b>NS_ALL</b></dt>
    ///</dl> </td> <td width="60%"> All installed and active namespaces. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td> <td width="60%"> The Bluetooth
    ///namespace. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The domain name
    ///system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
    ///<dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace identifier is supported
    ///on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
    ///<dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA) namespace. This
    ///namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The
    ///peer-to-peer name space for a specific peer name. This namespace identifier is supported on Windows Vista and
    ///later. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
    ///<dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td width="60%"> The peer-to-peer name space for a collection of peer
    ///names. This namespace identifier is supported on Windows Vista and later. </td> </tr> </table>
    uint         dwNameSpace;
    ///Type: <b>LPGUID</b> A pointer to an optional GUID of a specific namespace provider to query in the case where
    ///multiple namespace providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for
    ///a specific namespace provider will result in only the specified namespace provider being queried. The
    ///WSAEnumNameSpaceProviders and WSAEnumNameSpaceProvidersEx functions can be called to retrieve the GUID for a
    ///namespace provider.
    GUID*        lpNSProviderId;
    ///Type: <b>LPTSTR</b> A pointer to an optional starting point of the query in a hierarchical namespace.
    const(char)* lpszContext;
    ///Type: <b>DWORD</b> The size, in bytes, of the protocol constraint array. This member can be zero.
    uint         dwNumberOfProtocols;
    ///Type: <b>LPAFPROTOCOLS</b> A pointer to an optional array of AFPROTOCOLS structures. Only services that utilize
    ///these protocols will be returned.
    AFPROTOCOLS* lpafpProtocols;
    ///Type: <b>LPTSTR</b> A pointer to an optional <b>NULL</b>-terminated query string. Some namespaces, such as
    ///Whois++, support enriched SQL-like queries that are contained in a simple text string. This parameter is used to
    ///specify that string.
    const(char)* lpszQueryString;
    ///Type: <b>DWORD</b> This member is ignored for queries.
    uint         dwNumberOfCsAddrs;
    ///Type: <b>LPCSADDR_INFO</b> This member is ignored for queries.
    CSADDR_INFO* lpcsaBuffer;
    ///Type: <b>DWORD</b> This member is ignored for queries.
    uint         dwOutputFlags;
    ///Type: <b>LPBLOB</b> An optional pointer to data that is used to query or set provider-specific namespace
    ///information. The format of this information is specific to the namespace provider.
    BLOB*        lpBlob;
}

///The <b>WSAQUERYSET2</b> structure provides relevant information about a given service, including service class ID,
///service name , applicable namespace identifier and protocol information, as well as a set of transport addresses at
///which the service listens.
struct WSAQUERYSET2W
{
    ///Type: <b>DWORD</b> The size, in bytes, of the <b>WSAQUERYSET2</b> structure. This member is used as a versioning
    ///mechanism since the size of the <b>WSAQUERYSET2</b> structure may change on later versions of Windows.
    uint          dwSize;
    ///Type: <b>LPTSTR</b> A pointer to an optional <b>NULL</b>-terminated string that contains service name. The
    ///semantics for using wildcards within the string are not defined, but can be supported by certain namespace
    ///providers.
    const(wchar)* lpszServiceInstanceName;
    ///Type: <b>LPWSAVERSION</b> A pointer to an optional desired version number of the namespace provider. This member
    ///provides version comparison semantics (that is, the version requested must match exactly, or version must be not
    ///less than the value supplied).
    WSAVERSION*   lpVersion;
    ///Type: <b>LPTSTR</b> This member is ignored for queries.
    const(wchar)* lpszComment;
    ///Type: <b>DWORD</b> A namespace identifier that determines which namespace providers are queried. Passing a
    ///specific namespace identifier will result in only namespace providers that support the specified namespace being
    ///queried. Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried.
    ///Options for the <b>dwNameSpace</b> member are listed in the <i>Winsock2.h</i> include file. Several new namespace
    ///providers are included with Windows Vista and later. Other namespace providers can be installed, so the following
    ///possible values are only those commonly available. Many other values are possible. <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl> <dt><b>NS_ALL</b></dt>
    ///</dl> </td> <td width="60%"> All installed and active namespaces. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td> <td width="60%"> The Bluetooth
    ///namespace. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The domain name
    ///system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
    ///<dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace identifier is supported
    ///on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
    ///<dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA) namespace. This
    ///namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The
    ///peer-to-peer name space for a specific peer name. This namespace identifier is supported on Windows Vista and
    ///later. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
    ///<dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td width="60%"> The peer-to-peer name space for a collection of peer
    ///names. This namespace identifier is supported on Windows Vista and later. </td> </tr> </table>
    uint          dwNameSpace;
    ///Type: <b>LPGUID</b> A pointer to an optional GUID of a specific namespace provider to query in the case where
    ///multiple namespace providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for
    ///a specific namespace provider will result in only the specified namespace provider being queried. The
    ///WSAEnumNameSpaceProviders and WSAEnumNameSpaceProvidersEx functions can be called to retrieve the GUID for a
    ///namespace provider.
    GUID*         lpNSProviderId;
    ///Type: <b>LPTSTR</b> A pointer to an optional starting point of the query in a hierarchical namespace.
    const(wchar)* lpszContext;
    ///Type: <b>DWORD</b> The size, in bytes, of the protocol constraint array. This member can be zero.
    uint          dwNumberOfProtocols;
    ///Type: <b>LPAFPROTOCOLS</b> A pointer to an optional array of AFPROTOCOLS structures. Only services that utilize
    ///these protocols will be returned.
    AFPROTOCOLS*  lpafpProtocols;
    ///Type: <b>LPTSTR</b> A pointer to an optional <b>NULL</b>-terminated query string. Some namespaces, such as
    ///Whois++, support enriched SQL-like queries that are contained in a simple text string. This parameter is used to
    ///specify that string.
    const(wchar)* lpszQueryString;
    ///Type: <b>DWORD</b> This member is ignored for queries.
    uint          dwNumberOfCsAddrs;
    ///Type: <b>LPCSADDR_INFO</b> This member is ignored for queries.
    CSADDR_INFO*  lpcsaBuffer;
    ///Type: <b>DWORD</b> This member is ignored for queries.
    uint          dwOutputFlags;
    ///Type: <b>LPBLOB</b> An optional pointer to data that is used to query or set provider-specific namespace
    ///information. The format of this information is specific to the namespace provider.
    BLOB*         lpBlob;
}

///The <b>WSANSCLASSINFO</b> structure provides individual parameter information for a specific Windows Sockets
///namespace.
struct WSANSCLASSINFOA
{
    ///String value associated with the parameter, such as SAPID, TCPPORT, and so forth.
    const(char)* lpszName;
    ///GUID associated with the namespace.
    uint         dwNameSpace;
    ///Value type for the parameter, such as REG_DWORD or REG_SZ, and so forth.
    uint         dwValueType;
    ///Size of the parameter provided in <b>lpValue</b>, in bytes.
    uint         dwValueSize;
    ///Pointer to the value of the parameter.
    void*        lpValue;
}

///The <b>WSANSCLASSINFO</b> structure provides individual parameter information for a specific Windows Sockets
///namespace.
struct WSANSCLASSINFOW
{
    ///String value associated with the parameter, such as SAPID, TCPPORT, and so forth.
    const(wchar)* lpszName;
    ///GUID associated with the namespace.
    uint          dwNameSpace;
    ///Value type for the parameter, such as REG_DWORD or REG_SZ, and so forth.
    uint          dwValueType;
    ///Size of the parameter provided in <b>lpValue</b>, in bytes.
    uint          dwValueSize;
    ///Pointer to the value of the parameter.
    void*         lpValue;
}

///The <b>WSASERVICECLASSINFO</b> structure contains information about a specified service class. For each service class
///in Windows Sockets 2, there is a single <b>WSASERVICECLASSINFO</b> structure.
struct WSASERVICECLASSINFOA
{
    ///Unique Identifier (GUID) for the service class.
    GUID*            lpServiceClassId;
    ///Well known name associated with the service class.
    const(char)*     lpszServiceClassName;
    ///Number of entries in <b>lpClassInfos</b>.
    uint             dwCount;
    ///Array of WSANSCLASSINFO structures that contains information about the service class.
    WSANSCLASSINFOA* lpClassInfos;
}

///The <b>WSASERVICECLASSINFO</b> structure contains information about a specified service class. For each service class
///in Windows Sockets 2, there is a single <b>WSASERVICECLASSINFO</b> structure.
struct WSASERVICECLASSINFOW
{
    ///Unique Identifier (GUID) for the service class.
    GUID*            lpServiceClassId;
    ///Well known name associated with the service class.
    const(wchar)*    lpszServiceClassName;
    ///Number of entries in <b>lpClassInfos</b>.
    uint             dwCount;
    ///Array of WSANSCLASSINFO structures that contains information about the service class.
    WSANSCLASSINFOW* lpClassInfos;
}

///The <b>WSANAMESPACE_INFO</b> structure contains all registration information for a namespace provider.
struct WSANAMESPACE_INFOA
{
    ///Type: <b>GUID</b> A unique GUID for this namespace provider.
    GUID         NSProviderId;
    ///Type: <b>DWORD</b> The namespace supported by this provider. Possible values for the <b>dwNameSpace</b> member
    ///are listed in the <i>Winsock2.h</i> include file. Several namespace providers are included with Windows Vista and
    ///later. Other namespace providers can be installed, so the following possible values are only those commonly
    ///available. Many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td> <td width="60%"> The
    ///Bluetooth namespace. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The
    ///domain name system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a
    ///id="ns_email"></a><dl> <dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace
    ///identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a
    ///id="ns_nla"></a><dl> <dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA)
    ///namespace. This namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_NTDS"></a><a id="ns_ntds"></a><dl> <dt><b>NS_NTDS</b></dt> </dl> </td> <td width="60%"> The Windows NT
    ///directory service (NTDS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPNAME"></a><a
    ///id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The peer-to-peer name space
    ///for a specific peer name. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl> <dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td
    ///width="60%"> The peer-to-peer name space for a collection of peer names. This namespace identifier is supported
    ///on Windows Vista and later. </td> </tr> </table>
    uint         dwNameSpace;
    ///Type: <b>BOOL</b> If <b>TRUE</b>, indicates that this namespace provider is active. If <b>FALSE</b>, the
    ///namespace provider is inactive and is not accessible for queries, even if the query specifically references this
    ///namespace provider.
    BOOL         fActive;
    ///Type: <b>DWORD</b> The version number of the namespace provider.
    uint         dwVersion;
    ///Type: <b>LPTSTR</b> A display string that identifies the namespace provider.
    const(char)* lpszIdentifier;
}

///The <b>WSANAMESPACE_INFO</b> structure contains all registration information for a namespace provider.
struct WSANAMESPACE_INFOW
{
    ///Type: <b>GUID</b> A unique GUID for this namespace provider.
    GUID          NSProviderId;
    ///Type: <b>DWORD</b> The namespace supported by this provider. Possible values for the <b>dwNameSpace</b> member
    ///are listed in the <i>Winsock2.h</i> include file. Several namespace providers are included with Windows Vista and
    ///later. Other namespace providers can be installed, so the following possible values are only those commonly
    ///available. Many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td> <td width="60%"> The
    ///Bluetooth namespace. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The
    ///domain name system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a
    ///id="ns_email"></a><dl> <dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace
    ///identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a
    ///id="ns_nla"></a><dl> <dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA)
    ///namespace. This namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_NTDS"></a><a id="ns_ntds"></a><dl> <dt><b>NS_NTDS</b></dt> </dl> </td> <td width="60%"> The Windows NT
    ///directory service (NTDS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPNAME"></a><a
    ///id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The peer-to-peer name space
    ///for a specific peer name. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl> <dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td
    ///width="60%"> The peer-to-peer name space for a collection of peer names. This namespace identifier is supported
    ///on Windows Vista and later. </td> </tr> </table>
    uint          dwNameSpace;
    ///Type: <b>BOOL</b> If <b>TRUE</b>, indicates that this namespace provider is active. If <b>FALSE</b>, the
    ///namespace provider is inactive and is not accessible for queries, even if the query specifically references this
    ///namespace provider.
    BOOL          fActive;
    ///Type: <b>DWORD</b> The version number of the namespace provider.
    uint          dwVersion;
    ///Type: <b>LPTSTR</b> A display string that identifies the namespace provider.
    const(wchar)* lpszIdentifier;
}

///The <b>WSANAMESPACE_INFOEX</b> structure contains all registration information for a namespace provider.
struct WSANAMESPACE_INFOEXA
{
    ///Type: <b>GUID</b> A unique GUID for this namespace provider.
    GUID         NSProviderId;
    ///Type: <b>DWORD</b> The namespace supported by this provider. Possible values for the <b>dwNameSpace</b> member
    ///are listed in the <i>Winsock2.h</i> include file. Several namespace providers are included with Windows Vista and
    ///later. Other namespace providers can be installed, so the following possible values are only those commonly
    ///available. Many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td> <td width="60%"> The
    ///Bluetooth namespace. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The
    ///domain name system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a
    ///id="ns_email"></a><dl> <dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace
    ///identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a
    ///id="ns_nla"></a><dl> <dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA)
    ///namespace. This namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_NTDS"></a><a id="ns_ntds"></a><dl> <dt><b>NS_NTDS</b></dt> </dl> </td> <td width="60%"> The Windows NT
    ///directory service (NTDS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPNAME"></a><a
    ///id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The peer-to-peer name space
    ///for a specific peer name. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl> <dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td
    ///width="60%"> The peer-to-peer name space for a collection of peer names. This namespace identifier is supported
    ///on Windows Vista and later. </td> </tr> </table>
    uint         dwNameSpace;
    ///Type: <b>BOOL</b> If <b>TRUE</b>, indicates that this namespace provider is active. If <b>FALSE</b>, the
    ///namespace provider is inactive and is not accessible for queries, even if the query specifically references this
    ///namespace provider.
    BOOL         fActive;
    ///Type: <b>DWORD</b> The version number of the namespace provider.
    uint         dwVersion;
    ///Type: <b>LPTSTR</b> A display string that identifies the namespace provider.
    const(char)* lpszIdentifier;
    ///Type: <b>BLOB</b> A provider-specific data blob associated with namespace entry.
    BLOB         ProviderSpecific;
}

///The <b>WSANAMESPACE_INFOEX</b> structure contains all registration information for a namespace provider.
struct WSANAMESPACE_INFOEXW
{
    ///Type: <b>GUID</b> A unique GUID for this namespace provider.
    GUID          NSProviderId;
    ///Type: <b>DWORD</b> The namespace supported by this provider. Possible values for the <b>dwNameSpace</b> member
    ///are listed in the <i>Winsock2.h</i> include file. Several namespace providers are included with Windows Vista and
    ///later. Other namespace providers can be installed, so the following possible values are only those commonly
    ///available. Many other values are possible. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td> <td width="60%"> The
    ///Bluetooth namespace. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The
    ///domain name system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a
    ///id="ns_email"></a><dl> <dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace
    ///identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a
    ///id="ns_nla"></a><dl> <dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA)
    ///namespace. This namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_NTDS"></a><a id="ns_ntds"></a><dl> <dt><b>NS_NTDS</b></dt> </dl> </td> <td width="60%"> The Windows NT
    ///directory service (NTDS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPNAME"></a><a
    ///id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The peer-to-peer name space
    ///for a specific peer name. This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl> <dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td
    ///width="60%"> The peer-to-peer name space for a collection of peer names. This namespace identifier is supported
    ///on Windows Vista and later. </td> </tr> </table>
    uint          dwNameSpace;
    ///Type: <b>BOOL</b> If <b>TRUE</b>, indicates that this namespace provider is active. If <b>FALSE</b>, the
    ///namespace provider is inactive and is not accessible for queries, even if the query specifically references this
    ///namespace provider.
    BOOL          fActive;
    ///Type: <b>DWORD</b> The version number of the namespace provider.
    uint          dwVersion;
    ///Type: <b>LPTSTR</b> A display string that identifies the namespace provider.
    const(wchar)* lpszIdentifier;
    ///Type: <b>BLOB</b> A provider-specific data blob associated with namespace entry.
    BLOB          ProviderSpecific;
}

///The <b>WSAPOLLFD</b> structure stores socket information used by the WSAPoll function.
struct WSAPOLLFD
{
    ///Type: <b>SOCKET</b> The identifier of the socket for which to find status. This parameter is ignored if set to a
    ///negative value. See Remarks.
    size_t fd;
    ///Type: <b>short</b> A set of flags indicating the type of status being requested. This must be one or more of the
    ///following. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td>POLLPRI</td> <td>Priority data may be read
    ///without blocking. This flag is not supported by the Microsoft Winsock provider.</td> </tr> <tr>
    ///<td>POLLRDBAND</td> <td>Priority band (out-of-band) data can be read without blocking.</td> </tr> <tr>
    ///<td>POLLRDNORM</td> <td>Normal data can be read without blocking.</td> </tr> <tr> <td>POLLWRNORM</td> <td>Normal
    ///data can be written without blocking.</td> </tr> </table> The POLLIN flag is defined as the combination of the
    ///<b>POLLRDNORM</b> and <b>POLLRDBAND</b> flag values. The POLLOUT flag is defined as the same as the
    ///<b>POLLWRNORM</b> flag value.
    short  events;
    ///Type: <b>short</b> A set of flags that indicate, upon return from the WSAPoll function call, the results of the
    ///status query. This can a combination of the following flags. <table> <tr> <th>Flag</th> <th>Description</th>
    ///</tr> <tr> <td>POLLERR</td> <td>An error has occurred.</td> </tr> <tr> <td>POLLHUP</td> <td>A stream-oriented
    ///connection was either disconnected or aborted.</td> </tr> <tr> <td>POLLNVAL</td> <td>An invalid socket was
    ///used.</td> </tr> <tr> <td>POLLPRI</td> <td>Priority data may be read without blocking. This flag is not returned
    ///by the Microsoft Winsock provider.</td> </tr> <tr> <td>POLLRDBAND</td> <td>Priority band (out-of-band) data may
    ///be read without blocking.</td> </tr> <tr> <td>POLLRDNORM</td> <td>Normal data may be read without blocking.</td>
    ///</tr> <tr> <td>POLLWRNORM</td> <td>Normal data may be written without blocking.</td> </tr> </table> The POLLIN
    ///flag is defined as the combination of the <b>POLLRDNORM</b> and <b>POLLRDBAND</b> flag values. The POLLOUT flag
    ///is defined as the same as the <b>POLLWRNORM</b> flag value. For sockets that do not satisfy the status query, and
    ///have no error, the <b>revents</b> member is set to zero upon return.
    short  revents;
}

///The IN6_ADDR structure specifies an IPv6 transport address.
struct in6_addr
{
    union u
    {
        ubyte[16] Byte;
        ushort[8] Word;
    }
}

///The sockaddr structure varies depending on the protocol selected. Except for the <i>sin*_family</i> parameter,
///sockaddr contents are expressed in network byte order.
struct sockaddr_in6_old
{
    short    sin6_family;
    ushort   sin6_port;
    uint     sin6_flowinfo;
    in6_addr sin6_addr;
}

///The <b>sockaddr_gen</b> union provides generic socket address information, and is used with the INTERFACE_INFO
///structure.
union sockaddr_gen
{
    ///IP address information expressed in a sockaddr structure.
    SOCKADDR         Address;
    ///IP address information expressed in a sockaddr_in structure.
    sockaddr_in      AddressIn;
    ///IP address information expressed in a sockaddr_in6_old structure.
    sockaddr_in6_old AddressIn6;
}

///The <b>INTERFACE_INFO</b> structure is used in conjunction with the <b>SIO_GET_INTERFACE_LIST</b> ioctl command to
///obtain information about an interface IP address.
struct INTERFACE_INFO
{
    ///A bitmask describing the status of the interface. The following flags are possible. <table> <tr> <th>Flag</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IFF_UP"></a><a id="iff_up"></a><dl> <dt><b>IFF_UP</b></dt>
    ///</dl> </td> <td width="60%"> The interface is running. </td> </tr> <tr> <td width="40%"><a
    ///id="IFF_BROADCAST"></a><a id="iff_broadcast"></a><dl> <dt><b>IFF_BROADCAST</b></dt> </dl> </td> <td width="60%">
    ///The broadcast feature is supported. </td> </tr> <tr> <td width="40%"><a id="IFF_LOOPBACK"></a><a
    ///id="iff_loopback"></a><dl> <dt><b>IFF_LOOPBACK</b></dt> </dl> </td> <td width="60%"> The loopback interface is
    ///running. </td> </tr> <tr> <td width="40%"><a id="IFF_POINTTOPOINT"></a><a id="iff_pointtopoint"></a><dl>
    ///<dt><b>IFF_POINTTOPOINT</b></dt> </dl> </td> <td width="60%"> The interface is using point-to-point link. </td>
    ///</tr> <tr> <td width="40%"><a id="IFF_MULTICAST"></a><a id="iff_multicast"></a><dl> <dt><b>IFF_MULTICAST</b></dt>
    ///</dl> </td> <td width="60%"> The multicast feature is supported. </td> </tr> </table>
    uint         iiFlags;
    ///Address of an interface.
    sockaddr_gen iiAddress;
    ///Broadcast address of the interface or the address of the other side for point-to-point links.
    sockaddr_gen iiBroadcastAddress;
    ///Netmask used by the interface.
    sockaddr_gen iiNetmask;
}

///The <b>INTERFACE_INFO_EX</b> structure is used in conjunction with the <b>SIO_GET_INTERFACE_LIST IOCTL</b> command to
///obtain information about an interface IP address. Unlike the INTERFACE_INFO structure, <b>INTERFACE_INFO_EX</b> is
///address-size independent, enabling it to work with IPv6.
struct INTERFACE_INFO_EX
{
    ///Bitmask describing the status of the interface. The following flags are possible. <table> <tr> <th>Flag</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="IFF_UP"></a><a id="iff_up"></a><dl> <dt><b>IFF_UP</b></dt>
    ///</dl> </td> <td width="60%"> The interface is running. </td> </tr> <tr> <td width="40%"><a
    ///id="IFF_BROADCAST"></a><a id="iff_broadcast"></a><dl> <dt><b>IFF_BROADCAST</b></dt> </dl> </td> <td width="60%">
    ///The broadcast feature is supported. </td> </tr> <tr> <td width="40%"><a id="IFF_LOOPBACK"></a><a
    ///id="iff_loopback"></a><dl> <dt><b>IFF_LOOPBACK</b></dt> </dl> </td> <td width="60%"> The loopback interface is
    ///running. </td> </tr> <tr> <td width="40%"><a id="IFF_POINTTOPOINT"></a><a id="iff_pointtopoint"></a><dl>
    ///<dt><b>IFF_POINTTOPOINT</b></dt> </dl> </td> <td width="60%"> The interface is using point-to-point link. </td>
    ///</tr> <tr> <td width="40%"><a id="IFF_MULTICAST"></a><a id="iff_multicast"></a><dl> <dt><b>IFF_MULTICAST</b></dt>
    ///</dl> </td> <td width="60%"> The multicast feature is supported. </td> </tr> </table>
    uint           iiFlags;
    ///Address of an interface.
    SOCKET_ADDRESS iiAddress;
    ///Broadcast address of the interface or the address of the other side for point-to-point links.
    SOCKET_ADDRESS iiBroadcastAddress;
    ///Netmask used by the interface.
    SOCKET_ADDRESS iiNetmask;
}

///The SOCKADDR_IN6 structure specifies a transport address and port for the AF_INET6 address family.
struct sockaddr_in6_w2ksp1
{
    ///The address family for the transport address. This member should always be set to AF_INET6.
    short    sin6_family;
    ///A transport protocol port number.
    ushort   sin6_port;
    ///The IPv6 flow information.
    uint     sin6_flowinfo;
    ///An IN6_ADDR structure that contains an IPv6 transport address.
    in6_addr sin6_addr;
    ///A ULONG representation of the IPv6 scope identifier that is defined in the <b>sin6_scope_struct</b> member.
    uint     sin6_scope_id;
}

///The <b>ip_mreq</b> structure provides multicast group information for IPv4 addresses.
struct ip_mreq
{
    ///The address of the IPv4 multicast group.
    in_addr imr_multiaddr;
    ///The local IPv4 address of the interface or the interface index on which the multicast group should be joined or
    ///dropped. This value is in network byte order. If this member specifies an IPv4 address of 0.0.0.0, the default
    ///IPv4 multicast interface is used. To use an interface index of 1 would be the same as an IP address of 0.0.0.1.
    in_addr imr_interface;
}

///The <b>ip_mreq_source</b> structure provides multicast group information for IPv4 addresses.
struct ip_mreq_source
{
    ///The address of the IPv4 multicast group.
    in_addr imr_multiaddr;
    ///The address of the IPv4 multicast source.
    in_addr imr_sourceaddr;
    ///The local IPv4 address of the interface or the interface index on which the multicast group should be joined,
    ///dropped, blocked, or unblocked. This value is in network byte order. If this member specifies an IPv4 address of
    ///0.0.0.0, the default IPv4 multicast interface is used. To use an interface index of 1 would be the same as an IP
    ///address of 0.0.0.1.
    in_addr imr_interface;
}

///The <b>ip_msfilter</b> structure provides multicast filtering parameters for IPv4 addresses.
struct ip_msfilter
{
    ///The IPv4 address of the multicast group.
    in_addr             imsf_multiaddr;
    ///The local IPv4 address of the interface or the interface index on which the multicast group should be filtered.
    ///This value is in network byte order. If this member specifies an IPv4 address of 0.0.0.0, the default IPv4
    ///multicast interface is used. To use an interface index of 1 would be the same as an IP address of 0.0.0.1.
    in_addr             imsf_interface;
    ///The multicast filter mode to be used. This parameter can be either MCAST_INCLUDE (value of 0) to include
    ///particular multicast sources, or MCAST_EXCLUDE (value of 1) to exclude traffic from specified sources. On Windows
    ///Server 2003 and Windows XP, these values are defined in the <i>Ws2tcpip.h</i> header file. On Windows Vistaand
    ///later, these values are defined as enumeration values in the MULTICAST_MODE_TYPE enumeration defined in the
    ///<i>Ws2ipdef.h</i> header file.
    MULTICAST_MODE_TYPE imsf_fmode;
    ///The number of sources in the <b>imsf_slist</b> member.
    uint                imsf_numsrc;
    ///An array of in_addr structures that specify the IPv4 multicast source addresses to include or exclude.
    in_addr[1]          imsf_slist;
}

///The <b>ipv6_mreq</b> structure provides multicast group information for IPv6 addresses.
struct ipv6_mreq
{
    ///The address of the IPv6 multicast group.
    in6_addr ipv6mr_multiaddr;
    ///The interface index of the local interface on which the multicast group should be joined or dropped. If this
    ///member specifies an interface index of 0, the default multicast interface is used.
    uint     ipv6mr_interface;
}

///The <b>GROUP_REQ</b> structure provides multicast group information for IPv6 or IPv4 addresses.
struct group_req
{
    ///The interface index of the local interface on which the multicast group should be joined or dropped.
    uint                gr_interface;
    ///The address of the multicast group. This may be either an IPv6 or IPv4 multicast address.
    SOCKADDR_STORAGE_LH gr_group;
}

///The <b>GROUP_SOURCE_REQ</b> structure provides multicast group information for IPv6 or IPv4 addresses that includes
///the source IP address.
struct group_source_req
{
    ///The interface index of the local interface on which the multicast group should be joined, dropped, blocked, or
    ///unblocked.
    uint                gsr_interface;
    ///The address of the multicast group. This may be either an IPv6 or IPv4 multicast address.
    SOCKADDR_STORAGE_LH gsr_group;
    ///The source address that should be used. This may be either an IPv6 or IPv4 multicast address, but it must be the
    ///same address family (IPv6 or IPv4) as the address specified in the <b>gsr_group</b> member.
    SOCKADDR_STORAGE_LH gsr_source;
}

///The <b>GROUP_FILTER</b> structure provides multicast filtering parameters for multicast IPv6 or IPv4 addresses.
struct group_filter
{
    ///The interface index of the local interface for the multicast group to filter.
    uint                gf_interface;
    ///The multicast address group that should be filtered. This may be either an IPv6 or IPv4 multicast address.
    SOCKADDR_STORAGE_LH gf_group;
    ///The multicast filter mode. This member can be one of the values from the MULTICAST_MODE_TYPE enumeration type
    ///defined in the <i>Ws2ipdef.h</i> header file. This member determines if the list of IP addresses in the
    ///<b>gf_numsrc</b> member should be included or excluded. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="MCAST_INCLUDE"></a><a id="mcast_include"></a><dl> <dt><b>MCAST_INCLUDE</b></dt> </dl>
    ///</td> <td width="60%"> The filter contains a list of IP addresses to include. </td> </tr> <tr> <td width="40%"><a
    ///id="_MCAST_EXCLUDE"></a><a id="_mcast_exclude"></a><dl> <dt><b> MCAST_EXCLUDE</b></dt> </dl> </td> <td
    ///width="60%"> The filter contains a list of IP addresses to exclude. </td> </tr> </table>
    MULTICAST_MODE_TYPE gf_fmode;
    ///The number of multicast filter source address entries in the <b>gf_slist</b> member.
    uint                gf_numsrc;
    ///An array of SOCKADDR_STORAGE structures specifying the multicast source addresses to include or exclude. These IP
    ///addresses may be either IPv6 or IPv4 addresses, but they must be the same address family (IPv6 or IPv4) as the
    ///address specified in the <b>gf_group</b> member..
    SOCKADDR_STORAGE_LH[1] gf_slist;
}

///The <b>in_pktinfo</b> structure is used to store received packet address information, and is used by Windows to
///return information about received packets and also allows specifying the local IPv4 address to use for sending
///packets.
struct in_pktinfo
{
    ///The destination IPv4 address from the IP header of the received packet when used with the LPFN_WSARECVMSG
    ///(WSARecvMsg)function. The local source IPv4 address to set in the IP header when used with the WSASendMsg
    ///function.
    in_addr ipi_addr;
    ///The interface on which the packet was received when used with the LPFN_WSARECVMSG (WSARecvMsg)function. The
    ///interface on which the packet should be sent when used with the WSASendMsg function.
    uint    ipi_ifindex;
}

///The <b>in6_pktinfo</b> structure is used to store received IPv6 packet address information, and is used by Windows to
///return information about received packets and also allows specifying the local IPv6 address to use for sending
///packets.
struct in6_pktinfo
{
    ///The destination IPv6 address from the IP header of the received packet when used with the LPFN_WSARECVMSG
    ///(WSARecvMsg)function. The local source IPv6 address to set in the IP header when used with the WSASendMsg
    ///function.
    in6_addr ipi6_addr;
    ///The interface on which the packet was received when used with the LPFN_WSARECVMSG (WSARecvMsg)function. The
    ///interface on which the packet should be sent when used with the WSASendMsg function.
    uint     ipi6_ifindex;
}

struct in_pktinfo_ex
{
    in_pktinfo pkt_info;
    SCOPE_ID   scope_id;
}

struct in6_pktinfo_ex
{
    in6_pktinfo pkt_info;
    SCOPE_ID    scope_id;
}

struct in_recverr
{
    IPPROTO protocol;
    uint    info;
    ubyte   type;
    ubyte   code;
}

///Used to store received ICMP error information.
struct icmp_error_info
{
    ///Type: **[SOCKADDR_INET](./ns-ws2ipdef-sockaddr_inet.md)** The source IP address of the ICMP error.
    SOCKADDR_INET srcaddress;
    ///Type: **IPPROTO** The protocol of the ICMP error (either **IPPROTO_ICMP** or **IPPROTO_ICMPV6**).
    IPPROTO       protocol;
    ///Type: **[UINT8](/windows/win32/winprog/windows-data-types)** The ICMP error type.
    ubyte         type;
    ///Type: **[UINT8](/windows/win32/winprog/windows-data-types)** The ICMP error code.
    ubyte         code;
}

///The <b>RM_SEND_WINDOW</b> structure specifies the Reliable Multicast send window. This structure is used with the
///RM_RATE_WINDOW_SIZE socket option.
struct RM_SEND_WINDOW
{
    ///Transmission rate for the send window, in kilobits per second.
    uint RateKbitsPerSec;
    ///Window size for the send window, in milliseconds.
    uint WindowSizeInMSecs;
    ///Window size for the session, in bytes.
    uint WindowSizeInBytes;
}

///The <b>RM_SENDER_STATS</b> structure provides statistical information for a Reliable Multicast sender session. This
///structure is used with the RM_SENDER_STATISTICS socket option.
struct RM_SENDER_STATS
{
    ///Type: <b>ULONGULONG</b> Number of client data bytes sent out.
    ulong DataBytesSent;
    ///Type: <b>ULONGULONG</b> Total bytes sent, consisting of source path message (SPM), original data (ODATA) and
    ///repair data (RDATA) sequences.
    ulong TotalBytesSent;
    ///Type: <b>ULONGULONG</b> Number of NAKs received.
    ulong NaksReceived;
    ///Type: <b>ULONGULONG</b> Number of NAKs received after the send window advanced beyond the NAK'ed sequence.
    ulong NaksReceivedTooLate;
    ///Type: <b>ULONGULONG</b> Number of NAKs for which responses have not been sent.
    ulong NumOutstandingNaks;
    ///Type: <b>ULONGULONG</b> Number of NAKs after repair data (RDATA) sequences were sent for which responses have not
    ///been sent.
    ulong NumNaksAfterRData;
    ///Type: <b>ULONGULONG</b> Number of repair data (RDATA) packets sent.
    ulong RepairPacketsSent;
    ///Type: <b>ULONGULONG</b> Number of partial messages dropped.
    ulong BufferSpaceAvailable;
    ///Type: <b>ULONGULONG</b> Oldest sequence identifier in the send window.
    ulong TrailingEdgeSeqId;
    ///Type: <b>ULONGULONG</b> Newest sequence identifier in the send window.
    ulong LeadingEdgeSeqId;
    ///Type: <b>ULONGULONG</b> Internally calculated send rate from the beginning of the session, in kilobits per
    ///second.
    ulong RateKBitsPerSecOverall;
    ///Type: <b>ULONGULONG</b> Send rate for the period specified by INTERNAL_RATE_CALCULATION_FREQUENCY.
    ulong RateKBitsPerSecLast;
    ///Type: <b>ULONGULONG</b> Total original data (ODATA) packets sent.
    ulong TotalODataPacketsSent;
}

///The <b>RM_RECEIVER_STATS</b> structure provides statistical information for a Reliable Multicast receiver session.
///This structure is used with the RM_RECEIVER_STATISTICS socket option.
struct RM_RECEIVER_STATS
{
    ///Type: <b>ULONGULONG</b> The number of original data (ODATA) sequences received.
    ulong NumODataPacketsReceived;
    ///Type: <b>ULONGULONG</b> The number of repair data (RDATA) sequences received.
    ulong NumRDataPacketsReceived;
    ///Type: <b>ULONGULONG</b> The number of duplicate sequences received.
    ulong NumDuplicateDataPackets;
    ///Type: <b>ULONGULONG</b> The number of data bytes received.
    ulong DataBytesReceived;
    ///Type: <b>ULONGULONG</b> The total bytes received, consisting of source path message (SPM), original data (ODATA)
    ///and repair data (RDATA) sequences.
    ulong TotalBytesReceived;
    ///Type: <b>ULONGULONG</b> An internally calculated receive rate from the beginning of the session, in kilobits per
    ///second.
    ulong RateKBitsPerSecOverall;
    ///Type: <b>ULONGULONG</b> The receive rate for the period specified by INTERNAL_RATE_CALCULATION_FREQUENCY.
    ulong RateKBitsPerSecLast;
    ///Type: <b>ULONGULONG</b> The oldest sequence identifier in the receive window.
    ulong TrailingEdgeSeqId;
    ///Type: <b>ULONGULONG</b> The newest sequence identifier in the receive window.
    ulong LeadingEdgeSeqId;
    ///Type: <b>ULONGULONG</b> The average number of sequences in the receive window.
    ulong AverageSequencesInWindow;
    ///Type: <b>ULONGULONG</b> The minimum number of sequences in the receive window.
    ulong MinSequencesInWindow;
    ///Type: <b>ULONGULONG</b> The maximum number of sequences in the receive window.
    ulong MaxSequencesInWindow;
    ///Type: <b>ULONGULONG</b> The sequence number for the first outstanding negative acknowledgment (NAK).
    ulong FirstNakSequenceNumber;
    ///Type: <b>ULONGULONG</b> The number of sequences awaiting a NAK confirmation.
    ulong NumPendingNaks;
    ///Type: <b>ULONGULONG</b> The number of sequences awaiting repair data (RDATA).
    ulong NumOutstandingNaks;
    ///Type: <b>ULONGULONG</b> The number of packets currently buffered.
    ulong NumDataPacketsBuffered;
    ///Type: <b>ULONGULONG</b> The number of selective NAKs sent this session.
    ulong TotalSelectiveNaksSent;
    ///Type: <b>ULONGULONG</b> The number of parity NAKs sent this session.
    ulong TotalParityNaksSent;
}

///The <b>RM_FEC_INFO</b> structure specifies settings for using forward error correction (FEC) with Reliable Multicast.
///This structure is used with the RM_USE_FEC socket option.
struct RM_FEC_INFO
{
    ///Maximum number of packets that can be sent for any group, including original data and parity packets. Maximum and
    ///default value is 255.
    ushort FECBlockSize;
    ///Number of packets to send proactively with each group. Use this option when the network is dispersed, and
    ///upstream NAK requests would have an impact on throughput.
    ushort FECProActivePackets;
    ///Number of packets to be treated as one group for the purpose of computing parity packets. Group size must be a
    ///power of two. In lossy networks, keep the group size relatively small.
    ubyte  FECGroupSize;
    ///Specifies whether the sender is enabled for sending parity repair packets. When <b>TRUE</b>, receivers should
    ///only request parity repair packets.
    ubyte  fFECOnDemandParityEnabled;
}

///The <b>IPX_ADDRESS_DATA</b> structure provides information about a specific adapter to which IPX is bound. Used in
///conjunction with getsockopt function calls that specify IPX_ADDRESS in the <i>optname</i> parameter.
struct IPX_ADDRESS_DATA
{
    ///0-based adapter number.
    int      adapternum;
    ///IPX network number for the associated adapter.
    ubyte[4] netnum;
    ///IPX node address for the associated adapter.
    ubyte[6] nodenum;
    ///Specifies whether the adapter is on a wide area network (WAN) link. When <b>TRUE</b>, the adapter is on a WAN
    ///link.
    ubyte    wan;
    ///Specifies whether the WAN link is up. <b>FALSE</b> indicates that the WAN link is up or the adapter is not on a
    ///WAN. Compare with the <b>wan</b> member to determine the meaning.
    ubyte    status;
    ///Maximum allowable packet size, excluding the IPX header.
    int      maxpkt;
    ///Link speed, returned in 100 byte-per-second increments. For example, a 9600 byte-per-second link would return a
    ///value of 96.
    uint     linkspeed;
}

///The <b>IPX_NETNUM_DATA</b> structure provides information about a specified IPX network number. Used in conjunction
///with getsockopt function calls that specify IPX_GETNETINFO in the <i>optname</i> parameter.
struct IPX_NETNUM_DATA
{
    ///IPX network number for which information is being requested.
    ubyte[4] netnum;
    ///Number of hops to the IPX network being queried, in machine order.
    ushort   hopcount;
    ///Network delay tick count required to reach the IPX network, in machine order.
    ushort   netdelay;
    ///Adapter number used to reach the IPX network. The adapter number is zero based, such that if eight adapters are
    ///on a given computer, they are numbered 0-7.
    int      cardnum;
    ///Media Access Control (MAC) address of the next-hop router in the path between the computer and the IPX network.
    ///This value is zero if the computer is directly attached to the IPX network.
    ubyte[6] router;
}

///The <b>IPX_SPXCONNSTATUS_DATA</b> structure provides information about a connected SPX socket. Used in conjunction
///with getsockopt function calls that specify IPX_SPXGETCONNECTIONSTATUS in the <i>optname</i> parameter. All numbers
///in <b>IPX_SPXCONNSTATUS_DATA</b> are in Novell (high-low) order.
struct IPX_SPXCONNSTATUS_DATA
{
    ///Specifies the connection state.
    ubyte    ConnectionState;
    ///Specifies whether watchdog capabilities are active.
    ubyte    WatchDogActive;
    ///Specifies the local connection ID.
    ushort   LocalConnectionId;
    ///Specifies the remote connection ID.
    ushort   RemoteConnectionId;
    ///Specifies the local sequence number.
    ushort   LocalSequenceNumber;
    ///Specifies the local acknowledgment (ACK) number.
    ushort   LocalAckNumber;
    ///Specifies the local allocation number.
    ushort   LocalAllocNumber;
    ///Specifies the remote acknowledgment (ACK) number.
    ushort   RemoteAckNumber;
    ///Specifies the remote allocation number.
    ushort   RemoteAllocNumber;
    ///Specifies the local socket.
    ushort   LocalSocket;
    ///Specifies the IPX address to which the local computer is attached.
    ubyte[6] ImmediateAddress;
    ///Specifies the network to which the remote host is attached.
    ubyte[4] RemoteNetwork;
    ///Specifies the remote node.
    ubyte[6] RemoteNode;
    ///Specifies the remote socket.
    ushort   RemoteSocket;
    ///Specifies the number of retransmissions.
    ushort   RetransmissionCount;
    ///Specifies the estimated round trip–time, in milliseconds, delay for a given packet.
    ushort   EstimatedRoundTripDelay;
    ///Specifies the number of retransmitted packets on the socket.
    ushort   RetransmittedPackets;
    ///Specifies the number of suppressed packets on the socket.
    ushort   SuppressedPacket;
}

struct LM_IRPARMS
{
    uint   nTXDataBytes;
    uint   nRXDataBytes;
    uint   nBaudRate;
    uint   thresholdTime;
    uint   discTime;
    ushort nMSLinkTurn;
    ubyte  nTXPackets;
    ubyte  nRXPackets;
}

///The <b>SOCKADDR_IRDA</b> structure is used in conjunction with IrDA socket operations, defined by address family
///AF_IRDA.
struct SOCKADDR_IRDA
{
    ///Address family. This member is always AF_IRDA.
    ushort   irdaAddressFamily;
    ///Device identifier (ID) of the IrDA device to which the client wants to issue the connect function call. Ignored
    ///by server applications.
    ubyte[4] irdaDeviceID;
    ///Well-known service name associated with a server application. Specified by servers during their bind function
    ///call.
    byte[25] irdaServiceName;
}

struct WINDOWS_IRDA_DEVICE_INFO
{
    ubyte[4] irdaDeviceID;
    byte[22] irdaDeviceName;
    ubyte    irdaDeviceHints1;
    ubyte    irdaDeviceHints2;
    ubyte    irdaCharSet;
}

struct WCE_IRDA_DEVICE_INFO
{
    ubyte[4] irdaDeviceID;
    byte[22] irdaDeviceName;
    ubyte[2] Reserved;
}

struct WINDOWS_DEVICELIST
{
    uint numDevice;
    WINDOWS_IRDA_DEVICE_INFO[1] Device;
}

struct WCE_DEVICELIST
{
    uint numDevice;
    WCE_IRDA_DEVICE_INFO[1] Device;
}

struct WINDOWS_IAS_SET
{
    byte[64]  irdaClassName;
    byte[256] irdaAttribName;
    uint      irdaAttribType;
    union irdaAttribute
    {
        int irdaAttribInt;
        struct irdaAttribOctetSeq
        {
            ushort      Len;
            ubyte[1024] OctetSeq;
        }
        struct irdaAttribUsrStr
        {
            ubyte      Len;
            ubyte      CharSet;
            ubyte[256] UsrStr;
        }
    }
}

struct WINDOWS_IAS_QUERY
{
    ubyte[4]  irdaDeviceID;
    byte[64]  irdaClassName;
    byte[256] irdaAttribName;
    uint      irdaAttribType;
    union irdaAttribute
    {
        int irdaAttribInt;
        struct irdaAttribOctetSeq
        {
            uint        Len;
            ubyte[1024] OctetSeq;
        }
        struct irdaAttribUsrStr
        {
            uint       Len;
            uint       CharSet;
            ubyte[256] UsrStr;
        }
    }
}

struct NL_PATH_BANDWIDTH_ROD
{
    ulong Bandwidth;
    ulong Instability;
    ubyte BandwidthPeaked;
}

///The <b>TRANSPORT_SETTING_ID</b> structure specifies the transport setting ID used by the SIO_APPLY_TRANSPORT_SETTING
///and SIO_QUERY_TRANSPORT_SETTING IOCTLs to apply or query the transport setting for a socket.
struct TRANSPORT_SETTING_ID
{
    ///The transport setting ID.
    GUID Guid;
}

struct tcp_keepalive
{
    uint onoff;
    uint keepalivetime;
    uint keepaliveinterval;
}

///The <b>REAL_TIME_NOTIFICATION_SETTING_INPUT</b> structure provides input settings to apply for the
///<b>REAL_TIME_NOTIFICATION_CAPABILITY</b> transport setting for a TCP socket that is used with ControlChannelTrigger
///to receive background network notifications in a Windows Store app.
struct REAL_TIME_NOTIFICATION_SETTING_INPUT
{
    ///The transort setting ID.
    TRANSPORT_SETTING_ID TransportSettingId;
    ///The realtime notification broker event GUID for this transport ID.
    GUID                 BrokerEventGuid;
}

struct REAL_TIME_NOTIFICATION_SETTING_INPUT_EX
{
    TRANSPORT_SETTING_ID TransportSettingId;
    GUID                 BrokerEventGuid;
    ubyte                Unmark;
}

///The REAL_TIME_NOTIFICATION_SETTING_OUTPUT structure provides the output settings from a query for the
///<b>REAL_TIME_NOTIFICATION_CAPABILITY</b> transport setting for a TCP socket that is used with ControlChannelTrigger
///to receive background network notifications in a Windows Store app.
struct REAL_TIME_NOTIFICATION_SETTING_OUTPUT
{
    ///The channel status for a socket that is used with the ControlChannelTrigger.
    CONTROL_CHANNEL_TRIGGER_STATUS ChannelStatus;
}

///<p class="CCE_Message">[Some information relates to pre-released product which may be substantially modified before
///it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information
///provided here.] The <b>ASSOCIATE_NAMERES_CONTEXT_INPUT</b> structure contains the transport setting ID and handle to
///a fully qualified domain name.
struct ASSOCIATE_NAMERES_CONTEXT_INPUT
{
    ///The transport setting ID.
    TRANSPORT_SETTING_ID TransportSettingId;
    ///Handle to a fully qualified domain name.
    ulong                Handle;
}

struct RCVALL_IF
{
    RCVALL_VALUE Mode;
    uint         Interface;
}

///The TCP_INITIAL_RTO_PARAMETERS structure specifies data used by the SIO_TCP_INITIAL_RTO IOCTL to configure initial
///re-transmission timeout (RTO) parameters to be used on the socket.
struct TCP_INITIAL_RTO_PARAMETERS
{
    ///Supplies the initial RTT in milliseconds.
    ushort Rtt;
    ///Supplies the number of retransmissions attempted before the connection setup fails.
    ubyte  MaxSynRetransmissions;
}

struct TCP_ICW_PARAMETERS
{
    TCP_ICW_LEVEL Level;
}

struct TCP_ACK_FREQUENCY_PARAMETERS
{
    ubyte TcpDelayedAckFrequency;
}

///Contains the Transmission Control Protocol (TCP) statistics that were collected for a socket.
struct TCP_INFO_v0
{
    ///A value from the TCPSTATE enumeration that indicates the state of the TCP connection.
    TCPSTATE State;
    ///The current maximum segment size (MSS) for the connection, in bytes.
    uint     Mss;
    ///The lifetime of the connection, in milliseconds.
    ulong    ConnectionTimeMs;
    ///<b>TRUE</b> if TCP time stamps are turned on for the connection; otherwise <b>FALSE</b>.
    ubyte    TimestampsEnabled;
    ///The current estimated round-trip time for the connection, in microseconds.
    uint     RttUs;
    ///The minimum sampled round trip time, in microseconds.
    uint     MinRttUs;
    ///The current number of sent bytes that are unacknowledged.
    uint     BytesInFlight;
    ///The size of the current congestion window, in bytes.
    uint     Cwnd;
    ///The size of the send window (SND.WND in RFC 793), in bytes.
    uint     SndWnd;
    ///The size of the receive window (RCV.WND in RFC 793), in bytes.
    uint     RcvWnd;
    ///The size of the current receive buffer, in bytes. The size of the receive buffer changes dynamically when
    ///autotuning is turned on for the receive window.
    uint     RcvBuf;
    ///The total number of bytes sent.
    ulong    BytesOut;
    ///The total number of bytes received.
    ulong    BytesIn;
    ///The total number of bytes reordered.
    uint     BytesReordered;
    ///The total number of bytes retransmitted.
    uint     BytesRetrans;
    ///The number of calls of the Fast Retransmit algorithm.
    uint     FastRetrans;
    ///The total number of duplicate acknowledgments received.
    uint     DupAcksIn;
    ///The total number of retransmission timeout episodes. Each episode can consist of multiple timeouts.
    uint     TimeoutEpisodes;
    ///The total number of retransmitted synchronize control flags (SYNs).
    ubyte    SynRetrans;
}

struct TCP_INFO_v1
{
    TCPSTATE State;
    uint     Mss;
    ulong    ConnectionTimeMs;
    ubyte    TimestampsEnabled;
    uint     RttUs;
    uint     MinRttUs;
    uint     BytesInFlight;
    uint     Cwnd;
    uint     SndWnd;
    uint     RcvWnd;
    uint     RcvBuf;
    ulong    BytesOut;
    ulong    BytesIn;
    uint     BytesReordered;
    uint     BytesRetrans;
    uint     FastRetrans;
    uint     DupAcksIn;
    uint     TimeoutEpisodes;
    ubyte    SynRetrans;
    uint     SndLimTransRwin;
    uint     SndLimTimeRwin;
    ulong    SndLimBytesRwin;
    uint     SndLimTransCwnd;
    uint     SndLimTimeCwnd;
    ulong    SndLimBytesCwnd;
    uint     SndLimTransSnd;
    uint     SndLimTimeSnd;
    ulong    SndLimBytesSnd;
}

///The <b>INET_PORT_RANGE</b> structure provides input data used by the SIO_ACQUIRE_PORT_RESERVATION IOCTL to acquire a
///runtime reservation for a block of TCP or UDP ports.
struct INET_PORT_RANGE
{
    ///The starting TCP or UDP port number. If this parameter is set to zero, the system will choose a starting TCP or
    ///UDP port number.
    ushort StartPort;
    ///The number of TCP or UDP port numbers to reserve.
    ushort NumberOfPorts;
}

///The <b>INET_PORT_RESERVATION_TOKEN</b> structure contains a port reservation token for a block of TCP or UDP ports.
struct INET_PORT_RESERVATION_TOKEN
{
    ///A port reservation token for a block of TCP or UDP ports.
    ulong Token;
}

///The <b>INET_PORT_RESERVATION_INSTANCE</b> structure contains a port reservation and a token for a block of TCP or UDP
///ports.
struct INET_PORT_RESERVATION_INSTANCE
{
    ///A runtime port reservation for a block of TCP or UDP ports. The INET_PORT_RESERVATION structure is typedefed to
    ///the INET_PORT_RANGE structure.
    INET_PORT_RANGE Reservation;
    ///A port reservation token for a block of TCP or UDP ports.
    INET_PORT_RESERVATION_TOKEN Token;
}

struct INET_PORT_RESERVATION_INFORMATION
{
    uint OwningPid;
}

///The <b>SOCKET_SECURITY_SETTINGS</b> structure specifies generic security requirements for a socket.
struct SOCKET_SECURITY_SETTINGS
{
    ///A SOCKET_SECURITY_PROTOCOL value that identifies the type of security protocol to be used on the socket.
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    ///A set of flags that allow applications to set specific security requirements on a socket. The possible values are
    ///defined in the <i>Mstcpip.h</i> header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="SOCKET_SETTINGS_GUARANTEE_ENCRYPTION"></a><a
    ///id="socket_settings_guarantee_encryption"></a><dl> <dt><b>SOCKET_SETTINGS_GUARANTEE_ENCRYPTION</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> Indicates that guaranteed encryption of traffic is required.
    ///This flag should be set if the default policy prefers methods of protection that do not use encryption. If this
    ///flag is set and encryption is not possible for any reason, no packets will be sent and a connection will not be
    ///established. </td> </tr> <tr> <td width="40%"><a id="SOCKET_SETTINGS_ALLOW_INSECURE"></a><a
    ///id="socket_settings_allow_insecure"></a><dl> <dt><b>SOCKET_SETTINGS_ALLOW_INSECURE</b></dt> <dt>0x00000002</dt>
    ///</dl> </td> <td width="60%"> Indicates that clear text connections are allowed. If this flag is set, some or all
    ///of the sent packets will be sent in clear text, especially if security with the peer could not be negotiated.
    ///<div class="alert"><b>Note</b> If this flag is not set, it is guaranteed that packets will never be sent in clear
    ///text, even if security negotiation fails.</div> <div> </div> </td> </tr> </table>
    uint SecurityFlags;
}

///The <b>SOCKET_SECURITY_SETTINGS_IPSEC</b> structure specifies various security requirements and settings that are
///specific to IPsec.
struct SOCKET_SECURITY_SETTINGS_IPSEC
{
    ///Type: <b>SOCKET_SECURITY_PROTOCOL</b> A SOCKET_SECURITY_PROTOCOL value that identifies the type of security
    ///protocol to be used on the socket. This member must be set to <b>SOCKET_SECURITY_PROTOCOL_IPSEC</b>.
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    ///Type: <b>ULONG</b> A set of flags that allow applications to set specific security requirements on a socket. The
    ///possible values are defined in the <i>Mstcpip.h</i> header file. <table> <tr> <th>Value</th> <th>Meaning</th>
    ///</tr> <tr> <td width="40%"><a id="SOCKET_SETTINGS_GUARANTEE_ENCRYPTION"></a><a
    ///id="socket_settings_guarantee_encryption"></a><dl> <dt><b>SOCKET_SETTINGS_GUARANTEE_ENCRYPTION</b></dt>
    ///<dt>0x00000001</dt> </dl> </td> <td width="60%"> Indicates that guaranteed encryption of traffic is required.
    ///This flag should be set if the default policy prefers methods of protection that do not use encryption. If this
    ///flag is set and encryption is not possible for any reason, no packets will be sent and a connection will not be
    ///established. </td> </tr> <tr> <td width="40%"><a id="SOCKET_SETTINGS_ALLOW_INSECURE"></a><a
    ///id="socket_settings_allow_insecure"></a><dl> <dt><b>SOCKET_SETTINGS_ALLOW_INSECURE</b></dt> <dt>0x00000002</dt>
    ///</dl> </td> <td width="60%"> Indicates that clear text connections are allowed. If this flag is set, some or all
    ///of the sent packets will be sent in clear text, especially if security with the peer could not be negotiated.
    ///<div class="alert"><b>Note</b> If this flag is not set, it is guaranteed that packets will never be sent in clear
    ///text, even if security negotiation fails.</div> <div> </div> </td> </tr> </table>
    uint      SecurityFlags;
    ///Type: <b>ULONG</b> Flags for IPsec security settings. The possible values are defined in the <i>Mstcpip.h</i>
    ///header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SOCKET_SETTINGS_IPSEC_SKIP_FILTER_INSTANTIATION"></a><a
    ///id="socket_settings_ipsec_skip_filter_instantiation"></a><dl>
    ///<dt><b>SOCKET_SETTINGS_IPSEC_SKIP_FILTER_INSTANTIATION</b></dt> <dt>0x00000001</dt> </dl> </td> <td width="60%">
    ///When this flag is set, IPsec filter instantiation is omitted for the socket. This flag should be set when an
    ///application knows that IPsec filters and policy already exist for its traffic. Applications running on a domain
    ///with IPsec policy in place can also set this flag. </td> </tr> </table>
    uint      IpsecFlags;
    ///Type: <b>GUID</b> The GUID for the Windows Filtering Platform key of the AuthIP main mode provider context. If an
    ///application wishes to use a custom main mode policy, it should first use the FwpmProviderContextAdd0 function to
    ///add the corresponding provider context and specify the returned key in this member. This field is ignored for a
    ///GUID of zero.
    GUID      AuthipMMPolicyKey;
    ///Type: <b>GUID</b> The Windows Filtering Platform key of the AuthIp quick mode provider context. If an application
    ///wishes to use a custom quick mode policy, it should first use the FwpmProviderContextAdd0 function to add the
    ///corresponding provider context and specify the returned key in this field. This field is ignored for a GUID of
    ///zero.
    GUID      AuthipQMPolicyKey;
    ///Type: <b>GUID</b> Reserved for future use.
    GUID      Reserved;
    ///Type: <b>UINT64</b> Reserved for future use.
    ulong     Reserved2;
    ///Type: <b>ULONG</b> The length, in bytes, of the user name in the <b>AllStrings</b> member.
    uint      UserNameStringLen;
    ///Type: <b>ULONG</b> The length, in bytes, of the domain name in the <b>AllStrings</b> member.
    uint      DomainNameStringLen;
    ///Type: <b>ULONG</b> The length, in bytes, of the password in the <b>AllStrings</b> member.
    uint      PasswordStringLen;
    ///Type: <b>wchar_t[]</b> A string that contains the user name, the domain name, and the password concatenated in
    ///this order.
    ushort[1] AllStrings;
}

///The <b>SOCKET_PEER_TARGET_NAME</b> structure contains the IP address and name for a peer target and the type of
///security protocol to be used on a socket.
struct SOCKET_PEER_TARGET_NAME
{
    ///A SOCKET_SECURITY_PROTOCOL value that identifies the type of protocol used to secure the traffic on the socket.
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    ///The IP address of the peer for the socket.
    SOCKADDR_STORAGE_LH PeerAddress;
    ///The length, in bytes, of the peer target name in the <b>AllStrings</b> member.
    uint                PeerTargetNameStringLen;
    ///The peer target name for the socket.
    ushort[1]           AllStrings;
}

///The <b>SOCKET_SECURITY_QUERY_TEMPLATE</b> structure contains the security template used by the WSAQuerySocketSecurity
///function.
struct SOCKET_SECURITY_QUERY_TEMPLATE
{
    ///A SOCKET_SECURITY_PROTOCOL value that identifies the protocol used to secure the traffic.
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    ///The IP address of the peer for which security information is being queried. For connection-oriented sockets
    ///(protocol of <b>IPPROTO_TCP</b>), the connected socket uniquely identifies a peer. In this case, this parameter
    ///is ignored.
    SOCKADDR_STORAGE_LH PeerAddress;
    ///The access mask used for opening the peer user application and computer token handles that are returned as part
    ///of the query information.
    uint                PeerTokenAccessMask;
}

struct SOCKET_SECURITY_QUERY_TEMPLATE_IPSEC2
{
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    SOCKADDR_STORAGE_LH PeerAddress;
    uint                PeerTokenAccessMask;
    uint                Flags;
    uint                FieldMask;
}

///The <b>SOCKET_SECURITY_QUERY_INFO</b> structure contains security information returned by the WSAQuerySocketSecurity
///function.
struct SOCKET_SECURITY_QUERY_INFO
{
    ///A SOCKET_SECURITY_PROTOCOL value that identifies the protocol used to secure the traffic.
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    ///The set of possible security flags for the connection defined in the <i>Mstcpip.h</i> header file. <table> <tr>
    ///<th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SOCKET_INFO_CONNECTION_SECURED"></a><a
    ///id="socket_info_connection_secured"></a><dl> <dt><b>SOCKET_INFO_CONNECTION_SECURED</b></dt> <dt>0x00000001</dt>
    ///</dl> </td> <td width="60%"> If present, traffic is being secured by a security protocol. If absent, the traffic
    ///is flowing in the clear. </td> </tr> <tr> <td width="40%"><a id="SOCKET_INFO_CONNECTION_ENCRYPTED"></a><a
    ///id="socket_info_connection_encrypted"></a><dl> <dt><b>SOCKET_INFO_CONNECTION_ENCRYPTED</b></dt>
    ///<dt>0x00000002</dt> </dl> </td> <td width="60%"> If present, the connection traffic is being encrypted. The
    ///<b>SOCKET_INFO_CONNECTION_SECURED</b> flag is always set when this flag is present. </td> </tr> </table>
    uint  Flags;
    ///A handle to the access token that represents the account under which the peer application is running. After using
    ///the token for access checks, the application should close the handle using the CloseHandle function.
    ulong PeerApplicationAccessTokenHandle;
    ///A handle to the access token for the peer computer's account during the course of the application. After using
    ///the token for access checks, the application should close the handle using the CloseHandle function.
    ulong PeerMachineAccessTokenHandle;
}

struct SOCKET_SECURITY_QUERY_INFO_IPSEC2
{
    SOCKET_SECURITY_PROTOCOL SecurityProtocol;
    uint  Flags;
    ulong PeerApplicationAccessTokenHandle;
    ulong PeerMachineAccessTokenHandle;
    ulong MmSaId;
    ulong QmSaId;
    uint  NegotiationWinerr;
    GUID  SaLookupContext;
}

struct RSS_SCALABILITY_INFO
{
    ubyte RssEnabled;
}

struct WSA_COMPATIBILITY_MODE
{
    WSA_COMPATIBILITY_BEHAVIOR_ID BehaviorId;
    uint TargetOsVersion;
}

struct RIO_BUFFERID_t
{
}

struct RIO_CQ_t
{
}

struct RIO_RQ_t
{
}

///The <b>RIORESULT</b> structure contains data used to indicate request completion results used with the Winsock
///registered I/O extensions.
struct RIORESULT
{
    ///The completion status of the Winsock registered I/O request.
    int   Status;
    ///The number of bytes sent or received in the I/O request.
    uint  BytesTransferred;
    ///An application-provided context specified in call to the RIOCreateRequestQueue function.
    ulong SocketContext;
    ///An application-provided context specified with the registered I/O request to the RIOReceive, RIOReceiveEx,
    ///RIOSend, and RIOSendEx functions.
    ulong RequestContext;
}

///The <b>RIO_BUF</b> structure specifies a portion of a registered buffer used for sending or receiving network data
///with the Winsock registered I/O extensions.
struct RIO_BUF
{
    ///The registered buffer descriptor for a Winsock registered I/O buffer used with send and receive requests.
    RIO_BUFFERID_t* BufferId;
    ///The offset, in bytes, into the buffer specified by the <b>BufferId</b> member. An <b>Offset</b> value of zero
    ///points to the beginning of the buffer
    uint            Offset;
    ///A length, in bytes, of the buffer to use from the <b>Offset</b> member.
    uint            Length;
}

struct RIO_CMSG_BUFFER
{
    uint TotalLength;
}

///The <b>ATM_ADDRESS</b> structure holds ATM address data for ATM-based sockets.
struct ATM_ADDRESS
{
    ///Type of end-system ATM address.
    uint      AddressType;
    ///Number of digits in the <b>Addr</b> parameter.
    uint      NumofDigits;
    ///Array representing the ATM address.
    ubyte[20] Addr;
}

///The <b>ATM_BLLI</b> structure is used to identify B-LLI information for an associated ATM socket.
struct ATM_BLLI
{
    ///Identifies the layer-two protocol. Corresponds to the <i>User information layer 2 protocol</i> field in the B-LLI
    ///information element. A value of SAP_FIELD_ABSENT indicates that this field is not used, and a value of
    ///SAP_FIELD_ANY means wildcard.
    uint     Layer2Protocol;
    ///Identifies the user-specified layer-two protocol. Only used if the <b>Layer2Protocol</b> parameter is set to
    ///BLLI_L2_USER_SPECIFIED. The valid values range from zero–127. Corresponds to the <i>User specified layer 2
    ///protocol information</i> field in the B-LLI information element.
    uint     Layer2UserSpecifiedProtocol;
    ///Identifies the layer-three protocol. Corresponds to the <i>User information layer 3 protocol</i> field in the
    ///B-LLI information element. A value of SAP_FIELD_ABSENT indicates that this field is not used, and a value of
    ///SAP_FIELD_ANY means wildcard.
    uint     Layer3Protocol;
    ///Identifies the user-specified layer-three protocol. Only used if the <b>Layer3Protocol</b> parameter is set to
    ///BLLI_L3_USER_SPECIFIED. The valid values range from zero–127. Corresponds to the <i>User specified layer 3
    ///protocol information</i> field in the B-LLI information element.
    uint     Layer3UserSpecifiedProtocol;
    ///Identifies the layer-three Initial Protocol Identifier. Only used if the <b>Layer3Protocol</b> parameter is set
    ///to BLLI_L3_ISO_TR9577. Corresponds to the <i>ISO/IEC TR 9577 Initial Protocol Identifier</i> field in the B-LLI
    ///information element.
    uint     Layer3IPI;
    ///Identifies the 802.1 SNAP identifier. Only used if the <b>Layer3Protocol</b> parameter is set to
    ///BLLI_L3_ISO_TR9577 and <b>Layer3IPI</b> is set to BLLI_L3_IPI_SNAP, indicating an IEEE 802.1 SNAP identifier.
    ///Corresponds to the <i>OUI</i> and <i>PID</i> fields in the B-LLI information element.
    ubyte[5] SnapID;
}

///The <b>ATM_BHLI</b> structure is used to identify B-HLI information for an associated ATM socket.
struct ATM_BHLI
{
    ///Identifies the <b>high layer information type</b> field in the B-LLI information element. Note that the type
    ///<b>BHLI_HighLayerProfile</b> has been eliminated in UNI 3.1. A value of SAP_FIELD_ABSENT indicates that B-HLI is
    ///not present, and a value of SAP_FIELD_ANY means wildcard.
    uint     HighLayerInfoType;
    ///Identifies the number of bytes from one to eight in the <b>HighLayerInfo</b> array. Valid values include eight
    ///for the cases of BHLI_ISO and BHLI_UserSpecific, four for BHLI_HighLayerProfile, and seven for
    ///BHLI_VendorSpecificAppId.
    uint     HighLayerInfoLength;
    ///Identifies the <b>high layer information</b> field in the B-LLI information element. In the case of
    ///<b>HighLayerInfoType</b> being BHLI_VendorSpecificAppId, the first 3 bytes consist of a globally-administered
    ///organizationally unique identifier (OUI), (according to IEEE standard 802-1990), followed by a 4-byte application
    ///identifier, which is administered by the vendor identified by the OUI. Value for the case of BHLI_UserSpecific is
    ///user defined and requires bilateral agreement between two end users.
    ubyte[8] HighLayerInfo;
}

///The Windows Sockets <b>sockaddr_atm</b> structure stores socket address information for ATM sockets.
struct sockaddr_atm
{
    ///Identifies the address family, which is AF_ATM in this case.
    ushort      satm_family;
    ///Identifies the ATM address that could be either in E.164 or NSAP-style ATM End Systems Address format. This field
    ///will be mapped to the called party number information element (IE) if it is specified in bind and WSPBind for a
    ///listening socket, or in connect, WSAConnect, WSPConnect, WSAJoinLeaf, or WSPJoinLeaf for a connecting socket. It
    ///will be mapped to the Calling Party Number IE if specified in <b>bind</b> and <b>WSPBind</b> for a connecting
    ///socket.
    ATM_ADDRESS satm_number;
    ///Identifies the fields in the B-LLI information element that are used along with <b>satm_bhli</b> to identify an
    ///application. See ATM_BLLI for more details. Note that the B-LLI layer two information is treated as not present
    ///if its <b>Layer2Protocol</b> field contains SAP_FIELD_ABSENT, or as a wildcard if it contains SAP_FIELD_ANY.
    ///Similarly, the B-LLI layer three information is treated as not present if its <b>Layer3Protocol</b> field
    ///contains SAP_FIELD_ABSENT, or as a wildcard if it contains SAP_FIELD_ANY.
    ATM_BLLI    satm_blli;
    ///Identifies the fields in the B-HLI information element that are used along with <b>satm_blli</b> to identify an
    ///application. See ATM_BHLI for information about the <b>ATM_BHLI</b> structure. <div class="alert"><b>Note</b>
    ///<b>satm_bhli</b> is treated as not present if its <b>HighLayerInfoType</b> field contains SAP_FIELD_ABSENT, or as
    ///a wildcard if it contains SAP_FIELD_ANY.</div> <div> </div>
    ATM_BHLI    satm_bhli;
}

struct Q2931_IE
{
    Q2931_IE_TYPE IEType;
    uint          IELength;
    ubyte[1]      IE;
}

struct AAL5_PARAMETERS
{
    uint  ForwardMaxCPCSSDUSize;
    uint  BackwardMaxCPCSSDUSize;
    ubyte Mode;
    ubyte SSCSType;
}

struct AALUSER_PARAMETERS
{
    uint UserDefined;
}

struct AAL_PARAMETERS_IE
{
    AAL_TYPE AALType;
    union AALSpecificParameters
    {
        AAL5_PARAMETERS    AAL5Parameters;
        AALUSER_PARAMETERS AALUserParameters;
    }
}

struct ATM_TD
{
    uint PeakCellRate_CLP0;
    uint PeakCellRate_CLP01;
    uint SustainableCellRate_CLP0;
    uint SustainableCellRate_CLP01;
    uint MaxBurstSize_CLP0;
    uint MaxBurstSize_CLP01;
    BOOL Tagging;
}

struct ATM_TRAFFIC_DESCRIPTOR_IE
{
    ATM_TD Forward;
    ATM_TD Backward;
    BOOL   BestEffort;
}

struct ATM_BROADBAND_BEARER_CAPABILITY_IE
{
    ubyte BearerClass;
    ubyte TrafficType;
    ubyte TimingRequirements;
    ubyte ClippingSusceptability;
    ubyte UserPlaneConnectionConfig;
}

struct ATM_BLLI_IE
{
    uint     Layer2Protocol;
    ubyte    Layer2Mode;
    ubyte    Layer2WindowSize;
    uint     Layer2UserSpecifiedProtocol;
    uint     Layer3Protocol;
    ubyte    Layer3Mode;
    ubyte    Layer3DefaultPacketSize;
    ubyte    Layer3PacketWindowSize;
    uint     Layer3UserSpecifiedProtocol;
    uint     Layer3IPI;
    ubyte[5] SnapID;
}

struct ATM_CALLING_PARTY_NUMBER_IE
{
    ATM_ADDRESS ATM_Number;
    ubyte       Presentation_Indication;
    ubyte       Screening_Indicator;
}

struct ATM_CAUSE_IE
{
    ubyte    Location;
    ubyte    Cause;
    ubyte    DiagnosticsLength;
    ubyte[4] Diagnostics;
}

struct ATM_QOS_CLASS_IE
{
    ubyte QOSClassForward;
    ubyte QOSClassBackward;
}

struct ATM_TRANSIT_NETWORK_SELECTION_IE
{
    ubyte    TypeOfNetworkId;
    ubyte    NetworkIdPlan;
    ubyte    NetworkIdLength;
    ubyte[1] NetworkId;
}

struct ATM_CONNECTION_ID
{
    uint DeviceNumber;
    uint VPI;
    uint VCI;
}

struct ATM_PVC_PARAMS
{
    ATM_CONNECTION_ID PvcConnectionId;
    QOS               PvcQos;
}

///The <b>NAPI_DOMAIN_DESCRIPTION_BLOB</b> structure describes a domain handled by a namespace provider for the NS_EMAIL
///namespace.
struct NAPI_DOMAIN_DESCRIPTION_BLOB
{
    ///The authority level of the namespace provider for this domain. This member can be one of the values from the
    ///NAPI_PROVIDER_LEVEL enumeration type defined in the <i>Nsemail.h</i> header file.
    uint AuthLevel;
    ///The length, in Unicode characters, of the Unicode string that contains the domain name represented by the
    ///<b>OffsetThisDomainName</b> member. The <b>NULL</b> terminator is not counted when calculating the length.
    uint cchDomainName;
    ///The offset, in bytes, to the next <b>NAPI_DOMAIN_DESCRIPTION_BLOB</b> structure in the
    ///NAPI_PROVIDER_INSTALLATION_BLOB structure.
    uint OffsetNextDomainDescription;
    ///The offset, in bytes, to a Unicode string that contains a domain name handled by this namespace provider for the
    ///NS_EMAIL namespace. The domain name must be at least <b>cchDomainName</b> Unicode characters in length.
    ///<b>NULL</b>-termination of the Unicode string that contains the domain name is recommended, but not required.
    ///This offset must be aligned on a minimum of a two-byte boundary.
    uint OffsetThisDomainName;
}

///The <b>NAPI_PROVIDER_INSTALLATION_BLOB</b> structure contains the information required to install a namespace
///provider for the NS_EMAIL namespace.
struct NAPI_PROVIDER_INSTALLATION_BLOB
{
    ///Type: <b>DWORD</b> The version number of the NS_EMAIL namespace provider. This member is specific to the
    ///namespace provider.
    uint dwVersion;
    ///Type: <b>DWORD</b> The type of namespace provider for the NS_EMAIL namespace. This member can be one of the
    ///values from the NAPI_PROVIDER_TYPE enumeration type defined in the <i>Nsemail.h</i> header file.
    uint dwProviderType;
    ///Type: <b>DWORD</b> A Boolean value that indicates if this NS_EMAIL namespace provider supports wildcard names. If
    ///this member is nonzero, then an NS_EMAIL provider claims to be potentially able to resolve or register any name
    ///that does not belong to any domains the provider is specifically registered for as primary or secondary. If this
    ///member is nonzero, then the NS_EMAIL provider may be called to resolve or register any address, if no primary or
    ///secondary provider for the domain is available. There may be multiple providers that claim to be able to resolve
    ///any address (the <b>fSupportsWildCard</b> set to nonzero). If there are namespace providers with this value that
    ///also registered as a wildcard provider, the providers are called in the order that they appear in the Winsock
    ///namespace catalog.
    uint fSupportsWildCard;
    ///Type: <b>DWORD</b> The number of NAPI_DOMAIN_DESCRIPTION_BLOB structures the starting at the
    ///<b>OffsetFirstDomain</b> member used to describe domains that are supported by this NS_EMAIL namespace provider.
    uint cDomains;
    ///Type: <b>DWORD</b> The offset, in bytes, to the first of multiple NAPI_DOMAIN_DESCRIPTION_BLOB structures used to
    ///describe domains that are supported by this NS_EMAIL namespace provider. This offset must be aligned on a minimum
    ///of a four-byte boundary.
    uint OffsetFirstDomain;
}

///The <b>TRANSMIT_FILE_BUFFERS</b> structure specifies data to be transmitted before and after file data during a
///TransmitFile function file transfer operation.
struct TRANSMIT_FILE_BUFFERS
{
    ///Pointer to a buffer that contains data to be transmitted before the file data is transmitted.
    void* Head;
    ///Size of the buffer pointed to by <b>Head</b>, in bytes, to be transmitted.
    uint  HeadLength;
    ///Pointer to a buffer that contains data to be transmitted after the file data is transmitted.
    void* Tail;
    ///Size of the buffer pointed to <b>Tail</b>, in bytes, to be transmitted.
    uint  TailLength;
}

///The <b>TRANSMIT_PACKETS_ELEMENT</b> structure specifies a single data element to be transmitted by the
///TransmitPackets function.
struct TRANSMIT_PACKETS_ELEMENT
{
    ///Type: <b>ULONG</b> Flags used to describe the contents of the packet array element, and to customize
    ///<b>TransmitPackets</b> function processing. The following table lists valid flags: <table> <tr> <th>Flag</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="TP_ELEMENT_FILE"></a><a id="tp_element_file"></a><dl>
    ///<dt><b>TP_ELEMENT_FILE</b></dt> </dl> </td> <td width="60%"> Specifies that data resides in a file. Default
    ///setting for <b>dwElFlags</b>. Mutually exclusive with TP_ELEMENT_MEMORY. </td> </tr> <tr> <td width="40%"><a
    ///id="TP_ELEMENT_MEMORY"></a><a id="tp_element_memory"></a><dl> <dt><b>TP_ELEMENT_MEMORY</b></dt> </dl> </td> <td
    ///width="60%"> Specifies that data resides in memory. Mutually exclusive with TP_ELEMENT_FILE. </td> </tr> <tr> <td
    ///width="40%"><a id="TP_ELEMENT_EOP"></a><a id="tp_element_eop"></a><dl> <dt><b>TP_ELEMENT_EOP</b></dt> </dl> </td>
    ///<td width="60%"> Specifies that this element should not be combined with the next element in a single send
    ///request from the sockets layer to the transport. This flag is used for granular control of the content of each
    ///message on a datagram or message-oriented socket. </td> </tr> </table>
    uint dwElFlags;
    ///Type: <b>ULONG</b> The number of bytes to transmit. If zero, the entire file is transmitted.
    uint cLength;
    union
    {
        struct
        {
            LARGE_INTEGER nFileOffset;
            HANDLE        hFile;
        }
        void* pBuffer;
    }
}

struct NLA_BLOB
{
    struct header
    {
        NLA_BLOB_DATA_TYPE type;
        uint               dwSize;
        uint               nextOffset;
    }
    union data
    {
        byte[1] rawData;
        struct interfaceData
        {
            uint    dwType;
            uint    dwSpeed;
            byte[1] adapterName;
        }
        struct locationData
        {
            byte[1] information;
        }
        struct connectivity
        {
            NLA_CONNECTIVITY_TYPE type;
            NLA_INTERNET internet;
        }
        struct ICS
        {
            struct remote
            {
                uint        speed;
                uint        type;
                uint        state;
                ushort[256] machineName;
                ushort[256] sharedAdapterName;
            }
        }
    }
}

struct WSAPOLLDATA
{
    int          result;
    uint         fds;
    int          timeout;
    WSAPOLLFD[1] fdArray;
}

struct WSASENDMSG
{
    WSAMSG*     lpMsg;
    uint        dwFlags;
    uint*       lpNumberOfBytesSent;
    OVERLAPPED* lpOverlapped;
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine;
}

///The <b>RIO_NOTIFICATION_COMPLETION</b> structure specifies the method for I/O completion to be used with a RIONotify
///function for sending or receiving network data with the Winsock registered I/O extensions.
struct RIO_NOTIFICATION_COMPLETION
{
    ///The type of completion to use with the RIONotify function when sending or receiving data.
    RIO_NOTIFICATION_COMPLETION_TYPE Type;
    union
    {
        struct Event
        {
            HANDLE EventHandle;
            BOOL   NotifyReset;
        }
        struct Iocp
        {
            HANDLE IocpHandle;
            void*  CompletionKey;
            void*  Overlapped;
        }
    }
}

///The <b>RIO_EXTENSION_FUNCTION_TABLE</b> structure contains information on the functions that implement the Winsock
///registered I/O extensions.
struct RIO_EXTENSION_FUNCTION_TABLE
{
    ///The size, in bytes, of the structure.
    uint              cbSize;
    ///A pointer to the RIOReceive function.
    LPFN_RIORECEIVE   RIOReceive;
    ///A pointer to the RIOReceiveEx function.
    LPFN_RIORECEIVEEX RIOReceiveEx;
    ///A pointer to the RIOSend function.
    LPFN_RIOSEND      RIOSend;
    ///A pointer to the RIOSendEx function.
    LPFN_RIOSENDEX    RIOSendEx;
    ///A pointer to the RIOCloseCompletionQueue function.
    LPFN_RIOCLOSECOMPLETIONQUEUE RIOCloseCompletionQueue;
    ///A pointer to the RIOCreateCompletionQueue function.
    LPFN_RIOCREATECOMPLETIONQUEUE RIOCreateCompletionQueue;
    ///A pointer to the RIOCreateRequestQueue function.
    LPFN_RIOCREATEREQUESTQUEUE RIOCreateRequestQueue;
    ///A pointer to the RIODequeueCompletion function.
    LPFN_RIODEQUEUECOMPLETION RIODequeueCompletion;
    ///A pointer to the RIODeregisterBuffer function.
    LPFN_RIODEREGISTERBUFFER RIODeregisterBuffer;
    ///A pointer to the RIONotify function.
    LPFN_RIONOTIFY    RIONotify;
    ///A pointer to the RIORegisterBuffer function.
    LPFN_RIOREGISTERBUFFER RIORegisterBuffer;
    ///A pointer to the RIOResizeCompletionQueue function.
    LPFN_RIORESIZECOMPLETIONQUEUE RIOResizeCompletionQueue;
    ///A pointer to the RIOResizeRequestQueue function.
    LPFN_RIORESIZEREQUESTQUEUE RIOResizeRequestQueue;
}

///The **WSPDATA** structure contains service provider information.
struct WSPData
{
    ///Version of the Windows Sockets SPI specification that the Windows Sockets service provider expects the caller to
    ///use.
    ushort      wVersion;
    ///Highest version of the Windows Sockets SPI specification that this service provider can support (also encoded as
    ///above). Normally this will be the same as **wVersion**.
    ushort      wHighVersion;
    ///Null-terminated Unicode string into which the Windows Sockets provider copies a description of itself. The text
    ///(up to 256 characters in length) can contain any characters except control and formatting characters: the most
    ///likely use to which an SPI client will put this is to display it (possibly truncated) in a status message.
    ushort[256] szDescription;
}

///The **WSATHREADID** structure enables a provider to identify a thread on which asynchronous procedure calls (APCs)
///can be queued using the [**WPUQueueApc**](./nf-ws2spi-wpuqueueapc.md) function.
struct WSATHREADID
{
    ///Handle to the thread ID.
    HANDLE ThreadHandle;
    ///Reserved.
    size_t Reserved;
}

///The **WSPPROC_TABLE** structure contains a table of pointers to service provider functions.
struct WSPPROC_TABLE
{
    ///A pointer to the **[LPWSPAccept](nc-ws2spi-lpwspaccept.md)** function.
    LPWSPACCEPT          lpWSPAccept;
    ///A pointer to the [**LPWSPAddressToString**](nc-ws2spi-lpwspaddresstostring.md) function.
    LPWSPADDRESSTOSTRING lpWSPAddressToString;
    ///A pointer to the **[LPWSPAsyncSelect](nc-ws2spi-lpwspasyncselect.md)** function.
    LPWSPASYNCSELECT     lpWSPAsyncSelect;
    ///A pointer to the <b>LPWSPBind</b> function.
    LPWSPBIND            lpWSPBind;
    ///A pointer to the <b>LPWSPCancelBlockingCall</b> function.
    LPWSPCANCELBLOCKINGCALL lpWSPCancelBlockingCall;
    ///A pointer to the [**WSPCleanup**](./nc-ws2spi-lpwspcleanup.md) function.
    LPWSPCLEANUP         lpWSPCleanup;
    ///A pointer to the <b>LPWSPCloseSocket</b> function.
    LPWSPCLOSESOCKET     lpWSPCloseSocket;
    ///A pointer to the <b>LPWSPConnect</b> function.
    LPWSPCONNECT         lpWSPConnect;
    ///A pointer to the [**WSPDuplicateSocket**](./nc-ws2spi-lpwspduplicatesocket.md) function.
    LPWSPDUPLICATESOCKET lpWSPDuplicateSocket;
    ///A pointer to the [**WSPEnumNetworkEvents**](./nc-ws2spi-lpwspenumnetworkevents.md) function.
    LPWSPENUMNETWORKEVENTS lpWSPEnumNetworkEvents;
    ///A pointer to the [**LPWSPEventSelect**](./nc-ws2spi-lpwspenumnetworkevents.md) function.
    LPWSPEVENTSELECT     lpWSPEventSelect;
    ///A pointer to the [**LPWSPGetOverlappedResult**](./nc-ws2spi-lpwspgetoverlappedresult.md) function.
    LPWSPGETOVERLAPPEDRESULT lpWSPGetOverlappedResult;
    ///A pointer to the function.
    LPWSPGETPEERNAME     lpWSPGetPeerName;
    ///A pointer to the [**WSPGetSockName**](./nc-ws2spi-lpwspgetsockname.md) function.
    LPWSPGETSOCKNAME     lpWSPGetSockName;
    ///A pointer to the <b>LPWSPGetSockopt</b> function.
    LPWSPGETSOCKOPT      lpWSPGetSockOpt;
    ///A pointer to the [**WSPGetQOSByName**](./nc-ws2spi-lpwspgetqosbyname.md) function.
    LPWSPGETQOSBYNAME    lpWSPGetQOSByName;
    ///A pointer to the <b>LPWSPIoctl</b> function.
    LPWSPIOCTL           lpWSPIoctl;
    ///A pointer to the <b>LPWSPJoinLeaf</b> function.
    LPWSPJOINLEAF        lpWSPJoinLeaf;
    ///A pointer to the <b>LPWSPListen</b> function.
    LPWSPLISTEN          lpWSPListen;
    ///A pointer to the <b>LPWSPRecv</b> function.
    LPWSPRECV            lpWSPRecv;
    ///A pointer to the [**WSPRecvDisconnect**](./nc-ws2spi-lpwsprecvdisconnect.md) function.
    LPWSPRECVDISCONNECT  lpWSPRecvDisconnect;
    ///A pointer to the <b>LPWSPRecvFrom</b> function.
    LPWSPRECVFROM        lpWSPRecvFrom;
    ///A pointer to the [**LPWSPSelect**](./nc-ws2spi-lpwspselect.md) function.
    LPWSPSELECT          lpWSPSelect;
    ///A pointer to the <b>LPWSPSend</b> function.
    LPWSPSEND            lpWSPSend;
    ///A pointer to the [**WSPSendDisconnect**](./nc-ws2spi-lpwspsenddisconnect.md) function.
    LPWSPSENDDISCONNECT  lpWSPSendDisconnect;
    ///A pointer to the <b>LPWSPSendTo</b> function.
    LPWSPSENDTO          lpWSPSendTo;
    ///A pointer to the <b>LPWSPSetSockOpt</b> function.
    LPWSPSETSOCKOPT      lpWSPSetSockOpt;
    ///A pointer to the <b>LPWSPShutdown</b> function.
    LPWSPSHUTDOWN        lpWSPShutdown;
    ///A pointer to the LPWSPSocket function.
    LPWSPSOCKET          lpWSPSocket;
    ///A pointer to the <a href="/windows/win32/api/ws2spi/nc-ws2spi-lpwspstringtoaddress">LPWSPStringToAddress<a>
    ///function.
    LPWSPSTRINGTOADDRESS lpWSPStringToAddress;
}

///The **WSPUPCALLTABLE** structure contains a table of pointers to service provider upcall functions.
struct WSPUPCALLTABLE
{
    ///Type: **LPWPUCLOSEEVENT** A pointer to the WPUCloseEvent function.
    LPWPUCLOSEEVENT      lpWPUCloseEvent;
    ///Type: **LPWPUCLOSESOCKETHANDLE** A pointer to the WPUCloseSocketHandle function.
    LPWPUCLOSESOCKETHANDLE lpWPUCloseSocketHandle;
    ///Type: **LPWPUCREATEEVENT** A pointer to the WPUCreateEvent function.
    LPWPUCREATEEVENT     lpWPUCreateEvent;
    ///Type: **LPWPUCREATESOCKETHANDLE** A pointer to the WPUCreateSocketHandle function.
    LPWPUCREATESOCKETHANDLE lpWPUCreateSocketHandle;
    ///Type: **LPWPUFDISSET** A pointer to the WPUFDIsSet function.
    LPWPUFDISSET         lpWPUFDIsSet;
    ///Type: **LPWPUGETPROVIDERPATH** A pointer to the WPUGetProviderPath function.
    LPWPUGETPROVIDERPATH lpWPUGetProviderPath;
    ///Type: **LPWPUMODIFYIFSHANDLE** A pointer to the WPUModifyIFSHandle function.
    LPWPUMODIFYIFSHANDLE lpWPUModifyIFSHandle;
    ///Type: **LPWPUPOSTMESSAGE** A pointer to the WPUPostMessage function.
    LPWPUPOSTMESSAGE     lpWPUPostMessage;
    ///Type: **LPWPUQUERYBLOCKINGCALLBACK** A pointer to the WPUQueryBlockingCallback function.
    LPWPUQUERYBLOCKINGCALLBACK lpWPUQueryBlockingCallback;
    ///Type: **LPWPUQUERYSOCKETHANDLECONTEXT** A pointer to the WPUQuerySocketHandleContext function.
    LPWPUQUERYSOCKETHANDLECONTEXT lpWPUQuerySocketHandleContext;
    ///Type: **LPWPUQUEUEAPC** A pointer to the WPUQueueApc function.
    LPWPUQUEUEAPC        lpWPUQueueApc;
    ///Type: **LPWPURESETEVENT** A pointer to the WPUResetEvent function.
    LPWPURESETEVENT      lpWPUResetEvent;
    ///Type: **LPWPUSETEVENT** A pointer to the WPUSetEvent function.
    LPWPUSETEVENT        lpWPUSetEvent;
    ///Type: **LPWPUOPENCURRENTTHREAD** A pointer to the WPUOpenCurrentThread function.
    LPWPUOPENCURRENTTHREAD lpWPUOpenCurrentThread;
    ///Type: **LPWPUCLOSETHREAD** A pointer to the WPUCloseThread function.
    LPWPUCLOSETHREAD     lpWPUCloseThread;
}

///<div class="alert">**Note** Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server
///2012, use Windows Filtering Platform.</div><div> </div>The **WSC_PROVIDER_AUDIT_INFO** structure contains audit
///information for a layered service provider (LSP) entry in Windows Sockets 2.
struct WSC_PROVIDER_AUDIT_INFO
{
    ///The size, in bytes of this audit information record which includes this member.
    uint  RecordSize;
    ///A reserved member for the audit information record.
    void* Reserved;
}

///The **NSP_ROUTINE** structure contains information regarding the functions implemented by a namespace service
///provider version 1 (NSPv1) provider. <div class="alert">**Note** The <i>Ws2spi.h</i> header file structure contains
///complete prototypes for all the NSPv1 function pointers.</div><div> </div>
struct NSP_ROUTINE
{
    ///Type: **DWORD** The size, in bytes, of the structure. Note that the size of the **NSP_ROUTINE** structure changed
    ///on Windows XP and later.
    uint            cbSize;
    ///Type: **DWORD** The major version of the service provider specification supported by this provider.
    uint            dwMajorVersion;
    ///Type: **DWORD** The minor version of the service provider specification supported by this provider.
    uint            dwMinorVersion;
    ///Type: **LPNSPCLEANUP** A pointer to the NSPCleanup function implemented by the namespace provider. Every NSP
    ///function entry must point to a valid function. If the provider does not implement this function, the
    ///**NSPCleanup** function should return <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2
    LPNSPCLEANUP    NSPCleanup;
    ///Type: **LPNSPLOOKUPSERVICEBEGIN** A pointer to the NSPLookupServiceBegin function implemented by the namespace
    ///provider. Every NSP function entry must point to a valid function. If the provider does not implement this
    ///function, the **NSPLookupServiceBegin** function should return <a
    ///href="/windows/desktop/WinSock/windows-sockets-error-codes-2
    LPNSPLOOKUPSERVICEBEGIN NSPLookupServiceBegin;
    ///Type: **LPNSPLOOKUPSERVICENEXT** A pointer to the NSPLookupServiceNext function implemented by the namespace
    ///provider. Every NSP function entry must point to a valid function. If the provider does not implement this
    ///function, the **NSPLookupServiceNext** function should return <a
    ///href="/windows/desktop/WinSock/windows-sockets-error-codes-2
    LPNSPLOOKUPSERVICENEXT NSPLookupServiceNext;
    ///Type: **LPNSPLOOKUPSERVICEEND** A pointer to the NSPLookupServiceEnd function implemented by the namespace
    ///provider. Every NSP function entry must point to a valid function. If the provider does not implement this
    ///function, the **NSPLookupServiceEnd** function should return <a
    ///href="/windows/desktop/WinSock/windows-sockets-error-codes-2
    LPNSPLOOKUPSERVICEEND NSPLookupServiceEnd;
    ///Type: **LPNSPSETSERVICE** A pointer to the NSPSetService function implemented by the namespace provider. Every
    ///NSP function entry must point to a valid function. If the provider does not implement this function, the
    ///**NSPSetService** function should return <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2
    LPNSPSETSERVICE NSPSetService;
    ///Type: **LPNSPINSTALLSERVICECLASS** A pointer to the NSPInstallServiceClass function implemented by the namespace
    ///provider. Every NSP function entry must point to a valid function. If the provider does not implement this
    ///function, the **NSPInstallServiceClass** function should return <a
    ///href="/windows/desktop/WinSock/windows-sockets-error-codes-2
    LPNSPINSTALLSERVICECLASS NSPInstallServiceClass;
    ///Type: **LPNSPREMOVESERVICECLASS** A pointer to the NSPRemoveServiceClass function implemented by the namespace
    ///provider. Every NSP function entry must point to a valid function. If the provider does not implement this
    ///function, the **NSPRemoveServiceClass** function should return <a
    ///href="/windows/desktop/WinSock/windows-sockets-error-codes-2
    LPNSPREMOVESERVICECLASS NSPRemoveServiceClass;
    ///Type: **LPNSPGETSERVICECLASSINFO** A pointer to the NSPGetServiceClassInfo function implemented by the namespace
    ///provider. Every NSP function entry must point to a valid function. If the provider does not implement this
    ///function, the **NSPGetServiceClassInfo** function should return <a
    ///href="/windows/desktop/WinSock/windows-sockets-error-codes-2
    LPNSPGETSERVICECLASSINFO NSPGetServiceClassInfo;
    ///Type: **LPNSPIOCTL** A pointer to the NSPIoctl function implemented by the namespace provider. Every NSP function
    ///entry must point to a valid function. If the provider does not implement this function, the **NSPIoctl** function
    ///should return <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2
    LPNSPIOCTL      NSPIoctl;
}

///The **NSPV2_ROUTINE** structure contains information on the functions implemented by a namespace service provider
///version-2 (NSPv2) provider.<div class="alert">**Note** The <i>Ws2spi.h</i> header file structure contains complete
///prototypes for all the NSPV2 function pointers.</div> <div> </div>
struct NSPV2_ROUTINE
{
    ///Type: **DWORD** The size, in bytes, of the structure.
    uint                cbSize;
    ///Type: **DWORD** The major version of the service provider specification supported by this provider.
    uint                dwMajorVersion;
    ///Type: **DWORD** The minor version of the service provider specification supported by this provider.
    uint                dwMinorVersion;
    ///Type: ** LPNSPV2STARTUP** A pointer to the NSPv2Startup function for this NSPv2 provider.
    LPNSPV2STARTUP      NSPv2Startup;
    ///Type: **LPNSPV2CLEANUP** A pointer to the NSPv2Cleanup function for this NSPv2 provider.
    LPNSPV2CLEANUP      NSPv2Cleanup;
    ///Type: **LPNSPV2LOOKUPSERVICEBEGIN** A pointer to the NSPv2LookupServiceBegin function for this NSPv2 provider.
    LPNSPV2LOOKUPSERVICEBEGIN NSPv2LookupServiceBegin;
    ///Type: **LPNSPV2LOOKUPSERVICENEXTEX** A pointer to the NSPv2LookupServiceNextEx function for this NSPv2 provider.
    LPNSPV2LOOKUPSERVICENEXTEX NSPv2LookupServiceNextEx;
    ///Type: **LPNSPV2LOOKUPSERVICEEND** A pointer to the NSPv2LookupServiceEnd function for this NSPv2 provider.
    LPNSPV2LOOKUPSERVICEEND NSPv2LookupServiceEnd;
    ///Type: **LPNSPV2SETSERVICEEX** A pointer to the NSPv2SetServiceEx function for this NSPv2 provider.
    LPNSPV2SETSERVICEEX NSPv2SetServiceEx;
    ///Type: **LPNSPV2CLIENTSESSIONRUNDOWN** A pointer to the NSPv2ClientSessionRundown function for this NSPv2
    ///provider.
    LPNSPV2CLIENTSESSIONRUNDOWN NSPv2ClientSessionRundown;
}

struct NS_INFOA
{
    uint         dwNameSpace;
    uint         dwNameSpaceFlags;
    const(char)* lpNameSpace;
}

struct NS_INFOW
{
    uint          dwNameSpace;
    uint          dwNameSpaceFlags;
    const(wchar)* lpNameSpace;
}

struct SERVICE_TYPE_VALUE
{
    uint dwNameSpace;
    uint dwValueType;
    uint dwValueSize;
    uint dwValueNameOffset;
    uint dwValueOffset;
}

///The <b>SERVICE_TYPE_VALUE_ABS</b> structure contains information about a network-service type value. This information
///may be specific to a namespace.
struct SERVICE_TYPE_VALUE_ABSA
{
    ///Type: <b>DWORD</b> A namespace, or a set of default namespaces, for which the network service type value is
    ///intended. Namespace providers will look only at values intended for their namespace. Use one of the following
    ///constants to specify a namespace: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="NS_DEFAULT"></a><a id="ns_default"></a><dl> <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td width="60%"> A set of
    ///default namespaces. The function queries each namespace within this set. The set of default namespaces typically
    ///includes all the namespaces installed on the system. System administrators, however, can exclude particular
    ///namespaces from the set. NS_DEFAULT is the value that most applications should use for <b>dwNameSpace</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td
    ///width="60%"> The Domain Name System used in the Internet for host name resolution. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%">
    ///The NetBIOS over TCP/IP layer. All Windows operating systems register their computer names with NetBIOS. This
    ///namespace is used to convert a computer name to an IP address that uses this registration. Note that NS_NETBT may
    ///access a WINS server to perform the resolution. </td> </tr> <tr> <td width="40%"><a id="NS_SAP"></a><a
    ///id="ns_sap"></a><dl> <dt><b>NS_SAP</b></dt> </dl> </td> <td width="60%"> The NetWare Service Advertising
    ///Protocol. This may access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows
    ///registration of services. </td> </tr> <tr> <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a
    ///id="ns_tcpip_hosts"></a><dl> <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td> <td width="60%"> Lookup value in the
    ///&lt;systemroot&gt;\system32\drivers\etc\hosts file. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl> <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td> <td
    ///width="60%"> Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks
    ///up host names and IP addresses in cache of host to IP address mappings. </td> </tr> </table>
    uint         dwNameSpace;
    ///Type: <b>DWORD</b> The type of the value data. Specify one of the following types: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="REG_BINARY"></a><a id="reg_binary"></a><dl>
    ///<dt><b>REG_BINARY</b></dt> </dl> </td> <td width="60%"> Binary data in any form. </td> </tr> <tr> <td
    ///width="40%"><a id="REG_DWORD"></a><a id="reg_dword"></a><dl> <dt><b>REG_DWORD</b></dt> </dl> </td> <td
    ///width="60%"> A 32-bit number. </td> </tr> <tr> <td width="40%"><a id="REG_MULTI_SZ"></a><a
    ///id="reg_multi_sz"></a><dl> <dt><b>REG_MULTI_SZ</b></dt> </dl> </td> <td width="60%"> An array of null-terminated
    ///strings, terminated by two null characters. </td> </tr> <tr> <td width="40%"><a id="REG_SZ"></a><a
    ///id="reg_sz"></a><dl> <dt><b>REG_SZ</b></dt> </dl> </td> <td width="60%"> A null-terminated string. </td> </tr>
    ///</table>
    uint         dwValueType;
    ///Type: <b>DWORD</b> The size, in bytes, of the value pointed to by the <b>lpValue</b> member. In the case of
    ///REG_SZ and REG_MULTI_SZ string data, the terminating characters are counted as part of the size.
    uint         dwValueSize;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that is the name of the value. This name is
    ///specific to a namespace. Several commonly used value name strings are associated with defined constants. These
    ///name strings include the following. <table> <tr> <th>Constant</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SERVICE_TYPE_VALUE_SAPID"></a><a id="service_type_value_sapid"></a><dl>
    ///<dt><b>SERVICE_TYPE_VALUE_SAPID</b></dt> </dl> </td> <td width="60%"> "SapId" </td> </tr> <tr> <td width="40%"><a
    ///id="SERVICE_TYPE_VALUE_CONN"></a><a id="service_type_value_conn"></a><dl> <dt><b>SERVICE_TYPE_VALUE_CONN</b></dt>
    ///</dl> </td> <td width="60%"> "ConnectionOriented" </td> </tr> <tr> <td width="40%"><a
    ///id="SERVICE_TYPE_VALUE_TCPPORT"></a><a id="service_type_value_tcpport"></a><dl>
    ///<dt><b>SERVICE_TYPE_VALUE_TCPPORT</b></dt> </dl> </td> <td width="60%"> "TcpPort" </td> </tr> <tr> <td
    ///width="40%"><a id="SERVICE_TYPE_VALUE_UDPPORT"></a><a id="service_type_value_udpport"></a><dl>
    ///<dt><b>SERVICE_TYPE_VALUE_UDPPORT</b></dt> </dl> </td> <td width="60%"> "UdpPort" </td> </tr> </table>
    const(char)* lpValueName;
    ///Type: <b>PVOID</b> A pointer to the value data.
    void*        lpValue;
}

///The <b>SERVICE_TYPE_VALUE_ABS</b> structure contains information about a network-service type value. This information
///may be specific to a namespace.
struct SERVICE_TYPE_VALUE_ABSW
{
    ///Type: <b>DWORD</b> A namespace, or a set of default namespaces, for which the network service type value is
    ///intended. Namespace providers will look only at values intended for their namespace. Use one of the following
    ///constants to specify a namespace: <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="NS_DEFAULT"></a><a id="ns_default"></a><dl> <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td width="60%"> A set of
    ///default namespaces. The function queries each namespace within this set. The set of default namespaces typically
    ///includes all the namespaces installed on the system. System administrators, however, can exclude particular
    ///namespaces from the set. NS_DEFAULT is the value that most applications should use for <b>dwNameSpace</b>. </td>
    ///</tr> <tr> <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td
    ///width="60%"> The Domain Name System used in the Internet for host name resolution. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%">
    ///The NetBIOS over TCP/IP layer. All Windows operating systems register their computer names with NetBIOS. This
    ///namespace is used to convert a computer name to an IP address that uses this registration. Note that NS_NETBT may
    ///access a WINS server to perform the resolution. </td> </tr> <tr> <td width="40%"><a id="NS_SAP"></a><a
    ///id="ns_sap"></a><dl> <dt><b>NS_SAP</b></dt> </dl> </td> <td width="60%"> The NetWare Service Advertising
    ///Protocol. This may access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows
    ///registration of services. </td> </tr> <tr> <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a
    ///id="ns_tcpip_hosts"></a><dl> <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td> <td width="60%"> Lookup value in the
    ///&lt;systemroot&gt;\system32\drivers\etc\hosts file. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl> <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td> <td
    ///width="60%"> Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks
    ///up host names and IP addresses in cache of host to IP address mappings. </td> </tr> </table>
    uint          dwNameSpace;
    ///Type: <b>DWORD</b> The type of the value data. Specify one of the following types: <table> <tr> <th>Value</th>
    ///<th>Meaning</th> </tr> <tr> <td width="40%"><a id="REG_BINARY"></a><a id="reg_binary"></a><dl>
    ///<dt><b>REG_BINARY</b></dt> </dl> </td> <td width="60%"> Binary data in any form. </td> </tr> <tr> <td
    ///width="40%"><a id="REG_DWORD"></a><a id="reg_dword"></a><dl> <dt><b>REG_DWORD</b></dt> </dl> </td> <td
    ///width="60%"> A 32-bit number. </td> </tr> <tr> <td width="40%"><a id="REG_MULTI_SZ"></a><a
    ///id="reg_multi_sz"></a><dl> <dt><b>REG_MULTI_SZ</b></dt> </dl> </td> <td width="60%"> An array of null-terminated
    ///strings, terminated by two null characters. </td> </tr> <tr> <td width="40%"><a id="REG_SZ"></a><a
    ///id="reg_sz"></a><dl> <dt><b>REG_SZ</b></dt> </dl> </td> <td width="60%"> A null-terminated string. </td> </tr>
    ///</table>
    uint          dwValueType;
    ///Type: <b>DWORD</b> The size, in bytes, of the value pointed to by the <b>lpValue</b> member. In the case of
    ///REG_SZ and REG_MULTI_SZ string data, the terminating characters are counted as part of the size.
    uint          dwValueSize;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that is the name of the value. This name is
    ///specific to a namespace. Several commonly used value name strings are associated with defined constants. These
    ///name strings include the following. <table> <tr> <th>Constant</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SERVICE_TYPE_VALUE_SAPID"></a><a id="service_type_value_sapid"></a><dl>
    ///<dt><b>SERVICE_TYPE_VALUE_SAPID</b></dt> </dl> </td> <td width="60%"> "SapId" </td> </tr> <tr> <td width="40%"><a
    ///id="SERVICE_TYPE_VALUE_CONN"></a><a id="service_type_value_conn"></a><dl> <dt><b>SERVICE_TYPE_VALUE_CONN</b></dt>
    ///</dl> </td> <td width="60%"> "ConnectionOriented" </td> </tr> <tr> <td width="40%"><a
    ///id="SERVICE_TYPE_VALUE_TCPPORT"></a><a id="service_type_value_tcpport"></a><dl>
    ///<dt><b>SERVICE_TYPE_VALUE_TCPPORT</b></dt> </dl> </td> <td width="60%"> "TcpPort" </td> </tr> <tr> <td
    ///width="40%"><a id="SERVICE_TYPE_VALUE_UDPPORT"></a><a id="service_type_value_udpport"></a><dl>
    ///<dt><b>SERVICE_TYPE_VALUE_UDPPORT</b></dt> </dl> </td> <td width="60%"> "UdpPort" </td> </tr> </table>
    const(wchar)* lpValueName;
    ///Type: <b>PVOID</b> A pointer to the value data.
    void*         lpValue;
}

struct SERVICE_TYPE_INFO
{
    uint dwTypeNameOffset;
    uint dwValueCount;
    SERVICE_TYPE_VALUE[1] Values;
}

///The <b>SERVICE_TYPE_INFO_ABS</b> structure contains information about a network service type. Use
///<b>SERVICE_TYPE_INFO_ABS</b> to add a network service type to a namespace.
struct SERVICE_TYPE_INFO_ABSA
{
    ///Pointer to a zero-terminated string that is the name of the network service type. This name is the same in all
    ///namespaces, and is used by the GetTypeByName and <b>GetNameByType</b> functions.
    const(char)* lpTypeName;
    ///Number of SERVICE_TYPE_VALUE_ABS structures in the <b>Values</b> member array that follows <b>dwValueCount</b>.
    uint         dwValueCount;
    ///Array of SERVICE_TYPE_VALUE_ABS structures. Each of these structures contains information about a service type
    ///value that the operating system or network service may need when an instance of this network service type is
    ///registered with a namespace. The information in these structures may be specific to a namespace. For example, if
    ///a network service uses the SAP namespace, but does not have a <b>GUID</b> that contains the SAP identifier
    ///(SAPID), it defines the SAPID in a SERVICE_TYPE_VALUE_ABS structure.
    SERVICE_TYPE_VALUE_ABSA[1] Values;
}

///The <b>SERVICE_TYPE_INFO_ABS</b> structure contains information about a network service type. Use
///<b>SERVICE_TYPE_INFO_ABS</b> to add a network service type to a namespace.
struct SERVICE_TYPE_INFO_ABSW
{
    ///Pointer to a zero-terminated string that is the name of the network service type. This name is the same in all
    ///namespaces, and is used by the GetTypeByName and <b>GetNameByType</b> functions.
    const(wchar)* lpTypeName;
    ///Number of SERVICE_TYPE_VALUE_ABS structures in the <b>Values</b> member array that follows <b>dwValueCount</b>.
    uint          dwValueCount;
    ///Array of SERVICE_TYPE_VALUE_ABS structures. Each of these structures contains information about a service type
    ///value that the operating system or network service may need when an instance of this network service type is
    ///registered with a namespace. The information in these structures may be specific to a namespace. For example, if
    ///a network service uses the SAP namespace, but does not have a <b>GUID</b> that contains the SAP identifier
    ///(SAPID), it defines the SAPID in a SERVICE_TYPE_VALUE_ABS structure.
    SERVICE_TYPE_VALUE_ABSW[1] Values;
}

///The <b>SERVICE_ADDRESS</b> structure contains address information for a service. The structure can accommodate many
///types of interprocess communications (IPC) mechanisms and their address forms, including remote procedure calls
///(RPC), named pipes, and sockets.
struct SERVICE_ADDRESS
{
    ///Type: <b>DWORD</b> The address family to which the socket address pointed to by <b>lpAddress</b> member belongs.
    uint   dwAddressType;
    ///Type: <b>DWORD</b> A set of bit flags that specify properties of the address. The following bit flags are
    ///defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="SERVICE_ADDRESS_FLAG_RPC_CN"></a><a id="service_address_flag_rpc_cn"></a><dl>
    ///<dt><b>SERVICE_ADDRESS_FLAG_RPC_CN</b></dt> </dl> </td> <td width="60%"> If this bit flag is set, the service
    ///supports connection-oriented RPC over this transport protocol. </td> </tr> <tr> <td width="40%"><a
    ///id="SERVICE_ADDRESS_FLAG_RPC_DG"></a><a id="service_address_flag_rpc_dg"></a><dl>
    ///<dt><b>SERVICE_ADDRESS_FLAG_RPC_DG</b></dt> </dl> </td> <td width="60%"> If this bit flag is set, the service
    ///supports datagram-oriented RPC over this transport protocol. </td> </tr> <tr> <td width="40%"><a
    ///id="SERVICE_ADDRESS_FLAG_RPC_NB"></a><a id="service_address_flag_rpc_nb"></a><dl>
    ///<dt><b>SERVICE_ADDRESS_FLAG_RPC_NB</b></dt> </dl> </td> <td width="60%"> If this bit flag is set, the service
    ///supports NetBIOS RPC over this transport protocol. </td> </tr> </table>
    uint   dwAddressFlags;
    ///Type: <b>DWORD</b> The size, in bytes, of the address.
    uint   dwAddressLength;
    ///Type: <b>DWORD</b> Reserved for future use. Must be zero.
    uint   dwPrincipalLength;
    ubyte* lpAddress;
    ubyte* lpPrincipal;
}

///The <b>SERVICE_ADDRESSES</b> structure contains an array of SERVICE_ADDRESS data structures.
struct SERVICE_ADDRESSES
{
    ///Number of SERVICE_ADDRESS structures in the <b>Addresses</b> array.
    uint               dwAddressCount;
    ///Array of SERVICE_ADDRESS data structures. Each <b>SERVICE_ADDRESS</b> structure contains information about a
    ///network service address.
    SERVICE_ADDRESS[1] Addresses;
}

///The <b>SERVICE_INFO</b> structure contains information about a network service or a network service type.
struct SERVICE_INFOA
{
    ///Type: <b>LPGUID</b> A pointer to a GUID that is the type of the network service.
    GUID*              lpServiceType;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that is the name of the network service. If you
    ///are calling the <b>SetService</b> function with the <i>dwNameSpace</i> parameter set to NS_DEFAULT, the network
    ///service name must be a common name. A common name is what the network service is commonly known as. An example of
    ///a common name for a network service is "My SQL Server". If you are calling the <b>SetService</b> function with
    ///the <i>dwNameSpace</i> parameter set to a specific service name, the network service name can be a common name or
    ///a distinguished name. A distinguished name distinguishes the service to a unique location with a directory
    ///service. An example of a distinguished name for a network service is "MS\\SYS\\NT\\DEV\\My SQL Server".
    const(char)*       lpServiceName;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that is a comment or description for the network
    ///service. For example, "Used for development upgrades."
    const(char)*       lpComment;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that contains locale information.
    const(char)*       lpLocale;
    ///Type: <b>DWORD</b> A hint as to how to display the network service in a network browsing user interface. This can
    ///be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="RESOURCEDISPLAYTYPE_DOMAIN"></a><a id="resourcedisplaytype_domain"></a><dl>
    ///<dt><b>RESOURCEDISPLAYTYPE_DOMAIN</b></dt> </dl> </td> <td width="60%"> Display the network service as a domain.
    ///</td> </tr> <tr> <td width="40%"><a id="RESOURCEDISPLAYTYPE_FILE"></a><a id="resourcedisplaytype_file"></a><dl>
    ///<dt><b>RESOURCEDISPLAYTYPE_FILE</b></dt> </dl> </td> <td width="60%"> Display the network service as a file.
    ///</td> </tr> <tr> <td width="40%"><a id="RESOURCEDISPLAYTYPE_GENERIC"></a><a
    ///id="resourcedisplaytype_generic"></a><dl> <dt><b>RESOURCEDISPLAYTYPE_GENERIC</b></dt> </dl> </td> <td
    ///width="60%"> The method used to display the object does not matter. </td> </tr> <tr> <td width="40%"><a
    ///id="RESOURCEDISPLAYTYPE_GROUP"></a><a id="resourcedisplaytype_group"></a><dl>
    ///<dt><b>RESOURCEDISPLAYTYPE_GROUP</b></dt> </dl> </td> <td width="60%"> Display the network service as a group.
    ///</td> </tr> <tr> <td width="40%"><a id="RESOURCEDISPLAYTYPE_SERVER"></a><a
    ///id="resourcedisplaytype_server"></a><dl> <dt><b>RESOURCEDISPLAYTYPE_SERVER</b></dt> </dl> </td> <td width="60%">
    ///Display the network service as a server. </td> </tr> <tr> <td width="40%"><a
    ///id="RESOURCEDISPLAYTYPE_SHARE"></a><a id="resourcedisplaytype_share"></a><dl>
    ///<dt><b>RESOURCEDISPLAYTYPE_SHARE</b></dt> </dl> </td> <td width="60%"> Display the network service as a
    ///sharepoint. </td> </tr> <tr> <td width="40%"><a id="RESOURCEDISPLAYTYPE_TREE"></a><a
    ///id="resourcedisplaytype_tree"></a><dl> <dt><b>RESOURCEDISPLAYTYPE_TREE</b></dt> </dl> </td> <td width="60%">
    ///Display the network service as a tree. </td> </tr> </table>
    uint               dwDisplayHint;
    ///Type: <b>DWORD</b> The version for the network service. The high word of this value specifies a major version
    ///number. The low word of this value specifies a minor version number.
    uint               dwVersion;
    ///Type: <b>DWORD</b> Reserved for future use. Must be zero.
    uint               dwTime;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that is the name of the computer on which the
    ///network service is running.
    const(char)*       lpMachineName;
    ///Type: <b>LPSERVICE_ADDRESSES</b> A pointer to a SERVICE_ADDRESSES structure that contains an array of
    ///SERVICE_ADDRESS structures. Each <b>SERVICE_ADDRESS</b> structure contains information about a network service
    ///address. A network service can call the getsockname function to determine the local address of the system.
    SERVICE_ADDRESSES* lpServiceAddress;
    ///Type: <b>BLOB</b> A BLOB structure that specifies service-defined information. <div class="alert"><b>Note</b> In
    ///general, the data pointed to by the BLOB structure's <b>pBlobData</b> member must not contain any pointers. That
    ///is because only the network service knows the format of the data; copying the data without such knowledge would
    ///lead to pointer invalidation. If the data pointed to by <b>pBlobData</b> contains variable-sized elements,
    ///offsets from <b>pBlobData</b> can be used to indicate the location of those elements. There is one exception to
    ///this general rule: when <b>pBlobData</b> points to a SERVICE_TYPE_INFO_ABS structure. This is possible because
    ///both the <b>SERVICE_TYPE_INFO_ABS</b> structure, and any SERVICE_TYPE_VALUE_ABS structures it contains are
    ///predefined, and thus their formats are known to the operating system.</div> <div> </div>
    BLOB               ServiceSpecificInfo;
}

///The <b>SERVICE_INFO</b> structure contains information about a network service or a network service type.
struct SERVICE_INFOW
{
    ///Type: <b>LPGUID</b> A pointer to a GUID that is the type of the network service.
    GUID*              lpServiceType;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that is the name of the network service. If you
    ///are calling the <b>SetService</b> function with the <i>dwNameSpace</i> parameter set to NS_DEFAULT, the network
    ///service name must be a common name. A common name is what the network service is commonly known as. An example of
    ///a common name for a network service is "My SQL Server". If you are calling the <b>SetService</b> function with
    ///the <i>dwNameSpace</i> parameter set to a specific service name, the network service name can be a common name or
    ///a distinguished name. A distinguished name distinguishes the service to a unique location with a directory
    ///service. An example of a distinguished name for a network service is "MS\\SYS\\NT\\DEV\\My SQL Server".
    const(wchar)*      lpServiceName;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that is a comment or description for the network
    ///service. For example, "Used for development upgrades."
    const(wchar)*      lpComment;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that contains locale information.
    const(wchar)*      lpLocale;
    ///Type: <b>DWORD</b> A hint as to how to display the network service in a network browsing user interface. This can
    ///be one of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="RESOURCEDISPLAYTYPE_DOMAIN"></a><a id="resourcedisplaytype_domain"></a><dl>
    ///<dt><b>RESOURCEDISPLAYTYPE_DOMAIN</b></dt> </dl> </td> <td width="60%"> Display the network service as a domain.
    ///</td> </tr> <tr> <td width="40%"><a id="RESOURCEDISPLAYTYPE_FILE"></a><a id="resourcedisplaytype_file"></a><dl>
    ///<dt><b>RESOURCEDISPLAYTYPE_FILE</b></dt> </dl> </td> <td width="60%"> Display the network service as a file.
    ///</td> </tr> <tr> <td width="40%"><a id="RESOURCEDISPLAYTYPE_GENERIC"></a><a
    ///id="resourcedisplaytype_generic"></a><dl> <dt><b>RESOURCEDISPLAYTYPE_GENERIC</b></dt> </dl> </td> <td
    ///width="60%"> The method used to display the object does not matter. </td> </tr> <tr> <td width="40%"><a
    ///id="RESOURCEDISPLAYTYPE_GROUP"></a><a id="resourcedisplaytype_group"></a><dl>
    ///<dt><b>RESOURCEDISPLAYTYPE_GROUP</b></dt> </dl> </td> <td width="60%"> Display the network service as a group.
    ///</td> </tr> <tr> <td width="40%"><a id="RESOURCEDISPLAYTYPE_SERVER"></a><a
    ///id="resourcedisplaytype_server"></a><dl> <dt><b>RESOURCEDISPLAYTYPE_SERVER</b></dt> </dl> </td> <td width="60%">
    ///Display the network service as a server. </td> </tr> <tr> <td width="40%"><a
    ///id="RESOURCEDISPLAYTYPE_SHARE"></a><a id="resourcedisplaytype_share"></a><dl>
    ///<dt><b>RESOURCEDISPLAYTYPE_SHARE</b></dt> </dl> </td> <td width="60%"> Display the network service as a
    ///sharepoint. </td> </tr> <tr> <td width="40%"><a id="RESOURCEDISPLAYTYPE_TREE"></a><a
    ///id="resourcedisplaytype_tree"></a><dl> <dt><b>RESOURCEDISPLAYTYPE_TREE</b></dt> </dl> </td> <td width="60%">
    ///Display the network service as a tree. </td> </tr> </table>
    uint               dwDisplayHint;
    ///Type: <b>DWORD</b> The version for the network service. The high word of this value specifies a major version
    ///number. The low word of this value specifies a minor version number.
    uint               dwVersion;
    ///Type: <b>DWORD</b> Reserved for future use. Must be zero.
    uint               dwTime;
    ///Type: <b>LPTSTR</b> A pointer to a <b>NULL</b>-terminated string that is the name of the computer on which the
    ///network service is running.
    const(wchar)*      lpMachineName;
    ///Type: <b>LPSERVICE_ADDRESSES</b> A pointer to a SERVICE_ADDRESSES structure that contains an array of
    ///SERVICE_ADDRESS structures. Each <b>SERVICE_ADDRESS</b> structure contains information about a network service
    ///address. A network service can call the getsockname function to determine the local address of the system.
    SERVICE_ADDRESSES* lpServiceAddress;
    ///Type: <b>BLOB</b> A BLOB structure that specifies service-defined information. <div class="alert"><b>Note</b> In
    ///general, the data pointed to by the BLOB structure's <b>pBlobData</b> member must not contain any pointers. That
    ///is because only the network service knows the format of the data; copying the data without such knowledge would
    ///lead to pointer invalidation. If the data pointed to by <b>pBlobData</b> contains variable-sized elements,
    ///offsets from <b>pBlobData</b> can be used to indicate the location of those elements. There is one exception to
    ///this general rule: when <b>pBlobData</b> points to a SERVICE_TYPE_INFO_ABS structure. This is possible because
    ///both the <b>SERVICE_TYPE_INFO_ABS</b> structure, and any SERVICE_TYPE_VALUE_ABS structures it contains are
    ///predefined, and thus their formats are known to the operating system.</div> <div> </div>
    BLOB               ServiceSpecificInfo;
}

///The <b>NS_SERVICE_INFO</b> structure contains information about a network service or a network service type in the
///context of a specified namespace, or a set of default namespaces.
struct NS_SERVICE_INFOA
{
    ///Type: <b>DWORD</b> Namespace, or a set of default namespaces, to which this service information applies. Use one
    ///of the following constant values to specify a namespace. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl> <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td
    ///width="60%"> A set of default namespaces. The set of default namespaces typically includes all the namespaces
    ///installed on the system. System administrators, however, can exclude particular namespaces from the set. </td>
    ///</tr> <tr> <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td
    ///width="60%"> The Domain Name System used in the Internet to resolve the name of the host. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_MS"></a><a id="ns_ms"></a><dl> <dt><b>NS_MS</b></dt> </dl> </td> <td width="60%"> The
    ///Microsoft namespace. </td> </tr> <tr> <td width="40%"><a id="NS_NDS"></a><a id="ns_nds"></a><dl>
    ///<dt><b>NS_NDS</b></dt> </dl> </td> <td width="60%"> The NetWare 4 provider. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_NETBT"></a><a id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%"> The NetBIOS
    ///over TCP/IP layer. The operating system registers their computer names with NetBIOS. This namespace is used to
    ///convert a computer name to an IP address that uses this registration. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_NIS"></a><a id="ns_nis"></a><dl> <dt><b>NS_NIS</b></dt> </dl> </td> <td width="60%"> </td> </tr> <tr> <td
    ///width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl> <dt><b>NS_SAP</b></dt> </dl> </td> <td width="60%"> The
    ///NetWare Service Advertising Protocol. This can access the NetWare bindery, if appropriate. NS_SAP is a dynamic
    ///namespace that enables the registration of services. </td> </tr> <tr> <td width="40%"><a id="NS_STDA"></a><a
    ///id="ns_stda"></a><dl> <dt><b>NS_STDA</b></dt> </dl> </td> <td width="60%"> </td> </tr> <tr> <td width="40%"><a
    ///id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl> <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td> <td
    ///width="60%"> Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\posts file. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl> <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td>
    ///<td width="60%"> Local TCP/IP name resolution mechanisms, including comparisons against the local host name and
    ///lookup value in the cache of host to IP address mappings. </td> </tr> <tr> <td width="40%"><a id="NS_WINS"></a><a
    ///id="ns_wins"></a><dl> <dt><b>NS_WINS</b></dt> </dl> </td> <td width="60%"> The Windows Internet Name System
    ///(WINS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_X500"></a><a id="ns_x500"></a><dl>
    ///<dt><b>NS_X500</b></dt> </dl> </td> <td width="60%"> The X.500 directory service namespace. </td> </tr> </table>
    uint          dwNameSpace;
    ///Type: <b>SERVICE_INFO</b> A SERVICE_INFO structure that contains information about a network service or network
    ///service type.
    SERVICE_INFOA ServiceInfo;
}

///The <b>NS_SERVICE_INFO</b> structure contains information about a network service or a network service type in the
///context of a specified namespace, or a set of default namespaces.
struct NS_SERVICE_INFOW
{
    ///Type: <b>DWORD</b> Namespace, or a set of default namespaces, to which this service information applies. Use one
    ///of the following constant values to specify a namespace. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
    ///<td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl> <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td
    ///width="60%"> A set of default namespaces. The set of default namespaces typically includes all the namespaces
    ///installed on the system. System administrators, however, can exclude particular namespaces from the set. </td>
    ///</tr> <tr> <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td
    ///width="60%"> The Domain Name System used in the Internet to resolve the name of the host. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_MS"></a><a id="ns_ms"></a><dl> <dt><b>NS_MS</b></dt> </dl> </td> <td width="60%"> The
    ///Microsoft namespace. </td> </tr> <tr> <td width="40%"><a id="NS_NDS"></a><a id="ns_nds"></a><dl>
    ///<dt><b>NS_NDS</b></dt> </dl> </td> <td width="60%"> The NetWare 4 provider. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_NETBT"></a><a id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%"> The NetBIOS
    ///over TCP/IP layer. The operating system registers their computer names with NetBIOS. This namespace is used to
    ///convert a computer name to an IP address that uses this registration. </td> </tr> <tr> <td width="40%"><a
    ///id="NS_NIS"></a><a id="ns_nis"></a><dl> <dt><b>NS_NIS</b></dt> </dl> </td> <td width="60%"> </td> </tr> <tr> <td
    ///width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl> <dt><b>NS_SAP</b></dt> </dl> </td> <td width="60%"> The
    ///NetWare Service Advertising Protocol. This can access the NetWare bindery, if appropriate. NS_SAP is a dynamic
    ///namespace that enables the registration of services. </td> </tr> <tr> <td width="40%"><a id="NS_STDA"></a><a
    ///id="ns_stda"></a><dl> <dt><b>NS_STDA</b></dt> </dl> </td> <td width="60%"> </td> </tr> <tr> <td width="40%"><a
    ///id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl> <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td> <td
    ///width="60%"> Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\posts file. </td> </tr> <tr> <td
    ///width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl> <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td>
    ///<td width="60%"> Local TCP/IP name resolution mechanisms, including comparisons against the local host name and
    ///lookup value in the cache of host to IP address mappings. </td> </tr> <tr> <td width="40%"><a id="NS_WINS"></a><a
    ///id="ns_wins"></a><dl> <dt><b>NS_WINS</b></dt> </dl> </td> <td width="60%"> The Windows Internet Name System
    ///(WINS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_X500"></a><a id="ns_x500"></a><dl>
    ///<dt><b>NS_X500</b></dt> </dl> </td> <td width="60%"> The X.500 directory service namespace. </td> </tr> </table>
    uint          dwNameSpace;
    ///Type: <b>SERVICE_INFO</b> A SERVICE_INFO structure that contains information about a network service or network
    ///service type.
    SERVICE_INFOW ServiceInfo;
}

///The <b>PROTOCOL_INFO</b> structure contains information about a protocol.
struct PROTOCOL_INFOA
{
    ///Type: <b>DWORD</b> A set of bit flags that specifies the services provided by the protocol. One or more of the
    ///following bit flags may be set. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="XP_CONNECTIONLESS"></a><a id="xp_connectionless"></a><dl> <dt><b>XP_CONNECTIONLESS</b></dt> </dl> </td> <td
    ///width="60%"> If this flag is set, the protocol provides connectionless (datagram) service. If this flag is clear,
    ///the protocol provides connection-oriented data transfer. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_GUARANTEED_DELIVERY"></a><a id="xp_guaranteed_delivery"></a><dl> <dt><b>XP_GUARANTEED_DELIVERY</b></dt>
    ///</dl> </td> <td width="60%"> If this flag is set, the protocol guarantees that all data sent will reach the
    ///intended destination. If this flag is clear, there is no such guarantee. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_GUARANTEED_ORDER"></a><a id="xp_guaranteed_order"></a><dl> <dt><b>XP_GUARANTEED_ORDER</b></dt> </dl> </td>
    ///<td width="60%"> If this flag is set, the protocol guarantees that data will arrive in the order in which it was
    ///sent. Note that this characteristic does not guarantee delivery of the data, only its order. If this flag is
    ///clear, the order of data sent is not guaranteed. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_MESSAGE_ORIENTED"></a><a id="xp_message_oriented"></a><dl> <dt><b>XP_MESSAGE_ORIENTED</b></dt> </dl> </td>
    ///<td width="60%"> If this flag is set, the protocol is message-oriented. A message-oriented protocol honors
    ///message boundaries. If this flag is clear, the protocol is stream oriented, and the concept of message boundaries
    ///is irrelevant. </td> </tr> <tr> <td width="40%"><a id="XP_PSEUDO_STREAM"></a><a id="xp_pseudo_stream"></a><dl>
    ///<dt><b>XP_PSEUDO_STREAM</b></dt> </dl> </td> <td width="60%"> If this flag is set, the protocol is a
    ///message-oriented protocol that ignores message boundaries for all receive operations. This optional capability is
    ///useful when you do not want the protocol to frame messages. An application that requires stream-oriented
    ///characteristics can open a socket with type SOCK_STREAM for transport protocols that support this functionality,
    ///regardless of the value of <b>iSocketType</b>. </td> </tr> <tr> <td width="40%"><a id="XP_GRACEFUL_CLOSE"></a><a
    ///id="xp_graceful_close"></a><dl> <dt><b>XP_GRACEFUL_CLOSE</b></dt> </dl> </td> <td width="60%"> If this flag is
    ///set, the protocol supports two-phase close operations, also known as graceful close operations. If this flag is
    ///clear, the protocol supports only abortive close operations. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_EXPEDITED_DATA"></a><a id="xp_expedited_data"></a><dl> <dt><b>XP_EXPEDITED_DATA</b></dt> </dl> </td> <td
    ///width="60%"> If this flag is set, the protocol supports expedited data, also known as urgent data. </td> </tr>
    ///<tr> <td width="40%"><a id="XP_CONNECT_DATA"></a><a id="xp_connect_data"></a><dl> <dt><b>XP_CONNECT_DATA</b></dt>
    ///</dl> </td> <td width="60%"> If this flag is set, the protocol supports connect data. </td> </tr> <tr> <td
    ///width="40%"><a id="XP_DISCONNECT_DATA"></a><a id="xp_disconnect_data"></a><dl> <dt><b>XP_DISCONNECT_DATA</b></dt>
    ///</dl> </td> <td width="60%"> If this flag is set, the protocol supports disconnect data. </td> </tr> <tr> <td
    ///width="40%"><a id="XP_SUPPORTS_BROADCAST"></a><a id="xp_supports_broadcast"></a><dl>
    ///<dt><b>XP_SUPPORTS_BROADCAST</b></dt> </dl> </td> <td width="60%"> If this flag is set, the protocol supports a
    ///broadcast mechanism. </td> </tr> <tr> <td width="40%"><a id="XP_SUPPORTS_MULTICAST"></a><a
    ///id="xp_supports_multicast"></a><dl> <dt><b>XP_SUPPORTS_MULTICAST</b></dt> </dl> </td> <td width="60%"> If this
    ///flag is set, the protocol supports a multicast mechanism. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_BANDWIDTH_ALLOCATION"></a><a id="xp_bandwidth_allocation"></a><dl> <dt><b>XP_BANDWIDTH_ALLOCATION</b></dt>
    ///</dl> </td> <td width="60%"> If this flag is set, the protocol supports a mechanism for allocating a guaranteed
    ///bandwidth to an application. </td> </tr> <tr> <td width="40%"><a id="XP_FRAGMENTATION"></a><a
    ///id="xp_fragmentation"></a><dl> <dt><b>XP_FRAGMENTATION</b></dt> </dl> </td> <td width="60%"> If this flag is set,
    ///the protocol supports message fragmentation; physical network MTU is hidden from applications. </td> </tr> <tr>
    ///<td width="40%"><a id="XP_ENCRYPTS"></a><a id="xp_encrypts"></a><dl> <dt><b>XP_ENCRYPTS</b></dt> </dl> </td> <td
    ///width="60%"> If this flag is set, the protocol supports data encryption. </td> </tr> </table>
    uint         dwServiceFlags;
    ///Type: <b>INT</b> Value to pass as the <i>af</i> parameter when the socket function is called to open a socket for
    ///the protocol. This address family value uniquely defines the structure of protocol addresses, also known as
    ///<b>sockaddr</b> structures, used by the protocol.
    int          iAddressFamily;
    ///Type: <b>INT</b> Maximum length of a socket address supported by the protocol, in bytes.
    int          iMaxSockAddr;
    ///Type: <b>INT</b> Minimum length of a socket address supported by the protocol, in bytes.
    int          iMinSockAddr;
    ///Type: <b>INT</b> Value to pass as the <i>type</i> parameter when the <b>socket</b> function is called to open a
    ///socket for the protocol. Note that if XP_PSEUDO_STREAM is set in <b>dwServiceFlags</b>, the application can
    ///specify SOCK_STREAM as the <i>type</i> parameter to <b>socket</b>, regardless of the value of <b>iSocketType</b>.
    int          iSocketType;
    ///Type: <b>INT</b> Value to pass as the <i>protocol</i> parameter when the <b>socket</b> function is called to open
    ///a socket for the protocol.
    int          iProtocol;
    ///Type: <b>DWORD</b> Maximum message size supported by the protocol, in bytes. This is the maximum size of a
    ///message that can be sent from or received by the host. For protocols that do not support message framing, the
    ///actual maximum size of a message that can be sent to a given address may be less than this value. The following
    ///special message size values are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> The protocol is stream-oriented;
    ///the concept of message size is not relevant. </td> </tr> <tr> <td width="40%"><a id="0xFFFFFFFF"></a><a
    ///id="0xffffffff"></a><a id="0XFFFFFFFF"></a><dl> <dt><b>0xFFFFFFFF</b></dt> </dl> </td> <td width="60%"> The
    ///protocol is message-oriented, but there is no maximum message size. </td> </tr> </table>
    uint         dwMessageSize;
    ///Type: <b>LPTSTR</b> Pointer to a zero-terminated string that supplies a name for the protocol; for example,
    ///"SPX2."
    const(char)* lpProtocol;
}

///The <b>PROTOCOL_INFO</b> structure contains information about a protocol.
struct PROTOCOL_INFOW
{
    ///Type: <b>DWORD</b> A set of bit flags that specifies the services provided by the protocol. One or more of the
    ///following bit flags may be set. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
    ///id="XP_CONNECTIONLESS"></a><a id="xp_connectionless"></a><dl> <dt><b>XP_CONNECTIONLESS</b></dt> </dl> </td> <td
    ///width="60%"> If this flag is set, the protocol provides connectionless (datagram) service. If this flag is clear,
    ///the protocol provides connection-oriented data transfer. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_GUARANTEED_DELIVERY"></a><a id="xp_guaranteed_delivery"></a><dl> <dt><b>XP_GUARANTEED_DELIVERY</b></dt>
    ///</dl> </td> <td width="60%"> If this flag is set, the protocol guarantees that all data sent will reach the
    ///intended destination. If this flag is clear, there is no such guarantee. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_GUARANTEED_ORDER"></a><a id="xp_guaranteed_order"></a><dl> <dt><b>XP_GUARANTEED_ORDER</b></dt> </dl> </td>
    ///<td width="60%"> If this flag is set, the protocol guarantees that data will arrive in the order in which it was
    ///sent. Note that this characteristic does not guarantee delivery of the data, only its order. If this flag is
    ///clear, the order of data sent is not guaranteed. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_MESSAGE_ORIENTED"></a><a id="xp_message_oriented"></a><dl> <dt><b>XP_MESSAGE_ORIENTED</b></dt> </dl> </td>
    ///<td width="60%"> If this flag is set, the protocol is message-oriented. A message-oriented protocol honors
    ///message boundaries. If this flag is clear, the protocol is stream oriented, and the concept of message boundaries
    ///is irrelevant. </td> </tr> <tr> <td width="40%"><a id="XP_PSEUDO_STREAM"></a><a id="xp_pseudo_stream"></a><dl>
    ///<dt><b>XP_PSEUDO_STREAM</b></dt> </dl> </td> <td width="60%"> If this flag is set, the protocol is a
    ///message-oriented protocol that ignores message boundaries for all receive operations. This optional capability is
    ///useful when you do not want the protocol to frame messages. An application that requires stream-oriented
    ///characteristics can open a socket with type SOCK_STREAM for transport protocols that support this functionality,
    ///regardless of the value of <b>iSocketType</b>. </td> </tr> <tr> <td width="40%"><a id="XP_GRACEFUL_CLOSE"></a><a
    ///id="xp_graceful_close"></a><dl> <dt><b>XP_GRACEFUL_CLOSE</b></dt> </dl> </td> <td width="60%"> If this flag is
    ///set, the protocol supports two-phase close operations, also known as graceful close operations. If this flag is
    ///clear, the protocol supports only abortive close operations. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_EXPEDITED_DATA"></a><a id="xp_expedited_data"></a><dl> <dt><b>XP_EXPEDITED_DATA</b></dt> </dl> </td> <td
    ///width="60%"> If this flag is set, the protocol supports expedited data, also known as urgent data. </td> </tr>
    ///<tr> <td width="40%"><a id="XP_CONNECT_DATA"></a><a id="xp_connect_data"></a><dl> <dt><b>XP_CONNECT_DATA</b></dt>
    ///</dl> </td> <td width="60%"> If this flag is set, the protocol supports connect data. </td> </tr> <tr> <td
    ///width="40%"><a id="XP_DISCONNECT_DATA"></a><a id="xp_disconnect_data"></a><dl> <dt><b>XP_DISCONNECT_DATA</b></dt>
    ///</dl> </td> <td width="60%"> If this flag is set, the protocol supports disconnect data. </td> </tr> <tr> <td
    ///width="40%"><a id="XP_SUPPORTS_BROADCAST"></a><a id="xp_supports_broadcast"></a><dl>
    ///<dt><b>XP_SUPPORTS_BROADCAST</b></dt> </dl> </td> <td width="60%"> If this flag is set, the protocol supports a
    ///broadcast mechanism. </td> </tr> <tr> <td width="40%"><a id="XP_SUPPORTS_MULTICAST"></a><a
    ///id="xp_supports_multicast"></a><dl> <dt><b>XP_SUPPORTS_MULTICAST</b></dt> </dl> </td> <td width="60%"> If this
    ///flag is set, the protocol supports a multicast mechanism. </td> </tr> <tr> <td width="40%"><a
    ///id="XP_BANDWIDTH_ALLOCATION"></a><a id="xp_bandwidth_allocation"></a><dl> <dt><b>XP_BANDWIDTH_ALLOCATION</b></dt>
    ///</dl> </td> <td width="60%"> If this flag is set, the protocol supports a mechanism for allocating a guaranteed
    ///bandwidth to an application. </td> </tr> <tr> <td width="40%"><a id="XP_FRAGMENTATION"></a><a
    ///id="xp_fragmentation"></a><dl> <dt><b>XP_FRAGMENTATION</b></dt> </dl> </td> <td width="60%"> If this flag is set,
    ///the protocol supports message fragmentation; physical network MTU is hidden from applications. </td> </tr> <tr>
    ///<td width="40%"><a id="XP_ENCRYPTS"></a><a id="xp_encrypts"></a><dl> <dt><b>XP_ENCRYPTS</b></dt> </dl> </td> <td
    ///width="60%"> If this flag is set, the protocol supports data encryption. </td> </tr> </table>
    uint          dwServiceFlags;
    ///Type: <b>INT</b> Value to pass as the <i>af</i> parameter when the socket function is called to open a socket for
    ///the protocol. This address family value uniquely defines the structure of protocol addresses, also known as
    ///<b>sockaddr</b> structures, used by the protocol.
    int           iAddressFamily;
    ///Type: <b>INT</b> Maximum length of a socket address supported by the protocol, in bytes.
    int           iMaxSockAddr;
    ///Type: <b>INT</b> Minimum length of a socket address supported by the protocol, in bytes.
    int           iMinSockAddr;
    ///Type: <b>INT</b> Value to pass as the <i>type</i> parameter when the <b>socket</b> function is called to open a
    ///socket for the protocol. Note that if XP_PSEUDO_STREAM is set in <b>dwServiceFlags</b>, the application can
    ///specify SOCK_STREAM as the <i>type</i> parameter to <b>socket</b>, regardless of the value of <b>iSocketType</b>.
    int           iSocketType;
    ///Type: <b>INT</b> Value to pass as the <i>protocol</i> parameter when the <b>socket</b> function is called to open
    ///a socket for the protocol.
    int           iProtocol;
    ///Type: <b>DWORD</b> Maximum message size supported by the protocol, in bytes. This is the maximum size of a
    ///message that can be sent from or received by the host. For protocols that do not support message framing, the
    ///actual maximum size of a message that can be sent to a given address may be less than this value. The following
    ///special message size values are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
    ///width="40%"><a id="0"></a><dl> <dt><b>0</b></dt> </dl> </td> <td width="60%"> The protocol is stream-oriented;
    ///the concept of message size is not relevant. </td> </tr> <tr> <td width="40%"><a id="0xFFFFFFFF"></a><a
    ///id="0xffffffff"></a><a id="0XFFFFFFFF"></a><dl> <dt><b>0xFFFFFFFF</b></dt> </dl> </td> <td width="60%"> The
    ///protocol is message-oriented, but there is no maximum message size. </td> </tr> </table>
    uint          dwMessageSize;
    ///Type: <b>LPTSTR</b> Pointer to a zero-terminated string that supplies a name for the protocol; for example,
    ///"SPX2."
    const(wchar)* lpProtocol;
}

struct NETRESOURCE2A
{
    uint         dwScope;
    uint         dwType;
    uint         dwUsage;
    uint         dwDisplayType;
    const(char)* lpLocalName;
    const(char)* lpRemoteName;
    const(char)* lpComment;
    NS_INFOA     ns_info;
    GUID         ServiceType;
    uint         dwProtocols;
    int*         lpiProtocols;
}

struct NETRESOURCE2W
{
    uint          dwScope;
    uint          dwType;
    uint          dwUsage;
    uint          dwDisplayType;
    const(wchar)* lpLocalName;
    const(wchar)* lpRemoteName;
    const(wchar)* lpComment;
    NS_INFOA      ns_info;
    GUID          ServiceType;
    uint          dwProtocols;
    int*          lpiProtocols;
}

struct SERVICE_ASYNC_INFO
{
    LPSERVICE_CALLBACK_PROC lpServiceCallbackProc;
    LPARAM lParam;
    HANDLE hAsyncTaskHandle;
}

// Functions

///The <b>__WSAFDIsSet</b> function specifies whether a socket is included in a set of socket descriptors.
///Params:
///    fd = Descriptor identifying a socket.
///    arg2 = Pointer to an fd_set structure containing the set of socket descriptors. The <b>__WSAFDIsSet</b> function
///           determines whether the socket specified in the <i>fd</i> parameter is a member of that set.
@DllImport("WS2_32")
int __WSAFDIsSet(size_t fd, fd_set* param1);

///The <b>accept</b> function permits an incoming connection attempt on a socket.
///Params:
///    s = A descriptor that identifies a socket that has been placed in a listening state with the listen function. The
///        connection is actually made with the socket that is returned by <b>accept</b>.
///    addr = An optional pointer to a buffer that receives the address of the connecting entity, as known to the
///           communications layer. The exact format of the <i>addr</i> parameter is determined by the address family that was
///           established when the socket from the sockaddr structure was created.
///    addrlen = An optional pointer to an integer that contains the length of structure pointed to by the <i>addr</i> parameter.
///Returns:
///    If no error occurs, <b>accept</b> returns a value of type <b>SOCKET</b> that is a descriptor for the new socket.
///    This returned value is a handle for the socket on which the actual connection is made. Otherwise, a value of
///    <b>INVALID_SOCKET</b> is returned, and a specific error code can be retrieved by calling WSAGetLastError. The
///    integer referred to by <i>addrlen</i> initially contains the amount of space pointed to by <i>addr</i>. On return
///    it will contain the actual length in bytes of the address returned. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> An incoming connection was indicated, but was
///    subsequently terminated by the remote peer prior to accepting the call. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>addrlen</i> parameter is too small or <i>addr</i>
///    is not a valid part of the user address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dt>
///    </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call was canceled through WSACancelBlockingCall.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The listen function
///    was not invoked prior to accept. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl>
///    </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still
///    processing a callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMFILE</b></dt> </dl> </td> <td
///    width="60%"> The queue is nonempty upon entry to accept and there are no descriptors available. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> No buffer space is
///    available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The
///    descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td
///    width="60%"> The referenced socket is not a type that supports connection-oriented service. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> The socket is marked as nonblocking
///    and no connections are present to be accepted. </td> </tr> </table>
///    
@DllImport("WS2_32")
size_t accept(size_t s, char* addr, int* addrlen);

///The <b>bind</b> function associates a local address with a socket.
///Params:
///    s = A descriptor identifying an unbound socket.
///    name = A pointer to a sockaddr structure of the local address to assign to the bound socket .
///    namelen = The length, in bytes, of the value pointed to by the <i>name</i> parameter.
///Returns:
///    If no error occurs, <b>bind</b> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can
///    be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> <div class="alert"><b>Note</b> A
///    successful WSAStartup call must occur before using this function.</div> <div> </div> </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td width="60%"> An attempt was made
///    to access a socket in a way forbidden by its access permissions. This error is returned if nn attempt to bind a
///    datagram socket to the broadcast address failed because the setsockopt option SO_BROADCAST is not enabled. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRINUSE</b></dt> </dl> </td> <td width="60%"> Only one usage of
///    each socket address (protocol/network address/port) is normally permitted. This error is returned if a process on
///    the computer is already bound to the same fully qualified address and the socket has not been marked to allow
///    address reuse with SO_REUSEADDR. For example, the IP address and port specified in the <i>name</i> parameter are
///    already bound to another socket being used by another application. For more information, see the SO_REUSEADDR
///    socket option in the SOL_SOCKET Socket Options reference, Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE, and
///    SO_EXCLUSIVEADDRUSE. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRNOTAVAIL</b></dt> </dl> </td> <td
///    width="60%"> The requested address is not valid in its context. This error is returned if the specified address
///    pointed to by the <i>name</i> parameter is not a valid local IP address on this computer. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The system detected an invalid pointer
///    address in attempting to use a pointer argument in a call. This error is returned if the <i>name</i> parameter is
///    NULL, the <i>name</i> or <i>namelen</i> parameter is not a valid part of the user address space, the
///    <i>namelen</i> parameter is too small, the <i>name</i> parameter contains an incorrect address format for the
///    associated address family, or the first two bytes of the memory block specified by <i>name</i> do not match the
///    address family associated with the socket descriptor <i>s</i>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress,
///    or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid argument was supplied. This error is returned
///    of the socket <i>s</i> is already bound to an address. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> An operation on a socket could not be performed because
///    the system lacked sufficient buffer space or because a queue was full. This error is returned of not enough
///    buffers are available or there are too many connections. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> An operation was attempted on something that is not a
///    socket. This error is returned if the descriptor in the <i>s</i> parameter is not a socket. </td> </tr> </table>
///    
@DllImport("WS2_32")
int bind(size_t s, char* name, int namelen);

///The <b>closesocket</b> function closes an existing socket.
///Params:
///    s = A descriptor identifying the socket to close.
///Returns:
///    If no error occurs, <b>closesocket</b> returns zero. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows
///    Sockets 1.1 call is in progress, or the service provider is still processing a callback function. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> The (blocking) Windows Socket
///    1.1 call was canceled through WSACancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> The socket is marked as nonblocking, but the
///    <b>l_onoff</b> member of the linger structure is set to nonzero and the <b>l_linger</b> member of the
///    <b>linger</b> structure is set to a nonzero timeout value. </td> </tr> </table>
///    
@DllImport("WS2_32")
int closesocket(size_t s);

///The <b>connect</b> function establishes a connection to a specified socket.
///Params:
///    s = A descriptor identifying an unconnected socket.
///    name = A pointer to the sockaddr structure to which the connection should be established.
///    namelen = The length, in bytes, of the sockaddr structure pointed to by the <i>name</i> parameter.
///Returns:
///    If no error occurs, <b>connect</b> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code
///    can be retrieved by calling WSAGetLastError. On a blocking socket, the return value indicates success or failure
///    of the connection attempt. With a nonblocking socket, the connection attempt cannot be completed immediately. In
///    this case, <b>connect</b> will return SOCKET_ERROR, and WSAGetLastError will return WSAEWOULDBLOCK. In this case,
///    there are three possible scenarios: <ul> <li>Use the select function to determine the completion of the
///    connection request by checking to see if the socket is writeable.</li> <li>If the application is using
///    WSAAsyncSelect to indicate interest in connection events, then the application will receive an FD_CONNECT
///    notification indicating that the <b>connect</b> operation is complete (successfully or not).</li> <li>If the
///    application is using WSAEventSelect to indicate interest in connection events, then the associated event object
///    will be signaled indicating that the <b>connect</b> operation is complete (successfully or not).</li> </ul> Until
///    the connection attempt completes on a nonblocking socket, all subsequent calls to <b>connect</b> on the same
///    socket will fail with the error code WSAEALREADY, and WSAEISCONN when the connection completes successfully. Due
///    to ambiguities in version 1.1 of the Windows Sockets specification, error codes returned from <b>connect</b>
///    while a connection is already pending may vary among implementations. As a result, it is not recommended that
///    applications use multiple calls to connect to detect connection completion. If they do, they must be prepared to
///    handle WSAEINVAL and WSAEWOULDBLOCK error values the same way that they handle WSAEALREADY, to assure robust
///    operation. If the error code returned indicates the connection attempt failed (that is, WSAECONNREFUSED,
///    WSAENETUNREACH, WSAETIMEDOUT) the application can call <b>connect</b> again for the same socket. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRINUSE</b></dt> </dl> </td> <td width="60%"> The socket's
///    local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This
///    error usually occurs when executing bind, but could be delayed until the connect function if the <b>bind</b> was
///    to a wildcard address (<b>INADDR_ANY</b> or <b>in6addr_any</b>) for the local IP address. A specific address
///    needs to be implicitly bound by the <b>connect</b> function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> The blocking Windows Socket 1.1 call was canceled through
///    WSACancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td
///    width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a
///    callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEALREADY</b></dt> </dl> </td> <td
///    width="60%"> A nonblocking connect call is in progress on the specified socket. <div class="alert"><b>Note</b> In
///    order to preserve backward compatibility, this error is reported as WSAEINVAL to Windows Sockets 1.1 applications
///    that link to either Winsock.dll or Wsock32.dll.</div> <div> </div> </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEADDRNOTAVAIL</b></dt> </dl> </td> <td width="60%"> The remote address is not a valid address (such as
///    <b>INADDR_ANY</b> or <b>in6addr_any</b>) . </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt>
///    </dl> </td> <td width="60%"> Addresses in the specified family cannot be used with this socket. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAECONNREFUSED</b></dt> </dl> </td> <td width="60%"> The attempt to connect was
///    forcefully rejected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The sockaddr structure pointed to by the <i>name</i> contains incorrect address format for the
///    associated address family or the <i>namelen</i> parameter is too small. This error is also returned if the
///    <b>sockaddr</b> structure pointed to by the <i>name</i> parameter with a length specified in the <i>namelen</i>
///    parameter is not in a valid part of the user address space. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The parameter <i>s</i> is a listening socket. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEISCONN</b></dt> </dl> </td> <td width="60%"> The socket is already
///    connected (connection-oriented sockets only). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETUNREACH</b></dt> </dl> </td> <td width="60%"> The network cannot be reached from this host at this
///    time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEHOSTUNREACH</b></dt> </dl> </td> <td width="60%"> A
///    socket operation was attempted to an unreachable host. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> <div class="alert"><b>Note</b> No buffer space is
///    available. The socket cannot be connected.</div> <div> </div> </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor specified in the <i>s</i> parameter is
///    not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> An
///    attempt to connect timed out without establishing a connection. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> The socket is marked as nonblocking and the
///    connection cannot be completed immediately. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt>
///    </dl> </td> <td width="60%"> An attempt to connect a datagram socket to broadcast address failed because
///    setsockopt option SO_BROADCAST is not enabled. </td> </tr> </table>
///    
@DllImport("WS2_32")
int connect(size_t s, char* name, int namelen);

///The <b>ioctlsocket</b> function controls the I/O mode of a socket.
///Params:
///    s = A descriptor identifying a socket.
///    cmd = A command to perform on the socket <i>s</i>.
///    argp = A pointer to a parameter for <i>cmd</i>.
///Returns:
///    Upon successful completion, the <b>ioctlsocket</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned,
///    and a specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call
///    is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor <i>s</i> is not a
///    socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The
///    <i>argp</i> parameter is not a valid part of the user address space. </td> </tr> </table>
///    
@DllImport("WS2_32")
int ioctlsocket(size_t s, int cmd, uint* argp);

///The <b>getpeername</b> function retrieves the address of the peer to which a socket is connected.
///Params:
///    s = A descriptor identifying a connected socket.
///    name = The SOCKADDR structure that receives the address of the peer.
///    namelen = A pointer to the size, in bytes, of the <i>name</i> parameter.
///Returns:
///    If no error occurs, <b>getpeername</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>name</i> or the <i>namelen</i>
///    parameter is not in a valid part of the user address space, or the <i>namelen</i> parameter is too small. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows
///    Sockets 1.1 call is in progress, or the service provider is still processing a callback function. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%"> The socket is not connected.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is
///    not a socket. </td> </tr> </table>
///    
@DllImport("WS2_32")
int getpeername(size_t s, char* name, int* namelen);

///The <b>getsockname</b> function retrieves the local name for a socket.
///Params:
///    s = Descriptor identifying a socket.
///    name = Pointer to a SOCKADDR structure that receives the address (name) of the socket.
///    namelen = Size of the <i>name</i> buffer, in bytes.
///Returns:
///    If no error occurs, <b>getsockname</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this API. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>name</i> or the <i>namelen</i>
///    parameter is not a valid part of the user address space, or the <i>namelen</i> parameter is too small. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows
///    Sockets 1.1 call is in progress, or the service provider is still processing a callback function. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a
///    socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The socket
///    has not been bound to an address with bind, or ADDR_ANY is specified in <b>bind</b> but connection has not yet
///    occurred. </td> </tr> </table>
///    
@DllImport("WS2_32")
int getsockname(size_t s, char* name, int* namelen);

///The <b>getsockopt</b> function retrieves a socket option.
///Params:
///    s = A descriptor identifying a socket.
///    level = The level at which the option is defined. Example: SOL_SOCKET.
///    optname = The socket option for which the value is to be retrieved. Example: SO_ACCEPTCONN. The <i>optname</i> value must
///              be a socket option defined within the specified <i>level</i>, or behavior is undefined.
///    optval = A pointer to the buffer in which the value for the requested option is to be returned.
///    optlen = A pointer to the size, in bytes, of the <i>optval</i> buffer.
///Returns:
///    If no error occurs, <b>getsockopt</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> <div class="alert"><b>Note</b> The network subsystem has
///    failed.</div> <div> </div> </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> One of the <i>optval</i> or the <i>optlen</i> parameters is not a valid part of the user address
///    space, or the <i>optlen</i> parameter is too small. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress,
///    or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The <i>level</i> parameter is unknown or invalid. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOPROTOOPT</b></dt> </dl> </td> <td width="60%"> The option is
///    unknown or unsupported by the indicated protocol family. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> </table>
///    
@DllImport("WS2_32")
int getsockopt(size_t s, int level, int optname, char* optval, int* optlen);

///The <b>htonl</b> function converts a <b>u_long</b> from host to TCP/IP network byte order (which is big-endian).
///Params:
///    hostlong = A 32-bit number in host byte order.
///Returns:
///    The <b>htonl</b> function returns the value in TCP/IP's network byte order.
///    
@DllImport("WS2_32")
uint htonl(uint hostlong);

///The <b>htons</b> function converts a <b>u_short</b> from host to TCP/IP network byte order (which is big-endian).
///Params:
///    hostshort = A 16-bit number in host byte order.
///Returns:
///    The <b>htons</b> function returns the value in TCP/IP network byte order.
///    
@DllImport("WS2_32")
ushort htons(ushort hostshort);

///The <b>inet_addr</b> function converts a string containing an IPv4 dotted-decimal address into a proper address for
///the IN_ADDR structure.
///Params:
///    a = A <b>NULL</b>-terminated character string representing a number expressed in the Internet standard ".'' (dotted)
///        notation.
@DllImport("WS2_32")
uint inet_addr(const(byte)* cp);

///The <b>inet_ntoa</b> function converts an (Ipv4) Internet network address into an ASCII string in Internet standard
///dotted-decimal format.
///Params:
///    a = An in_addr structure that represents an Internet host address.
@DllImport("WS2_32")
byte* inet_ntoa(in_addr in_);

///The <b>listen</b> function places a socket in a state in which it is listening for an incoming connection.
///Params:
///    s = A descriptor identifying a bound, unconnected socket.
///    backlog = The maximum length of the queue of pending connections. If set to <b>SOMAXCONN</b>, the underlying service
///              provider responsible for socket <i>s</i> will set the backlog to a maximum reasonable value. If set to
///              <b>SOMAXCONN_HINT(N)</b> (where N is a number), the backlog value will be N, adjusted to be within the range
///              (200, 65535). Note that <b>SOMAXCONN_HINT</b> can be used to set the backlog to a larger value than possible with
///              SOMAXCONN. <b>SOMAXCONN_HINT</b> is only supported by the Microsoft TCP/IP service provider. There is no standard
///              provision to obtain the actual backlog value.
///Returns:
///    If no error occurs, <b>listen</b> returns zero. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEADDRINUSE</b></dt> </dl> </td> <td width="60%"> The socket's local address is
///    already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs
///    during execution of the bind function, but could be delayed until this function if the <b>bind</b> was to a
///    partially wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of
///    this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%">
///    A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The
///    socket has not been bound with bind. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEISCONN</b></dt> </dl>
///    </td> <td width="60%"> The socket is already connected. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEMFILE</b></dt> </dl> </td> <td width="60%"> No more socket descriptors are available. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> No buffer space is available. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a
///    socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The
///    referenced socket is not of a type that supports the listen operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int listen(size_t s, int backlog);

///The <b>ntohl</b> function converts a <b>u_long</b> from TCP/IP network order to host byte order (which is
///little-endian on Intel processors).
///Params:
///    netlong = A 32-bit number in TCP/IP network byte order.
///Returns:
///    The <b>ntohl</b> function returns the value supplied in the <i>netlong</i> parameter with the byte order
///    reversed. If <i>netlong</i> is already in host byte order, then this function will reverse it. It is up to the
///    application to determine if the byte order must be reversed.
///    
@DllImport("WS2_32")
uint ntohl(uint netlong);

///The <b>ntohs</b> function converts a <b>u_short</b> from TCP/IP network byte order to host byte order (which is
///little-endian on Intel processors).
///Params:
///    netshort = A 16-bit number in TCP/IP network byte order.
///Returns:
///    The <b>ntohs</b> function returns the value in host byte order. If the <i>netshort</i> parameter is already in
///    host byte order, then this function will reverse it. It is up to the application to determine if the byte order
///    must be reversed.
///    
@DllImport("WS2_32")
ushort ntohs(ushort netshort);

///The <b>recv</b> function receives data from a connected socket or a bound connectionless socket.
///Params:
///    s = The descriptor that identifies a connected socket.
///    buf = A pointer to the buffer to receive the incoming data.
///    len = The length, in bytes, of the buffer pointed to by the <i>buf</i> parameter.
///    flags = A set of flags that influences the behavior of this function. See remarks below. See the Remarks section for
///            details on the possible value for this parameter.
///Returns:
///    If no error occurs, <b>recv</b> returns the number of bytes received and the buffer pointed to by the <i>buf</i>
///    parameter will contain this data received. If the connection has been gracefully closed, the return value is
///    zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling
///    WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call must occur before
///    using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td
///    width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt>
///    </dl> </td> <td width="60%"> The <i>buf</i> parameter is not completely contained in a valid part of the user
///    address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%">
///    The socket is not connected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td
///    width="60%"> The (blocking) call was canceled through WSACancelBlockingCall. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in
///    progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETRESET</b></dt> </dl> </td> <td width="60%"> For a connection-oriented socket, this error indicates
///    that the connection has been broken due to <i>keep-alive</i> activity that detected a failure while the operation
///    was in progress. For a datagram socket, this error indicates that the time to live has expired. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> MSG_OOB was
///    specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the
///    communication domain associated with this socket, or the socket is unidirectional and supports only send
///    operations. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
///    socket has been shut down; it is not possible to receive on a socket after shutdown has been invoked with
///    <b>how</b> set to SD_RECEIVE or SD_BOTH. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt>
///    </dl> </td> <td width="60%"> The socket is marked as nonblocking and the receive operation would block. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> The message was too
///    large to fit into the specified buffer and was truncated. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The socket has not been bound with bind, or an unknown
///    flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled or (for byte stream sockets
///    only) <i>len</i> was zero or negative. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNABORTED</b></dt>
///    </dl> </td> <td width="60%"> The virtual circuit was terminated due to a time-out or other failure. The
///    application should close the socket as it is no longer usable. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> The connection has been dropped because of a network
///    failure or because the peer system failed to respond. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> The virtual circuit was reset by the remote side
///    executing a hard or abortive close. The application should close the socket as it is no longer usable. On a
///    UDP-datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port
///    Unreachable" message. </td> </tr> </table>
///    
@DllImport("WS2_32")
int recv(size_t s, char* buf, int len, int flags);

///The <b>recvfrom</b> function receives a datagram, and stores the source address.
///Params:
///    s = A descriptor identifying a bound socket.
///    buf = A buffer for the incoming data.
///    len = The length, in bytes, of the buffer pointed to by the <i>buf</i> parameter.
///    flags = A set of options that modify the behavior of the function call beyond the options specified for the associated
///            socket. See the Remarks below for more details.
///    from = An optional pointer to a buffer in a sockaddr structure that will hold the source address upon return.
///    fromlen = An optional pointer to the size, in bytes, of the buffer pointed to by the <i>from</i> parameter.
///Returns:
///    If no error occurs, <b>recvfrom</b> returns the number of bytes received. If the connection has been gracefully
///    closed, the return value is zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can
///    be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl>
///    </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The buffer pointed to by the <i>buf</i> or <i>from</i>
///    parameters are not in the user address space, or the <i>fromlen</i> parameter is too small to accommodate the
///    source address of the peer address. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td>
///    <td width="60%"> The (blocking) call was canceled through WSACancelBlockingCall. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call
///    is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The socket has not been bound with bind,
///    or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled, or (for byte
///    stream-style sockets only) <i>len</i> was zero or negative. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEISCONN</b></dt> </dl> </td> <td width="60%"> The socket is connected. This function is not permitted
///    with a connected socket, whether the socket is connection oriented or connectionless. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETRESET</b></dt> </dl> </td> <td width="60%"> For a datagram socket, this error
///    indicates that the time to live has expired. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt>
///    </dl> </td> <td width="60%"> The descriptor in the <i>s</i> parameter is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> MSG_OOB was specified, but the
///    socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain
///    associated with this socket, or the socket is unidirectional and supports only send operations. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%"> The socket has been shut down; it
///    is not possible to recvfrom on a socket after shutdown has been invoked with <i>how</i> set to SD_RECEIVE or
///    SD_BOTH. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> The
///    socket is marked as nonblocking and the recvfrom operation would block. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> The message was too large to fit into the buffer pointed
///    to by the <i>buf</i> parameter and was truncated. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> The connection has been dropped, because of a network
///    failure or because the system on the other end went down without notice. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> The virtual circuit was reset by the remote side
///    executing a hard or abortive close. The application should close the socket; it is no longer usable. On a
///    UDP-datagram socket this error indicates a previous send operation resulted in an ICMP <i>Port Unreachable</i>
///    message. </td> </tr> </table>
///    
@DllImport("WS2_32")
int recvfrom(size_t s, char* buf, int len, int flags, char* from, int* fromlen);

///The <b>select</b> function determines the status of one or more sockets, waiting if necessary, to perform synchronous
///I/O.
///Params:
///    nfds = Ignored. The <i>nfds</i> parameter is included only for compatibility with Berkeley sockets.
///    readfds = An optional pointer to a set of sockets to be checked for readability.
///    writefds = An optional pointer to a set of sockets to be checked for writability.
///    exceptfds = An optional pointer to a set of sockets to be checked for errors.
///    timeout = The maximum time for <b>select</b> to wait, provided in the form of a TIMEVAL structure. Set the <i>timeout</i>
///              parameter to <b>null</b> for blocking operations.
///Returns:
///    The <b>select</b> function returns the total number of socket handles that are ready and contained in the fd_set
///    structures, zero if the time limit expired, or SOCKET_ERROR if an error occurred. If the return value is
///    SOCKET_ERROR, WSAGetLastError can be used to retrieve a specific error code. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The Windows Sockets implementation was unable to allocate
///    needed resources for its internal operations, or the <i>readfds</i>, <i>writefds</i>, <i>exceptfds</i>, or
///    <i>timeval</i> parameters are not part of the user address space. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The <i>time-out</i> value is not valid,
///    or all three descriptor parameters were <b>null</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking Windows Socket 1.1 call was canceled through
///    WSACancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td
///    width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a
///    callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td
///    width="60%"> One of the descriptor sets contains an entry that is not a socket. </td> </tr> </table>
///    
@DllImport("WS2_32")
int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const(timeval)* timeout);

///The <b>send</b> function sends data on a connected socket.
///Params:
///    s = A descriptor identifying a connected socket.
///    buf = A pointer to a buffer containing the data to be transmitted.
///    len = The length, in bytes, of the data in buffer pointed to by the <i>buf</i> parameter.
///    flags = A set of flags that specify the way in which the call is made. This parameter is constructed by using the bitwise
///            OR operator with any of the following values. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td
///            width="40%"><a id="MSG_DONTROUTE"></a><a id="msg_dontroute"></a><dl> <dt><b>MSG_DONTROUTE</b></dt> </dl> </td>
///            <td width="60%"> Specifies that the data should not be subject to routing. A Windows Sockets service provider can
///            choose to ignore this flag. </td> </tr> <tr> <td width="40%"><a id="MSG_OOB"></a><a id="msg_oob"></a><dl>
///            <dt><b>MSG_OOB</b></dt> </dl> </td> <td width="60%"> Sends OOB data (stream-style socket such as SOCK_STREAM
///            only. </td> </tr> </table>
///Returns:
///    If no error occurs, <b>send</b> returns the total number of bytes sent, which can be less than the number
///    requested to be sent in the <i>len</i> parameter. Otherwise, a value of SOCKET_ERROR is returned, and a specific
///    error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup
///    call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEACCES</b></dt> </dl> </td> <td width="60%"> The requested address is a broadcast address, but the
///    appropriate flag was not set. Call setsockopt with the SO_BROADCAST socket option to enable use of the broadcast
///    address. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking
///    Windows Sockets 1.1 call was canceled through WSACancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress,
///    or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>buf</i> parameter is not completely contained in a
///    valid part of the user address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETRESET</b></dt> </dl>
///    </td> <td width="60%"> The connection has been broken due to the keep-alive activity detecting a failure while
///    the operation was in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td
///    width="60%"> No buffer space is available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt>
///    </dl> </td> <td width="60%"> The socket is not connected. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> MSG_OOB was specified, but the
///    socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain
///    associated with this socket, or the socket is unidirectional and supports only receive operations. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%"> The socket has been shut
///    down; it is not possible to send on a socket after shutdown has been invoked with <i>how</i> set to SD_SEND or
///    SD_BOTH. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> The
///    socket is marked as nonblocking and the requested operation would block. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> The socket is message oriented, and the message is
///    larger than the maximum supported by the underlying transport. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEHOSTUNREACH</b></dt> </dl> </td> <td width="60%"> The remote host cannot be reached from this host at
///    this time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The
///    socket has not been bound with bind, or an unknown flag was specified, or MSG_OOB was specified for a socket with
///    SO_OOBINLINE enabled. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNABORTED</b></dt> </dl> </td> <td
///    width="60%"> The virtual circuit was terminated due to a time-out or other failure. The application should close
///    the socket as it is no longer usable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl>
///    </td> <td width="60%"> The virtual circuit was reset by the remote side executing a hard or abortive close. For
///    UDP sockets, the remote host was unable to deliver a previously sent UDP datagram and responded with a "Port
///    Unreachable" ICMP packet. The application should close the socket as it is no longer usable. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> The connection has been dropped,
///    because of a network failure or because the system on the other end went down without notice. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
int send(size_t s, char* buf, int len, int flags);

///The <b>sendto</b> function sends data to a specific destination.
///Params:
///    s = A descriptor identifying a (possibly connected) socket.
///    buf = A pointer to a buffer containing the data to be transmitted.
///    len = The length, in bytes, of the data pointed to by the <i>buf</i> parameter.
///    flags = A set of flags that specify the way in which the call is made.
///    to = An optional pointer to a sockaddr structure that contains the address of the target socket.
///    tolen = The size, in bytes, of the address pointed to by the <i>to</i> parameter.
///Returns:
///    If no error occurs, <b>sendto</b> returns the total number of bytes sent, which can be less than the number
///    indicated by <i>len</i>. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be
///    retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl>
///    </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEACCES</b></dt> </dl> </td> <td width="60%"> The requested address is a broadcast address, but the
///    appropriate flag was not set. Call setsockopt with the SO_BROADCAST parameter to allow the use of the broadcast
///    address. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An unknown
///    flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call was
///    canceled through WSACancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt>
///    </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still
///    processing a callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The <i>buf</i> or <i>to</i> parameters are not part of the user address space, or the <i>tolen</i>
///    parameter is too small. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETRESET</b></dt> </dl> </td> <td
///    width="60%"> The connection has been broken due to keep-alive activity detecting a failure while the operation
///    was in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%">
///    No buffer space is available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td
///    width="60%"> The socket is not connected (connection-oriented sockets only). </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> MSG_OOB was specified, but the
///    socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain
///    associated with this socket, or the socket is unidirectional and supports only receive operations. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%"> The socket has been shut
///    down; it is not possible to sendto on a socket after shutdown has been invoked with <i>how</i> set to SD_SEND or
///    SD_BOTH. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> The
///    socket is marked as nonblocking and the requested operation would block. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> The socket is message oriented, and the message is
///    larger than the maximum supported by the underlying transport. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEHOSTUNREACH</b></dt> </dl> </td> <td width="60%"> The remote host cannot be reached from this host at
///    this time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNABORTED</b></dt> </dl> </td> <td width="60%">
///    The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as
///    it is no longer usable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td
///    width="60%"> The virtual circuit was reset by the remote side executing a hard or abortive close. For UPD
///    sockets, the remote host was unable to deliver a previously sent UDP datagram and responded with a "Port
///    Unreachable" ICMP packet. The application should close the socket as it is no longer usable. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEADDRNOTAVAIL</b></dt> </dl> </td> <td width="60%"> The remote address is not a valid
///    address, for example, ADDR_ANY. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl>
///    </td> <td width="60%"> Addresses in the specified family cannot be used with this socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEDESTADDRREQ</b></dt> </dl> </td> <td width="60%"> A destination address is required.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETUNREACH</b></dt> </dl> </td> <td width="60%"> The network
///    cannot be reached from this host at this time. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEHOSTUNREACH</b></dt> </dl> </td> <td width="60%"> A socket operation was attempted to an unreachable
///    host. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> The
///    connection has been dropped, because of a network failure or because the system on the other end went down
///    without notice. </td> </tr> </table>
///    
@DllImport("WS2_32")
int sendto(size_t s, char* buf, int len, int flags, char* to, int tolen);

///The <b>setsockopt</b> function sets a socket option.
///Params:
///    s = A descriptor that identifies a socket.
///    level = The level at which the option is defined (for example, SOL_SOCKET).
///    optname = The socket option for which the value is to be set (for example, SO_BROADCAST). The <i>optname</i> parameter must
///              be a socket option defined within the specified <i>level</i>, or behavior is undefined.
///    optval = A pointer to the buffer in which the value for the requested option is specified.
///    optlen = The size, in bytes, of the buffer pointed to by the <i>optval</i> parameter.
///Returns:
///    If no error occurs, <b>setsockopt</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The buffer pointed to by the
///    <i>optval</i> parameter is not in a valid part of the process address space or the <i>optlen</i> parameter is too
///    small. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A
///    blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The
///    <i>level</i> parameter is not valid, or the information in the buffer pointed to by the <i>optval</i> parameter
///    is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETRESET</b></dt> </dl> </td> <td width="60%">
///    The connection has timed out when SO_KEEPALIVE is set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOPROTOOPT</b></dt> </dl> </td> <td width="60%"> The option is unknown or unsupported for the
///    specified provider or socket (see SO_GROUP_PRIORITY limitations). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%"> The connection has been reset when SO_KEEPALIVE is set.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is
///    not a socket. </td> </tr> </table>
///    
@DllImport("WS2_32")
int setsockopt(size_t s, int level, int optname, char* optval, int optlen);

///The <b>shutdown</b> function disables sends or receives on a socket.
///Params:
///    s = A descriptor identifying a socket.
///    how = A flag that describes what types of operation will no longer be allowed. Possible values for this flag are listed
///          in the <i>Winsock2.h</i> header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///          id="SD_RECEIVE"></a><a id="sd_receive"></a><dl> <dt><b>SD_RECEIVE</b></dt> <dt>0</dt> </dl> </td> <td
///          width="60%"> Shutdown receive operations. </td> </tr> <tr> <td width="40%"><a id="SD_SEND"></a><a
///          id="sd_send"></a><dl> <dt><b>SD_SEND</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> Shutdown send operations.
///          </td> </tr> <tr> <td width="40%"><a id="SD_BOTH"></a><a id="sd_both"></a><dl> <dt><b>SD_BOTH</b></dt> <dt>2</dt>
///          </dl> </td> <td width="60%"> Shutdown both send and receive operations. </td> </tr> </table>
///Returns:
///    If no error occurs, <b>shutdown</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific
///    error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAECONNABORTED</b></dt> </dl> </td> <td width="60%"> The virtual circuit was
///    terminated due to a time-out or other failure. The application should close the socket as it is no longer usable.
///    This error applies only to a connection-oriented socket. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> The virtual circuit was reset by the remote side
///    executing a hard or abortive close. The application should close the socket as it is no longer usable. This error
///    applies only to a connection-oriented socket. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress,
///    or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The <i>how</i> parameter is not valid, or is not
///    consistent with the socket type. For example, SD_SEND is used with a UNI_RECV socket type. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%"> The socket is not
///    connected. This error applies only to a connection-oriented socket. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> <div class="alert"><b>Note</b> The descriptor is not a
///    socket.</div> <div> </div> </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td>
///    <td width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> </table>
///    
@DllImport("WS2_32")
int shutdown(size_t s, int how);

///The <b>socket</b> function creates a socket that is bound to a specific transport service provider.
///Params:
///    af = The address family specification. Possible values for the address family are defined in the <i>Winsock2.h</i>
///         header file. On the Windows SDK released for Windows Vista and later, the organization of header files has
///         changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that
///         the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
///         directly. The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats
///         for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported
///         if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_
///         address family and PF_ protocol family constants are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>),
///         so either constant can be used. The table below lists common values for address family although many other values
///         are possible. <table> <tr> <th>Af</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AF_UNSPEC"></a><a
///         id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The address family is
///         unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
///         <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol version 4 (IPv4) address
///         family. </td> </tr> <tr> <td width="40%"><a id="AF_IPX"></a><a id="af_ipx"></a><dl> <dt><b>AF_IPX</b></dt>
///         <dt>6</dt> </dl> </td> <td width="60%"> The IPX/SPX address family. This address family is only supported if the
///         NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed. This address family is not supported on
///         Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl>
///         <dt><b>AF_APPLETALK</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> The AppleTalk address family. This address
///         family is only supported if the AppleTalk protocol is installed. This address family is not supported on Windows
///         Vista and later. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl>
///         <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address family. This address
///         family is only supported if the Windows Sockets provider for NetBIOS is installed. The Windows Sockets provider
///         for NetBIOS is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions
///         of Windows. The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including
///         Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP. The Windows Sockets provider
///         for NetBIOS only supports sockets where the <i>type</i> parameter is set to <b>SOCK_DGRAM</b>. The Windows
///         Sockets provider for NetBIOS is not directly related to the NetBIOS programming interface. The NetBIOS
///         programming interface is not supported on Windows Vista, Windows Server 2008, and later. </td> </tr> <tr> <td
///         width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl> </td> <td
///         width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
///         id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
///         Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
///         infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
///         <dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
///         is supported on Windows XP with SP2 or later if the computer has a Bluetooth adapter and driver installed. </td>
///         </tr> </table>
///    type = The type specification for the new socket. Possible values for the socket type are defined in the
///           <i>Winsock2.h</i> header file. The following table lists the possible values for the <i>type</i> parameter
///           supported for Windows Sockets 2: <table> <tr> <th>Type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///           id="SOCK_STREAM"></a><a id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td
///           width="60%"> A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB
///           data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet
///           address family (AF_INET or AF_INET6). </td> </tr> <tr> <td width="40%"><a id="SOCK_DGRAM"></a><a
///           id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> A socket type that
///           supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.
///           This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
///           </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl> <dt><b>SOCK_RAW</b></dt>
///           <dt>3</dt> </dl> </td> <td width="60%"> A socket type that provides a raw socket that allows an application to
///           manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option must
///           be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the socket.
///           </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt>
///           <dt>4</dt> </dl> </td> <td width="60%"> A socket type that provides a reliable message datagram. An example of
///           this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred
///           to as reliable multicast programming. This <i>type</i> value is only supported if the Reliable Multicast Protocol
///           is installed. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
///           <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> A socket type that provides a
///           pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
///           introduced. An application can dynamically discover the attributes of each available transport protocol through
///           the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
///           an address family and use this information when specifying this parameter. Socket type definitions in the
///           <i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
///           families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are <b>SOCK_DGRAM</b>
///           and <b>SOCK_STREAM</b>.
///    protocol = The protocol to be used. The possible options for the <i>protocol</i> parameter are specific to the address
///               family and socket type specified. Possible values for the <i>protocol</i> are defined in the <i>Winsock2.h</i>
///               and <i>Wsrm.h</i> header files. On the Windows SDK released for Windows Vista and later, the organization of
///               header files has changed and this parameter can be one of the values from the <b>IPPROTO</b> enumeration type
///               defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included
///               in <i>Winsock2.h</i>, and should never be used directly. If a value of 0 is specified, the caller does not wish
///               to specify a protocol and the service provider will choose the <i>protocol</i> to use. When the <i>af</i>
///               parameter is AF_INET or AF_INET6 and the <i>type</i> is <b>SOCK_RAW</b>, the value specified for the
///               <i>protocol</i> is set in the protocol field of the IPv6 or IPv4 packet header. The table below lists common
///               values for the <i>protocol</i> although many other values are possible. <table> <tr> <th>protocol</th>
///               <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
///               <dt><b>IPPROTO_ICMP</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The Internet Control Message Protocol
///               (ICMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or
///               <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified. This <i>protocol</i> value is
///               supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_IGMP"></a><a
///               id="ipproto_igmp"></a><dl> <dt><b>IPPROTO_IGMP</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet
///               Group Management Protocol (IGMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>,
///               <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified. This
///               <i>protocol</i> value is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
///               id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl> <dt><b>BTHPROTO_RFCOMM</b></dt> <dt>3</dt> </dl> </td>
///               <td width="60%"> The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible
///               value when the <i>af</i> parameter is <b>AF_BTH</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. This
///               <i>protocol</i> value is supported on Windows XP with SP2 or later. </td> </tr> <tr> <td width="40%"><a
///               id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl> </td> <td
///               width="60%"> The Transmission Control Protocol (TCP). This is a possible value when the <i>af</i> parameter is
///               <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. </td> </tr> <tr> <td
///               width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl>
///               </td> <td width="60%"> The User Datagram Protocol (UDP). This is a possible value when the <i>af</i> parameter is
///               <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td
///               width="40%"><a id="IPPROTO_ICMPV6"></a><a id="ipproto_icmpv6"></a><dl> <dt><b>IPPROTO_ICMPV6</b></dt> <dt>58</dt>
///               </dl> </td> <td width="60%"> The Internet Control Message Protocol Version 6 (ICMPv6). This is a possible value
///               when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i>
///               parameter is <b>SOCK_RAW</b> or unspecified. This <i>protocol</i> value is supported on Windows XP and later.
///               </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt>
///               <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol for reliable multicast. This is a possible value when
///               the <i>af</i> parameter is <b>AF_INET</b> and the <i>type</i> parameter is <b>SOCK_RDM</b>. On the Windows SDK
///               released for Windows Vista and later, this protocol is also called <b>IPPROTO_PGM</b>. This <i>protocol</i> value
///               is only supported if the Reliable Multicast Protocol is installed. </td> </tr> </table>
///Returns:
///    If no error occurs, <b>socket</b> returns a descriptor referencing the new socket. Otherwise, a value of
///    INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem or the
///    associated service provider has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt>
///    </dl> </td> <td width="60%"> The specified address family is not supported. For example, an application tried to
///    create a socket for the <b>AF_IRDA</b> address family but an infrared adapter and device driver is not installed
///    on the local computer. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td
///    width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a
///    callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMFILE</b></dt> </dl> </td> <td width="60%">
///    No more socket descriptors are available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl>
///    </td> <td width="60%"> An invalid argument was supplied. This error is returned if the <i>af</i> parameter is set
///    to <b>AF_UNSPEC</b> and the <i>type</i> and <i>protocol</i> parameter are unspecified. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVALIDPROVIDER</b></dt> </dl> </td> <td width="60%"> The service provider returned
///    a version other than 2.2. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVALIDPROCTABLE</b></dt> </dl> </td>
///    <td width="60%"> The service provider returned an invalid or incomplete procedure table to the WSPStartup. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> No buffer space is
///    available. The socket cannot be created. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEPROTONOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified protocol is not supported. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEPROTOTYPE</b></dt> </dl> </td> <td width="60%"> The specified
///    protocol is the wrong type for this socket. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEPROVIDERFAILEDINIT</b></dt> </dl> </td> <td width="60%"> The service provider failed to initialize.
///    This error is returned if a layered service provider (LSP) or namespace provider was improperly installed or the
///    provider fails to operate correctly. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESOCKTNOSUPPORT</b></dt>
///    </dl> </td> <td width="60%"> The specified socket type is not supported in this address family. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
size_t socket(int af, int type, int protocol);

///<p class="CCE_Message">[<b>gethostbyaddr</b> is no longer recommended for use as of Windows Sockets 2. Instead, use
///getnameinfo.] The <b>gethostbyaddr</b> function retrieves the host information corresponding to a network address.
///Params:
///    a = A pointer to an address in network byte order.
///    b = The length, in bytes, of the address.
///    c = The type of the address, such as the AF_INET address family type (used with TCP, UDP, and other associated
///        Internet protocols). Possible values for the address family are defined in the Winsock2.h header file. On the
///        Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible
///        values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is
///        automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address
///        family and PF_ protocol family constants are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so
///        either constant can be used. The table below lists the possible values for address family that are supported.
///        <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a
///        id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol
///        version 4 (IPv4) address family. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a
///        id="af_netbios"></a><dl> <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address
///        family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed. </td> </tr>
///        <tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl>
///        </td> <td width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> </table>
@DllImport("WS2_32")
hostent* gethostbyaddr(char* addr, int len, int type);

///The <b>gethostbyname</b> function retrieves host information corresponding to a host name from a host database. <div
///class="alert"><b>Note</b> The <b>gethostbyname</b> function has been deprecated by the introduction of the
///getaddrinfo function. Developers creating Windows Sockets 2 applications are urged to use the <b>getaddrinfo</b>
///function instead of <b>gethostbyname</b>.</div> <div> </div>
///Params:
///    a = A pointer to the <b>null</b>-terminated name of the host to resolve.
@DllImport("WS2_32")
hostent* gethostbyname(const(byte)* name);

///The <b>gethostname</b> function retrieves the standard host name for the local computer.
///Params:
///    name = A pointer to a buffer that receives the local host name.
///    namelen = The length, in bytes, of the buffer pointed to by the <i>name</i> parameter.
///Returns:
///    If no error occurs, <b>gethostname</b> returns zero. Otherwise, it returns SOCKET_ERROR and a specific error code
///    can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>name</i> parameter is a
///    <b>NULL</b> pointer or is not a valid part of the user address space. This error is also returned if the buffer
///    size specified by <i>namelen</i> parameter is too small to hold the complete host name. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl>
///    </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress,
///    or the service provider is still processing a callback function. </td> </tr> </table>
///    
@DllImport("WS2_32")
int gethostname(char* name, int namelen);

///The <b>GetHostNameW</b> function retrieves the standard host name for the local computer as a Unicode string.
///Params:
///    name = A pointer to a buffer that receives the local host name as a <b>null</b>-terminated Unicode string.
///    namelen = The length, in wide characters, of the buffer pointed to by the <i>name</i> parameter.
///Returns:
///    If no error occurs, <b>GetHostNameW</b> returns zero. Otherwise, it returns <b>SOCKET_ERROR</b> and a specific
///    error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>name</i> parameter is a
///    <b>NULL</b> pointer or is not a valid part of the user address space. This error is also returned if the buffer
///    size specified by <i>namelen</i> parameter is too small to hold the complete host name. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl>
///    </td> <td width="60%"> The network subsystem has failed. </td> </tr> </table>
///    
@DllImport("WS2_32")
int GetHostNameW(const(wchar)* name, int namelen);

///The <b>getservbyport</b> function retrieves service information corresponding to a port and protocol.
///Params:
///    port = Port for a service, in network byte order.
///    proto = Optional pointer to a protocol name. If this is null, <b>getservbyport</b> returns the first service entry for
///            which the <i>port</i> matches the <b>s_port</b> of the servent structure. Otherwise, <b>getservbyport</b> matches
///            both the <i>port</i> and the <i>proto</i> parameters.
///Returns:
///    If no error occurs, <b>getservbyport</b> returns a pointer to the servent structure. Otherwise, it returns a null
///    pointer and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Authoritative Answer Service not
///    found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt> </dl> </td> <td width="60%"> A
///    nonauthoritative Service not found, or server failure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> Nonrecoverable errors, the services database is not
///    accessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> Valid
///    name, no data record of requested type. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt>
///    </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still
///    processing a callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The <i>proto</i> parameter is not a valid part of the user address space. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking Windows Socket 1.1 call was
///    canceled through WSACancelBlockingCall. </td> </tr> </table>
///    
@DllImport("WS2_32")
servent* getservbyport(int port, const(byte)* proto);

///The <b>getservbyname</b> function retrieves service information corresponding to a service name and protocol.
///Params:
///    name = A pointer to a <b>null</b>-terminated service name.
///    proto = A pointer to a <b>null</b>-terminated protocol name. If this pointer is <b>NULL</b>, the <b>getservbyname</b>
///            function returns the first service entry where <i>name</i> matches the <b>s_name</b> member of the servent
///            structure or the <b>s_aliases</b> member of the <b>servent</b> structure. Otherwise, <b>getservbyname</b> matches
///            both the <i>name</i> and the <i>proto</i>.
///Returns:
///    If no error occurs, <b>getservbyname</b> returns a pointer to the servent structure. Otherwise, it returns a
///    <b>null</b> pointer and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
///    Authoritative Answer Service not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt> </dl>
///    </td> <td width="60%"> A nonauthoritative Service not found, or server failure. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> Nonrecoverable errors, the services database is
///    not accessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%">
///    Valid name, no data record of requested type. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress,
///    or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking Windows Socket 1.1 call was canceled through
///    WSACancelBlockingCall. </td> </tr> </table>
///    
@DllImport("WS2_32")
servent* getservbyname(const(byte)* name, const(byte)* proto);

///The <b>getprotobynumber</b> function retrieves protocol information corresponding to a protocol number.
///Params:
///    number = Protocol number, in host byte order.
///Returns:
///    If no error occurs, <b>getprotobynumber</b> returns a pointer to the protoent structure. Otherwise, it returns a
///    null pointer and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td
///    width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
///    Authoritative answer protocol not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt>
///    </dl> </td> <td width="60%"> A nonauthoritative Protocol not found, or server failure. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> Nonrecoverable errors, the
///    protocols database is not accessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl>
///    </td> <td width="60%"> Valid name, no data record of requested type. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress,
///    or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking Windows Socket 1.1 call was canceled through
///    WSACancelBlockingCall. </td> </tr> </table>
///    
@DllImport("WS2_32")
protoent* getprotobynumber(int number);

///The <b>getprotobyname</b> function retrieves the protocol information corresponding to a protocol name.
///Params:
///    name = Pointer to a null-terminated protocol name.
///Returns:
///    If no error occurs, <b>getprotobyname</b> returns a pointer to the protoent. Otherwise, it returns a null pointer
///    and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Authoritative answer protocol
///    not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt> </dl> </td> <td width="60%"> A
///    nonauthoritative protocol not found, or server failure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> Nonrecoverable errors, the protocols database is not
///    accessible. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> Valid
///    name, no data record of requested type. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt>
///    </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still
///    processing a callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The <i>name</i> parameter is not a valid part of the user address space. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking Windows Socket 1.1 call was
///    canceled through WSACancelBlockingCall. </td> </tr> </table>
///    
@DllImport("WS2_32")
protoent* getprotobyname(const(byte)* name);

///The <b>WSAStartup</b> function initiates use of the Winsock DLL by a process.
///Params:
///    wVersionRequested = The highest version of Windows Sockets specification that the caller can use. The high-order byte specifies the
///                        minor version number; the low-order byte specifies the major version number.
///    lpWSAData = A pointer to the WSADATA data structure that is to receive details of the Windows Sockets implementation.
///Returns:
///    If successful, the <b>WSAStartup</b> function returns zero. Otherwise, it returns one of the error codes listed
///    below. The <b>WSAStartup</b> function directly returns the extended error code in the return value for this
///    function. A call to the WSAGetLastError function is not needed and should not be used. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSASYSNOTREADY</b></dt> </dl> </td> <td
///    width="60%"> The underlying network subsystem is not ready for network communication. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAVERNOTSUPPORTED</b></dt> </dl> </td> <td width="60%"> The version of Windows Sockets
///    support requested is not provided by this particular Windows Sockets implementation. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1
///    operation is in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEPROCLIM</b></dt> </dl> </td> <td
///    width="60%"> A limit on the number of tasks supported by the Windows Sockets implementation has been reached.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpWSAData</i> parameter is not a valid pointer. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAStartup(ushort wVersionRequested, WSAData* lpWSAData);

///The <b>WSACleanup</b> function terminates use of the Winsock 2 DLL (<i>Ws2_32.dll</i>).
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. In a multithreaded environment,
///    <b>WSACleanup</b> terminates Windows Sockets operations for all threads. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call
///    is in progress, or the service provider is still processing a callback function. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSACleanup();

///The <b>WSASetLastError</b> function sets the error code that can be retrieved through the WSAGetLastError function.
///Params:
///    iError = Integer that specifies the error code to be returned by a subsequent WSAGetLastError call.
///Returns:
///    This function generates no return values. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> </table>
///    
@DllImport("WS2_32")
void WSASetLastError(int iError);

///The <b>WSAGetLastError</b> function returns the error status for the last Windows Sockets operation that failed.
///Returns:
///    The return value indicates the error code for this thread's last Windows Sockets operation that failed.
///    
@DllImport("WS2_32")
int WSAGetLastError();

///This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0. The Windows
///Socket <b>WSAIsBlocking</b> function is not exported directly by WS2_32.DLL, and Windows Sockets 2 applications
///should not use this function. Windows Sockets 1.1 applications that call this function are still supported through
///the WINSOCK.DLL and WSOCK32.DLL. Blocking hooks are generally used to keep a single-threaded GUI application
///responsive during calls to blocking functions. Instead of using blocking hooks, an applications should use a separate
///thread (separate from the main GUI thread) for network activity.
@DllImport("WS2_32")
BOOL WSAIsBlocking();

///This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0. The function
///is not exported directly by WS2_32.DLL, and Windows Sockets 2 applications should not use this function. Windows
///Sockets 1.1 applications that call this function are still supported through the WINSOCK.DLL and WSOCK32.DLL.
///Blocking hooks are generally used to keep a single-threaded GUI application responsive during calls to blocking
///functions. Instead of using blocking hooks, an application should use a separate thread (separate from the main GUI
///thread) for network activity.
@DllImport("WS2_32")
int WSAUnhookBlockingHook();

///This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0. The function
///is not exported directly by WS2_32.DLL, and Windows Sockets 2 applications should not use this function. Windows
///Sockets 1.1 applications that call this function are still supported through the WINSOCK.DLL and WSOCK32.DLL.
///Blocking hooks are generally used to keep a single-threaded GUI application responsive during calls to blocking
///functions. Instead of using blocking hooks, an application should use a separate thread (separate from the main GUI
///thread) for network activity.
///Params:
///    lpBlockFunc = 
@DllImport("WS2_32")
FARPROC WSASetBlockingHook(FARPROC lpBlockFunc);

///The <b>WSACancelBlockingCall</b> function has been removed in compliance with the Windows Sockets 2 specification,
///revision 2.2.0. The function is not exported directly by WS2_32.DLL and Windows Sockets 2 applications should not use
///this function. Windows Sockets 1.1 applications that call this function are still supported through the WINSOCK.DLL
///and WSOCK32.DLL. Blocking hooks are generally used to keep a single-threaded GUI application responsive during calls
///to blocking functions. Instead of using blocking hooks, an applications should use a separate thread (separate from
///the main GUI thread) for network activity.
@DllImport("WS2_32")
int WSACancelBlockingCall();

///The <b>WSAAsyncGetServByName</b> function asynchronously retrieves service information that corresponds to a service
///name and port.
///Params:
///    hWnd = Handle of the window that should receive a message when the asynchronous request completes.
///    wMsg = Message to be received when the asynchronous request completes.
///    name = Pointer to a <b>null</b>-terminated service name.
///    proto = Pointer to a protocol name. This can be <b>NULL</b>, in which case <b>WSAAsyncGetServByName</b> will search for
///            the first service entry for which <i>s_name</i> or one of the <i>s_aliases</i> matches the given <i>name</i>.
///            Otherwise, <b>WSAAsyncGetServByName</b> matches both <i>name</i> and <i>proto</i>.
///    buf = Pointer to the data area to receive the servent data. The data area must be larger than the size of a
///          <b>servent</b> structure because the data area is used by Windows Sockets to contain a <b>servent</b> structure
///          and all of the data that is referenced by members of the <b>servent</b> structure. A buffer of MAXGETHOSTSTRUCT
///          bytes is recommended.
///    buflen = Size of data area for the <i>buf</i> parameter, in bytes.
///Returns:
///    The return value specifies whether or not the asynchronous operation was successfully initiated. It does not
///    imply success or failure of the operation itself. If no error occurs, <b>WSAAsyncGetServByName</b> returns a
///    nonzero value of type <b>HANDLE</b> that is the asynchronous task handle for the request (not to be confused with
///    a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using
///    WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by
///    examining the <i>wParam</i> message parameter. If the asynchronous operation could not be initiated,
///    <b>WSAAsyncServByName</b> returns a zero value, and a specific error number can be retrieved by calling
///    WSAGetLastError. The following error codes can be set when an application window receives a message. As described
///    above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> Insufficient buffer space is available. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>buf</i> parameter is not in a
///    valid part of the process address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAHOST_NOT_FOUND</b></dt>
///    </dl> </td> <td width="60%"> Authoritative answer host not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSATRY_AGAIN</b></dt> </dl> </td> <td width="60%"> Nonauthoritative service not found, or server failure.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> Nonrecoverable
///    errors, the services database is not accessible. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> Valid name, no data record of requested type. </td> </tr>
///    </table> The following errors can occur at the time of the function call, and indicate that the asynchronous
///    operation could not be initiated. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr>
///    <td>WSANOTINITIALISED</td> <td>A successful WSAStartup call must occur before using this function.</td> </tr>
///    <tr> <td>WSAENETDOWN</td> <td>The network subsystem has failed.</td> </tr> <tr> <td>WSAEINPROGRESS</td> <td>A
///    blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
///    function.</td> </tr> <tr> <td>WSAEWOULDBLOCK</td> <td>The asynchronous operation cannot be scheduled at this time
///    due to resource or other constraints within the Windows Sockets implementation.</td> </tr> </table>
///    
@DllImport("WS2_32")
HANDLE WSAAsyncGetServByName(HWND hWnd, uint wMsg, const(byte)* name, const(byte)* proto, char* buf, int buflen);

///The <b>WSAAsyncGetServByPort</b> function asynchronously retrieves service information that corresponds to a port and
///protocol.
///Params:
///    hWnd = Handle of the window that should receive a message when the asynchronous request completes.
///    wMsg = Message to be received when the asynchronous request completes.
///    port = Port for the service, in network byte order.
///    proto = Pointer to a protocol name. This can be <b>NULL</b>, in which case <b>WSAAsyncGetServByPort</b> will search for
///            the first service entry for which <i>s_port</i> match the given <i>port</i>. Otherwise,
///            <b>WSAAsyncGetServByPort</b> matches both <i>port</i> and <i>proto</i>.
///    buf = Pointer to the data area to receive the servent data. The data area must be larger than the size of a
///          <b>servent</b> structure because the data area is used by Windows Sockets to contain a <b>servent</b> structure
///          and all of the data that is referenced by members of the <b>servent</b> structure. A buffer of MAXGETHOSTSTRUCT
///          bytes is recommended.
///    buflen = Size of data area for the <i>buf</i> parameter, in bytes.
///Returns:
///    The return value specifies whether or not the asynchronous operation was successfully initiated. It does not
///    imply success or failure of the operation itself. If no error occurs, <b>WSAAsyncGetServByPort</b> returns a
///    nonzero value of type <b>HANDLE</b> that is the asynchronous task handle for the request (not to be confused with
///    a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using
///    WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by
///    examining the <i>wParam</i> message parameter. If the asynchronous operation could not be initiated,
///    <b>WSAAsyncGetServByPort</b> returns a zero value, and a specific error number can be retrieved by calling
///    WSAGetLastError. The following error codes can be set when an application window receives a message. As described
///    above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> Insufficient buffer space is available. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>proto</i> or <i>buf</i>
///    parameter is not in a valid part of the process address space. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Authoritative answer port not found. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt> </dl> </td> <td width="60%"> Nonauthoritative port not
///    found, or server failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td
///    width="60%"> Nonrecoverable errors, the services database is not accessible. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> Valid name, no data record of requested type. </td>
///    </tr> </table> The following errors can occur at the time of the function call, and indicate that the
///    asynchronous operation could not be initiated. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr>
///    <td>WSANOTINITIALISED</td> <td>A successful WSAStartup call must occur before using this function.</td> </tr>
///    <tr> <td>WSAENETDOWN</td> <td>The network subsystem has failed.</td> </tr> <tr> <td>WSAEINPROGRESS</td> <td>A
///    blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
///    function.</td> </tr> <tr> <td>WSAEWOULDBLOCK</td> <td>The asynchronous operation cannot be scheduled at this time
///    due to resource or other constraints within the Windows Sockets implementation.</td> </tr> </table>
///    
@DllImport("WS2_32")
HANDLE WSAAsyncGetServByPort(HWND hWnd, uint wMsg, int port, const(byte)* proto, char* buf, int buflen);

///The <b>WSAAsyncGetProtoByName</b> function asynchronously retrieves protocol information that corresponds to a
///protocol name.
///Params:
///    hWnd = Handle of the window that will receive a message when the asynchronous request completes.
///    wMsg = Message to be received when the asynchronous request completes.
///    name = Pointer to the null-terminated protocol name to be resolved.
///    buf = Pointer to the data area to receive the protoent data. The data area must be larger than the size of a
///          <b>protoent</b> structure because the data area is used by Windows Sockets to contain a <b>protoent</b> structure
///          and all of the data that is referenced by members of the <b>protoent</b> structure. A buffer of MAXGETHOSTSTRUCT
///          bytes is recommended.
///    buflen = Size of data area for the <i>buf</i> parameter, in bytes.
///Returns:
///    The return value specifies whether or not the asynchronous operation was successfully initiated. It does not
///    imply success or failure of the operation itself. If no error occurs, <b>WSAAsyncGetProtoByName</b> returns a
///    nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a
///    Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using
///    WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by
///    examining the <i>wParam</i> message parameter. If the asynchronous operation could not be initiated,
///    <b>WSAAsyncGetProtoByName</b> returns a zero value, and a specific error number can be retrieved by calling
///    WSAGetLastError. The following error codes can be set when an application window receives a message. As described
///    above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> Insufficient buffer space is available. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>name</i> or <i>buf</i>
///    parameter is not in a valid part of the process address space. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> Authoritative answer protocol not found. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt> </dl> </td> <td width="60%"> A nonauthoritative
///    protocol not found, or server failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt>
///    </dl> </td> <td width="60%"> Nonrecoverable errors, the protocols database is not accessible. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> Valid name, no data record of
///    requested type. </td> </tr> </table> The following errors can occur at the time of the function call, and
///    indicate that the asynchronous operation could not be initiated. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td>WSANOTINITIALISED</td> <td>A successful WSAStartup call must occur before using
///    this function.</td> </tr> <tr> <td>WSAENETDOWN</td> <td>The network subsystem has failed.</td> </tr> <tr>
///    <td>WSAEINPROGRESS</td> <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still
///    processing a callback function.</td> </tr> <tr> <td>WSAEWOULDBLOCK</td> <td>The asynchronous operation cannot be
///    scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td> </tr>
///    </table>
///    
@DllImport("WS2_32")
HANDLE WSAAsyncGetProtoByName(HWND hWnd, uint wMsg, const(byte)* name, char* buf, int buflen);

///The <b>WSAAsyncGetProtoByNumber</b> function asynchronously retrieves protocol information that corresponds to a
///protocol number.
///Params:
///    hWnd = Handle of the window that will receive a message when the asynchronous request completes.
///    wMsg = Message to be received when the asynchronous request completes.
///    number = Protocol number to be resolved, in host byte order.
///    buf = Pointer to the data area to receive the protoent data. The data area must be larger than the size of a
///          <b>protoent</b> structure because the data area is used by Windows Sockets to contain a <b>protoent</b> structure
///          and all of the data that is referenced by members of the <b>protoent</b> structure. A buffer of MAXGETHOSTSTRUCT
///          bytes is recommended.
///    buflen = Size of data area for the <i>buf</i> parameter, in bytes.
///Returns:
///    The return value specifies whether or not the asynchronous operation was successfully initiated. It does not
///    imply success or failure of the operation itself. If no error occurs, <b>WSAAsyncGetProtoByNumber</b> returns a
///    nonzero value of type <b>HANDLE</b> that is the asynchronous task handle for the request (not to be confused with
///    a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using
///    WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by
///    examining the <i>wParam</i> message parameter. If the asynchronous operation could not be initiated,
///    <b>WSAAsyncGetProtoByNumber</b> returns a zero value, and a specific error number can be retrieved by calling
///    WSAGetLastError. The following error codes can be set when an application window receives a message. As described
///    above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> Insufficient buffer space is available. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>buf</i> parameter is not in a
///    valid part of the process address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAHOST_NOT_FOUND</b></dt>
///    </dl> </td> <td width="60%"> Authoritative answer protocol not found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSATRY_AGAIN</b></dt> </dl> </td> <td width="60%"> Nonauthoritative protocol not found, or server failure.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> Nonrecoverable
///    errors, the protocols database is not accessible. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> Valid name, no data record of requested type. </td> </tr>
///    </table> The following errors can occur at the time of the function call, and indicate that the asynchronous
///    operation could not be initiated. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr>
///    <td>WSANOTINITIALISED</td> <td>A successful WSAStartup call must occur before using this function.</td> </tr>
///    <tr> <td>WSAENETDOWN</td> <td>The network subsystem has failed.</td> </tr> <tr> <td>WSAEINPROGRESS</td> <td>A
///    blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
///    function.</td> </tr> <tr> <td>WSAEWOULDBLOCK</td> <td>The asynchronous operation cannot be scheduled at this time
///    due to resource or other constraints within the Windows Sockets implementation.</td> </tr> </table>
///    
@DllImport("WS2_32")
HANDLE WSAAsyncGetProtoByNumber(HWND hWnd, uint wMsg, int number, char* buf, int buflen);

///The <b>WSAAsyncGetHostByName</b> function asynchronously retrieves host information that corresponds to a host name.
///<div class="alert"><b>Note</b> The <b>WSAAsyncGetHostByName</b> function is not designed to provide parallel
///resolution of several names. Therefore, applications that issue several requests should not expect them to be
///executed concurrently. Alternatively, applications can start another thread and use the getaddrinfo function to
///resolve names in an IP-version agnostic manner. Developers creating Windows Sockets 2 applications are urged to use
///the <b>getaddrinfo</b> function to enable smooth transition to IPv6 compatibility.</div><div> </div>
///Params:
///    a = Handle of the window that will receive a message when the asynchronous request completes.
///    b = Message to be received when the asynchronous request completes.
///    c = Pointer to the null-terminated name of the host.
///    d = Pointer to the data area to receive the hostent data. The data area must be larger than the size of a
///        <b>hostent</b> structure because the specified data area is used by Windows Sockets to contain a <b>hostent</b>
///        structure and all of the data referenced by members of the <b>hostent</b> structure. A buffer of MAXGETHOSTSTRUCT
///        bytes is recommended.
///    e = Size of data area for the <i>buf</i> parameter, in bytes.
@DllImport("WS2_32")
HANDLE WSAAsyncGetHostByName(HWND hWnd, uint wMsg, const(byte)* name, char* buf, int buflen);

///The <b>WSAAsyncGetHostByAddr</b> function asynchronously retrieves host information that corresponds to an address.
///<div class="alert"><b>Note</b> The <b>WSAAsyncGetHostByAddr</b> function is not designed to provide parallel
///resolution of several addresses. Therefore, applications that issue several requests should not expect them to be
///executed concurrently. Alternatively, applications can start another thread and use the getnameinfo function to
///resolve addresses in an IP-version agnostic manner. Developers creating Windows Sockets 2 applications are urged to
///use the <b>getnameinfo</b> function to enable smooth transition to IPv6 compatibility.</div><div> </div>
///Params:
///    a = Handle of the window that will receive a message when the asynchronous request completes.
///    b = Message to be received when the asynchronous request completes.
///    c = Pointer to the network address for the host. Host addresses are stored in network byte order.
///    d = Length of the address, in bytes.
///    e = Type of the address.
///    f = Pointer to the data area to receive the hostent data. The data area must be larger than the size of a
///        <b>hostent</b> structure because the data area is used by Windows Sockets to contain a <b>hostent</b> structure
///        and all of the data referenced by members of the <b>hostent</b> structure. A buffer of MAXGETHOSTSTRUCT bytes is
///        recommended.
///    g = Size of data area for the <i>buf</i> parameter, in bytes.
@DllImport("WS2_32")
HANDLE WSAAsyncGetHostByAddr(HWND hWnd, uint wMsg, char* addr, int len, int type, char* buf, int buflen);

///The <b>WSACancelAsyncRequest</b> function cancels an incomplete asynchronous operation.
///Params:
///    hAsyncTaskHandle = Handle that specifies the asynchronous operation to be canceled.
///Returns:
///    The value returned by <b>WSACancelAsyncRequest</b> is zero if the operation was successfully canceled. Otherwise,
///    the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call must occur before
///    using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td
///    width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt>
///    </dl> </td> <td width="60%"> Indicates that the specified asynchronous task handle was invalid. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1
///    call is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEALREADY</b></dt> </dl> </td> <td width="60%"> The asynchronous routine being
///    canceled has already completed. </td> </tr> </table> <div class="alert"><b>Note</b> It is unclear whether the
///    application can usefully distinguish between WSAEINVAL and WSAEALREADY, since in both cases the error indicates
///    that there is no asynchronous operation in progress with the indicated handle. (Trivial exception: zero is always
///    an invalid asynchronous task handle.) The Windows Sockets specification does not prescribe how a conformant
///    Windows Sockets provider should distinguish between the two cases. For maximum portability, a Windows Sockets
///    application should treat the two errors as equivalent.</div> <div> </div>
///    
@DllImport("WS2_32")
int WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);

///<p class="CCE_Message">[The <b>WSAAsyncSelect</b> function is available for use in the operating systems specified in
///the Requirements section. It may be altered or unavailable in subsequent versions. Rather than use Select-style I/O,
///use Overlapped I/O and Event Objects with WinSock2.] The <b>WSAAsyncSelect</b> function requests Windows
///message-based notification of network events for a socket.
///Params:
///    s = A descriptor that identifies the socket for which event notification is required.
///    hWnd = A handle that identifies the window that will receive a message when a network event occurs.
///    wMsg = A message to be received when a network event occurs.
///    lEvent = A bitmask that specifies a combination of network events in which the application is interested.
///Returns:
///    If the <b>WSAAsyncSelect</b> function succeeds, the return value is zero, provided that the application's
///    declaration of interest in the network event set was successful. Otherwise, the value SOCKET_ERROR is returned,
///    and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> One of the specified parameters was
///    invalid, such as the window handle not referring to an existing window, or the specified socket is in an invalid
///    state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A
///    blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The
///    descriptor is not a socket. </td> </tr> </table> Additional error codes can be set when an application window
///    receives a message. This error code is extracted from the <i>lParam</i> in the reply message using the
///    <b>WSAGETSELECTERROR</b> macro. Possible error codes for each network event are listed in the following table.
///    Event: FD_CONNECT <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td>WSAEAFNOSUPPORT</td>
///    <td>Addresses in the specified family cannot be used with this socket.</td> </tr> <tr> <td>WSAECONNREFUSED</td>
///    <td>The attempt to connect was rejected.</td> </tr> <tr> <td>WSAENETUNREACH</td> <td>The network cannot be
///    reached from this host at this time.</td> </tr> <tr> <td>WSAEFAULT</td> <td>The <i>namelen</i> parameter is
///    invalid.</td> </tr> <tr> <td>WSAEINVAL</td> <td>The socket is already bound to an address.</td> </tr> <tr>
///    <td>WSAEISCONN</td> <td>The socket is already connected.</td> </tr> <tr> <td>WSAEMFILE</td> <td>No more file
///    descriptors are available.</td> </tr> <tr> <td>WSAENOBUFS</td> <td>No buffer space is available. The socket
///    cannot be connected.</td> </tr> <tr> <td>WSAENOTCONN</td> <td>The socket is not connected.</td> </tr> <tr>
///    <td>WSAETIMEDOUT</td> <td>Attempt to connect timed out without establishing a connection.</td> </tr> </table>
///    Event: FD_CLOSE <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td>WSAENETDOWN</td> <td>The network
///    subsystem failed.</td> </tr> <tr> <td>WSAECONNRESET</td> <td>The connection was reset by the remote side.</td>
///    </tr> <tr> <td>WSAECONNABORTED</td> <td>The connection was terminated due to a time-out or other failure.</td>
///    </tr> </table> <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td>WSAENETDOWN</td> <td>The network
///    subsystem failed.</td> </tr> </table> Event: FD_ROUTING_INTERFACE_CHANGE <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td>WSAENETUNREACH</td> <td>The specified destination is no longer reachable.</td>
///    </tr> <tr> <td>WSAENETDOWN</td> <td>The network subsystem failed.</td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAAsyncSelect(size_t s, HWND hWnd, uint wMsg, int lEvent);

///The <b>WSAAccept</b> function conditionally accepts a connection based on the return value of a condition function,
///provides quality of service flow specifications, and allows the transfer of connection data.
///Params:
///    s = A descriptor that identifies a socket that is listening for connections after a call to the listen function.
///    addr = An optional pointer to an sockaddr structure that receives the address of the connecting entity, as known to the
///           communications layer. The exact format of the <i>addr</i> parameter is determined by the address family
///           established when the socket was created.
///    addrlen = An optional pointer to an integer that contains the length of the sockaddr structure pointed to by the
///              <i>addr</i> parameter, in bytes.
///    lpfnCondition = The address of an optional, application-specified condition function that will make an accept/reject decision
///                    based on the caller information passed in as parameters, and optionally create or join a socket group by
///                    assigning an appropriate value to the result parameter <i>g</i> of this function. If this parameter is
///                    <b>NULL</b>, then no condition function is called.
///    dwCallbackData = Callback data passed back to the application-specified condition function as the value of the
///                     <i>dwCallbackData</i> parameter passed to the condition function. This parameter is only applicable if the
///                     <i>lpfnCondition</i> parameter is not <b>NULL</b>. This parameter is not interpreted by Windows Sockets.
///Returns:
///    If no error occurs, <b>WSAAccept</b> returns a value of type SOCKET that is a descriptor for the accepted socket.
///    Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling
///    WSAGetLastError. The integer referred to by <i>addrlen</i> initially contains the amount of space pointed to by
///    <i>addr</i>. On return it will contain the actual length in bytes of the address returned. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td
///    width="60%"> An attempt was made to access a socket in a way forbidden by its access permissions. This error is
///    returned if the connection request that was offered has timed out or been withdrawn. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAECONNREFUSED</b></dt> </dl> </td> <td width="60%"> No connection could be made
///    because the target machine actively refused it. This error is returned if the connection request was forcefully
///    rejected as indicated in the return value of the condition function (CF_REJECT). </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> An existing connection was forcibly
///    closed by the remote host. This error is returned of an incoming connection was indicated, but was subsequently
///    terminated by the remote peer prior to accepting the call. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The system detected an invalid pointer address in
///    attempting to use a pointer argument in a call. This error is returned of the <i>addrlen</i> parameter is too
///    small or the <i>addr</i> or <i>lpfnCondition</i> is not part of the user address space. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking operation was interrupted by a
///    call to WSACancelBlockingCall. This error is returned if a blocking Windows Sockets 1.1 call was canceled through
///    <b>WSACancelBlockingCall</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td>
///    <td width="60%"> A blocking operation is currently executing. This error is returned if a blocking Windows
///    Sockets 1.1 call is in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td
///    width="60%"> An invalid argument was supplied. This error is returned if listen was not invoked prior to
///    WSAAccept, the return value of the condition function is not a valid one, or any case where the specified socket
///    is in an invalid state. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMFILE</b></dt> </dl> </td> <td
///    width="60%"> Too many open sockets. This error is returned if the queue is nonempty upon entry to WSAAccept and
///    there are no socket descriptors available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> A socket operation encountered a dead network. This error is returned if the network
///    subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td
///    width="60%"> An operation on a socket could not be performed because the system lacked sufficient buffer space or
///    because a queue was full. This error is returned if no buffer space is available. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> An operation was attempted on
///    something that is not a socket. This error is returned if the socket descriptor passed in the <i>s</i> parameter
///    is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td
///    width="60%"> The protocol family has not been configured into the system or no implementation for it exists. This
///    error is returned if the referenced socket is not a type that supports connection-oriented service. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> A non-blocking socket
///    operation could not be completed immediately. This error is returned if the socket is marked as nonblocking and
///    no connections are present to be accepted. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> Either the application has not called WSAStartup,
///    or <b>WSAStartup</b> failed. This error is returned of a successful call to the <b>WSAStartup</b> function dit
///    not occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt> </dl>
///    </td> <td width="60%"> This is usually a temporary error during hostname resolution and means that the local
///    server did not receive a response from an authoritative server. This error is returned if the acceptance of the
///    connection request was deferred as indicated in the return value of the condition function (CF_DEFER). </td>
///    </tr> </table>
///    
@DllImport("WS2_32")
size_t WSAAccept(size_t s, char* addr, int* addrlen, LPCONDITIONPROC lpfnCondition, size_t dwCallbackData);

///The <b>WSACloseEvent</b> function closes an open event object handle.
///Params:
///    hEvent = Object handle identifying the open event.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is
///    <b>FALSE</b>. To get extended error information, call WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call
///    is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The <i>hEvent</i> is not a
///    valid event object handle. </td> </tr> </table>
///    
@DllImport("WS2_32")
BOOL WSACloseEvent(HANDLE hEvent);

///The <b>WSAConnect</b> function establishes a connection to another socket application, exchanges connect data, and
///specifies required quality of service based on the specified FLOWSPEC structure.
///Params:
///    s = A descriptor identifying an unconnected socket.
///    name = A pointer to a sockaddr structure that specifies the address to which to connect. For IPv4, the <b>sockaddr</b>
///           contains <b>AF_INET</b> for the address family, the destination IPv4 address, and the destination port. For IPv6,
///           the <b>sockaddr</b> structure contains <b>AF_INET6</b> for the address family, the destination IPv6 address, the
///           destination port, and may contain additional flow and scope-id information.
///    namelen = The length, in bytes, of the sockaddr structure pointed to by the <i>name</i> parameter.
///    lpCallerData = A pointer to the user data that is to be transferred to the other socket during connection establishment. See
///                   Remarks.
///    lpCalleeData = A pointer to the user data that is to be transferred back from the other socket during connection establishment.
///                   See Remarks.
///    lpSQOS = A pointer to the FLOWSPEC structures for socket <i>s</i>, one for each direction.
///    lpGQOS = Reserved for future use with socket groups. A pointer to the FLOWSPEC structures for the socket group (if
///             applicable). This parameter should be <b>NULL</b>.
///Returns:
///    If no error occurs, <b>WSAConnect</b> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code
///    can be retrieved by calling WSAGetLastError. On a blocking socket, the return value indicates success or failure
///    of the connection attempt. With a nonblocking socket, the connection attempt cannot be completed immediately. In
///    this case, <b>WSAConnect</b> will return SOCKET_ERROR, and WSAGetLastError will return WSAEWOULDBLOCK; the
///    application could therefore: <ul> <li>Use select to determine the completion of the connection request by
///    checking if the socket is writeable.</li> <li>If your application is using WSAAsyncSelect to indicate interest in
///    connection events, then your application will receive an FD_CONNECT notification when the connect operation is
///    complete(successful or not).</li> <li>If your application is using WSAEventSelect to indicate interest in
///    connection events, then the associated event object will be signaled when the connect operation is complete
///    (successful or not).</li> </ul> For a nonblocking socket, until the connection attempt completes all subsequent
///    calls to <b>WSAConnect</b> on the same socket will fail with the error code WSAEALREADY. If the return error code
///    indicates the connection attempt failed (that is, WSAECONNREFUSED, WSAENETUNREACH, WSAETIMEDOUT) the application
///    can call <b>WSAConnect</b> again for the same socket. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup
///    call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEADDRINUSE</b></dt> </dl> </td> <td width="60%"> The local address of the socket is already in use and
///    the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs during the
///    execution of bind, but could be delayed until this function if the <b>bind</b> function operates on a partially
///    wildcard address (involving ADDR_ANY) and if a specific address needs to be "committed" at the time of this
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> The
///    (blocking) Windows Socket 1.1 call was canceled through WSACancelBlockingCall. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in
///    progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEALREADY</b></dt> </dl> </td> <td width="60%"> A nonblocking connect or WSAConnect call is in progress
///    on the specified socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRNOTAVAIL</b></dt> </dl> </td> <td
///    width="60%"> The remote address is not a valid address (such as ADDR_ANY). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> Addresses in the specified family cannot be used
///    with this socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNREFUSED</b></dt> </dl> </td> <td
///    width="60%"> The attempt to connect was rejected. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>name</i> or the <i>namelen</i> parameter is not a
///    valid part of the user address space, the <i>namelen</i> parameter is too small, the buffer length for
///    <i>lpCalleeData</i>, <i>lpSQOS</i>, and <i>lpGQOS</i> are too small, or the buffer length for <i>lpCallerData</i>
///    is too large. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The
///    parameter <i>s</i> is a listening socket, or the destination address specified is not consistent with that of the
///    constrained group to which the socket belongs, or the <i>lpGQOS</i> parameter is not <b>NULL</b>. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEISCONN</b></dt> </dl> </td> <td width="60%"> The socket is already
///    connected (connection-oriented sockets only). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETUNREACH</b></dt> </dl> </td> <td width="60%"> The network cannot be reached from this host at this
///    time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEHOSTUNREACH</b></dt> </dl> </td> <td width="60%"> A
///    socket operation was attempted to an unreachable host. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> No buffer space is available. The socket cannot be
///    connected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The
///    descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td
///    width="60%"> The FLOWSPEC structures specified in <i>lpSQOS</i> and <i>lpGQOS</i> cannot be satisfied. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEPROTONOSUPPORT</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpCallerData</i> parameter is not supported by the service provider. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> Attempt to connect timed out without establishing a
///    connection. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%">
///    The socket is marked as nonblocking and the connection cannot be completed immediately. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td width="60%"> Attempt to connect datagram socket to
///    broadcast address failed because setsockopt SO_BROADCAST is not enabled. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAConnect(size_t s, char* name, int namelen, WSABUF* lpCallerData, WSABUF* lpCalleeData, QOS* lpSQOS, 
               QOS* lpGQOS);

///The <b>WSAConnectByName</b> function establishes a connection to a specified host and port. This function is provided
///to allow a quick connection to a network endpoint given a host name and port. This function supports both IPv4 and
///IPv6 addresses.
///Params:
///    s = A descriptor that identifies an unconnected socket. <div class="alert"><b>Note</b> On Windows 7, Windows Server
///        2008 R2, and earlier, the <b>WSAConnectByName</b> function requires an unbound and unconnected socket. This
///        differs from other Winsock calls to establish a connection (for example, WSAConnect). </div> <div> </div>
///    nodename = A <b>NULL</b>-terminated string that contains the name of the host or the IP address of the host on which to
///               connect for IPv4 or IPv6.
///    servicename = A <b>NULL</b>-terminated string that contains the service name or destination port of the host on which to
///                  connect for IPv4 or IPv6. A service name is a string alias for a port number. For example, “http” is an alias
///                  for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the
///                  HTTP protocol. Possible values for the <i>servicename</i> parameter when a port number is not specified are
///                  listed in the following file: <code>%WINDIR%\system32\drivers\etc\services</code>
///    LocalAddressLength = On input, a pointer to the size, in bytes, of the <i>LocalAddress</i> buffer provided by the caller. On output, a
///                         pointer to the size, in bytes, of the <b>SOCKADDR</b> for the local address stored in the <i>LocalAddress</i>
///                         buffer filled in by the system upon successful completion of the call.
///    LocalAddress = A pointer to the <b>SOCKADDR</b> structure that receives the local address of the connection. The size of the
///                   parameter is exactly the size returned in <i>LocalAddressLength</i>. This is the same information that would be
///                   returned by the getsockname function. This parameter can be <b>NULL</b>, in which case, the
///                   <i>LocalAddressLength</i> parameter is ignored.
///    RemoteAddressLength = On input, a pointer to the size, in bytes, of the <i>RemoteAddress</i> buffer provided by the caller. On output,
///                          a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the remote address stored in <i>RemoteAddress</i>
///                          buffer filled-in by the system upon successful completion of the call.
///    RemoteAddress = A pointer to the <b>SOCKADDR</b> structure that receives the remote address of the connection. This is the same
///                    information that would be returned by the <b>getpeername</b> function. This parameter can be <b>NULL</b>, in
///                    which case, the <i>RemoteAddressLength</i> is ignored.
///    timeout = The time, in milliseconds, to wait for a response from the remote application before aborting the call.
///    Reserved = Reserved for future implementation. This parameter must be set to <b>NULL</b>.
///Returns:
///    If a connection is established, <b>WSAConnectByName</b> returns <b>TRUE</b> and <i>LocalAddress</i> and
///    <i>RemoteAddress</i> parameters are filled in if these buffers were supplied by the caller. If the call fails,
///    <b>FALSE</b> is returned. WSAGetLastError can then be called to get extended error information. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEHOSTUNREACH</b></dt> </dl>
///    </td> <td width="60%"> The host passed as the <i>nodename</i> parameter was unreachable. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. The <i>nodename</i> or the <i>servicename</i> parameter must not be <b>NULL</b>. The <i>Reserved</i>
///    parameter must be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td
///    width="60%"> Sufficient memory could not be allocated. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> An invalid socket was passed to the function. The
///    <i>s</i> parameter must not be <b>INVALID_SOCKET</b> or <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> A response from the remote application was not received
///    before the <i>timeout</i> parameter was exceeded. </td> </tr> </table>
///    
@DllImport("WS2_32")
BOOL WSAConnectByNameW(size_t s, const(wchar)* nodename, const(wchar)* servicename, uint* LocalAddressLength, 
                       char* LocalAddress, uint* RemoteAddressLength, char* RemoteAddress, const(timeval)* timeout, 
                       OVERLAPPED* Reserved);

///The <b>WSAConnectByName</b> function establishes a connection to a specified host and port. This function is provided
///to allow a quick connection to a network endpoint given a host name and port. This function supports both IPv4 and
///IPv6 addresses.
///Params:
///    s = A descriptor that identifies an unconnected socket. <div class="alert"><b>Note</b> On Windows 7, Windows Server
///        2008 R2, and earlier, the <b>WSAConnectByName</b> function requires an unbound and unconnected socket. This
///        differs from other Winsock calls to establish a connection (for example, WSAConnect). </div> <div> </div>
///    nodename = A <b>NULL</b>-terminated string that contains the name of the host or the IP address of the host on which to
///               connect for IPv4 or IPv6.
///    servicename = A <b>NULL</b>-terminated string that contains the service name or destination port of the host on which to
///                  connect for IPv4 or IPv6. A service name is a string alias for a port number. For example, “http” is an alias
///                  for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the
///                  HTTP protocol. Possible values for the <i>servicename</i> parameter when a port number is not specified are
///                  listed in the following file: <code>%WINDIR%\system32\drivers\etc\services</code>
///    LocalAddressLength = On input, a pointer to the size, in bytes, of the <i>LocalAddress</i> buffer provided by the caller. On output, a
///                         pointer to the size, in bytes, of the <b>SOCKADDR</b> for the local address stored in the <i>LocalAddress</i>
///                         buffer filled in by the system upon successful completion of the call.
///    LocalAddress = A pointer to the <b>SOCKADDR</b> structure that receives the local address of the connection. The size of the
///                   parameter is exactly the size returned in <i>LocalAddressLength</i>. This is the same information that would be
///                   returned by the getsockname function. This parameter can be <b>NULL</b>, in which case, the
///                   <i>LocalAddressLength</i> parameter is ignored.
///    RemoteAddressLength = On input, a pointer to the size, in bytes, of the <i>RemoteAddress</i> buffer provided by the caller. On output,
///                          a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the remote address stored in <i>RemoteAddress</i>
///                          buffer filled-in by the system upon successful completion of the call.
///    RemoteAddress = A pointer to the <b>SOCKADDR</b> structure that receives the remote address of the connection. This is the same
///                    information that would be returned by the <b>getpeername</b> function. This parameter can be <b>NULL</b>, in
///                    which case, the <i>RemoteAddressLength</i> is ignored.
///    timeout = The time, in milliseconds, to wait for a response from the remote application before aborting the call.
///    Reserved = Reserved for future implementation. This parameter must be set to <b>NULL</b>.
///Returns:
///    If a connection is established, <b>WSAConnectByName</b> returns <b>TRUE</b> and <i>LocalAddress</i> and
///    <i>RemoteAddress</i> parameters are filled in if these buffers were supplied by the caller. If the call fails,
///    <b>FALSE</b> is returned. WSAGetLastError can then be called to get extended error information. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEHOSTUNREACH</b></dt> </dl>
///    </td> <td width="60%"> The host passed as the <i>nodename</i> parameter was unreachable. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. The <i>nodename</i> or the <i>servicename</i> parameter must not be <b>NULL</b>. The <i>Reserved</i>
///    parameter must be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td
///    width="60%"> Sufficient memory could not be allocated. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> An invalid socket was passed to the function. The
///    <i>s</i> parameter must not be <b>INVALID_SOCKET</b> or <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> A response from the remote application was not received
///    before the <i>timeout</i> parameter was exceeded. </td> </tr> </table>
///    
@DllImport("WS2_32")
BOOL WSAConnectByNameA(size_t s, const(char)* nodename, const(char)* servicename, uint* LocalAddressLength, 
                       char* LocalAddress, uint* RemoteAddressLength, char* RemoteAddress, const(timeval)* timeout, 
                       OVERLAPPED* Reserved);

///The <b>WSAConnectByList</b> function establishes a connection to one out of a collection of possible endpoints
///represented by a set of destination addresses (host names and ports). This function takes all the destination
///addresses passed to it and all of the local computer's source addresses, and tries connecting using all possible
///address combinations before giving up. This function supports both IPv4 and IPv6 addresses.
///Params:
///    s = A descriptor that identifies an unbound and unconnected socket. Note that unlike other Winsock calls to establish
///        a connection (for example, WSAConnect), the <b>WSAConnectByList</b> function requires an unbound socket.
///    SocketAddress = A pointer to a SOCKET_ADDRESS_LIST structure that represents the possible destination address and port pairs to
///                    connect to a peer. It is the application's responsibility to fill in the port number in the each SOCKET_ADDRESS
///                    structure in the <b>SOCKET_ADDRESS_LIST</b>.
///    LocalAddressLength = On input, a pointer to the size, in bytes, of the <i>LocalAddress</i> buffer provided by the caller. On output, a
///                         pointer to the size, in bytes, of the <b>SOCKADDR</b> for the local address stored in the <i>LocalAddress</i>
///                         buffer filled in by the system upon successful completion of the call.
///    LocalAddress = A pointer to the <b>SOCKADDR</b> structure that receives the local address of the connection. The size of the
///                   parameter is exactly the size returned in <i>LocalAddressLength</i>. This is the same information that would be
///                   returned by the getsockname function. This parameter can be <b>NULL</b>, in which case, the
///                   <i>LocalAddressLength</i> parameter is ignored.
///    RemoteAddressLength = On input, a pointer to the size, in bytes, of the <i>RemoteAddress</i> buffer provided by the caller. On output,
///                          a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the remote address stored in <i>RemoteAddress</i>
///                          buffer filled-in by the system upon successful completion of the call.
///    RemoteAddress = A pointer to the <b>SOCKADDR</b> structure that receives the remote address of the connection. This is the same
///                    information that would be returned by the <b>getpeername</b> function. This parameter can be <b>NULL</b>, in
///                    which case, the <i>RemoteAddressLength</i> is ignored.
///    timeout = The time, in milliseconds, to wait for a response from the remote application before aborting the call. This
///              parameter can be <b>NULL</b> in which case <b>WSAConnectByList</b> will complete after either the connection is
///              successfully established or after a connection was attempted and failed on all possible local-remote address
///              pairs.
///    Reserved = Reserved for future implementation. This parameter must be set to <b>NULL</b>.
///Returns:
///    If a connection is established, <b>WSAConnectByList</b> returns <b>TRUE</b> and <i>LocalAddress</i> and
///    <i>RemoteAddress</i> parameters are filled in if these buffers were supplied by the caller. If the call fails,
///    <b>FALSE</b> is returned. WSAGetLastError can then be called to get extended error information. <table> <tr>
///    <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEHOSTUNREACH</b></dt> </dl>
///    </td> <td width="60%"> The host passed as the <i>nodename</i> parameter was unreachable. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. The <i>Reserved</i> parameter must be <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> Sufficient memory could not be allocated. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> An invalid socket was passed
///    to the function. The <i>s</i> parameter must not be <b>INVALID_SOCKET</b> or <b>NULL</b>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> A response from the remote
///    application was not received before the <i>timeout</i> parameter was exceeded. </td> </tr> </table>
///    
@DllImport("WS2_32")
BOOL WSAConnectByList(size_t s, SOCKET_ADDRESS_LIST* SocketAddress, uint* LocalAddressLength, char* LocalAddress, 
                      uint* RemoteAddressLength, char* RemoteAddress, const(timeval)* timeout, OVERLAPPED* Reserved);

///The <b>WSACreateEvent</b> function creates a new event object.
///Returns:
///    If no error occurs, <b>WSACreateEvent</b> returns the handle of the event object. Otherwise, the return value is
///    WSA_INVALID_EVENT. To get extended error information, call WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call
///    is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough free memory
///    available to create the event object. </td> </tr> </table>
///    
@DllImport("WS2_32")
HANDLE WSACreateEvent();

///The <b>WSADuplicateSocket</b> function returns a WSAPROTOCOL_INFO structure that can be used to create a new socket
///descriptor for a shared socket. The <b>WSADuplicateSocket</b> function cannot be used on a QOS-enabled socket.
///Params:
///    s = Descriptor identifying the local socket.
///    dwProcessId = Process identifier of the target process in which the duplicated socket will be used.
///    lpProtocolInfo = Pointer to a buffer, allocated by the client, that is large enough to contain a WSAPROTOCOL_INFO structure. The
///                     service provider copies the protocol information structure contents to this buffer.
///Returns:
///    If no error occurs, <b>WSADuplicateSocket</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> Indicates that one of the specified
///    parameters was invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td
///    width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a
///    callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMFILE</b></dt> </dl> </td> <td width="60%">
///    No more socket descriptors are available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl>
///    </td> <td width="60%"> No buffer space is available. The socket cannot be created. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpProtocolInfo</i>
///    parameter is not a valid part of the user address space. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSADuplicateSocketA(size_t s, uint dwProcessId, WSAPROTOCOL_INFOA* lpProtocolInfo);

///The <b>WSADuplicateSocket</b> function returns a WSAPROTOCOL_INFO structure that can be used to create a new socket
///descriptor for a shared socket. The <b>WSADuplicateSocket</b> function cannot be used on a QOS-enabled socket.
///Params:
///    s = Descriptor identifying the local socket.
///    dwProcessId = Process identifier of the target process in which the duplicated socket will be used.
///    lpProtocolInfo = Pointer to a buffer, allocated by the client, that is large enough to contain a WSAPROTOCOL_INFO structure. The
///                     service provider copies the protocol information structure contents to this buffer.
///Returns:
///    If no error occurs, <b>WSADuplicateSocket</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> Indicates that one of the specified
///    parameters was invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td
///    width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a
///    callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMFILE</b></dt> </dl> </td> <td width="60%">
///    No more socket descriptors are available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl>
///    </td> <td width="60%"> No buffer space is available. The socket cannot be created. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpProtocolInfo</i>
///    parameter is not a valid part of the user address space. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSADuplicateSocketW(size_t s, uint dwProcessId, WSAPROTOCOL_INFOW* lpProtocolInfo);

///The <b>WSAEnumNetworkEvents</b> function discovers occurrences of network events for the indicated socket, clear
///internal network event records, and reset event objects (optional).
///Params:
///    s = A descriptor identifying the socket.
///    hEventObject = An optional handle identifying an associated event object to be reset.
///    lpNetworkEvents = A pointer to a WSANETWORKEVENTS structure that is filled with a record of network events that occurred and any
///                      associated error codes.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> One of the specified parameters was
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A
///    blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The
///    descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpNetworkEvents</i> parameter is not a valid part of the user address space. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
int WSAEnumNetworkEvents(size_t s, HANDLE hEventObject, WSANETWORKEVENTS* lpNetworkEvents);

///The <b>WSAEnumProtocols</b> function retrieves information about available transport protocols.
///Params:
///    lpiProtocols = A <b>NULLl</b>-terminated array of iProtocol values. This parameter is optional; if <i>lpiProtocols</i> is
///                   <b>NULL</b>, information on all available protocols is returned. Otherwise, information is retrieved only for
///                   those protocols listed in the array.
///    lpProtocolBuffer = A pointer to a buffer that is filled with WSAPROTOCOL_INFO structures.
///    lpdwBufferLength = On input, number of bytes in the <i>lpProtocolBuffer</i> buffer passed to <b>WSAEnumProtocols</b>. On output, the
///                       minimum buffer size that can be passed to <b>WSAEnumProtocols</b> to retrieve all the requested information. This
///                       routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all
///                       entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem
///                       because the number of protocols loaded on a computer is typically small.
///Returns:
///    If no error occurs, <b>WSAEnumProtocols</b> returns the number of protocols to be reported. Otherwise, a value of
///    SOCKET_ERROR is returned and a specific error code can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking
///    Windows Sockets 1.1 call is in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl>
///    </td> <td width="60%"> Indicates that one of the specified parameters was invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> The buffer length was too small to
///    receive all the relevant WSAPROTOCOL_INFO structures and associated information. Pass in a buffer at least as
///    large as the value returned in <i>lpdwBufferLength</i>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> One or more of the <i>lpiProtocols</i>,
///    <i>lpProtocolBuffer</i>, or <i>lpdwBufferLength</i> parameters are not a valid part of the user address space.
///    </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAEnumProtocolsA(int* lpiProtocols, char* lpProtocolBuffer, uint* lpdwBufferLength);

///The <b>WSAEnumProtocols</b> function retrieves information about available transport protocols.
///Params:
///    lpiProtocols = A <b>NULLl</b>-terminated array of iProtocol values. This parameter is optional; if <i>lpiProtocols</i> is
///                   <b>NULL</b>, information on all available protocols is returned. Otherwise, information is retrieved only for
///                   those protocols listed in the array.
///    lpProtocolBuffer = A pointer to a buffer that is filled with WSAPROTOCOL_INFO structures.
///    lpdwBufferLength = On input, number of bytes in the <i>lpProtocolBuffer</i> buffer passed to <b>WSAEnumProtocols</b>. On output, the
///                       minimum buffer size that can be passed to <b>WSAEnumProtocols</b> to retrieve all the requested information. This
///                       routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all
///                       entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem
///                       because the number of protocols loaded on a computer is typically small.
///Returns:
///    If no error occurs, <b>WSAEnumProtocols</b> returns the number of protocols to be reported. Otherwise, a value of
///    SOCKET_ERROR is returned and a specific error code can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking
///    Windows Sockets 1.1 call is in progress. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl>
///    </td> <td width="60%"> Indicates that one of the specified parameters was invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> The buffer length was too small to
///    receive all the relevant WSAPROTOCOL_INFO structures and associated information. Pass in a buffer at least as
///    large as the value returned in <i>lpdwBufferLength</i>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> One or more of the <i>lpiProtocols</i>,
///    <i>lpProtocolBuffer</i>, or <i>lpdwBufferLength</i> parameters are not a valid part of the user address space.
///    </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAEnumProtocolsW(int* lpiProtocols, char* lpProtocolBuffer, uint* lpdwBufferLength);

///The <b>WSAEventSelect</b> function specifies an event object to be associated with the specified set of FD_XXX
///network events.
///Params:
///    s = A descriptor identifying the socket.
///    hEventObject = A handle identifying the event object to be associated with the specified set of FD_XXX network events.
///    lNetworkEvents = A bitmask that specifies the combination of FD_XXX network events in which the application has interest.
///Returns:
///    The return value is zero if the application's specification of the network events and the associated event object
///    was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by
///    calling WSAGetLastError. As in the case of the select and WSAAsyncSelect functions, <b>WSAEventSelect</b> will
///    frequently be used to determine when a data transfer operation (send or recv) can be issued with the expectation
///    of immediate success. Nevertheless, a robust application must be prepared for the possibility that the event
///    object is set and it issues a Windows Sockets call that returns WSAEWOULDBLOCK immediately. For example, the
///    following sequence of operations is possible: <ul> <li>Data arrives on socket <i>s</i>; Windows Sockets sets the
///    <b>WSAEventSelect</b> event object.</li> <li>The application does some other processing.</li> <li>While
///    processing, the application issues an ioctlsocket(<i>s</i>, FIONREAD...) and notices that there is data ready to
///    be read.</li> <li>The application issues a recv(<i>s</i>,...) to read the data.</li> <li>The application
///    eventually waits on the event object specified in <b>WSAEventSelect</b>, which returns immediately indicating
///    that data is ready to read.</li> <li>The application issues recv(<i>s</i>,...), which fails with the error
///    WSAEWOULDBLOCK.</li> </ul> Having successfully recorded the occurrence of the network event (by setting the
///    corresponding bit in the internal network event record) and signaled the associated event object, no further
///    actions are taken for that network event until the application makes the function call that implicitly reenables
///    the setting of that network event and signaling of the associated event object. <table> <tr> <th>Network
///    event</th> <th>Re-enabling function</th> </tr> <tr> <td width="40%"> <dl> <dt><b>FD_READ</b></dt> </dl> </td> <td
///    width="60%"> The recv, recvfrom, WSARecv, WSARecvEx, or WSARecvFrom function. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>FD_WRITE</b></dt> </dl> </td> <td width="60%"> The send, sendto, WSASend, or WSASendTo function.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>FD_OOB</b></dt> </dl> </td> <td width="60%"> The recv, recvfrom,
///    WSARecv, WSARecvEx, or WSARecvFrom function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>FD_ACCEPT</b></dt>
///    </dl> </td> <td width="60%"> The accept, AcceptEx, or WSAAccept function unless the error code returned is
///    WSATRY_AGAIN indicating that the condition function returned CF_DEFER. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>FD_CONNECT</b></dt> </dl> </td> <td width="60%"> None. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>FD_CLOSE</b></dt> </dl> </td> <td width="60%"> None. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>FD_QOS</b></dt> </dl> </td> <td width="60%"> The WSAIoctl function with command <b>SIO_GET_QOS</b>. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>FD_GROUP_QOS</b></dt> </dl> </td> <td width="60%"> Reserved. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>FD_ROUTING_ INTERFACE_CHANGE</b></dt> </dl> </td> <td width="60%"> The WSAIoctl
///    function with command <b>SIO_ROUTING_INTERFACE_CHANGE</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>FD_ADDRESS_ LIST_CHANGE</b></dt> </dl> </td> <td width="60%"> The WSAIoctl function with command
///    <b>SIO_ADDRESS_LIST_CHANGE</b>. </td> </tr> </table> Any call to the reenabling routine, even one that fails,
///    results in reenabling of recording and signaling for the relevant network event and event object. For FD_READ,
///    FD_OOB, and FD_ACCEPT network events, network event recording and event object signaling are level-triggered.
///    This means that if the reenabling routine is called and the relevant network condition is still valid after the
///    call, the network event is recorded and the associated event object is set. This allows an application to be
///    event-driven and not be concerned with the amount of data that arrives at any one time. Consider the following
///    sequence: <ol> <li>The transport provider receives 100 bytes of data on socket <i>s</i> and causes WS2_32.DLL to
///    record the FD_READ network event and set the associated event object.</li> <li>The application issues
///    recv(<i>s</i>, <i>buffptr</i>, 50, 0) to read 50 bytes.</li> <li>The transport provider causes WS2_32.DLL to
///    record the FD_READ network event and sets the associated event object again since there is still data to be
///    read.</li> </ol> With these semantics, an application need not read all available data in response to an FD_READ
///    network event—a single recv in response to each FD_READ network event is appropriate. The FD_QOS event is
///    considered edge triggered. A message will be posted exactly once when a quality of service change occurs. Further
///    messages will not be forthcoming until either the provider detects a further change in quality of service or the
///    application renegotiates the quality of service for the socket. The FD_ROUTING_INTERFACE_CHANGE and
///    FD_ADDRESS_LIST_CHANGE events are considered edge triggered as well. A message will be posted exactly once when a
///    change occurs after the application has requested the notification by issuing WSAIoctl with
///    <b>SIO_ROUTING_INTERFACE_CHANGE</b> or <b>SIO_ADDRESS_LIST_CHANGE</b> correspondingly. Other messages will not be
///    forthcoming until the application reissues the IOCTL and another change is detected since the IOCTL has been
///    issued. If a network event has already happened when the application calls <b>WSAEventSelect</b> or when the
///    reenabling function is called, then a network event is recorded and the associated event object is set as
///    appropriate. For example, consider the following sequence: <ol> <li>An application calls listen.</li> <li>A
///    connect request is received but not yet accepted.</li> <li>The application calls <b>WSAEventSelect</b> specifying
///    that it is interested in the FD_ACCEPT network event for the socket. Due to the persistence of network events,
///    Windows Sockets records the FD_ACCEPT network event and sets the associated event object immediately.</li> </ol>
///    The FD_WRITE network event is handled slightly differently. An FD_WRITE network event is recorded when a socket
///    is first connected with a call to the connect, ConnectEx, WSAConnect, WSAConnectByList, or WSAConnectByName
///    function or when a socket is accepted with accept, AcceptEx, or WSAAccept function and then after a send fails
///    with WSAEWOULDBLOCK and buffer space becomes available. Therefore, an application can assume that sends are
///    possible starting from the first FD_WRITE network event setting and lasting until a send returns WSAEWOULDBLOCK.
///    After such a failure the application will find out that sends are again possible when an FD_WRITE network event
///    is recorded and the associated event object is set. The FD_OOB network event is used only when a socket is
///    configured to receive OOB data separately. If the socket is configured to receive OOB data inline, the OOB
///    (expedited) data is treated as normal data and the application should register an interest in, and will get
///    FD_READ network event, not FD_OOB network event. An application can set or inspect the way in which OOB data is
///    to be handled by using setsockopt or getsockopt for the SO_OOBINLINE option. The error code in an FD_CLOSE
///    network event indicates whether the socket close was graceful or abortive. If the error code is zero, then the
///    close was graceful; if the error code is WSAECONNRESET, then the socket's virtual circuit was reset. This only
///    applies to connection-oriented sockets such as SOCK_STREAM. The FD_CLOSE network event is recorded when a close
///    indication is received for the virtual circuit corresponding to the socket. In TCP terms, this means that the
///    FD_CLOSE is recorded when the connection goes into the TIME WAIT or CLOSE WAIT states. This results from the
///    remote end performing a shutdown on the send side or a closesocket. FD_CLOSE being posted after all data is read
///    from a socket. An application should check for remaining data upon receipt of FD_CLOSE to avoid any possibility
///    of losing data. For more information, see the section on Graceful Shutdown, Linger Options, and Socket Closure
///    and the <b>shutdown</b> function. Note that Windows Sockets will record only an FD_CLOSE network event to
///    indicate closure of a virtual circuit. It will not record an FD_READ network event to indicate this condition.
///    The FD_QOS or FD_GROUP_QOS network event is recorded when any parameter in the flow specification associated with
///    socket <i>s</i>. Applications should use WSAIoctl with command <b>SIO_GET_QOS</b> to get the current quality of
///    service for socket <i>s</i>. The FD_ROUTING_INTERFACE_CHANGE network event is recorded when the local interface
///    that should be used to reach the destination specified in WSAIoctl with <b>SIO_ROUTING_INTERFACE_CHANGE</b>
///    changes after such IOCTL has been issued. The FD_ADDRESS_LIST_CHANGE network event is recorded when the list of
///    addresses of protocol family for the socket to which the application can bind changes after WSAIoctl with
///    <b>SIO_ADDRESS_LIST_CHANGE</b> has been issued. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr>
///    <td>WSANOTINITIALISED</td> <td>A successful WSAStartup call must occur before using this function.</td> </tr>
///    <tr> <td>WSAENETDOWN</td> <td>The network subsystem has failed.</td> </tr> <tr> <td>WSAEINVAL</td> <td>One of the
///    specified parameters was invalid, or the specified socket is in an invalid state.</td> </tr> <tr>
///    <td>WSAEINPROGRESS</td> <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still
///    processing a callback function.</td> </tr> <tr> <td>WSAENOTSOCK</td> <td>The descriptor is not a socket.</td>
///    </tr> </table>
///    
@DllImport("WS2_32")
int WSAEventSelect(size_t s, HANDLE hEventObject, int lNetworkEvents);

///The <b>WSAGetOverlappedResult</b> function retrieves the results of an overlapped operation on the specified socket.
///Params:
///    s = A descriptor identifying the socket. This is the same socket that was specified when the overlapped operation was
///        started by a call to any of the Winsock functions that supports overlappped operations. These functions include
///        AcceptEx, ConnectEx, DisconnectEx, TransmitFile, TransmitPackets, WSARecv, WSARecvFrom, LPFN_WSARECVMSG
///        (WSARecvMsg), WSASend, WSASendMsg, WSASendTo, and WSAIoctl.
///    lpOverlapped = A pointer to a WSAOVERLAPPED structure that was specified when the overlapped operation was started. This
///                   parameter must not be a <b>NULL</b> pointer.
///    lpcbTransfer = A pointer to a 32-bit variable that receives the number of bytes that were actually transferred by a send or
///                   receive operation, or by the WSAIoctl function. This parameter must not be a <b>NULL</b> pointer.
///    fWait = A flag that specifies whether the function should wait for the pending overlapped operation to complete. If
///            <b>TRUE</b>, the function does not return until the operation has been completed. If <b>FALSE</b> and the
///            operation is still pending, the function returns <b>FALSE</b> and the WSAGetLastError function returns
///            WSA_IO_INCOMPLETE. The <i>fWait</i> parameter may be set to <b>TRUE</b> only if the overlapped operation selected
///            the event-based completion notification.
///    lpdwFlags = A pointer to a 32-bit variable that will receive one or more flags that supplement the completion status. If the
///                overlapped operation was initiated through WSARecv or WSARecvFrom, this parameter will contain the results value
///                for <i>lpFlags</i> parameter. This parameter must not be a <b>NULL</b> pointer.
///Returns:
///    If <b>WSAGetOverlappedResult</b> succeeds, the return value is <b>TRUE</b>. This means that the overlapped
///    operation has completed successfully and that the value pointed to by <i>lpcbTransfer</i> has been updated. If
///    <b>WSAGetOverlappedResult</b> returns <b>FALSE</b>, this means that either the overlapped operation has not
///    completed, the overlapped operation completed but with errors, or the overlapped operation's completion status
///    could not be determined due to errors in one or more parameters to <b>WSAGetOverlappedResult</b>. On failure, the
///    value pointed to by <i>lpcbTransfer</i> will not be updated. Use WSAGetLastError to determine the cause of the
///    failure (either by the <b>WSAGetOverlappedResult</b> function or by the associated overlapped operation). <table>
///    <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt>
///    </dl> </td> <td width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is
///    not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dt> </dl> </td> <td
///    width="60%"> The <i>hEvent</i> parameter of the WSAOVERLAPPED structure does not contain a valid event object
///    handle. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%">
///    One of the parameters is unacceptable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_IO_INCOMPLETE</b></dt>
///    </dl> </td> <td width="60%"> The <i>fWait</i> parameter is <b>FALSE</b> and the I/O operation has not yet
///    completed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> One or
///    more of the <i>lpOverlapped</i>, <i>lpcbTransfer</i>, or <i>lpdwFlags</i> parameters are not in a valid part of
///    the user address space. This error is returned if the <i>lpOverlapped</i>, <i>lpcbTransfer</i>, or
///    <i>lpdwFlags</i> parameter was a <b>NULL</b> pointer on Windows Server 2003 and earlier. </td> </tr> </table>
///    
@DllImport("WS2_32")
BOOL WSAGetOverlappedResult(size_t s, OVERLAPPED* lpOverlapped, uint* lpcbTransfer, BOOL fWait, uint* lpdwFlags);

///The <b>WSAGetQOSByName</b> function initializes a QOS structure based on a named template, or it supplies a buffer to
///retrieve an enumeration of the available template names.
///Params:
///    s = A descriptor identifying a socket.
///    lpQOSName = A pointer to a specific quality of service template.
///    lpQOS = A pointer to the QOS structure to be filled.
///Returns:
///    If <b>WSAGetQOSByName</b> succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is
///    <b>FALSE</b>. To get extended error information, call WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpQOSName</i> or
///    <i>lpQOS</i> parameter are not a valid part of the user address space, or the buffer length for <i>lpQOS</i> is
///    too small. </td> </tr> </table>
///    
@DllImport("WS2_32")
BOOL WSAGetQOSByName(size_t s, WSABUF* lpQOSName, QOS* lpQOS);

///The <b>WSAHtonl</b> function converts a <b>u_long</b> from host byte order to network byte order.
///Params:
///    s = A descriptor identifying a socket.
///    hostlong = A 32-bit number in host byte order.
///    lpnetlong = A pointer to a 32-bit number to receive the number in network byte order.
///Returns:
///    If no error occurs, <b>WSAHtonl</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific
///    error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup
///    call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpnetlong</i> parameter is
///    <b>NULL</b> or the address pointed to is not completely contained in a valid part of the user address space.
///    </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAHtonl(size_t s, uint hostlong, uint* lpnetlong);

///The <b>WSAHtons</b> function converts a <b>u_short</b> from host byte order to network byte order.
///Params:
///    s = A descriptor identifying a socket.
///    hostshort = A 16-bit number in host byte order.
///    lpnetshort = A pointer to a 16-bit buffer to receive the number in network byte order.
///Returns:
///    If no error occurs, <b>WSAHtons</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific
///    error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup
///    call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpnetshort</i> parameter is
///    <b>NULL</b> or the address pointed to is not completely contained in a valid part of the user address space.
///    </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAHtons(size_t s, ushort hostshort, ushort* lpnetshort);

///The <b>WSAIoctl</b> function controls the mode of a socket.
///Params:
///    s = A descriptor identifying a socket.
///    dwIoControlCode = The control code of operation to perform.
///    lpvInBuffer = A pointer to the input buffer.
///    cbInBuffer = The size, in bytes, of the input buffer.
///    lpvOutBuffer = A pointer to the output buffer.
///    cbOutBuffer = The size, in bytes, of the output buffer.
///    lpcbBytesReturned = A pointer to actual number of bytes of output.
///    lpOverlapped = A pointer to a WSAOVERLAPPED structure (ignored for non-overlapped sockets).
///    lpCompletionRoutine = Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
///                          <div class="alert"><b>Note</b> A pointer to the completion routine called when the operation has been completed
///                          (ignored for non-overlapped sockets). See Remarks.</div> <div> </div>
///Returns:
///    Upon successful completion, the <b>WSAIoctl</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and
///    a specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dt> </dl> </td> <td width="60%"> An
///    overlapped operation was successfully initiated and completion will be indicated at a later time. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has
///    failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpvInBuffer</i>, <i>lpvOutBuffer</i>, <i>lpcbBytesReturned</i>, <i>lpOverlapped</i>, or
///    <i>lpCompletionRoutine</i> parameter is not totally contained in a valid part of the user address space, or the
///    <i>cbInBuffer</i> or <i>cbOutBuffer</i> parameter is too small. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The <i>dwIoControlCode</i> parameter is not a valid
///    command, or a specified input parameter is not acceptable, or the command is not applicable to the type of socket
///    specified. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> The
///    function is invoked when a callback is in progress. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor <i>s</i> is not a socket. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The specified IOCTL command
///    cannot be realized. (For example, the FLOWSPEC structures specified in <b>SIO_SET_QOS</b> or
///    <b>SIO_SET_GROUP_QOS</b> cannot be satisfied.) </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> The socket is marked as non-blocking and the
///    requested operation would block. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOPROTOOPT</b></dt> </dl>
///    </td> <td width="60%"> The socket option is not supported on the specified protocol. For example, an attempt to
///    use the <b>SIO_GET_BROADCAST_ADDRESS</b> IOCTL was made on an IPv6 socket or an attempt to use the TCP
///    <b>SIO_KEEPALIVE_VALS</b> IOCTL was made on a datagram socket. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAIoctl(size_t s, uint dwIoControlCode, char* lpvInBuffer, uint cbInBuffer, char* lpvOutBuffer, 
             uint cbOutBuffer, uint* lpcbBytesReturned, OVERLAPPED* lpOverlapped, 
             LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///The <b>WSAJoinLeaf</b> function joins a leaf node into a multipoint session, exchanges connect data, and specifies
///needed quality of service based on the specified FLOWSPEC structures.
///Params:
///    s = Descriptor identifying a multipoint socket.
///    name = Name of the peer to which the socket is to be joined.
///    namelen = Length of <i>name</i>, in bytes.
///    lpCallerData = Pointer to the user data that is to be transferred to the peer during multipoint session establishment.
///    lpCalleeData = Pointer to the user data that is to be transferred back from the peer during multipoint session establishment.
///    lpSQOS = Pointer to the FLOWSPEC structures for socket <i>s</i>, one for each direction.
///    lpGQOS = Reserved for future use with socket groups. A pointer to the FLOWSPEC structures for the socket group (if
///             applicable).
///    dwFlags = Flags to indicate that the socket is acting as a sender (JL_SENDER_ONLY), receiver (JL_RECEIVER_ONLY), or both
///              (JL_BOTH).
///Returns:
///    If no error occurs, <b>WSAJoinLeaf</b> returns a value of type SOCKET that is a descriptor for the newly created
///    multipoint socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved
///    by calling WSAGetLastError. On a blocking socket, the return value indicates success or failure of the join
///    operation. With a nonblocking socket, successful initiation of a join operation is indicated by a return of a
///    valid socket descriptor. Subsequently, an FD_CONNECT indication will be given on the original socket <i>s</i>
///    when the join operation completes, either successfully or otherwise. The application must use either
///    WSAAsyncSelect or WSAEventSelect with interest registered for the FD_CONNECT event in order to determine when the
///    join operation has completed and checks the associated error code to determine the success or failure of the
///    operation. The select function cannot be used to determine when the join operation completes. Also, until the
///    multipoint session join attempt completes all subsequent calls to <b>WSAJoinLeaf</b> on the same socket will fail
///    with the error code WSAEALREADY. After the <b>WSAJoinLeaf</b> operation completes successfully, a subsequent
///    attempt will usually fail with the error code WSAEISCONN. An exception to the WSAEISCONN rule occurs for a c_root
///    socket that allows root-initiated joins. In such a case, another join may be initiated after a prior
///    <b>WSAJoinLeaf</b> operation completes. If the return error code indicates the multipoint session join attempt
///    failed (that is, WSAECONNREFUSED, WSAENETUNREACH, WSAETIMEDOUT) the application can call <b>WSAJoinLeaf</b> again
///    for the same socket. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call must occur before
///    using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRINUSE</b></dt> </dl> </td> <td
///    width="60%"> The socket's local address is already in use and the socket was not marked to allow address reuse
///    with SO_REUSEADDR. This error usually occurs at the time of bind, but could be delayed until this function if the
///    <b>bind</b> was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be
///    committed at the time of this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEADDRNOTAVAIL</b></dt>
///    </dl> </td> <td width="60%"> The remote address is not a valid address (such as ADDR_ANY). </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> Addresses in the specified family
///    cannot be used with this socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEALREADY</b></dt> </dl> </td>
///    <td width="60%"> A nonblocking WSAJoinLeaf call is in progress on the specified socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAECONNREFUSED</b></dt> </dl> </td> <td width="60%"> The attempt to join was forcefully
///    rejected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The
///    <i>name</i> or the <i>namelen</i> parameter is not a valid part of the user address space, the <i>namelen</i>
///    parameter is too small, the buffer length for <i>lpCalleeData</i>, <i>lpSQOS</i>, and <i>lpGQOS</i> are too
///    small, or the buffer length for <i>lpCallerData</i> is too large. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> A WSAJoinLeaf function call was performed on a UDP socket
///    that was opened without setting its WSA_FLAG_MULTIPOINT_C_LEAF or WSA_FLAG_MULTIPOINT_D_LEAF multipoint flag.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEISCONN</b></dt> </dl> </td> <td width="60%"> The socket is
///    already a member of the multipoint session. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl>
///    </td> <td width="60%"> A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets
///    1.1 call is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETUNREACH</b></dt> </dl> </td> <td width="60%"> The network
///    cannot be reached from this host at this time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt>
///    </dl> </td> <td width="60%"> No buffer space is available. The socket cannot be joined. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The FLOWSPEC
///    structures specified in <i>lpSQOS</i> and <i>lpGQOS</i> cannot be satisfied. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEPROTONOSUPPORT</b></dt> </dl> </td> <td width="60%"> The <i>lpCallerData</i> augment is not
///    supported by the service provider. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAETIMEDOUT</b></dt> </dl>
///    </td> <td width="60%"> The attempt to join timed out without establishing a multipoint session. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
size_t WSAJoinLeaf(size_t s, char* name, int namelen, WSABUF* lpCallerData, WSABUF* lpCalleeData, QOS* lpSQOS, 
                   QOS* lpGQOS, uint dwFlags);

///The <b>WSANtohl</b> function converts a <b>u_long</b> from network byte order to host byte order.
///Params:
///    s = A descriptor identifying a socket.
///    netlong = A 32-bit number in network byte order.
///    lphostlong = A pointer to a 32-bit number to receive the number in host byte order.
///Returns:
///    If no error occurs, <b>WSANtohl</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific
///    error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup
///    call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lphostlong</i> parameter is
///    <b>NULL</b> or the address pointed to is not completely contained in a valid part of the user address space.
///    </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSANtohl(size_t s, uint netlong, uint* lphostlong);

///The <b>WSANtohs</b> function converts a <b>u_short</b> from network byte order to host byte order.
///Params:
///    s = A descriptor identifying a socket.
///    netshort = A 16-bit number in network byte order.
///    lphostshort = A pointer to a 16-bit number to receive the number in host byte order.
///Returns:
///    If no error occurs, <b>WSANtohs</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific
///    error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup
///    call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt>
///    </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lphostshort</i> parameter is
///    <b>NULL</b> or the address pointed to is not completely contained in a valid part of the user address space.
///    </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSANtohs(size_t s, ushort netshort, ushort* lphostshort);

///The <b>WSARecv</b> function receives data from a connected socket or a bound connectionless socket.
///Params:
///    s = A descriptor identifying a connected socket.
///    lpBuffers = A pointer to an array of WSABUF structures. Each <b>WSABUF</b> structure contains a pointer to a buffer and the
///                length, in bytes, of the buffer.
///    dwBufferCount = The number of WSABUF structures in the <i>lpBuffers</i> array.
///    lpNumberOfBytesRecvd = A pointer to the number, in bytes, of data received by this call if the receive operation completes immediately.
///                           Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially
///                           erroneous results. This parameter can be <b>NULL</b> only if the <i>lpOverlapped</i> parameter is not
///                           <b>NULL</b>.
///    lpFlags = A pointer to flags used to modify the behavior of the <b>WSARecv</b> function call. For more information, see the
///              Remarks section.
///    lpOverlapped = A pointer to a WSAOVERLAPPED structure (ignored for nonoverlapped sockets).
///    lpCompletionRoutine = Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md) A
///                          pointer to the completion routine called when the receive operation has been completed (ignored for nonoverlapped
///                          sockets).
///Returns:
///    If no error occurs and the receive operation has completed immediately, <b>WSARecv</b> returns zero. In this
///    case, the completion routine will have already been scheduled to be called once the calling thread is in the
///    alertable state. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be
///    retrieved by calling WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has
///    been successfully initiated and that completion will be indicated at a later time. Any other error code indicates
///    that the overlapped operation was not successfully initiated and no completion indication will occur. <table>
///    <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNABORTED</b></dt> </dl>
///    </td> <td width="60%"> The virtual circuit was terminated due to a time-out or other failure. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> For a stream socket, the virtual
///    circuit was reset by the remote side. The application should close the socket as it is no longer usable. For a
///    UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port
///    Unreachable" message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEDISCON</b></dt> </dl> </td> <td
///    width="60%"> Socket <i>s</i> is message oriented and the virtual circuit was gracefully closed by the remote
///    side. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpBuffers</i> parameter is not completely contained in a valid part of the user address space. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets
///    1.1 call is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> The (blocking) call was canceled by the
///    WSACancelBlockingCall function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td
///    width="60%"> The socket has not been bound (for example, with bind). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> The message was too large to fit into the specified
///    buffer and (for unreliable protocols only) any trailing portion of the message that did not fit into the buffer
///    has been discarded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td
///    width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETRESET</b></dt> </dl> </td> <td width="60%"> For a connection-oriented socket, this error indicates
///    that the connection has been broken due to <i>keep-alive</i> activity that detected a failure while the operation
///    was in progress. For a datagram socket, this error indicates that the time to live has expired. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%"> The socket is not connected. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a
///    socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%">
///    <b>MSG_OOB</b> was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not
///    supported in the communication domain associated with this socket, or the socket is unidirectional and supports
///    only send operations. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td
///    width="60%"> The socket has been shut down; it is not possible to call WSARecv on a socket after shutdown has
///    been invoked with <i>how</i> set to <b>SD_RECEIVE</b> or <b>SD_BOTH</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> The connection has been dropped because of a network
///    failure or because the peer system failed to respond. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> <b>Windows NT: </b>Overlapped sockets: there are too
///    many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is marked as nonblocking and the
///    receive operation cannot be completed immediately. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call must occur before
///    using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dt> </dl> </td> <td
///    width="60%"> An overlapped operation was successfully initiated and completion will be indicated at a later time.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_OPERATION_ABORTED</b></dt> </dl> </td> <td width="60%"> The
///    overlapped operation has been canceled due to the closure of the socket. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSARecv(size_t s, char* lpBuffers, uint dwBufferCount, uint* lpNumberOfBytesRecvd, uint* lpFlags, 
            OVERLAPPED* lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///The <b>WSARecvDisconnect</b> function terminates reception on a socket, and retrieves the disconnect data if the
///socket is connection oriented.
///Params:
///    s = A descriptor identifying a socket.
///    lpInboundDisconnectData = A pointer to the incoming disconnect data.
///Returns:
///    If no error occurs, <b>WSARecvDisconnect</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The buffer referenced by the parameter
///    <i>lpInboundDisconnectData</i> is too small. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOPROTOOPT</b></dt> </dl> </td> <td width="60%"> The disconnect data is not supported by the indicated
///    protocol family. Note that implementations of TCP/IP that do not support disconnect data are not required to
///    return the WSAENOPROTOOPT error code. See the remarks section for information about the Microsoft implementation
///    of TCP/IP. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A
///    blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%"> The
///    socket is not connected (connection-oriented sockets only). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSARecvDisconnect(size_t s, WSABUF* lpInboundDisconnectData);

///The <b>WSARecvFrom</b> function receives a datagram and stores the source address.
///Params:
///    s = A descriptor identifying a socket.
///    lpBuffers = A pointer to an array of WSABUF structures. Each <b>WSABUF</b> structure contains a pointer to a buffer and the
///                length of the buffer.
///    dwBufferCount = The number of WSABUF structures in the <i>lpBuffers</i> array.
///    lpNumberOfBytesRecvd = A pointer to the number of bytes received by this call if the <b>WSARecvFrom</b> operation completes immediately.
///                           Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially
///                           erroneous results. This parameter can be <b>NULL</b> only if the <i>lpOverlapped</i> parameter is not
///                           <b>NULL</b>.
///    lpFlags = A pointer to flags used to modify the behavior of the <b>WSARecvFrom</b> function call. See remarks below.
///    lpFrom = An optional pointer to a buffer that will hold the source address upon the completion of the overlapped
///             operation.
///    lpFromlen = A pointer to the size, in bytes, of the "from" buffer required only if <i>lpFrom</i> is specified.
///    lpOverlapped = A pointer to a WSAOVERLAPPED structure (ignored for nonoverlapped sockets).
///    lpCompletionRoutine = Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md) A
///                          pointer to the completion routine called when the <b>WSARecvFrom</b> operation has been completed (ignored for
///                          nonoverlapped sockets).
///Returns:
///    If no error occurs and the receive operation has completed immediately, <b>WSARecvFrom</b> returns zero. In this
///    case, the completion routine will have already been scheduled to be called once the calling thread is in the
///    alertable state. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be
///    retrieved by calling WSAGetLastError. The error code <b>WSA_IO_PENDING</b> indicates that the overlapped
///    operation has been successfully initiated and that completion will be indicated at a later time. Any other error
///    code indicates that the overlapped operation was not successfully initiated and no completion indication will
///    occur. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> The virtual circuit was reset by the remote side
///    executing a hard or abortive close. The application should close the socket as it is no longer usable. For a UPD
///    datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable"
///    message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpBuffers</i>, <i>lpFlags</i>, <i>lpFrom</i>, <i>lpNumberOfBytesRecvd</i>, <i>lpFromlen</i>,
///    <i>lpOverlapped</i>, or <i>lpCompletionRoutine</i> parameter is not totally contained in a valid part of the user
///    address space: the <i>lpFrom</i> buffer was too small to accommodate the peer address. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call
///    is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking Windows Socket 1.1 call was
///    canceled through WSACancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl>
///    </td> <td width="60%"> The socket has not been bound (with bind, for example). </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> The message was too large for the specified buffer
///    and (for unreliable protocols only) any trailing portion of the message that did not fit into the buffer has been
///    discarded. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The
///    network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETRESET</b></dt> </dl> </td> <td
///    width="60%"> For a datagram socket, this error indicates that the time to live has expired. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%"> The socket is not connected
///    (connection-oriented sockets only). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl>
///    </td> <td width="60%"> <b>Windows NT: </b> Overlapped sockets: There are too many outstanding overlapped I/O
///    requests. Nonoverlapped sockets: The socket is marked as nonblocking and the receive operation cannot be
///    completed immediately. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td
///    width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dt> </dl> </td> <td width="60%"> An overlapped operation was
///    successfully initiated and completion will be indicated later. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_OPERATION_ABORTED</b></dt> </dl> </td> <td width="60%"> The overlapped operation has been canceled due
///    to the closure of the socket. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSARecvFrom(size_t s, char* lpBuffers, uint dwBufferCount, uint* lpNumberOfBytesRecvd, uint* lpFlags, 
                char* lpFrom, int* lpFromlen, OVERLAPPED* lpOverlapped, 
                LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///The <b>WSAResetEvent</b> function resets the state of the specified event object to nonsignaled.
///Params:
///    hEvent = A handle that identifies an open event object handle.
///Returns:
///    If the <b>WSAResetEvent</b> function succeeds, the return value is <b>TRUE</b>. If the function fails, the return
///    value is <b>FALSE</b>. To get extended error information, call WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call
///    is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The <i>hEvent</i> parameter is
///    not a valid event object handle. </td> </tr> </table>
///    
@DllImport("WS2_32")
BOOL WSAResetEvent(HANDLE hEvent);

///The <b>WSASend</b> function sends data on a connected socket.
///Params:
///    s = A descriptor that identifies a connected socket.
///    lpBuffers = A pointer to an array of WSABUF structures. Each <b>WSABUF</b> structure contains a pointer to a buffer and the
///                length, in bytes, of the buffer. For a Winsock application, once the <b>WSASend</b> function is called, the
///                system owns these buffers and the application may not access them. This array must remain valid for the duration
///                of the send operation.
///    dwBufferCount = The number of WSABUF structures in the <i>lpBuffers</i> array.
///    lpNumberOfBytesSent = A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately. Use <b>NULL</b>
///                          for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous
///                          results. This parameter can be <b>NULL</b> only if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
///    dwFlags = The flags used to modify the behavior of the <b>WSASend</b> function call. For more information, see Using
///              <i>dwFlags</i> in the Remarks section.
///    lpOverlapped = A pointer to a WSAOVERLAPPED structure. This parameter is ignored for nonoverlapped sockets.
///    lpCompletionRoutine = Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md) A
///                          pointer to the completion routine called when the send operation has been completed. This parameter is ignored
///                          for nonoverlapped sockets.
///Returns:
///    If no error occurs and the send operation has completed immediately, <b>WSASend</b> returns zero. In this case,
///    the completion routine will have already been scheduled to be called once the calling thread is in the alertable
///    state. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by
///    calling WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been
///    successfully initiated and that completion will be indicated at a later time. Any other error code indicates that
///    the overlapped operation was not successfully initiated and no completion indication will occur. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNABORTED</b></dt> </dl> </td>
///    <td width="60%"> The virtual circuit was terminated due to a time-out or other failure. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> For a stream socket, the virtual
///    circuit was reset by the remote side. The application should close the socket as it is no longer usable. For a
///    UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port
///    Unreachable" message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpBuffers</i>, <i>lpNumberOfBytesSent</i>, <i>lpOverlapped</i>, <i>lpCompletionRoutine</i>
///    parameter is not totally contained in a valid part of the user address space. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking Windows Socket 1.1 call was canceled
///    through WSACancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td>
///    <td width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing
///    a callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td
///    width="60%"> The socket has not been bound with bind or the socket is not created with the overlapped flag. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> The socket is message
///    oriented, and the message is larger than the maximum supported by the underlying transport. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETRESET</b></dt> </dl> </td> <td width="60%"> For a stream
///    socket, the connection has been broken due to keep-alive activity detecting a failure while the operation was in
///    progress. For a datagram socket, this error indicates that the time to live has expired. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> The Windows Sockets provider reports a
///    buffer deadlock. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%">
///    The socket is not connected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td
///    width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt>
///    </dl> </td> <td width="60%"> <b>MSG_OOB</b> was specified, but the socket is not stream-style such as type
///    <b>SOCK_STREAM</b>, OOB data is not supported in the communication domain associated with this socket,
///    <b>MSG_PARTIAL</b> is not supported, or the socket is unidirectional and supports only receive operations. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%"> The socket has been
///    shut down; it is not possible to WSASend on a socket after shutdown has been invoked with how set to
///    <b>SD_SEND</b> or <b>SD_BOTH</b>. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl>
///    </td> <td width="60%"> <b>Windows NT: </b> Overlapped sockets: There are too many outstanding overlapped I/O
///    requests. Nonoverlapped sockets: The socket is marked as nonblocking and the send operation cannot be completed
///    immediately. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td
///    width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dt> </dl> </td> <td width="60%"> An overlapped operation was
///    successfully initiated and completion will be indicated at a later time. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_OPERATION_ABORTED</b></dt> </dl> </td> <td width="60%"> The overlapped operation has been canceled due
///    to the closure of the socket, the execution of the "SIO_FLUSH" command in WSAIoctl, or the thread that initiated
///    the overlapped request exited before the operation completed. For more information, see the Remarks section.
///    </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSASend(size_t s, char* lpBuffers, uint dwBufferCount, uint* lpNumberOfBytesSent, uint dwFlags, 
            OVERLAPPED* lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///The <b>WSASendMsg</b> function sends data and optional control information from connected and unconnected sockets.
///<div class="alert"><b>Note</b> This function is a Microsoft-specific extension to the Windows Sockets
///specification.</div> <div> </div>
///Params:
///    Handle = A descriptor identifying the socket.
///    lpMsg = A WSAMSG structure storing the Posix.1g <b>msghdr</b> structure.
///    dwFlags = The flags used to modify the behavior of the <b>WSASendMsg</b> function call. For more information, see Using
///              <i>dwFlags</i> in the Remarks section.
///    lpNumberOfBytesSent = A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately. Use <b>NULL</b>
///                          for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous
///                          results. This parameter can be <b>NULL</b> only if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
///    lpOverlapped = A pointer to a WSAOVERLAPPED structure. Ignored for non-overlapped sockets.
///    lpCompletionRoutine = Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md) A
///                          pointer to the completion routine called when the send operation completes. Ignored for non-overlapped sockets.
///Returns:
///    Returns zero when successful and immediate completion occurs. When zero is returned, the specified completion
///    routine is called when the calling thread is in the alertable state. A return value of <b>SOCKET_ERROR</b>, and
///    subsequent call to WSAGetLastError that returns WSA_IO_PENDING, indicates the overlapped operation has
///    successfully initiated; completion is then indicated through other means, such as through events or completion
///    ports. Upon failure, returns <b>SOCKET_ERROR</b> and a subsequent call to WSAGetLastError returns a value other
///    than <b>WSA_IO_PENDING</b>. The following table lists error codes. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td width="60%"> The
///    requested address is a broadcast address, but the appropriate flag was not set. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> For a UDP datagram socket, this error would
///    indicate that a previous send operation resulted in an ICMP "Port Unreachable" message. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpMsg</i>,
///    <i>lpNumberOfBytesSent</i>, <i>lpOverlapped</i>, or <i>lpCompletionRoutine</i> parameter is not totally contained
///    in a valid part of the user address space. This error is also returned if a <b>name</b> member of the
///    WSAMSGstructure pointed to by the <i>lpMsg</i> parameter was a <b>NULL</b> pointer and the <b>namelen</b> member
///    of the <b>WSAMSG</b>structure was not set to zero. This error is also returned if a <b>Control.buf</b> member of
///    the <b>WSAMSG</b>structure pointed to by the <i>lpMsg</i> parameter was a <b>NULL</b> pointer and the
///    <b>Control.len</b> member of the <b>WSAMSG</b>structure was not set to zero. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in
///    progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> A blocking Windows Socket 1.1 call was canceled through
///    WSACancelBlockingCall. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td
///    width="60%"> The socket has not been bound with bind, or the socket was not created with the overlapped flag.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> The socket is
///    message oriented, and the message is larger than the maximum supported by the underlying transport. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has
///    failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETRESET</b></dt> </dl> </td> <td width="60%"> For a
///    datagram socket, this error indicates that the time to live has expired. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETUNREACH</b></dt> </dl> </td> <td width="60%"> The network is unreachable. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> The Windows Sockets provider reports a
///    buffer deadlock. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%">
///    The socket is not connected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td
///    width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt>
///    </dl> </td> <td width="60%"> The socket operation is not supported. This error is returned if the <b>dwFlags</b>
///    member of the WSAMSGstructure pointed to by the <i>lpMsg</i> parameter includes any control flags invalid for
///    WSASendMsg. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
///    socket has been shut down; it is not possible to call the WSASendMsg function on a socket after shutdown has been
///    invoked with <i>how</i> set to SD_SEND or SD_BOTH. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAETIMEDOUT</b></dt> </dl> </td> <td width="60%"> The socket timed out. This error is returned if the
///    socket had a wait timeout specified using the <b>SO_SNDTIMEO</b> socket option and the timeout was exceeded.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> Overlapped
///    sockets: There are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is marked as
///    nonblocking and the send operation cannot be completed immediately. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call must occur before
///    using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dt> </dl> </td> <td
///    width="60%"> An overlapped operation was successfully initiated and completion will be indicated at a later time.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_OPERATION_ABORTED</b></dt> </dl> </td> <td width="60%"> The
///    overlapped operation has been canceled due to the closure of the socket or due to the execution of the
///    <b>SIO_FLUSH</b> command in WSAIoctl. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSASendMsg(size_t Handle, WSAMSG* lpMsg, uint dwFlags, uint* lpNumberOfBytesSent, OVERLAPPED* lpOverlapped, 
               LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///The <b>WSASendDisconnect</b> function initiates termination of the connection for the socket and sends disconnect
///data.
///Params:
///    s = Descriptor identifying a socket.
///    lpOutboundDisconnectData = A pointer to the outgoing disconnect data.
///Returns:
///    If no error occurs, <b>WSASendDisconnect</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOPROTOOPT</b></dt> </dl> </td> <td width="60%"> The parameter
///    <i>lpOutboundDisconnectData</i> is not <b>NULL</b>, and the disconnect data is not supported by the service
///    provider. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A
///    blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback
///    function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%"> The
///    socket is not connected (connection-oriented sockets only). </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpOutboundDisconnectData</i>
///    parameter is not completely contained in a valid part of the user address space. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSASendDisconnect(size_t s, WSABUF* lpOutboundDisconnectData);

///The <b>WSASendTo</b> function sends data to a specific destination, using overlapped I/O where applicable.
///Params:
///    s = A descriptor identifying a (possibly connected) socket.
///    lpBuffers = A pointer to an array of WSABUF structures. Each <b>WSABUF</b> structure contains a pointer to a buffer and the
///                length of the buffer, in bytes. For a Winsock application, once the <b>WSASendTo</b> function is called, the
///                system owns these buffers and the application may not access them. This array must remain valid for the duration
///                of the send operation.
///    dwBufferCount = The number of WSABUF structures in the <i>lpBuffers</i> array.
///    lpNumberOfBytesSent = A pointer to the number of bytes sent by this call if the I/O operation completes immediately. Use <b>NULL</b>
///                          for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous
///                          results. This parameter can be <b>NULL</b> only if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
///    dwFlags = The flags used to modify the behavior of the <b>WSASendTo</b> function call.
///    lpTo = An optional pointer to the address of the target socket in the SOCKADDR structure.
///    iTolen = The size, in bytes, of the address in the <i>lpTo</i> parameter.
///    lpOverlapped = A pointer to a WSAOVERLAPPED structure (ignored for nonoverlapped sockets).
///    lpCompletionRoutine = Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md) A
///                          pointer to the completion routine called when the send operation has been completed (ignored for nonoverlapped
///                          sockets).
///Returns:
///    If no error occurs and the send operation has completed immediately, <b>WSASendTo</b> returns zero. In this case,
///    the completion routine will have already been scheduled to be called once the calling thread is in the alertable
///    state. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by
///    calling WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation has been
///    successfully initiated and that completion will be indicated at a later time. Any other error code indicates that
///    the overlapped operation was not successfully initiated and no completion indication will occur. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td
///    width="60%"> The requested address is a broadcast address, but the appropriate flag was not set. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEADDRNOTAVAIL</b></dt> </dl> </td> <td width="60%"> The remote address is not a
///    valid address (such as ADDR_ANY). </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl>
///    </td> <td width="60%"> Addresses in the specified family cannot be used with this socket. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> For a UDP datagram socket, this
///    error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEDESTADDRREQ</b></dt> </dl> </td> <td width="60%"> A destination address is
///    required. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The
///    <i>lpBuffers</i>, <i>lpTo</i>, <i>lpOverlapped</i>, <i>lpNumberOfBytesSent</i>, or <i>lpCompletionRoutine</i>
///    parameters are not part of the user address space, or the <i>lpTo</i> parameter is too small. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEHOSTUNREACH</b></dt> </dl> </td> <td width="60%"> A socket operation was
///    attempted to an unreachable host. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl>
///    </td> <td width="60%"> A blocking Windows Sockets 1.1 call is in progress, or the service provider is still
///    processing a callback function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td
///    width="60%"> A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The socket has not been bound with bind,
///    or the socket is not created with the overlapped flag. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> The socket is message oriented, and the message is
///    larger than the maximum supported by the underlying transport. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETRESET</b></dt> </dl> </td> <td width="60%"> For a datagram socket, this error
///    indicates that the time to live has expired. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETUNREACH</b></dt> </dl> </td> <td width="60%"> The network cannot be reached from this host at this
///    time. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> The Windows
///    Sockets provider reports a buffer deadlock. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt>
///    </dl> </td> <td width="60%"> The socket is not connected (connection-oriented sockets only). </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%"> The socket has been
///    shut down; it is not possible to WSASendTo on a socket after shutdown has been invoked with <i>how</i> set to
///    SD_SEND or SD_BOTH. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td
///    width="60%"> <b>Windows NT: </b> Overlapped sockets: there are too many outstanding overlapped I/O requests.
///    Nonoverlapped sockets: The socket is marked as nonblocking and the send operation cannot be completed
///    immediately. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td
///    width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dt> </dl> </td> <td width="60%"> An overlapped operation was
///    successfully initiated and completion will be indicated at a later time. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_OPERATION_ABORTED</b></dt> </dl> </td> <td width="60%"> The overlapped operation has been canceled due
///    to the closure of the socket, or the execution of the SIO_FLUSH command in WSAIoctl. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSASendTo(size_t s, char* lpBuffers, uint dwBufferCount, uint* lpNumberOfBytesSent, uint dwFlags, char* lpTo, 
              int iTolen, OVERLAPPED* lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///The <b>WSASetEvent</b> function sets the state of the specified event object to signaled.
///Params:
///    hEvent = Handle that identifies an open event object.
///Returns:
///    If the function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is
///    <b>FALSE</b>. To get extended error information, call WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%">
///    A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets 1.1 call
///    is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The <i>hEvent</i> parameter is
///    not a valid event object handle. </td> </tr> </table>
///    
@DllImport("WS2_32")
BOOL WSASetEvent(HANDLE hEvent);

///The <b>WSASocket</b> function creates a socket that is bound to a specific transport-service provider.
///Params:
///    af = The address family specification. Possible values for the address family are defined in the <i>Winsock2.h</i>
///         header file. On the Windows SDK released for Windows Vista and later, the organization of header files has
///         changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that
///         the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
///         directly. The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats
///         for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported
///         if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_
///         address family and PF_ protocol family constants are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>),
///         so either constant can be used. The table below lists common values for address family although many other values
///         are possible. <table> <tr> <th>Af</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AF_UNSPEC"></a><a
///         id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The address family is
///         unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
///         <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol version 4 (IPv4) address
///         family. </td> </tr> <tr> <td width="40%"><a id="AF_IPX"></a><a id="af_ipx"></a><dl> <dt><b>AF_IPX</b></dt>
///         <dt>6</dt> </dl> </td> <td width="60%"> The IPX/SPX address family. This address family is only supported if the
///         NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed. This address family is not supported on
///         Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl>
///         <dt><b>AF_APPLETALK</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> The AppleTalk address family. This address
///         family is only supported if the AppleTalk protocol is installed. This address family is not supported on Windows
///         Vista and later. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl>
///         <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address family. This address
///         family is only supported if the Windows Sockets provider for NetBIOS is installed. The Windows Sockets provider
///         for NetBIOS is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions
///         of Windows. The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including
///         Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP. The Windows Sockets provider
///         for NetBIOS only supports sockets where the <i>type</i> parameter is set to <b>SOCK_DGRAM</b>. The Windows
///         Sockets provider for NetBIOS is not directly related to the NetBIOS programming interface. The NetBIOS
///         programming interface is not supported on Windows Vista, Windows Server 2008, and later. </td> </tr> <tr> <td
///         width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl> </td> <td
///         width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
///         id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
///         Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
///         infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
///         <dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
///         is supported on Windows XP with SP2 or later if the computer has a Bluetooth adapter and driver installed. </td>
///         </tr> </table>
///    type = The type specification for the new socket. Possible values for the socket type are defined in the
///           <i>Winsock2.h</i> header file. The following table lists the possible values for the <i>type</i> parameter
///           supported for Windows Sockets 2: <table> <tr> <th>Type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///           id="SOCK_STREAM"></a><a id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td
///           width="60%"> A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB
///           data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet
///           address family (AF_INET or AF_INET6). </td> </tr> <tr> <td width="40%"><a id="SOCK_DGRAM"></a><a
///           id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> A socket type that
///           supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.
///           This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
///           </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl> <dt><b>SOCK_RAW</b></dt>
///           <dt>3</dt> </dl> </td> <td width="60%"> A socket type that provides a raw socket that allows an application to
///           manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option must
///           be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the socket.
///           </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt>
///           <dt>4</dt> </dl> </td> <td width="60%"> A socket type that provides a reliable message datagram. An example of
///           this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred
///           to as reliable multicast programming. This <i>type</i> value is only supported if the Reliable Multicast Protocol
///           is installed. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
///           <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> A socket type that provides a
///           pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
///           introduced. An application can dynamically discover the attributes of each available transport protocol through
///           the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
///           an address family and use this information when specifying this parameter. Socket type definitions in the
///           <i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
///           families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are <b>SOCK_DGRAM</b>
///           and <b>SOCK_STREAM</b>.
///    protocol = The protocol to be used. The possible options for the <i>protocol</i> parameter are specific to the address
///               family and socket type specified. Possible values for the <i>protocol</i> are defined are defined in the
///               <i>Winsock2.h</i> and <i>Wsrm.h</i> header files. On the Windows SDK released for Windows Vista and later,, the
///               organization of header files has changed and this parameter can be one of the values from the <b>IPPROTO</b>
///               enumeration type defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is
///               automatically included in <i>Winsock2.h</i>, and should never be used directly. If a value of 0 is specified, the
///               caller does not wish to specify a protocol and the service provider will choose the <i>protocol</i> to use. When
///               the <i>af</i> parameter is AF_INET or AF_INET6 and the <i>type</i> is <b>SOCK_RAW</b>, the value specified for
///               the <i>protocol</i> is set in the protocol field of the IPv6 or IPv4 packet header. The table below lists common
///               values for the <i>protocol</i> although many other values are possible. <table> <tr> <th>protocol</th>
///               <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
///               <dt><b>IPPROTO_ICMP</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The Internet Control Message Protocol
///               (ICMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or
///               <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified. This <i>protocol</i> value is
///               supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_IGMP"></a><a
///               id="ipproto_igmp"></a><dl> <dt><b>IPPROTO_IGMP</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet
///               Group Management Protocol (IGMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>,
///               <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified. This
///               <i>protocol</i> value is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
///               id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl> <dt><b>BTHPROTO_RFCOMM</b></dt> <dt>3</dt> </dl> </td>
///               <td width="60%"> The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible
///               value when the <i>af</i> parameter is <b>AF_BTH</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. This
///               <i>protocol</i> value is supported on Windows XP with SP2 or later. </td> </tr> <tr> <td width="40%"><a
///               id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl> </td> <td
///               width="60%"> The Transmission Control Protocol (TCP). This is a possible value when the <i>af</i> parameter is
///               <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. </td> </tr> <tr> <td
///               width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl>
///               </td> <td width="60%"> The User Datagram Protocol (UDP). This is a possible value when the <i>af</i> parameter is
///               <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td
///               width="40%"><a id="IPPROTO_ICMPV6"></a><a id="ipproto_icmpv6"></a><dl> <dt><b>IPPROTO_ICMPV6</b></dt> <dt>58</dt>
///               </dl> </td> <td width="60%"> The Internet Control Message Protocol Version 6 (ICMPv6). This is a possible value
///               when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i>
///               parameter is <b>SOCK_RAW</b> or unspecified. This <i>protocol</i> value is supported on Windows XP and later.
///               </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt>
///               <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol for reliable multicast. This is a possible value when
///               the <i>af</i> parameter is <b>AF_INET</b> and the <i>type</i> parameter is <b>SOCK_RDM</b>. On the Windows SDK
///               released for Windows Vista and later, this protocol is also called <b>IPPROTO_PGM</b>. This <i>protocol</i> value
///               is only supported if the Reliable Multicast Protocol is installed. </td> </tr> </table>
///    lpProtocolInfo = A pointer to a WSAPROTOCOL_INFO structure that defines the characteristics of the socket to be created. If this
///                     parameter is not <b>NULL</b>, the socket will be bound to the provider associated with the indicated
///                     <b>WSAPROTOCOL_INFO</b> structure.
///    g = An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group.
///        If <i>g</i> is an existing socket group ID, join the new socket to this socket group, provided all the
///        requirements set by this group are met. If <i>g</i> is not an existing socket group ID, then the following values
///        are possible. <table> <tr> <th>g</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl>
///        <dt><b></b></dt> <dt>0</dt> </dl> </td> <td width="60%"> No group operation is performed. </td> </tr> <tr> <td
///        width="40%"><a id="SG_UNCONSTRAINED_GROUP"></a><a id="sg_unconstrained_group"></a><dl>
///        <dt><b>SG_UNCONSTRAINED_GROUP</b></dt> <dt>0x01</dt> </dl> </td> <td width="60%"> Create an unconstrained socket
///        group and have the new socket be the first member. For an unconstrained group, Winsock does not constrain all
///        sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i>
///        parameters. </td> </tr> <tr> <td width="40%"><a id="SG_CONSTRAINED_GROUP"></a><a
///        id="sg_constrained_group"></a><dl> <dt><b>SG_CONSTRAINED_GROUP</b></dt> <dt>0x02</dt> </dl> </td> <td
///        width="60%"> Create a constrained socket group and have the new socket be the first member. For a contrained
///        socket group, Winsock constrains all sockets in the socket group to have been created with the same value for the
///        <i>type</i> and <i>protocol</i> parameters. A constrained socket group may consist only of connection-oriented
///        sockets, and requires that connections on all grouped sockets be to the same address on the same host. </td>
///        </tr> </table> <div class="alert"><b>Note</b> The SG_UNCONSTRAINED_GROUP and SG_CONSTRAINED_GROUP constants are
///        not currently defined in a public header file.</div> <div> </div>
///    dwFlags = A set of flags used to specify additional socket attributes. A combination of these flags may be set, although
///              some combinations are not allowed. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="WSA_FLAG_OVERLAPPED"></a><a id="wsa_flag_overlapped"></a><dl> <dt><b>WSA_FLAG_OVERLAPPED</b></dt>
///              <dt>0x01</dt> </dl> </td> <td width="60%"> Create a socket that supports overlapped I/O operations. Most sockets
///              should be created with this flag set. Overlapped sockets can utilize WSASend, WSASendTo, WSARecv, WSARecvFrom,
///              and WSAIoctl for overlapped I/O operations, which allow multiple operations to be initiated and in progress
///              simultaneously. All functions that allow overlapped operation (WSASend, WSARecv, WSASendTo, WSARecvFrom,
///              WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values for parameters related to
///              overlapped operations are <b>NULL</b>. </td> </tr> <tr> <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_ROOT"></a><a
///              id="wsa_flag_multipoint_c_root"></a><dl> <dt><b>WSA_FLAG_MULTIPOINT_C_ROOT</b></dt> <dt>0x02</dt> </dl> </td> <td
///              width="60%"> Create a socket that will be a c_root in a multipoint session. This attribute is only allowed if the
///              WSAPROTOCOL_INFO structure for the transport provider that creates the socket supports a multipoint or multicast
///              mechanism and the control plane for a multipoint session is rooted. This would be indicated by the
///              <b>dwServiceFlags1</b> member of the <b>WSAPROTOCOL_INFO</b> structure with the <b>XP1_SUPPORT_MULTIPOINT</b> and
///              <b>XP1_MULTIPOINT_CONTROL_PLANE</b> flags set. When the <i>lpProtocolInfo</i> parameter is not NULL, the
///              WSAPROTOCOL_INFO structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter. When
///              the <i>lpProtocolInfo</i> parameter is NULL, the <b>WSAPROTOCOL_INFO</b> structure is based on the transport
///              provider selected by the values specified for the <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. Refer
///              to Multipoint and Multicast Semantics for additional information on a multipoint session. </td> </tr> <tr> <td
///              width="40%"><a id="WSA_FLAG_MULTIPOINT_C_LEAF"></a><a id="wsa_flag_multipoint_c_leaf"></a><dl>
///              <dt><b>WSA_FLAG_MULTIPOINT_C_LEAF</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> Create a socket that will
///              be a c_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the
///              transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for
///              a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> member of the
///              <b>WSAPROTOCOL_INFO</b> structure with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the
///              <b>XP1_MULTIPOINT_CONTROL_PLANE</b> flag not set. When the <i>lpProtocolInfo</i> parameter is not NULL, the
///              WSAPROTOCOL_INFO structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter. When
///              the <i>lpProtocolInfo</i> parameter is NULL, the <b>WSAPROTOCOL_INFO</b> structure is based on the transport
///              provider selected by the values specified for the <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. Refer
///              to Multipoint and Multicast Semantics for additional information on a multipoint session. </td> </tr> <tr> <td
///              width="40%"><a id="WSA_FLAG_MULTIPOINT_D_ROOT"></a><a id="wsa_flag_multipoint_d_root"></a><dl>
///              <dt><b>WSA_FLAG_MULTIPOINT_D_ROOT</b></dt> <dt>0x08</dt> </dl> </td> <td width="60%"> Create a socket that will
///              be a d_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the
///              transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a
///              multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> member of the
///              <b>WSAPROTOCOL_INFO</b> structure with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_DATA_PLANE</b>
///              flags set. When the <i>lpProtocolInfo</i> parameter is not NULL, the WSAPROTOCOL_INFO structure for the transport
///              provider is pointed to by the <i>lpProtocolInfo</i> parameter. When the <i>lpProtocolInfo</i> parameter is NULL,
///              the <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the
///              <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. Refer to Multipoint and Multicast Semantics for
///              additional information on a multipoint session. </td> </tr> <tr> <td width="40%"><a
///              id="WSA_FLAG_MULTIPOINT_D_LEAF"></a><a id="wsa_flag_multipoint_d_leaf"></a><dl>
///              <dt><b>WSA_FLAG_MULTIPOINT_D_LEAF</b></dt> <dt>0x10</dt> </dl> </td> <td width="60%"> Create a socket that will
///              be a d_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the
///              transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a
///              multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> member of the
///              <b>WSAPROTOCOL_INFO</b> structure with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the
///              <b>XP1_MULTIPOINT_DATA_PLANE</b> flag not set. When the <i>lpProtocolInfo</i> parameter is not NULL, the
///              WSAPROTOCOL_INFO structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter. When
///              the <i>lpProtocolInfo</i> parameter is NULL, the <b>WSAPROTOCOL_INFO</b> structure is based on the transport
///              provider selected by the values specified for the <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. Refer
///              to Multipoint and Multicast Semantics for additional information on a multipoint session. </td> </tr> <tr> <td
///              width="40%"><a id="WSA_FLAG_ACCESS_SYSTEM_SECURITY"></a><a id="wsa_flag_access_system_security"></a><dl>
///              <dt><b>WSA_FLAG_ACCESS_SYSTEM_SECURITY</b></dt> <dt>0x40</dt> </dl> </td> <td width="60%"> Create a socket that
///              allows the the ability to set a security descriptor on the socket that contains a security access control list
///              (SACL) as opposed to just a discretionary access control list (DACL). SACLs are used for generating audits and
///              alarms when an access check occurs on the object. For a socket, an access check occurs to determine whether the
///              socket should be allowed to bind to a specific address specified to the bind function. The
///              <b>ACCESS_SYSTEM_SECURITY</b> access right controls the ability to get or set the SACL in an object's security
///              descriptor. The system grants this access right only if the <b>SE_SECURITY_NAME</b> privilege is enabled in the
///              access token of the requesting thread. </td> </tr> <tr> <td width="40%"><a id="WSA_FLAG_NO_HANDLE_INHERIT"></a><a
///              id="wsa_flag_no_handle_inherit"></a><dl> <dt><b>WSA_FLAG_NO_HANDLE_INHERIT</b></dt> <dt>0x80</dt> </dl> </td> <td
///              width="60%"> Create a socket that is non-inheritable. A socket handle created by the <b>WSASocket</b> or the
///              socket function is inheritable by default. When this flag is set, the socket handle is non-inheritable. The
///              GetHandleInformation function can be used to determine if a socket handle was created with the
///              <b>WSA_FLAG_NO_HANDLE_INHERIT</b> flag set. The <b>GetHandleInformation</b> function will return that the
///              <b>HANDLE_FLAG_INHERIT</b> value is set. This flag is supported on Windows 7 with SP1, Windows Server 2008 R2
///              with SP1, and later </td> </tr> </table> <div class="alert"><b>Important</b> For multipoint sockets, only one of
///              <b>WSA_FLAG_MULTIPOINT_C_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_C_LEAF</b> flags can be specified, and only one of
///              <b>WSA_FLAG_MULTIPOINT_D_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_D_LEAF</b> flags can be specified. Refer to
///              Multipoint and Multicast Semantics for additional information.</div> <div> </div>
///Returns:
///    If no error occurs, <b>WSASocket</b> returns a descriptor referencing the new socket. Otherwise, a value of
///    INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError. <div
///    class="alert"><b>Note</b> This error code description is Microsoft-specific.</div> <div> </div> <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified
///    address family is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpProtocolInfo</i> parameter is not in a valid part of the process address space. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets
///    1.1 call is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> This value is true for any of the
///    following conditions. <ul> <li>The parameter <i>g</i> specified is not valid.</li> <li>The WSAPROTOCOL_INFO
///    structure that <i>lpProtocolInfo</i> points to is incomplete, the contents are invalid or the
///    <b>WSAPROTOCOL_INFO</b> structure has already been used in an earlier duplicate socket operation.</li> <li>The
///    values specified for members of the socket triple &lt;<i>af</i>, <i>type</i>, and <i>protocol</i>&gt; are
///    individually supported, but the given combination is not.</li> </ul> </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVALIDPROVIDER</b></dt> </dl> </td> <td width="60%"> The service provider returned a version other
///    than 2.2. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVALIDPROCTABLE</b></dt> </dl> </td> <td
///    width="60%"> The service provider returned an invalid or incomplete procedure table to the WSPStartup. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMFILE</b></dt> </dl> </td> <td width="60%"> No more socket
///    descriptors are available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td
///    width="60%"> No buffer space is available. The socket cannot be created. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEPROTONOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified protocol is not supported. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEPROTOTYPE</b></dt> </dl> </td> <td width="60%"> The specified
///    protocol is the wrong type for this socket. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEPROVIDERFAILEDINIT</b></dt> </dl> </td> <td width="60%"> The service provider failed to initialize.
///    This error is returned if a layered service provider (LSP) or namespace provider was improperly installed or the
///    provider fails to operate correctly. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESOCKTNOSUPPORT</b></dt>
///    </dl> </td> <td width="60%"> The specified socket type is not supported in this address family. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
size_t WSASocketA(int af, int type, int protocol, WSAPROTOCOL_INFOA* lpProtocolInfo, uint g, uint dwFlags);

///The <b>WSASocket</b> function creates a socket that is bound to a specific transport-service provider.
///Params:
///    af = The address family specification. Possible values for the address family are defined in the <i>Winsock2.h</i>
///         header file. On the Windows SDK released for Windows Vista and later, the organization of header files has
///         changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that
///         the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
///         directly. The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats
///         for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported
///         if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_
///         address family and PF_ protocol family constants are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>),
///         so either constant can be used. The table below lists common values for address family although many other values
///         are possible. <table> <tr> <th>Af</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="AF_UNSPEC"></a><a
///         id="af_unspec"></a><dl> <dt><b>AF_UNSPEC</b></dt> <dt>0</dt> </dl> </td> <td width="60%"> The address family is
///         unspecified. </td> </tr> <tr> <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
///         <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet Protocol version 4 (IPv4) address
///         family. </td> </tr> <tr> <td width="40%"><a id="AF_IPX"></a><a id="af_ipx"></a><dl> <dt><b>AF_IPX</b></dt>
///         <dt>6</dt> </dl> </td> <td width="60%"> The IPX/SPX address family. This address family is only supported if the
///         NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed. This address family is not supported on
///         Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl>
///         <dt><b>AF_APPLETALK</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> The AppleTalk address family. This address
///         family is only supported if the AppleTalk protocol is installed. This address family is not supported on Windows
///         Vista and later. </td> </tr> <tr> <td width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl>
///         <dt><b>AF_NETBIOS</b></dt> <dt>17</dt> </dl> </td> <td width="60%"> The NetBIOS address family. This address
///         family is only supported if the Windows Sockets provider for NetBIOS is installed. The Windows Sockets provider
///         for NetBIOS is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions
///         of Windows. The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including
///         Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP. The Windows Sockets provider
///         for NetBIOS only supports sockets where the <i>type</i> parameter is set to <b>SOCK_DGRAM</b>. The Windows
///         Sockets provider for NetBIOS is not directly related to the NetBIOS programming interface. The NetBIOS
///         programming interface is not supported on Windows Vista, Windows Server 2008, and later. </td> </tr> <tr> <td
///         width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl> </td> <td
///         width="60%"> The Internet Protocol version 6 (IPv6) address family. </td> </tr> <tr> <td width="40%"><a
///         id="AF_IRDA"></a><a id="af_irda"></a><dl> <dt><b>AF_IRDA</b></dt> <dt>26</dt> </dl> </td> <td width="60%"> The
///         Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an
///         infrared port and driver installed. </td> </tr> <tr> <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
///         <dt><b>AF_BTH</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The Bluetooth address family. This address family
///         is supported on Windows XP with SP2 or later if the computer has a Bluetooth adapter and driver installed. </td>
///         </tr> </table>
///    type = The type specification for the new socket. Possible values for the socket type are defined in the
///           <i>Winsock2.h</i> header file. The following table lists the possible values for the <i>type</i> parameter
///           supported for Windows Sockets 2: <table> <tr> <th>Type</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///           id="SOCK_STREAM"></a><a id="sock_stream"></a><dl> <dt><b>SOCK_STREAM</b></dt> <dt>1</dt> </dl> </td> <td
///           width="60%"> A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB
///           data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet
///           address family (AF_INET or AF_INET6). </td> </tr> <tr> <td width="40%"><a id="SOCK_DGRAM"></a><a
///           id="sock_dgram"></a><dl> <dt><b>SOCK_DGRAM</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> A socket type that
///           supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.
///           This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
///           </td> </tr> <tr> <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl> <dt><b>SOCK_RAW</b></dt>
///           <dt>3</dt> </dl> </td> <td width="60%"> A socket type that provides a raw socket that allows an application to
///           manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the IP_HDRINCL socket option must
///           be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket option must be set on the socket.
///           </td> </tr> <tr> <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl> <dt><b>SOCK_RDM</b></dt>
///           <dt>4</dt> </dl> </td> <td width="60%"> A socket type that provides a reliable message datagram. An example of
///           this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred
///           to as reliable multicast programming. This <i>type</i> value is only supported if the Reliable Multicast Protocol
///           is installed. </td> </tr> <tr> <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
///           <dt><b>SOCK_SEQPACKET</b></dt> <dt>5</dt> </dl> </td> <td width="60%"> A socket type that provides a
///           pseudo-stream packet based on datagrams. </td> </tr> </table> In Windows Sockets 2, new socket types were
///           introduced. An application can dynamically discover the attributes of each available transport protocol through
///           the WSAEnumProtocols function. So an application can determine the possible socket type and protocol options for
///           an address family and use this information when specifying this parameter. Socket type definitions in the
///           <i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address
///           families, and protocols are defined. In Windows Sockets 1.1, the only possible socket types are <b>SOCK_DGRAM</b>
///           and <b>SOCK_STREAM</b>.
///    protocol = The protocol to be used. The possible options for the <i>protocol</i> parameter are specific to the address
///               family and socket type specified. Possible values for the <i>protocol</i> are defined are defined in the
///               <i>Winsock2.h</i> and <i>Wsrm.h</i> header files. On the Windows SDK released for Windows Vista and later,, the
///               organization of header files has changed and this parameter can be one of the values from the <b>IPPROTO</b>
///               enumeration type defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is
///               automatically included in <i>Winsock2.h</i>, and should never be used directly. If a value of 0 is specified, the
///               caller does not wish to specify a protocol and the service provider will choose the <i>protocol</i> to use. When
///               the <i>af</i> parameter is AF_INET or AF_INET6 and the <i>type</i> is <b>SOCK_RAW</b>, the value specified for
///               the <i>protocol</i> is set in the protocol field of the IPv6 or IPv4 packet header. The table below lists common
///               values for the <i>protocol</i> although many other values are possible. <table> <tr> <th>protocol</th>
///               <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
///               <dt><b>IPPROTO_ICMP</b></dt> <dt>1</dt> </dl> </td> <td width="60%"> The Internet Control Message Protocol
///               (ICMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or
///               <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified. This <i>protocol</i> value is
///               supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a id="IPPROTO_IGMP"></a><a
///               id="ipproto_igmp"></a><dl> <dt><b>IPPROTO_IGMP</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The Internet
///               Group Management Protocol (IGMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>,
///               <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified. This
///               <i>protocol</i> value is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
///               id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl> <dt><b>BTHPROTO_RFCOMM</b></dt> <dt>3</dt> </dl> </td>
///               <td width="60%"> The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible
///               value when the <i>af</i> parameter is <b>AF_BTH</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. This
///               <i>protocol</i> value is supported on Windows XP with SP2 or later. </td> </tr> <tr> <td width="40%"><a
///               id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> <dt>6</dt> </dl> </td> <td
///               width="60%"> The Transmission Control Protocol (TCP). This is a possible value when the <i>af</i> parameter is
///               <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. </td> </tr> <tr> <td
///               width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> <dt>17</dt> </dl>
///               </td> <td width="60%"> The User Datagram Protocol (UDP). This is a possible value when the <i>af</i> parameter is
///               <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_DGRAM</b>. </td> </tr> <tr> <td
///               width="40%"><a id="IPPROTO_ICMPV6"></a><a id="ipproto_icmpv6"></a><dl> <dt><b>IPPROTO_ICMPV6</b></dt> <dt>58</dt>
///               </dl> </td> <td width="60%"> The Internet Control Message Protocol Version 6 (ICMPv6). This is a possible value
///               when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i>
///               parameter is <b>SOCK_RAW</b> or unspecified. This <i>protocol</i> value is supported on Windows XP and later.
///               </td> </tr> <tr> <td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl> <dt><b>IPPROTO_RM</b></dt>
///               <dt>113</dt> </dl> </td> <td width="60%"> The PGM protocol for reliable multicast. This is a possible value when
///               the <i>af</i> parameter is <b>AF_INET</b> and the <i>type</i> parameter is <b>SOCK_RDM</b>. On the Windows SDK
///               released for Windows Vista and later, this protocol is also called <b>IPPROTO_PGM</b>. This <i>protocol</i> value
///               is only supported if the Reliable Multicast Protocol is installed. </td> </tr> </table>
///    lpProtocolInfo = A pointer to a WSAPROTOCOL_INFO structure that defines the characteristics of the socket to be created. If this
///                     parameter is not <b>NULL</b>, the socket will be bound to the provider associated with the indicated
///                     <b>WSAPROTOCOL_INFO</b> structure.
///    g = An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group.
///        If <i>g</i> is an existing socket group ID, join the new socket to this socket group, provided all the
///        requirements set by this group are met. If <i>g</i> is not an existing socket group ID, then the following values
///        are possible. <table> <tr> <th>g</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id=""></a><dl>
///        <dt><b></b></dt> <dt>0</dt> </dl> </td> <td width="60%"> No group operation is performed. </td> </tr> <tr> <td
///        width="40%"><a id="SG_UNCONSTRAINED_GROUP"></a><a id="sg_unconstrained_group"></a><dl>
///        <dt><b>SG_UNCONSTRAINED_GROUP</b></dt> <dt>0x01</dt> </dl> </td> <td width="60%"> Create an unconstrained socket
///        group and have the new socket be the first member. For an unconstrained group, Winsock does not constrain all
///        sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i>
///        parameters. </td> </tr> <tr> <td width="40%"><a id="SG_CONSTRAINED_GROUP"></a><a
///        id="sg_constrained_group"></a><dl> <dt><b>SG_CONSTRAINED_GROUP</b></dt> <dt>0x02</dt> </dl> </td> <td
///        width="60%"> Create a constrained socket group and have the new socket be the first member. For a contrained
///        socket group, Winsock constrains all sockets in the socket group to have been created with the same value for the
///        <i>type</i> and <i>protocol</i> parameters. A constrained socket group may consist only of connection-oriented
///        sockets, and requires that connections on all grouped sockets be to the same address on the same host. </td>
///        </tr> </table> <div class="alert"><b>Note</b> The SG_UNCONSTRAINED_GROUP and SG_CONSTRAINED_GROUP constants are
///        not currently defined in a public header file.</div> <div> </div>
///    dwFlags = A set of flags used to specify additional socket attributes. A combination of these flags may be set, although
///              some combinations are not allowed. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///              id="WSA_FLAG_OVERLAPPED"></a><a id="wsa_flag_overlapped"></a><dl> <dt><b>WSA_FLAG_OVERLAPPED</b></dt>
///              <dt>0x01</dt> </dl> </td> <td width="60%"> Create a socket that supports overlapped I/O operations. Most sockets
///              should be created with this flag set. Overlapped sockets can utilize WSASend, WSASendTo, WSARecv, WSARecvFrom,
///              and WSAIoctl for overlapped I/O operations, which allow multiple operations to be initiated and in progress
///              simultaneously. All functions that allow overlapped operation (WSASend, WSARecv, WSASendTo, WSARecvFrom,
///              WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values for parameters related to
///              overlapped operations are <b>NULL</b>. </td> </tr> <tr> <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_ROOT"></a><a
///              id="wsa_flag_multipoint_c_root"></a><dl> <dt><b>WSA_FLAG_MULTIPOINT_C_ROOT</b></dt> <dt>0x02</dt> </dl> </td> <td
///              width="60%"> Create a socket that will be a c_root in a multipoint session. This attribute is only allowed if the
///              WSAPROTOCOL_INFO structure for the transport provider that creates the socket supports a multipoint or multicast
///              mechanism and the control plane for a multipoint session is rooted. This would be indicated by the
///              <b>dwServiceFlags1</b> member of the <b>WSAPROTOCOL_INFO</b> structure with the <b>XP1_SUPPORT_MULTIPOINT</b> and
///              <b>XP1_MULTIPOINT_CONTROL_PLANE</b> flags set. When the <i>lpProtocolInfo</i> parameter is not NULL, the
///              WSAPROTOCOL_INFO structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter. When
///              the <i>lpProtocolInfo</i> parameter is NULL, the <b>WSAPROTOCOL_INFO</b> structure is based on the transport
///              provider selected by the values specified for the <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. Refer
///              to Multipoint and Multicast Semantics for additional information on a multipoint session. </td> </tr> <tr> <td
///              width="40%"><a id="WSA_FLAG_MULTIPOINT_C_LEAF"></a><a id="wsa_flag_multipoint_c_leaf"></a><dl>
///              <dt><b>WSA_FLAG_MULTIPOINT_C_LEAF</b></dt> <dt>0x04</dt> </dl> </td> <td width="60%"> Create a socket that will
///              be a c_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the
///              transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for
///              a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> member of the
///              <b>WSAPROTOCOL_INFO</b> structure with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the
///              <b>XP1_MULTIPOINT_CONTROL_PLANE</b> flag not set. When the <i>lpProtocolInfo</i> parameter is not NULL, the
///              WSAPROTOCOL_INFO structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter. When
///              the <i>lpProtocolInfo</i> parameter is NULL, the <b>WSAPROTOCOL_INFO</b> structure is based on the transport
///              provider selected by the values specified for the <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. Refer
///              to Multipoint and Multicast Semantics for additional information on a multipoint session. </td> </tr> <tr> <td
///              width="40%"><a id="WSA_FLAG_MULTIPOINT_D_ROOT"></a><a id="wsa_flag_multipoint_d_root"></a><dl>
///              <dt><b>WSA_FLAG_MULTIPOINT_D_ROOT</b></dt> <dt>0x08</dt> </dl> </td> <td width="60%"> Create a socket that will
///              be a d_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the
///              transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a
///              multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> member of the
///              <b>WSAPROTOCOL_INFO</b> structure with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_DATA_PLANE</b>
///              flags set. When the <i>lpProtocolInfo</i> parameter is not NULL, the WSAPROTOCOL_INFO structure for the transport
///              provider is pointed to by the <i>lpProtocolInfo</i> parameter. When the <i>lpProtocolInfo</i> parameter is NULL,
///              the <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the
///              <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. Refer to Multipoint and Multicast Semantics for
///              additional information on a multipoint session. </td> </tr> <tr> <td width="40%"><a
///              id="WSA_FLAG_MULTIPOINT_D_LEAF"></a><a id="wsa_flag_multipoint_d_leaf"></a><dl>
///              <dt><b>WSA_FLAG_MULTIPOINT_D_LEAF</b></dt> <dt>0x10</dt> </dl> </td> <td width="60%"> Create a socket that will
///              be a d_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure for the
///              transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a
///              multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> member of the
///              <b>WSAPROTOCOL_INFO</b> structure with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the
///              <b>XP1_MULTIPOINT_DATA_PLANE</b> flag not set. When the <i>lpProtocolInfo</i> parameter is not NULL, the
///              WSAPROTOCOL_INFO structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter. When
///              the <i>lpProtocolInfo</i> parameter is NULL, the <b>WSAPROTOCOL_INFO</b> structure is based on the transport
///              provider selected by the values specified for the <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. Refer
///              to Multipoint and Multicast Semantics for additional information on a multipoint session. </td> </tr> <tr> <td
///              width="40%"><a id="WSA_FLAG_ACCESS_SYSTEM_SECURITY"></a><a id="wsa_flag_access_system_security"></a><dl>
///              <dt><b>WSA_FLAG_ACCESS_SYSTEM_SECURITY</b></dt> <dt>0x40</dt> </dl> </td> <td width="60%"> Create a socket that
///              allows the the ability to set a security descriptor on the socket that contains a security access control list
///              (SACL) as opposed to just a discretionary access control list (DACL). SACLs are used for generating audits and
///              alarms when an access check occurs on the object. For a socket, an access check occurs to determine whether the
///              socket should be allowed to bind to a specific address specified to the bind function. The
///              <b>ACCESS_SYSTEM_SECURITY</b> access right controls the ability to get or set the SACL in an object's security
///              descriptor. The system grants this access right only if the <b>SE_SECURITY_NAME</b> privilege is enabled in the
///              access token of the requesting thread. </td> </tr> <tr> <td width="40%"><a id="WSA_FLAG_NO_HANDLE_INHERIT"></a><a
///              id="wsa_flag_no_handle_inherit"></a><dl> <dt><b>WSA_FLAG_NO_HANDLE_INHERIT</b></dt> <dt>0x80</dt> </dl> </td> <td
///              width="60%"> Create a socket that is non-inheritable. A socket handle created by the <b>WSASocket</b> or the
///              socket function is inheritable by default. When this flag is set, the socket handle is non-inheritable. The
///              GetHandleInformation function can be used to determine if a socket handle was created with the
///              <b>WSA_FLAG_NO_HANDLE_INHERIT</b> flag set. The <b>GetHandleInformation</b> function will return that the
///              <b>HANDLE_FLAG_INHERIT</b> value is set. This flag is supported on Windows 7 with SP1, Windows Server 2008 R2
///              with SP1, and later </td> </tr> </table> <div class="alert"><b>Important</b> For multipoint sockets, only one of
///              <b>WSA_FLAG_MULTIPOINT_C_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_C_LEAF</b> flags can be specified, and only one of
///              <b>WSA_FLAG_MULTIPOINT_D_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_D_LEAF</b> flags can be specified. Refer to
///              Multipoint and Multicast Semantics for additional information.</div> <div> </div>
///Returns:
///    If no error occurs, <b>WSASocket</b> returns a descriptor referencing the new socket. Otherwise, a value of
///    INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError. <div
///    class="alert"><b>Note</b> This error code description is Microsoft-specific.</div> <div> </div> <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> A successful WSAStartup call must occur before using this function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The network subsystem has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified
///    address family is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpProtocolInfo</i> parameter is not in a valid part of the process address space. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking Windows Sockets
///    1.1 call is in progress, or the service provider is still processing a callback function. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> This value is true for any of the
///    following conditions. <ul> <li>The parameter <i>g</i> specified is not valid.</li> <li>The WSAPROTOCOL_INFO
///    structure that <i>lpProtocolInfo</i> points to is incomplete, the contents are invalid or the
///    <b>WSAPROTOCOL_INFO</b> structure has already been used in an earlier duplicate socket operation.</li> <li>The
///    values specified for members of the socket triple &lt;<i>af</i>, <i>type</i>, and <i>protocol</i>&gt; are
///    individually supported, but the given combination is not.</li> </ul> </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVALIDPROVIDER</b></dt> </dl> </td> <td width="60%"> The service provider returned a version other
///    than 2.2. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVALIDPROCTABLE</b></dt> </dl> </td> <td
///    width="60%"> The service provider returned an invalid or incomplete procedure table to the WSPStartup. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMFILE</b></dt> </dl> </td> <td width="60%"> No more socket
///    descriptors are available. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td
///    width="60%"> No buffer space is available. The socket cannot be created. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEPROTONOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified protocol is not supported. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEPROTOTYPE</b></dt> </dl> </td> <td width="60%"> The specified
///    protocol is the wrong type for this socket. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEPROVIDERFAILEDINIT</b></dt> </dl> </td> <td width="60%"> The service provider failed to initialize.
///    This error is returned if a layered service provider (LSP) or namespace provider was improperly installed or the
///    provider fails to operate correctly. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESOCKTNOSUPPORT</b></dt>
///    </dl> </td> <td width="60%"> The specified socket type is not supported in this address family. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
size_t WSASocketW(int af, int type, int protocol, WSAPROTOCOL_INFOW* lpProtocolInfo, uint g, uint dwFlags);

///The <b>WSAWaitForMultipleEvents</b> function returns when one or all of the specified event objects are in the
///signaled state, when the time-out interval expires, or when an I/O completion routine has executed.
///Params:
///    cEvents = The number of event object handles in the array pointed to by <i>lphEvents</i>. The maximum number of event
///              object handles is <b>WSA_MAXIMUM_WAIT_EVENTS</b>. One or more events must be specified.
///    lphEvents = A pointer to an array of event object handles. The array can contain handles of objects of different types. It
///                may not contain multiple copies of the same handle if the <i>fWaitAll</i> parameter is set to <b>TRUE</b>. If one
///                of these handles is closed while the wait is still pending, the behavior of <b>WSAWaitForMultipleEvents</b> is
///                undefined. The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see Standard Access
///                Rights.
///    fWaitAll = A value that specifies the wait type. If <b>TRUE</b>, the function returns when the state of all objects in the
///               <i>lphEvents</i> array is signaled. If <b>FALSE</b>, the function returns when any of the event objects is
///               signaled. In the latter case, the return value minus <b>WSA_WAIT_EVENT_0</b> indicates the index of the event
///               object whose state caused the function to return. If more than one event object became signaled during the call,
///               this is the array index to the signaled event object with the smallest index value of all the signaled event
///               objects.
///    dwTimeout = The time-out interval, in milliseconds. <b>WSAWaitForMultipleEvents</b> returns if the time-out interval expires,
///                even if conditions specified by the <i>fWaitAll</i> parameter are not satisfied. If the <i>dwTimeout</i>
///                parameter is zero, <b>WSAWaitForMultipleEvents</b> tests the state of the specified event objects and returns
///                immediately. If <i>dwTimeout</i> is <b>WSA_INFINITE</b>, <b>WSAWaitForMultipleEvents</b> waits forever; that is,
///                the time-out interval never expires.
///    fAlertable = A value that specifies whether the thread is placed in an alertable wait state so the system can execute I/O
///                 completion routines. If <b>TRUE</b>, the thread is placed in an alertable wait state and
///                 <b>WSAWaitForMultipleEvents</b> can return when the system executes an I/O completion routine. In this case,
///                 <b>WSA_WAIT_IO_COMPLETION</b> is returned and the event that was being waited on is not signaled yet. The
///                 application must call the <b>WSAWaitForMultipleEvents</b> function again. If <b>FALSE</b>, the thread is not
///                 placed in an alertable wait state and I/O completion routines are not executed.
///Returns:
///    If the <b>WSAWaitForMultipleEvents</b> function succeeds, the return value upon success is one of the following
///    values. <table> <tr> <th>Return Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_WAIT_EVENT_0 to (WSA_WAIT_EVENT_0 + cEvents - 1)</b></dt> </dl> </td> <td width="60%"> If the
///    <i>fWaitAll</i> parameter is <b>TRUE</b>, the return value indicates that all specified event objects is
///    signaled. If the <i>fWaitAll</i> parameter is <b>FALSE</b>, the return value minus <b>WSA_WAIT_EVENT_0</b>
///    indicates the <i>lphEvents</i> array index of the signaled event object that satisfied the wait. If more than one
///    event object became signaled during the call, the return value indicates the <i>lphEvents</i> array index of the
///    signaled event object with the smallest index value of all the signaled event objects. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_WAIT_IO_COMPLETION</b></dt> </dl> </td> <td width="60%"> The wait was ended by one
///    or more I/O completion routines that were executed. The event that was being waited on is not signaled yet. The
///    application must call the WSAWaitForMultipleEvents function again. This return value can only be returned if the
///    <i>fAlertable</i> parameter is <b>TRUE</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_WAIT_TIMEOUT</b></dt> </dl> </td> <td width="60%"> The time-out interval elapsed and the conditions
///    specified by the <i>fWaitAll</i> parameter were not satisfied. No I/O completion routines were executed. </td>
///    </tr> </table> If the <b>WSAWaitForMultipleEvents</b> function fails, the return value is <b>WSA_WAIT_FAILED</b>.
///    The following table lists values that can be used with WSAGetLastError to get extended error information. <table>
///    <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td>WSANOTINITIALISED</td> <td>A successful WSAStartup call
///    must occur before using this function.</td> </tr> <tr> <td>WSAENETDOWN</td> <td>The network subsystem has
///    failed.</td> </tr> <tr> <td>WSAEINPROGRESS</td> <td>A blocking Windows Sockets 1.1 call is in progress, or the
///    service provider is still processing a callback function.</td> </tr> <tr> <td>WSA_NOT_ENOUGH_MEMORY</td> <td>Not
///    enough free memory was available to complete the operation.</td> </tr> <tr> <td>WSA_INVALID_HANDLE</td> <td>One
///    or more of the values in the <i>lphEvents</i> array is not a valid event object handle.</td> </tr> <tr>
///    <td>WSA_INVALID_PARAMETER</td> <td>The <i>cEvents</i> parameter does not contain a valid handle count.</td> </tr>
///    </table>
///    
@DllImport("WS2_32")
uint WSAWaitForMultipleEvents(uint cEvents, char* lphEvents, BOOL fWaitAll, uint dwTimeout, BOOL fAlertable);

///The <b>WSAAddressToString</b> function converts all components of a sockaddr structure into a human-readable string
///representation of the address. This is intended to be used mainly for display purposes. If the caller requires that
///the translation to be performed by a particular provider, it should supply the corresponding WSAPROTOCOL_INFO
///structure in the <i>lpProtocolInfo</i> parameter.
///Params:
///    lpsaAddress = A pointer to the sockaddr structure to translate into a string.
///    dwAddressLength = The length, in bytes, of the address in the sockaddr structure pointed to by the <i>lpsaAddress</i> parameter.
///                      The <i>dwAddressLength</i> parameter may vary in size with different protocols.
///    lpProtocolInfo = A pointer to the WSAPROTOCOL_INFO structure for a particular provider. If this is parameter is <b>NULL</b>, the
///                     call is routed to the provider of the first protocol supporting the address family indicated in the
///                     <i>lpsaAddress</i> parameter.
///    lpszAddressString = A pointer to the buffer that receives the human-readable address string.
///    lpdwAddressStringLength = On input, this parameter specifies the length of the buffer pointed to by the <i>lpszAddressString</i> parameter.
///                              The length is represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter
///                              returns the length of the string including the <b>NULL</b> terminator actually copied into the buffer pointed to
///                              by the <i>lpszAddressString</i> parameter. If the specified buffer is not large enough, the function fails with a
///                              specific error of WSAEFAULT and this parameter is updated with the required size.
///Returns:
///    If no error occurs, <b>WSAAddressToString</b> returns a value of zero. Otherwise, the value SOCKET_ERROR is
///    returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The specified <i>lpcsAddress</i>, <i>lpProtocolInfo</i>, and <i>lpszAddressString</i> parameters
///    point to memory that is not all in the address space of the process, or the buffer pointed to by the
///    <i>lpszAddressString</i> parameter is too small. Pass in a larger buffer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed. This error is returned if
///    the <i>lpsaAddress</i>, <i>dwAddressLength</i>, or <i>lpdwAddressStringLength</i> parameter are <b>NULL</b>. This
///    error is also returned if the specified address is not a valid socket address, or no transport provider supports
///    the indicated address family. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td
///    width="60%"> No buffer space is available. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The Winsock 2 DLL has not been initialized. The
///    application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAAddressToStringA(char* lpsaAddress, uint dwAddressLength, WSAPROTOCOL_INFOA* lpProtocolInfo, 
                        const(char)* lpszAddressString, uint* lpdwAddressStringLength);

///The <b>WSAAddressToString</b> function converts all components of a sockaddr structure into a human-readable string
///representation of the address. This is intended to be used mainly for display purposes. If the caller requires that
///the translation to be performed by a particular provider, it should supply the corresponding WSAPROTOCOL_INFO
///structure in the <i>lpProtocolInfo</i> parameter.
///Params:
///    lpsaAddress = A pointer to the sockaddr structure to translate into a string.
///    dwAddressLength = The length, in bytes, of the address in the sockaddr structure pointed to by the <i>lpsaAddress</i> parameter.
///                      The <i>dwAddressLength</i> parameter may vary in size with different protocols.
///    lpProtocolInfo = A pointer to the WSAPROTOCOL_INFO structure for a particular provider. If this is parameter is <b>NULL</b>, the
///                     call is routed to the provider of the first protocol supporting the address family indicated in the
///                     <i>lpsaAddress</i> parameter.
///    lpszAddressString = A pointer to the buffer that receives the human-readable address string.
///    lpdwAddressStringLength = On input, this parameter specifies the length of the buffer pointed to by the <i>lpszAddressString</i> parameter.
///                              The length is represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter
///                              returns the length of the string including the <b>NULL</b> terminator actually copied into the buffer pointed to
///                              by the <i>lpszAddressString</i> parameter. If the specified buffer is not large enough, the function fails with a
///                              specific error of WSAEFAULT and this parameter is updated with the required size.
///Returns:
///    If no error occurs, <b>WSAAddressToString</b> returns a value of zero. Otherwise, the value SOCKET_ERROR is
///    returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The specified <i>lpcsAddress</i>, <i>lpProtocolInfo</i>, and <i>lpszAddressString</i> parameters
///    point to memory that is not all in the address space of the process, or the buffer pointed to by the
///    <i>lpszAddressString</i> parameter is too small. Pass in a larger buffer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed. This error is returned if
///    the <i>lpsaAddress</i>, <i>dwAddressLength</i>, or <i>lpdwAddressStringLength</i> parameter are <b>NULL</b>. This
///    error is also returned if the specified address is not a valid socket address, or no transport provider supports
///    the indicated address family. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td
///    width="60%"> No buffer space is available. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The Winsock 2 DLL has not been initialized. The
///    application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAAddressToStringW(char* lpsaAddress, uint dwAddressLength, WSAPROTOCOL_INFOW* lpProtocolInfo, 
                        const(wchar)* lpszAddressString, uint* lpdwAddressStringLength);

///The <b>WSAStringToAddress</b> function converts a network address in its standard text presentation form into its
///numeric binary form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a
///structure.
///Params:
///    AddressString = A pointer to the zero-terminated string that contains the network address in standard text form to convert.
///    AddressFamily = The address family of the network address pointed to by the <i>AddressString</i> parameter.
///    lpProtocolInfo = The WSAPROTOCOL_INFO structure associated with the provider to be used. If this is <b>NULL</b>, the call is
///                     routed to the provider of the first protocol supporting the indicated <i>AddressFamily</i>.
///    lpAddress = A pointer to a buffer that is filled with a sockaddr structure for the address string if the function succeeds.
///    lpAddressLength = A pointer to the length, in bytes, of the buffer pointed to by the <i>lpAddress</i> parameter. If the function
///                      call is successful, this parameter returns a pointer to the size of the sockaddr structure returned in the
///                      <i>lpAddress</i> parameter. If the specified buffer is not large enough, the function fails with a specific error
///                      of WSAEFAULT and this parameter is updated with the required size in bytes.
///Returns:
///    The return value for <b>WSAStringToAddress</b> is zero if the operation was successful. Otherwise, the value
///    SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The buffer pointed to by the <i>lpAddress</i> parameter is too small. Pass in a larger buffer. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The functions was unable
///    to translate the string into a sockaddr. See the following Remarks section for more information. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The WS2_32.DLL has not been
///    initialized. The application must first call WSAStartup before calling any Windows Socket functions. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was
///    insufficient memory to perform the operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAStringToAddressA(const(char)* AddressString, int AddressFamily, WSAPROTOCOL_INFOA* lpProtocolInfo, 
                        char* lpAddress, int* lpAddressLength);

///The <b>WSAStringToAddress</b> function converts a network address in its standard text presentation form into its
///numeric binary form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a
///structure.
///Params:
///    AddressString = A pointer to the zero-terminated string that contains the network address in standard text form to convert.
///    AddressFamily = The address family of the network address pointed to by the <i>AddressString</i> parameter.
///    lpProtocolInfo = The WSAPROTOCOL_INFO structure associated with the provider to be used. If this is <b>NULL</b>, the call is
///                     routed to the provider of the first protocol supporting the indicated <i>AddressFamily</i>.
///    lpAddress = A pointer to a buffer that is filled with a sockaddr structure for the address string if the function succeeds.
///    lpAddressLength = A pointer to the length, in bytes, of the buffer pointed to by the <i>lpAddress</i> parameter. If the function
///                      call is successful, this parameter returns a pointer to the size of the sockaddr structure returned in the
///                      <i>lpAddress</i> parameter. If the specified buffer is not large enough, the function fails with a specific error
///                      of WSAEFAULT and this parameter is updated with the required size in bytes.
///Returns:
///    The return value for <b>WSAStringToAddress</b> is zero if the operation was successful. Otherwise, the value
///    SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The buffer pointed to by the <i>lpAddress</i> parameter is too small. Pass in a larger buffer. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The functions was unable
///    to translate the string into a sockaddr. See the following Remarks section for more information. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The WS2_32.DLL has not been
///    initialized. The application must first call WSAStartup before calling any Windows Socket functions. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was
///    insufficient memory to perform the operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAStringToAddressW(const(wchar)* AddressString, int AddressFamily, WSAPROTOCOL_INFOW* lpProtocolInfo, 
                        char* lpAddress, int* lpAddressLength);

///The <b>WSALookupServiceBegin</b> function initiates a client query that is constrained by the information contained
///within a WSAQUERYSET structure. <b>WSALookupServiceBegin</b> only returns a handle, which should be used by
///subsequent calls to WSALookupServiceNext to get the actual results.
///Params:
///    lpqsRestrictions = A pointer to the search criteria. See the Remarks for details.
///    dwControlFlags = A set of flags that controls the depth of the search. Supported values for the <i>dwControlFlags</i> parameter
///                     are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options. <table> <tr>
///                     <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
///                     <dt><b>LUP_DEEP</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Queries deep as opposed to just the first
///                     level. </td> </tr> <tr> <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
///                     <dt><b>LUP_CONTAINERS</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Returns containers only. </td> </tr>
///                     <tr> <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
///                     <dt><b>LUP_NOCONTAINERS</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Do not return containers. </td>
///                     </tr> <tr> <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl> <dt><b>LUP_NEAREST</b></dt>
///                     <dt>0x0008</dt> </dl> </td> <td width="60%"> If possible, returns results in the order of distance. The measure
///                     of distance is provider specific. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_NAME"></a><a
///                     id="lup_return_name"></a><dl> <dt><b>LUP_RETURN_NAME</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%">
///                     Retrieves the name as <i>lpszServiceInstanceName</i>. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl> <dt><b>LUP_RETURN_TYPE</b></dt> <dt>0x0020</dt> </dl>
///                     </td> <td width="60%"> Retrieves the type as <i>lpServiceClassId</i>. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl> <dt><b>LUP_RETURN_VERSION</b></dt>
///                     <dt>0x0040</dt> </dl> </td> <td width="60%"> Retrieves the version as <i>lpVersion</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl> <dt><b>LUP_RETURN_COMMENT</b></dt>
///                     <dt>0x0080</dt> </dl> </td> <td width="60%"> Retrieves the comment as <i>lpszComment</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl> <dt><b>LUP_RETURN_ADDR</b></dt>
///                     <dt>0x0100</dt> </dl> </td> <td width="60%"> Retrieves the addresses as <i>lpcsaBuffer</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl> <dt><b>LUP_RETURN_BLOB</b></dt>
///                     <dt>0x0200</dt> </dl> </td> <td width="60%"> Retrieves the private data as <i>lpBlob</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl> <dt><b>LUP_RETURN_ALIASES</b></dt>
///                     <dt>0x0400</dt> </dl> </td> <td width="60%"> Any available alias information is to be returned in successive
///                     calls to WSALookupServiceNext, and each alias returned will have the RESULT_IS_ALIAS flag set. </td> </tr> <tr>
///                     <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
///                     <dt><b>LUP_RETURN_QUERY_STRING</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> Retrieves the query string
///                     used for the request. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
///                     <dt><b>LUP_RETURN_ALL</b></dt> <dt>0x0FF0</dt> </dl> </td> <td width="60%"> A set of flags that retrieves all of
///                     the LUP_RETURN_* values. </td> </tr> <tr> <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a
///                     id="lup_flushprevious"></a><dl> <dt><b>LUP_FLUSHPREVIOUS</b></dt> <dt>0x1000</dt> </dl> </td> <td width="60%">
///                     Used as a value for the <i>dwControlFlags</i> parameter in WSALookupServiceNext. Setting this flag instructs the
///                     provider to discard the last result set, which was too large for the specified buffer, and move on to the next
///                     result set. </td> </tr> <tr> <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
///                     <dt><b>LUP_FLUSHCACHE</b></dt> <dt>0x2000</dt> </dl> </td> <td width="60%"> If the provider has been caching
///                     information, ignores the cache, and queries the namespace itself. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl> <dt><b>LUP_RES_SERVICE</b></dt> <dt>0x8000</dt> </dl>
///                     </td> <td width="60%"> This indicates whether prime response is in the remote or local part of CSADDR_INFO
///                     structure. The other part needs to be usable in either case. </td> </tr> </table>
///    lphLookup = A handle to be used when calling WSALookupServiceNext in order to start retrieving the results set.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> There was insufficient memory to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> One or more parameters were missing or invalid for this
///    provider. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> The name
///    was found in the database but no data matching the given restrictions was located. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The WS2_32.DLL has not been
///    initialized. The application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSASERVICE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No such service is
///    known. The service cannot be found in the specified name space. This error is returned for a bluetooth service
///    discovery request if no remote bluetooth devices were found. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSALookupServiceBeginA(WSAQUERYSETA* lpqsRestrictions, uint dwControlFlags, ptrdiff_t* lphLookup);

///The <b>WSALookupServiceBegin</b> function initiates a client query that is constrained by the information contained
///within a WSAQUERYSET structure. <b>WSALookupServiceBegin</b> only returns a handle, which should be used by
///subsequent calls to WSALookupServiceNext to get the actual results.
///Params:
///    lpqsRestrictions = A pointer to the search criteria. See the Remarks for details.
///    dwControlFlags = A set of flags that controls the depth of the search. Supported values for the <i>dwControlFlags</i> parameter
///                     are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options. <table> <tr>
///                     <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
///                     <dt><b>LUP_DEEP</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Queries deep as opposed to just the first
///                     level. </td> </tr> <tr> <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
///                     <dt><b>LUP_CONTAINERS</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Returns containers only. </td> </tr>
///                     <tr> <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
///                     <dt><b>LUP_NOCONTAINERS</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Do not return containers. </td>
///                     </tr> <tr> <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl> <dt><b>LUP_NEAREST</b></dt>
///                     <dt>0x0008</dt> </dl> </td> <td width="60%"> If possible, returns results in the order of distance. The measure
///                     of distance is provider specific. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_NAME"></a><a
///                     id="lup_return_name"></a><dl> <dt><b>LUP_RETURN_NAME</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%">
///                     Retrieves the name as <i>lpszServiceInstanceName</i>. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl> <dt><b>LUP_RETURN_TYPE</b></dt> <dt>0x0020</dt> </dl>
///                     </td> <td width="60%"> Retrieves the type as <i>lpServiceClassId</i>. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl> <dt><b>LUP_RETURN_VERSION</b></dt>
///                     <dt>0x0040</dt> </dl> </td> <td width="60%"> Retrieves the version as <i>lpVersion</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl> <dt><b>LUP_RETURN_COMMENT</b></dt>
///                     <dt>0x0080</dt> </dl> </td> <td width="60%"> Retrieves the comment as <i>lpszComment</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl> <dt><b>LUP_RETURN_ADDR</b></dt>
///                     <dt>0x0100</dt> </dl> </td> <td width="60%"> Retrieves the addresses as <i>lpcsaBuffer</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl> <dt><b>LUP_RETURN_BLOB</b></dt>
///                     <dt>0x0200</dt> </dl> </td> <td width="60%"> Retrieves the private data as <i>lpBlob</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl> <dt><b>LUP_RETURN_ALIASES</b></dt>
///                     <dt>0x0400</dt> </dl> </td> <td width="60%"> Any available alias information is to be returned in successive
///                     calls to WSALookupServiceNext, and each alias returned will have the RESULT_IS_ALIAS flag set. </td> </tr> <tr>
///                     <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
///                     <dt><b>LUP_RETURN_QUERY_STRING</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> Retrieves the query string
///                     used for the request. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
///                     <dt><b>LUP_RETURN_ALL</b></dt> <dt>0x0FF0</dt> </dl> </td> <td width="60%"> A set of flags that retrieves all of
///                     the LUP_RETURN_* values. </td> </tr> <tr> <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a
///                     id="lup_flushprevious"></a><dl> <dt><b>LUP_FLUSHPREVIOUS</b></dt> <dt>0x1000</dt> </dl> </td> <td width="60%">
///                     Used as a value for the <i>dwControlFlags</i> parameter in WSALookupServiceNext. Setting this flag instructs the
///                     provider to discard the last result set, which was too large for the specified buffer, and move on to the next
///                     result set. </td> </tr> <tr> <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
///                     <dt><b>LUP_FLUSHCACHE</b></dt> <dt>0x2000</dt> </dl> </td> <td width="60%"> If the provider has been caching
///                     information, ignores the cache, and queries the namespace itself. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl> <dt><b>LUP_RES_SERVICE</b></dt> <dt>0x8000</dt> </dl>
///                     </td> <td width="60%"> This indicates whether prime response is in the remote or local part of CSADDR_INFO
///                     structure. The other part needs to be usable in either case. </td> </tr> </table>
///    lphLookup = A handle to be used when calling WSALookupServiceNext in order to start retrieving the results set.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> There was insufficient memory to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> One or more parameters were missing or invalid for this
///    provider. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> The name
///    was found in the database but no data matching the given restrictions was located. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The WS2_32.DLL has not been
///    initialized. The application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSASERVICE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No such service is
///    known. The service cannot be found in the specified name space. This error is returned for a bluetooth service
///    discovery request if no remote bluetooth devices were found. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSALookupServiceBeginW(WSAQUERYSETW* lpqsRestrictions, uint dwControlFlags, ptrdiff_t* lphLookup);

///The <b>WSALookupServiceNext</b> function is called after obtaining a handle from a previous call to
///WSALookupServiceBegin in order to retrieve the requested service information. The provider will pass back a
///WSAQUERYSET structure in the <i>lpqsResults</i> buffer. The client should continue to call this function until it
///returns WSA_E_NO_MORE, indicating that all of <b>WSAQUERYSET</b> has been returned.
///Params:
///    hLookup = A handle returned from the previous call to WSALookupServiceBegin.
///    dwControlFlags = A set of flags that controls the operation. The values passed in the <i>dwControlFlags</i> parameter to the
///                     WSALookupServiceBeginfunction determine the possible criteria. Any values passed in the <i>dwControlFlags</i>
///                     parameter to the <b>WSALookupServiceNext</b> function further restrict the criteria for the service lookup.
///                     Currently, LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application
///                     does not (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard
///                     the last result set—which was too large—and move on to the next set for this call. Supported values for the
///                     <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the
///                     following options. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LUP_DEEP"></a><a
///                     id="lup_deep"></a><dl> <dt><b>LUP_DEEP</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Queries deep as
///                     opposed to just the first level. </td> </tr> <tr> <td width="40%"><a id="LUP_CONTAINERS"></a><a
///                     id="lup_containers"></a><dl> <dt><b>LUP_CONTAINERS</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Returns
///                     containers only. </td> </tr> <tr> <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
///                     <dt><b>LUP_NOCONTAINERS</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Do not return containers. </td>
///                     </tr> <tr> <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl> <dt><b>LUP_NEAREST</b></dt>
///                     <dt>0x0008</dt> </dl> </td> <td width="60%"> If possible, returns results in the order of distance. The measure
///                     of distance is provider specific. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_NAME"></a><a
///                     id="lup_return_name"></a><dl> <dt><b>LUP_RETURN_NAME</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%">
///                     Retrieves the name as <i>lpszServiceInstanceName</i>. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl> <dt><b>LUP_RETURN_TYPE</b></dt> <dt>0x0020</dt> </dl>
///                     </td> <td width="60%"> Retrieves the type as <i>lpServiceClassId</i>. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl> <dt><b>LUP_RETURN_VERSION</b></dt>
///                     <dt>0x0040</dt> </dl> </td> <td width="60%"> Retrieves the version as <i>lpVersion</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl> <dt><b>LUP_RETURN_COMMENT</b></dt>
///                     <dt>0x0080</dt> </dl> </td> <td width="60%"> Retrieves the comment as <i>lpszComment</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl> <dt><b>LUP_RETURN_ADDR</b></dt>
///                     <dt>0x0100</dt> </dl> </td> <td width="60%"> Retrieves the addresses as <i>lpcsaBuffer</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl> <dt><b>LUP_RETURN_BLOB</b></dt>
///                     <dt>0x0200</dt> </dl> </td> <td width="60%"> Retrieves the private data as <i>lpBlob</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl> <dt><b>LUP_RETURN_ALIASES</b></dt>
///                     <dt>0x0400</dt> </dl> </td> <td width="60%"> Any available alias information is to be returned in successive
///                     calls to <b>WSALookupServiceNext</b>, and each alias returned will have the RESULT_IS_ALIAS flag set. </td> </tr>
///                     <tr> <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
///                     <dt><b>LUP_RETURN_QUERY_STRING</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> Retrieves the query string
///                     used for the request. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
///                     <dt><b>LUP_RETURN_ALL</b></dt> <dt>0x0FF0</dt> </dl> </td> <td width="60%"> A set of flags that retrieves all of
///                     the LUP_RETURN_* values. </td> </tr> <tr> <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a
///                     id="lup_flushprevious"></a><dl> <dt><b>LUP_FLUSHPREVIOUS</b></dt> <dt>0x1000</dt> </dl> </td> <td width="60%">
///                     Used as a value for the <i>dwControlFlags</i> parameter in <b>WSALookupServiceNext</b>. Setting this flag
///                     instructs the provider to discard the last result set, which was too large for the specified buffer, and move on
///                     to the next result set. </td> </tr> <tr> <td width="40%"><a id="LUP_FLUSHCACHE"></a><a
///                     id="lup_flushcache"></a><dl> <dt><b>LUP_FLUSHCACHE</b></dt> <dt>0x2000</dt> </dl> </td> <td width="60%"> If the
///                     provider has been caching information, ignores the cache, and queries the namespace itself. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl> <dt><b>LUP_RES_SERVICE</b></dt>
///                     <dt>0x8000</dt> </dl> </td> <td width="60%"> This indicates whether prime response is in the remote or local part
///                     of CSADDR_INFO structure. The other part needs to be usable in either case. </td> </tr> </table>
///    lpdwBufferLength = On input, the number of bytes contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the
///                       function fails and the error is WSAEFAULT, then it contains the minimum number of bytes to pass for the
///                       <i>lpqsResults</i> to retrieve the record.
///    lpqsResults = A pointer to a block of memory, which will contain one result set in a WSAQUERYSET structure on return.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_E_CANCELLED</b></dt> </dl> </td> <td width="60%"> A
///    call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled. The data
///    in the <i>lpqsResults</i> buffer is undefined. In Windows Sockets version 2, conflicting error codes are defined
///    for WSAECANCELLED (10103) and WSA_E_CANCELLED (10111). The error code WSAECANCELLED will be removed in a future
///    version and only WSA_E_CANCELLED will remain. For Windows Sockets version 2, however, applications should check
///    for both WSAECANCELLED and WSA_E_CANCELLED for the widest possible compatibility with namespace providers that
///    use either one. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_E_NO_MORE</b></dt> </dl> </td> <td width="60%">
///    There is no more data available. In Windows Sockets version 2, conflicting error codes are defined for WSAENOMORE
///    (10102) and WSA_E_NO_MORE (10110). The error code WSAENOMORE will be removed in a future version and only
///    WSA_E_NO_MORE will remain. For Windows Sockets version 2, however, applications should check for both WSAENOMORE
///    and WSA_E_NO_MORE for the widest possible compatibility with name-space providers that use either one. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpqsResults</i>
///    buffer was too small to contain a WSAQUERYSET set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> One or more required parameters were invalid or missing.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The
///    specified Lookup handle is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt>
///    </dl> </td> <td width="60%"> The WS2_32.DLL has not been initialized. The application must first call WSAStartup
///    before calling any Windows Sockets functions. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt>
///    </dl> </td> <td width="60%"> The name was found in the database, but no data matching the given restrictions was
///    located. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> There was insufficient memory to perform the operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSALookupServiceNextA(HANDLE hLookup, uint dwControlFlags, uint* lpdwBufferLength, char* lpqsResults);

///The <b>WSALookupServiceNext</b> function is called after obtaining a handle from a previous call to
///WSALookupServiceBegin in order to retrieve the requested service information. The provider will pass back a
///WSAQUERYSET structure in the <i>lpqsResults</i> buffer. The client should continue to call this function until it
///returns WSA_E_NO_MORE, indicating that all of <b>WSAQUERYSET</b> has been returned.
///Params:
///    hLookup = A handle returned from the previous call to WSALookupServiceBegin.
///    dwControlFlags = A set of flags that controls the operation. The values passed in the <i>dwControlFlags</i> parameter to the
///                     WSALookupServiceBeginfunction determine the possible criteria. Any values passed in the <i>dwControlFlags</i>
///                     parameter to the <b>WSALookupServiceNext</b> function further restrict the criteria for the service lookup.
///                     Currently, LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application
///                     does not (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard
///                     the last result set—which was too large—and move on to the next set for this call. Supported values for the
///                     <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the
///                     following options. <table> <tr> <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="LUP_DEEP"></a><a
///                     id="lup_deep"></a><dl> <dt><b>LUP_DEEP</b></dt> <dt>0x0001</dt> </dl> </td> <td width="60%"> Queries deep as
///                     opposed to just the first level. </td> </tr> <tr> <td width="40%"><a id="LUP_CONTAINERS"></a><a
///                     id="lup_containers"></a><dl> <dt><b>LUP_CONTAINERS</b></dt> <dt>0x0002</dt> </dl> </td> <td width="60%"> Returns
///                     containers only. </td> </tr> <tr> <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
///                     <dt><b>LUP_NOCONTAINERS</b></dt> <dt>0x0004</dt> </dl> </td> <td width="60%"> Do not return containers. </td>
///                     </tr> <tr> <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl> <dt><b>LUP_NEAREST</b></dt>
///                     <dt>0x0008</dt> </dl> </td> <td width="60%"> If possible, returns results in the order of distance. The measure
///                     of distance is provider specific. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_NAME"></a><a
///                     id="lup_return_name"></a><dl> <dt><b>LUP_RETURN_NAME</b></dt> <dt>0x0010</dt> </dl> </td> <td width="60%">
///                     Retrieves the name as <i>lpszServiceInstanceName</i>. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl> <dt><b>LUP_RETURN_TYPE</b></dt> <dt>0x0020</dt> </dl>
///                     </td> <td width="60%"> Retrieves the type as <i>lpServiceClassId</i>. </td> </tr> <tr> <td width="40%"><a
///                     id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl> <dt><b>LUP_RETURN_VERSION</b></dt>
///                     <dt>0x0040</dt> </dl> </td> <td width="60%"> Retrieves the version as <i>lpVersion</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl> <dt><b>LUP_RETURN_COMMENT</b></dt>
///                     <dt>0x0080</dt> </dl> </td> <td width="60%"> Retrieves the comment as <i>lpszComment</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl> <dt><b>LUP_RETURN_ADDR</b></dt>
///                     <dt>0x0100</dt> </dl> </td> <td width="60%"> Retrieves the addresses as <i>lpcsaBuffer</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl> <dt><b>LUP_RETURN_BLOB</b></dt>
///                     <dt>0x0200</dt> </dl> </td> <td width="60%"> Retrieves the private data as <i>lpBlob</i>. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl> <dt><b>LUP_RETURN_ALIASES</b></dt>
///                     <dt>0x0400</dt> </dl> </td> <td width="60%"> Any available alias information is to be returned in successive
///                     calls to <b>WSALookupServiceNext</b>, and each alias returned will have the RESULT_IS_ALIAS flag set. </td> </tr>
///                     <tr> <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
///                     <dt><b>LUP_RETURN_QUERY_STRING</b></dt> <dt>0x0800</dt> </dl> </td> <td width="60%"> Retrieves the query string
///                     used for the request. </td> </tr> <tr> <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
///                     <dt><b>LUP_RETURN_ALL</b></dt> <dt>0x0FF0</dt> </dl> </td> <td width="60%"> A set of flags that retrieves all of
///                     the LUP_RETURN_* values. </td> </tr> <tr> <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a
///                     id="lup_flushprevious"></a><dl> <dt><b>LUP_FLUSHPREVIOUS</b></dt> <dt>0x1000</dt> </dl> </td> <td width="60%">
///                     Used as a value for the <i>dwControlFlags</i> parameter in <b>WSALookupServiceNext</b>. Setting this flag
///                     instructs the provider to discard the last result set, which was too large for the specified buffer, and move on
///                     to the next result set. </td> </tr> <tr> <td width="40%"><a id="LUP_FLUSHCACHE"></a><a
///                     id="lup_flushcache"></a><dl> <dt><b>LUP_FLUSHCACHE</b></dt> <dt>0x2000</dt> </dl> </td> <td width="60%"> If the
///                     provider has been caching information, ignores the cache, and queries the namespace itself. </td> </tr> <tr> <td
///                     width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl> <dt><b>LUP_RES_SERVICE</b></dt>
///                     <dt>0x8000</dt> </dl> </td> <td width="60%"> This indicates whether prime response is in the remote or local part
///                     of CSADDR_INFO structure. The other part needs to be usable in either case. </td> </tr> </table>
///    lpdwBufferLength = On input, the number of bytes contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the
///                       function fails and the error is WSAEFAULT, then it contains the minimum number of bytes to pass for the
///                       <i>lpqsResults</i> to retrieve the record.
///    lpqsResults = A pointer to a block of memory, which will contain one result set in a WSAQUERYSET structure on return.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_E_CANCELLED</b></dt> </dl> </td> <td width="60%"> A
///    call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled. The data
///    in the <i>lpqsResults</i> buffer is undefined. In Windows Sockets version 2, conflicting error codes are defined
///    for WSAECANCELLED (10103) and WSA_E_CANCELLED (10111). The error code WSAECANCELLED will be removed in a future
///    version and only WSA_E_CANCELLED will remain. For Windows Sockets version 2, however, applications should check
///    for both WSAECANCELLED and WSA_E_CANCELLED for the widest possible compatibility with namespace providers that
///    use either one. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_E_NO_MORE</b></dt> </dl> </td> <td width="60%">
///    There is no more data available. In Windows Sockets version 2, conflicting error codes are defined for WSAENOMORE
///    (10102) and WSA_E_NO_MORE (10110). The error code WSAENOMORE will be removed in a future version and only
///    WSA_E_NO_MORE will remain. For Windows Sockets version 2, however, applications should check for both WSAENOMORE
///    and WSA_E_NO_MORE for the widest possible compatibility with name-space providers that use either one. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpqsResults</i>
///    buffer was too small to contain a WSAQUERYSET set. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> One or more required parameters were invalid or missing.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%"> The
///    specified Lookup handle is invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt>
///    </dl> </td> <td width="60%"> The WS2_32.DLL has not been initialized. The application must first call WSAStartup
///    before calling any Windows Sockets functions. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt>
///    </dl> </td> <td width="60%"> The name was found in the database, but no data matching the given restrictions was
///    located. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> There was insufficient memory to perform the operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSALookupServiceNextW(HANDLE hLookup, uint dwControlFlags, uint* lpdwBufferLength, char* lpqsResults);

///The Windows Sockets <b>WSANSPIoctl</b> function enables developers to make I/O control calls to a registered
///namespace.
///Params:
///    hLookup = The lookup handle returned from a previous call to the WSALookupServiceBegin function.
///    dwControlCode = The control code of the operation to perform. The values that may be used for the <i>dwControlCode</i> parameter
///                    are determined by the namespace provider. The following value is supported by several Microsoft namespace
///                    providers including the Network Location Awareness (NS_NLA) namespace provider. This IOCTL is defined in the
///                    Winsock2.h header file. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                    id="SIO_NSP_NOTIFY_CHANGE"></a><a id="sio_nsp_notify_change"></a><dl> <dt><b>SIO_NSP_NOTIFY_CHANGE</b></dt> </dl>
///                    </td> <td width="60%"> This operation checks if the results returned with previous calls using the <i>hLookup</i>
///                    parameter are still valid. These previous calls include the initial call to the WSALookupServiceBegin function to
///                    retrieve the <i>hLookup</i> parameter. These previous calls may also include calls to the WSALookupServiceNext
///                    function using the <i>hLookup</i> parameter. </td> </tr> </table>
///    lpvInBuffer = A pointer to the input buffer.
///    cbInBuffer = The size, in bytes, of the input buffer.
///    lpvOutBuffer = A pointer to the output buffer.
///    cbOutBuffer = The size, in bytes, of the output buffer.
///    lpcbBytesReturned = A pointer to the number of bytes returned.
///    lpCompletion = A pointer to a WSACOMPLETION structure, used for asynchronous processing. Set <i>lpCompletion</i> to <b>NULL</b>
///                   to force blocking (synchronous) execution.
///Returns:
///    Success returns NO_ERROR. Failure returns SOCKET_ERROR, and a specific error code can be retrieved by calling the
///    WSAGetLastError function. The following table describes the error codes. <table> <tr> <th>Error code</th>
///    <th>Description</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dt> </dl> </td> <td
///    width="60%"> The <i>hLookup</i> parameter was not a valid query handle returned by WSALookupServiceBegin. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dt> </dl> </td> <td width="60%"> An overlapped
///    operation was successfully initiated and completion will be indicated at a later time. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpvInBuffer</i>,
///    <i>cbInBuffer</i>, <i>lpvOutBuffer</i>, <i>cbOutBuffer</i>, or <i>lpCompletion</i> argument is not totally
///    contained in a valid part of the user address space. Alternatively, the <i>cbInBuffer</i> or <i>cbOutBuffer</i>
///    argument is too small, and the argument is modified to reflect the required allocation size. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> A supplied parameter is not acceptable,
///    or the operation inappropriately returns results from multiple namespaces when it does not make sense for the
///    specified operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td
///    width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The operation is not supported. This error is returned
///    if the namespace provider does not implement this function. This error can also be returned if the specified
///    <i>dwControlCode</i> is an unrecognized command. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td width="60%"> The socket is not using overlapped I/O (asynchronous
///    processing), yet the <i>lpCompletion</i> parameter is non-<b>NULL</b>. This error is used as a special
///    notification for the SIO_NSP_NOTIFY_CHANGE IOCTL when the <i>lpCompletion</i> parameter is <b>NULL</b> (a poll)
///    to indicate that a query set remains valid. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSANSPIoctl(HANDLE hLookup, uint dwControlCode, char* lpvInBuffer, uint cbInBuffer, char* lpvOutBuffer, 
                uint cbOutBuffer, uint* lpcbBytesReturned, WSACOMPLETION* lpCompletion);

///The <b>WSALookupServiceEnd</b> function is called to free the handle after previous calls to WSALookupServiceBegin
///and WSALookupServiceNext. If you call <b>WSALookupServiceEnd</b> from another thread while an existing
///WSALookupServiceNext is blocked, the end call will have the same effect as a cancel and will cause the
///<b>WSALookupServiceNext</b> call to return immediately.
///Params:
///    hLookup = Handle previously obtained by calling WSALookupServiceBegin.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dt> </dl> </td> <td width="60%">
///    The handle is not valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td
///    width="60%"> The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling
///    any Windows Sockets functions. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl>
///    </td> <td width="60%"> There was insufficient memory to perform the operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSALookupServiceEnd(HANDLE hLookup);

///The <b>WSAInstallServiceClass</b> function registers a service class schema within a namespace. This schema includes
///the class name, class identifier, and any namespace-specific information that is common to all instances of the
///service, such as the SAP identifier or object identifier.
///Params:
///    lpServiceClassInfo = Service class to namespace specific–type mapping information. Multiple mappings can be handled at one time. See
///                         the section Service Class Data Structures for a description of pertinent data structures.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> The namespace provider cannot supply the requested class information. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient
///    memory to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td
///    width="60%"> The calling function does not have sufficient privileges to install the service. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEALREADY</b></dt> </dl> </td> <td width="60%"> Service class information has
///    already been registered for this service class identifier. To modify service class information, first use
///    WSARemoveServiceClass, and then reinstall with updated class information data. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The service class information was not valid or
///    improperly structured. This error is returned if the <i>lpServiceClassInfo</i> parameter is <b>NULL</b>. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The operation is not
///    supported. This error is returned if the namespace provider does not implement this function. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> The requested name is valid, but no
///    data of the requested type was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt>
///    </dl> </td> <td width="60%"> The WS2_32.DLL has not been initialized. The application must first call WSAStartup
///    before calling any Windows Sockets functions. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAInstallServiceClassA(WSASERVICECLASSINFOA* lpServiceClassInfo);

///The <b>WSAInstallServiceClass</b> function registers a service class schema within a namespace. This schema includes
///the class name, class identifier, and any namespace-specific information that is common to all instances of the
///service, such as the SAP identifier or object identifier.
///Params:
///    lpServiceClassInfo = Service class to namespace specific–type mapping information. Multiple mappings can be handled at one time. See
///                         the section Service Class Data Structures for a description of pertinent data structures.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_PARAMETER</b></dt> </dl> </td> <td
///    width="60%"> The namespace provider cannot supply the requested class information. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient
///    memory to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td
///    width="60%"> The calling function does not have sufficient privileges to install the service. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEALREADY</b></dt> </dl> </td> <td width="60%"> Service class information has
///    already been registered for this service class identifier. To modify service class information, first use
///    WSARemoveServiceClass, and then reinstall with updated class information data. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The service class information was not valid or
///    improperly structured. This error is returned if the <i>lpServiceClassInfo</i> parameter is <b>NULL</b>. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The operation is not
///    supported. This error is returned if the namespace provider does not implement this function. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> The requested name is valid, but no
///    data of the requested type was found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt>
///    </dl> </td> <td width="60%"> The WS2_32.DLL has not been initialized. The application must first call WSAStartup
///    before calling any Windows Sockets functions. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAInstallServiceClassW(WSASERVICECLASSINFOW* lpServiceClassInfo);

///The <b>WSARemoveServiceClass</b> function permanently removes the service class schema from the registry.
///Params:
///    lpServiceClassId = Pointer to the GUID for the service class you want to remove.
///Returns:
///    The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a
///    specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATYPE_NOT_FOUND</b></dt> </dl> </td> <td width="60%">
///    The specified class was not found. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td>
///    <td width="60%"> The calling routine does not have sufficient privileges to remove the Service. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAETOOMANYREFS</b></dt> </dl> </td> <td width="60%"> There are service instances
///    that still reference the class. Removal of this class is not possible at this time. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The WS2_32.DLL has not been
///    initialized. The application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The specified GUID was not
///    valid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%">
///    There was insufficient memory to perform the operation. </td> </tr> </table> <div> </div>
///    
@DllImport("WS2_32")
int WSARemoveServiceClass(GUID* lpServiceClassId);

///The <b>WSAGetServiceClassInfo</b> function retrieves the class information (schema) pertaining to a specified service
///class from a specified namespace provider.
///Params:
///    lpProviderId = A pointer to a GUID that identifies a specific namespace provider.
///    lpServiceClassId = A pointer to a GUID identifying the service class.
///    lpdwBufSize = On input, the number of bytes contained in the buffer pointed to by the <i>lpServiceClassInfo</i> parameter. On
///                  output, if the function fails and the error is WSAEFAULT, this parameter specifies the minimum size, in bytes, of
///                  the buffer pointed to <i>lpServiceClassInfo</i> needed to retrieve the record.
///    lpServiceClassInfo = A pointer to a WSASERVICECLASSINFO structure that contains the service class information from the indicated
///                         namespace provider for the specified service class.
///Returns:
///    The return value is zero if the <b>WSAGetServiceClassInfo</b> was successful. Otherwise, the value SOCKET_ERROR
///    is returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> There was insufficient memory to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEACCES</b></dt> </dl> </td> <td width="60%"> The calling routine does not have sufficient privileges to
///    access the information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The buffer pointed to by the <i>lpServiceClassInfo</i> parameter is too small to contain a
///    WSASERVICECLASSINFOW. The application needs to pass in a larger buffer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The specified service class identifier or namespace
///    provider identifier is not valid. This error is returned if the <i>lpProviderId</i>, <i>lpServiceClassId</i>,
///    <i>lpdwBufSize</i>, or <i>lpServiceClassInfo</i> parameters are <b>NULL</b>. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The operation is not supported for the type of
///    object referenced. This error is returned by some namespace providers that do not support getting service class
///    information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> The
///    requested name is valid, but no data of the requested type was found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The WS2_32.DLL has not been initialized. The
///    application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSATYPE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified class was not
///    found. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAGetServiceClassInfoA(GUID* lpProviderId, GUID* lpServiceClassId, uint* lpdwBufSize, 
                            char* lpServiceClassInfo);

///The <b>WSAGetServiceClassInfo</b> function retrieves the class information (schema) pertaining to a specified service
///class from a specified namespace provider.
///Params:
///    lpProviderId = A pointer to a GUID that identifies a specific namespace provider.
///    lpServiceClassId = A pointer to a GUID identifying the service class.
///    lpdwBufSize = On input, the number of bytes contained in the buffer pointed to by the <i>lpServiceClassInfo</i> parameter. On
///                  output, if the function fails and the error is WSAEFAULT, this parameter specifies the minimum size, in bytes, of
///                  the buffer pointed to <i>lpServiceClassInfo</i> needed to retrieve the record.
///    lpServiceClassInfo = A pointer to a WSASERVICECLASSINFO structure that contains the service class information from the indicated
///                         namespace provider for the specified service class.
///Returns:
///    The return value is zero if the <b>WSAGetServiceClassInfo</b> was successful. Otherwise, the value SOCKET_ERROR
///    is returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td
///    width="60%"> There was insufficient memory to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEACCES</b></dt> </dl> </td> <td width="60%"> The calling routine does not have sufficient privileges to
///    access the information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The buffer pointed to by the <i>lpServiceClassInfo</i> parameter is too small to contain a
///    WSASERVICECLASSINFOW. The application needs to pass in a larger buffer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> The specified service class identifier or namespace
///    provider identifier is not valid. This error is returned if the <i>lpProviderId</i>, <i>lpServiceClassId</i>,
///    <i>lpdwBufSize</i>, or <i>lpServiceClassInfo</i> parameters are <b>NULL</b>. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The operation is not supported for the type of
///    object referenced. This error is returned by some namespace providers that do not support getting service class
///    information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> The
///    requested name is valid, but no data of the requested type was found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The WS2_32.DLL has not been initialized. The
///    application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSATYPE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified class was not
///    found. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAGetServiceClassInfoW(GUID* lpProviderId, GUID* lpServiceClassId, uint* lpdwBufSize, 
                            char* lpServiceClassInfo);

///The <b>WSAEnumNameSpaceProviders</b> function retrieves information on available namespace providers.
///Params:
///    lpdwBufferLength = On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the
///                       function fails, and the error is WSAEFAULT), the minimum number of bytes to pass for the <i>lpnspBuffer</i> to
///                       retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProviders</b> must be sufficient
///                       to hold all of the namespace information.
///    lpnspBuffer = A buffer that is filled with WSANAMESPACE_INFO structures. The returned structures are located consecutively at
///                  the head of the buffer. Variable sized information referenced by pointers in the structures point to locations
///                  within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of
///                  structures filled in is the return value of <b>WSAEnumNameSpaceProviders</b>.
///Returns:
///    The <b>WSAEnumNameSpaceProviders</b> function returns the number of WSANAMESPACE_INFO structures copied into
///    <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved
///    by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpnspBuffer</i> parameter was a <b>NULL</b> pointer
///    or the buffer length, <i>lpdwBufferLength</i>, was too small to receive all the relevant WSANAMESPACE_INFO
///    structures and associated information. When this error is returned, the buffer length required is returned in the
///    <i>lpdwBufferLength</i> parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> The WS2_32.DLL has not been initialized. The application must first call WSAStartup before
///    calling any Windows Sockets functions. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAEnumNameSpaceProvidersA(uint* lpdwBufferLength, char* lpnspBuffer);

///The <b>WSAEnumNameSpaceProviders</b> function retrieves information on available namespace providers.
///Params:
///    lpdwBufferLength = On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the
///                       function fails, and the error is WSAEFAULT), the minimum number of bytes to pass for the <i>lpnspBuffer</i> to
///                       retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProviders</b> must be sufficient
///                       to hold all of the namespace information.
///    lpnspBuffer = A buffer that is filled with WSANAMESPACE_INFO structures. The returned structures are located consecutively at
///                  the head of the buffer. Variable sized information referenced by pointers in the structures point to locations
///                  within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of
///                  structures filled in is the return value of <b>WSAEnumNameSpaceProviders</b>.
///Returns:
///    The <b>WSAEnumNameSpaceProviders</b> function returns the number of WSANAMESPACE_INFO structures copied into
///    <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved
///    by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpnspBuffer</i> parameter was a <b>NULL</b> pointer
///    or the buffer length, <i>lpdwBufferLength</i>, was too small to receive all the relevant WSANAMESPACE_INFO
///    structures and associated information. When this error is returned, the buffer length required is returned in the
///    <i>lpdwBufferLength</i> parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> The WS2_32.DLL has not been initialized. The application must first call WSAStartup before
///    calling any Windows Sockets functions. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAEnumNameSpaceProvidersW(uint* lpdwBufferLength, char* lpnspBuffer);

///The <b>WSAEnumNameSpaceProvidersEx</b> function retrieves information on available namespace providers.
///Params:
///    lpdwBufferLength = On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the
///                       function fails, and the error is WSAEFAULT), the minimum number of bytes to allocate for the <i>lpnspBuffer</i>
///                       buffer to allow it to retrieve all the requested information. The buffer passed to
///                       <b>WSAEnumNameSpaceProvidersEx</b> must be sufficient to hold all of the namespace information.
///    lpnspBuffer = A buffer that is filled with WSANAMESPACE_INFOEX structures. The returned structures are located consecutively at
///                  the head of the buffer. Variable sized information referenced by pointers in the structures point to locations
///                  within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of
///                  structures filled in is the return value of <b>WSAEnumNameSpaceProvidersEx</b>.
///Returns:
///    The <b>WSAEnumNameSpaceProvidersEx</b> function returns the number of WSANAMESPACE_INFOEX structures copied into
///    <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved
///    by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpnspBuffer</i> parameter was a <b>NULL</b> pointer
///    or the buffer length, <i>lpdwBufferLength</i>, was too small to receive all the relevant WSANAMESPACE_INFOEX
///    structures and associated information. When this error is returned, the buffer length required is returned in the
///    <i>lpdwBufferLength</i> parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> The WS2_32.DLL has not been initialized. The application must first call WSAStartup before
///    calling any Windows Sockets functions. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAEnumNameSpaceProvidersExA(uint* lpdwBufferLength, char* lpnspBuffer);

///The <b>WSAEnumNameSpaceProvidersEx</b> function retrieves information on available namespace providers.
///Params:
///    lpdwBufferLength = On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the
///                       function fails, and the error is WSAEFAULT), the minimum number of bytes to allocate for the <i>lpnspBuffer</i>
///                       buffer to allow it to retrieve all the requested information. The buffer passed to
///                       <b>WSAEnumNameSpaceProvidersEx</b> must be sufficient to hold all of the namespace information.
///    lpnspBuffer = A buffer that is filled with WSANAMESPACE_INFOEX structures. The returned structures are located consecutively at
///                  the head of the buffer. Variable sized information referenced by pointers in the structures point to locations
///                  within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of
///                  structures filled in is the return value of <b>WSAEnumNameSpaceProvidersEx</b>.
///Returns:
///    The <b>WSAEnumNameSpaceProvidersEx</b> function returns the number of WSANAMESPACE_INFOEX structures copied into
///    <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved
///    by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>lpnspBuffer</i> parameter was a <b>NULL</b> pointer
///    or the buffer length, <i>lpdwBufferLength</i>, was too small to receive all the relevant WSANAMESPACE_INFOEX
///    structures and associated information. When this error is returned, the buffer length required is returned in the
///    <i>lpdwBufferLength</i> parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl>
///    </td> <td width="60%"> The WS2_32.DLL has not been initialized. The application must first call WSAStartup before
///    calling any Windows Sockets functions. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAEnumNameSpaceProvidersExW(uint* lpdwBufferLength, char* lpnspBuffer);

///The <b>WSAGetServiceClassNameByClassId</b> function retrieves the name of the service associated with the specified
///type. This name is the generic service name, like FTP or SNA, and not the name of a specific instance of that
///service.
///Params:
///    lpServiceClassId = A pointer to the GUID for the service class.
///    lpszServiceClassName = A pointer to the service name.
///    lpdwBufferLength = On input, the length of the buffer returned by <i>lpszServiceClassName</i>, in characters. On output, the length
///                       of the service name copied into <i>lpszServiceClassName</i>, in characters.
///Returns:
///    The <b>WSAGetServiceClassNameByClassId</b> function returns a value of zero if successful. Otherwise, the value
///    SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_PARAMETER</b></dt> </dl>
///    </td> <td width="60%"> The <i>lpServiceClassId</i> parameter specified is invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient
///    memory to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td
///    width="60%"> The calling routine does not have sufficient privileges to access the information. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The specified buffer pointed to by
///    <i>lpszServiceClassName</i> is too small. Pass in a larger buffer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> No buffer space available. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The operation is not supported for
///    the type of object referenced. This error is returned by some namespace providers that do not support getting
///    service class information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpServiceClassId</i> is valid, but no data of the requested type was found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The WS2_32.DLL has not been
///    initialized. The application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
int WSAGetServiceClassNameByClassIdA(GUID* lpServiceClassId, const(char)* lpszServiceClassName, 
                                     uint* lpdwBufferLength);

///The <b>WSAGetServiceClassNameByClassId</b> function retrieves the name of the service associated with the specified
///type. This name is the generic service name, like FTP or SNA, and not the name of a specific instance of that
///service.
///Params:
///    lpServiceClassId = A pointer to the GUID for the service class.
///    lpszServiceClassName = A pointer to the service name.
///    lpdwBufferLength = On input, the length of the buffer returned by <i>lpszServiceClassName</i>, in characters. On output, the length
///                       of the service name copied into <i>lpszServiceClassName</i>, in characters.
///Returns:
///    The <b>WSAGetServiceClassNameByClassId</b> function returns a value of zero if successful. Otherwise, the value
///    SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_PARAMETER</b></dt> </dl>
///    </td> <td width="60%"> The <i>lpServiceClassId</i> parameter specified is invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient
///    memory to perform the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td
///    width="60%"> The calling routine does not have sufficient privileges to access the information. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The specified buffer pointed to by
///    <i>lpszServiceClassName</i> is too small. Pass in a larger buffer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> No buffer space available. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> The operation is not supported for
///    the type of object referenced. This error is returned by some namespace providers that do not support getting
///    service class information. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td
///    width="60%"> The <i>lpServiceClassId</i> is valid, but no data of the requested type was found. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> The WS2_32.DLL has not been
///    initialized. The application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
int WSAGetServiceClassNameByClassIdW(GUID* lpServiceClassId, const(wchar)* lpszServiceClassName, 
                                     uint* lpdwBufferLength);

///The <b>WSASetService</b> function registers or removes from the registry a service instance within one or more
///namespaces.
///Params:
///    lpqsRegInfo = A pointer to the service information for registration or deregistration.
///    essoperation = A value that determines that operation requested. This parameter can be one of the values from the
///                   WSAESETSERVICEOP enumeration type defined in the <i>Winsock2.h</i> header file. <table> <tr> <th>Value</th>
///                   <th>Meaning</th> </tr> <tr> <td width="40%"><a id="RNRSERVICE_REGISTER"></a><a id="rnrservice_register"></a><dl>
///                   <dt><b>RNRSERVICE_REGISTER</b></dt> </dl> </td> <td width="60%"> Register the service. For SAP, this means
///                   sending out a periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores, this means
///                   updating the address information. </td> </tr> <tr> <td width="40%"><a id="RNRSERVICE_DEREGISTER"></a><a
///                   id="rnrservice_deregister"></a><dl> <dt><b>RNRSERVICE_DEREGISTER</b></dt> </dl> </td> <td width="60%"> Remove the
///                   service from the registry. For SAP, this means stop sending out the periodic broadcast. This is an NOP for the
///                   DNS namespace. For persistent data stores this means deleting address information. </td> </tr> <tr> <td
///                   width="40%"><a id="RNRSERVICE_DELETE"></a><a id="rnrservice_delete"></a><dl> <dt><b>RNRSERVICE_DELETE</b></dt>
///                   </dl> </td> <td width="60%"> Delete the service from dynamic name and persistent spaces. For services represented
///                   by multiple CSADDR_INFO structures (using the SERVICE_MULTIPLE flag), only the specified address will be deleted,
///                   and this must match exactly the corresponding <b>CSADDR_INFO</b> structure that was specified when the service
///                   was registered. </td> </tr> </table>
///    dwControlFlags = Service install flags value that further controls the operation performed of the <b>WSASetService</b>function.
///                     The possible values for this parameter are defined in the <i>Winsock2.h</i> header file. <table> <tr>
///                     <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SERVICE_MULTIPLE"></a><a
///                     id="service_multiple"></a><dl> <dt><b>SERVICE_MULTIPLE</b></dt> </dl> </td> <td width="60%"> Controls scope of
///                     operation. When this flag is not set, service addresses are managed as a group. A register or removal from the
///                     registry invalidates all existing addresses before adding the given address set. When set, the action is only
///                     performed on the given address set. A register does not invalidate existing addresses and a removal from the
///                     registry only invalidates the given set of addresses. </td> </tr> </table>
///Returns:
///    The return value for <b>WSASetService</b> is zero if the operation was successful. Otherwise, the value
///    SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td
///    width="60%"> The calling routine does not have sufficient privileges to install the Service. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> One or more required parameters were
///    invalid or missing. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td
///    width="60%"> The <i>Ws2_32.dll</i> has not been initialized. The application must first call WSAStartup before
///    calling any Windows Sockets functions. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSASetServiceA(WSAQUERYSETA* lpqsRegInfo, WSAESETSERVICEOP essoperation, uint dwControlFlags);

///The <b>WSASetService</b> function registers or removes from the registry a service instance within one or more
///namespaces.
///Params:
///    lpqsRegInfo = A pointer to the service information for registration or deregistration.
///    essoperation = A value that determines that operation requested. This parameter can be one of the values from the
///                   WSAESETSERVICEOP enumeration type defined in the <i>Winsock2.h</i> header file. <table> <tr> <th>Value</th>
///                   <th>Meaning</th> </tr> <tr> <td width="40%"><a id="RNRSERVICE_REGISTER"></a><a id="rnrservice_register"></a><dl>
///                   <dt><b>RNRSERVICE_REGISTER</b></dt> </dl> </td> <td width="60%"> Register the service. For SAP, this means
///                   sending out a periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores, this means
///                   updating the address information. </td> </tr> <tr> <td width="40%"><a id="RNRSERVICE_DEREGISTER"></a><a
///                   id="rnrservice_deregister"></a><dl> <dt><b>RNRSERVICE_DEREGISTER</b></dt> </dl> </td> <td width="60%"> Remove the
///                   service from the registry. For SAP, this means stop sending out the periodic broadcast. This is an NOP for the
///                   DNS namespace. For persistent data stores this means deleting address information. </td> </tr> <tr> <td
///                   width="40%"><a id="RNRSERVICE_DELETE"></a><a id="rnrservice_delete"></a><dl> <dt><b>RNRSERVICE_DELETE</b></dt>
///                   </dl> </td> <td width="60%"> Delete the service from dynamic name and persistent spaces. For services represented
///                   by multiple CSADDR_INFO structures (using the SERVICE_MULTIPLE flag), only the specified address will be deleted,
///                   and this must match exactly the corresponding <b>CSADDR_INFO</b> structure that was specified when the service
///                   was registered. </td> </tr> </table>
///    dwControlFlags = Service install flags value that further controls the operation performed of the <b>WSASetService</b>function.
///                     The possible values for this parameter are defined in the <i>Winsock2.h</i> header file. <table> <tr>
///                     <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SERVICE_MULTIPLE"></a><a
///                     id="service_multiple"></a><dl> <dt><b>SERVICE_MULTIPLE</b></dt> </dl> </td> <td width="60%"> Controls scope of
///                     operation. When this flag is not set, service addresses are managed as a group. A register or removal from the
///                     registry invalidates all existing addresses before adding the given address set. When set, the action is only
///                     performed on the given address set. A register does not invalidate existing addresses and a removal from the
///                     registry only invalidates the given set of addresses. </td> </tr> </table>
///Returns:
///    The return value for <b>WSASetService</b> is zero if the operation was successful. Otherwise, the value
///    SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEACCES</b></dt> </dl> </td> <td
///    width="60%"> The calling routine does not have sufficient privileges to install the Service. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> One or more required parameters were
///    invalid or missing. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td
///    width="60%"> The <i>Ws2_32.dll</i> has not been initialized. The application must first call WSAStartup before
///    calling any Windows Sockets functions. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSASetServiceW(WSAQUERYSETW* lpqsRegInfo, WSAESETSERVICEOP essoperation, uint dwControlFlags);

///The <b>WSAProviderConfigChange</b> function notifies the application when the provider configuration is changed.
///Params:
///    lpNotificationHandle = Pointer to notification handle. If the notification handle is set to <b>NULL</b> (the handle value not the
///                           pointer itself), this function returns a notification handle in the location pointed to by
///                           <i>lpNotificationHandle</i>.
///    lpOverlapped = Pointer to a WSAOVERLAPPED structure.
///    lpCompletionRoutine = Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
///                          Pointer to the completion routine called when the provider change notification is received.
///Returns:
///    If no error occurs the <b>WSAProviderConfigChange</b> returns 0. Otherwise, a value of SOCKET_ERROR is returned
///    and a specific error code may be retrieved by calling WSAGetLastError. The error code WSA_IO_PENDING indicates
///    that the overlapped operation has been successfully initiated and that completion (and thus change event) will be
///    indicated at a later time. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call must occur before
///    using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td
///    width="60%"> The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> Not enough free memory available to complete
///    the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_INVALID_HANDLE</b></dt> </dl> </td> <td
///    width="60%"> Value pointed by <i>lpNotificationHandle</i> parameter is not a valid notification handle. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> Current operating
///    system environment does not support provider installation or removal without restart. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAProviderConfigChange(ptrdiff_t* lpNotificationHandle, OVERLAPPED* lpOverlapped, 
                            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

///The <b>WSAPoll</b> function determines status of one or more sockets.
///Params:
///    fdArray = An array of one or more <b>POLLFD</b> structures specifying the set of sockets for which status is requested. The
///              array must contain at least one structure with a valid socket. Upon return, this parameter receives the updated
///              sockets with the <b>revents</b> status flags member set on each one that matches the status query criteria.
///    fds = The number of <b>WSAPOLLFD</b> structures in <i>fdarray</i>. This is not necessarily the number of sockets for
///          which status is requested.
///    timeout = A value that specifies the wait behavior, based on the following values. <table> <tr> <th>Value</th>
///              <th>Meaning</th> </tr> <tr> <td>Greater than zero</td> <td>The time, in milliseconds, to wait.</td> </tr> <tr>
///              <td>Zero</td> <td>Return immediately.</td> </tr> <tr> <td>Less than zero</td> <td>Wait indefinitely.</td> </tr>
///              </table>
///Returns:
///    Returns one of the following values. <table> <tr> <th>Return value</th> <th>Description</th> </tr> <tr>
///    <td>Zero</td> <td>No sockets were in the queried state before the timer expired.</td> </tr> <tr> <td>Greater than
///    zero</td> <td>The number of elements in <i>fdarray</i> for which an <b>revents</b> member of the <b>POLLFD</b>
///    structure is nonzero.</td> </tr> <tr> <td>SOCKET_ERROR</td> <td>An error occurred. Call the WSAGetLastError
///    function to retrieve the extended error code.</td> </tr> </table> <table> <tr> <th>Extended Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> The
///    network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> An exception occurred while reading user input parameters. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed. This error is returned if
///    the WSAPOLLFD structures pointed to by the <i>fdarray</i> parameter when requesting socket status. This error is
///    also returned if none of the sockets specified in the <b>fd</b> member of any of the <b>WSAPOLLFD</b> structures
///    pointed to by the <i>fdarray</i> parameter were valid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> The function was unable to allocate sufficient memory.
///    </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAPoll(WSAPOLLFD* fdArray, uint fds, int timeout);

@DllImport("ntdll")
int RtlIpv4AddressToStringExA(const(in_addr)* Address, ushort Port, const(char)* AddressString, 
                              uint* AddressStringLength);

@DllImport("ntdll")
int RtlIpv4StringToAddressExA(const(char)* AddressString, ubyte Strict, in_addr* Address, ushort* Port);

@DllImport("ntdll")
int RtlIpv6AddressToStringExA(const(in6_addr)* Address, uint ScopeId, ushort Port, const(char)* AddressString, 
                              uint* AddressStringLength);

@DllImport("ntdll")
int RtlIpv6StringToAddressExA(const(char)* AddressString, in6_addr* Address, uint* ScopeId, ushort* Port);

///The <b>WSARecvEx</b> function receives data from a connected socket or a bound connectionless socket. The
///<b>WSARecvEx</b> function is similar to the recv function, except that the <i>flags</i> parameter is used only to
///return information. When a partial message is received while using datagram protocol, the MSG_PARTIAL bit is set in
///the <i>flags</i> parameter on return from the function. <div class="alert"><b>Note</b> The <b>WSARecvEx</b> function
///is a Microsoft-specific extension to the Windows Sockets specification.</div><div> </div>
///Params:
///    s = A descriptor that identifies a connected socket.
///    buf = A pointer to the buffer to receive the incoming data.
///    len = The length, in bytes, of the buffer pointed to by the <i>buf</i> parameter.
///    flags = An indicator specifying whether the message is fully or partially received for datagram sockets.
///Returns:
///    If no error occurs, <b>WSARecvEx</b> returns the number of bytes received. If the connection has been closed, it
///    returns zero. Additionally, if a partial message was received, the MSG_PARTIAL bit is set in the <i>flags</i>
///    parameter. If a complete message was received, MSG_PARTIAL is not set in <i>flags</i> Otherwise, a value of
///    SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError. <div
///    class="alert"><b>Important</b> For a stream oriented-transport protocol, MSG_PARTIAL is never set on return from
///    <b>WSARecvEx</b>. This function behaves identically to the recv function for stream-transport protocols.</div>
///    <div> </div> <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAECONNABORTED</b></dt> </dl> </td> <td width="60%"> The virtual circuit was terminated due to a time-out
///    or other failure. The application should close the socket as it is no longer usable. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> The virtual circuit was reset by the
///    remote side executing a hard or abortive close. The application should close the socket as it is no longer
///    usable. On a UPD-datagram socket this error would indicate that a previous send operation resulted in an ICMP
///    "Port Unreachable" message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The <i>buf</i> parameter is not completely contained in a valid part of the user address space.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINPROGRESS</b></dt> </dl> </td> <td width="60%"> A blocking
///    Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINTR</b></dt> </dl> </td> <td width="60%"> The (blocking) call was
///    canceled by the WSACancelBlockingCall call. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt>
///    </dl> </td> <td width="60%"> The socket has not been bound with bind, or an unknown flag was specified, or
///    MSG_OOB was specified for a socket with SO_OOBINLINE enabled or (for byte stream sockets only) <i>len</i> was
///    zero or negative. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%">
///    The network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENETRESET</b></dt> </dl> </td>
///    <td width="60%"> For a connection-oriented socket, this error indicates that the connection has been broken due
///    to <i>keep-alive</i> activity that detected a failure while the operation was in progress. For a datagram socket,
///    this error indicates that the time to live has expired. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTCONN</b></dt> </dl> </td> <td width="60%"> The socket is not connected. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor is not a socket. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEOPNOTSUPP</b></dt> </dl> </td> <td width="60%"> MSG_OOB was
///    specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the
///    communication domain associated with this socket, or the socket is unidirectional and supports only send
///    operations. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%"> The
///    socket has been shut down; it is not possible to use WSARecvEx on a socket after shutdown has been invoked with
///    <i>how</i> set to SD_RECEIVE or SD_BOTH. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAETIMEDOUT</b></dt>
///    </dl> </td> <td width="60%"> The connection has been dropped because of a network failure or because the peer
///    system failed to respond. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEWOULDBLOCK</b></dt> </dl> </td> <td
///    width="60%"> The socket is marked as nonblocking and the receive operation would block. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int WSARecvEx(size_t s, char* buf, int len, int* flags);

///The <b>TransmitFile</b> function transmits file data over a connected socket handle. This function uses the operating
///system's cache manager to retrieve the file data, and provides high-performance file data transfer over sockets.<div
///class="alert"><b>Note</b> This function is a Microsoft-specific extension to the Windows Sockets specification.</div>
///<div> </div>
///Params:
///    hSocket = A handle to a connected socket. The <b>TransmitFile</b> function will transmit the file data over this socket.
///              The socket specified by the <i>hSocket</i> parameter must be a connection-oriented socket of type
///              <b>SOCK_STREAM</b>, <b>SOCK_SEQPACKET</b>, or <b>SOCK_RDM</b>.
///    hFile = A handle to the open file that the <b>TransmitFile</b> function transmits. Since the operating system reads the
///            file data sequentially, you can improve caching performance by opening the handle with FILE_FLAG_SEQUENTIAL_SCAN.
///            The <i>hFile</i> parameter is optional. If the <i>hFile</i> parameter is <b>NULL</b>, only data in the header
///            and/or the tail buffer is transmitted. Any additional action, such as socket disconnect or reuse, is performed as
///            specified by the <i>dwFlags</i> parameter.
///    nNumberOfBytesToWrite = The number of bytes in the file to transmit. The <b>TransmitFile</b> function completes when it has sent the
///                            specified number of bytes, or when an error occurs, whichever occurs first. Set this parameter to zero in order
///                            to transmit the entire file.
///    nNumberOfBytesPerSend = The size, in bytes, of each block of data sent in each send operation. This parameter is used by Windows' sockets
///                            layer to determine the block size for send operations. To select the default send size, set this parameter to
///                            zero. The <i>nNumberOfBytesPerSend</i> parameter is useful for protocols that have limitations on the size of
///                            individual send requests.
///    lpOverlapped = A pointer to an OVERLAPPED structure. If the socket handle has been opened as overlapped, specify this parameter
///                   in order to achieve an overlapped (asynchronous) I/O operation. By default, socket handles are opened as
///                   overlapped. You can use the <i>lpOverlapped</i> parameter to specify a 64-bit offset within the file at which to
///                   start the file data transfer by setting the <b>Offset</b> and <b>OffsetHigh</b> member of the OVERLAPPED
///                   structure. If <i>lpOverlapped</i> is a <b>NULL</b> pointer, the transmission of data always starts at the current
///                   byte offset in the file. When the <i>lpOverlapped</i> is not <b>NULL</b>, the overlapped I/O might not finish
///                   before <b>TransmitFile</b> returns. In that case, the <b>TransmitFile</b> function returns <b>FALSE</b>, and
///                   WSAGetLastError returns ERROR_IO_PENDING or WSA_IO_PENDING. This enables the caller to continue processing while
///                   the file transmission operation completes. Windows will set the event specified by the <b>hEvent</b> member of
///                   the OVERLAPPED structure, or the socket specified by <i>hSocket</i>, to the signaled state upon completion of the
///                   data transmission request.
///    lpTransmitBuffers = A pointer to a TRANSMIT_FILE_BUFFERS data structure that contains pointers to data to send before and after the
///                        file data is sent. This parameter should be set to a <b>NULL</b> pointer if you want to transmit only the file
///                        data.
///    dwReserved = A set of flags used to modify the behavior of the <b>TransmitFile</b> function call. The <i>dwFlags</i> parameter
///                 can contain a combination of the following options defined in the <i>Mswsock.h</i> header file: <table> <tr>
///                 <th>Flag</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="TF_DISCONNECT"></a><a
///                 id="tf_disconnect"></a><dl> <dt><b>TF_DISCONNECT</b></dt> </dl> </td> <td width="60%"> Start a transport-level
///                 disconnect after all the file data has been queued for transmission. </td> </tr> <tr> <td width="40%"><a
///                 id="TF_REUSE_SOCKET"></a><a id="tf_reuse_socket"></a><dl> <dt><b>TF_REUSE_SOCKET</b></dt> </dl> </td> <td
///                 width="60%"> Prepare the socket handle to be reused. This flag is valid only if <b>TF_DISCONNECT</b> is also
///                 specified. When the <b>TransmitFile</b> request completes, the socket handle can be passed to the function call
///                 previously used to establish the connection, such as AcceptEx or ConnectEx. Such reuse is mutually exclusive; for
///                 example, if the <b>AcceptEx</b> function was called for the socket, reuse is allowed only for subsequent calls to
///                 the <b>AcceptEx</b> function, and not allowed for a subsequent call to <b>ConnectEx</b>. <div
///                 class="alert"><b>Note</b> The socket level file transmit is subject to the behavior of the underlying transport.
///                 For example, a TCP socket may be subject to the TCP TIME_WAIT state, causing the <b>TransmitFile</b> call to be
///                 delayed.</div> <div> </div> </td> </tr> <tr> <td width="40%"><a id="TF_USE_DEFAULT_WORKER"></a><a
///                 id="tf_use_default_worker"></a><dl> <dt><b>TF_USE_DEFAULT_WORKER</b></dt> </dl> </td> <td width="60%"> Directs
///                 the Windows Sockets service provider to use the system's default thread to process long <b>TransmitFile</b>
///                 requests. The system default thread can be adjusted using the following registry parameter as a <b>REG_DWORD</b>:
///                 <b>HKEY_LOCAL_MACHINE</b>&
///Returns:
///    If the <b>TransmitFile</b> function succeeds, the return value is <b>TRUE</b>. Otherwise, the return value is
///    <b>FALSE</b>. To get extended error information, call WSAGetLastError. An error code of WSA_IO_PENDING or
///    ERROR_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will
///    be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully
///    initiated and no completion indication will occur. Applications should handle either ERROR_IO_PENDING or
///    WSA_IO_PENDING in this case. <table> <tr> <th>Return code</th> <th>Description</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAECONNABORTED</b></dt> </dl> </td> <td width="60%"> An established connection was aborted by the
///    software in your host machine. This error is returned if the virtual circuit was terminated due to a time-out or
///    other failure. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%">
///    An existing connection was forcibly closed by the remote host. This error is returned for a stream socket when
///    the virtual circuit was reset by the remote side. The application should close the socket as it is no longer
///    usable. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The system
///    detected an invalid pointer address in attempting to use a pointer argument in a call. This error is returned if
///    the <i>lpTransmitBuffers</i> or <i>lpOverlapped</i> parameter is not totally contained in a valid part of the
///    user address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%">
///    An invalid argument was supplied. This error is returned if the <i>hSocket</i> parameter specified a socket of
///    type <b>SOCK_DGRAM</b> or <b>SOCK_RAW</b>. This error is returned if the <i>dwFlags</i> parameter has the
///    <b>TF_REUSE_SOCKET</b> flag set, but the <b>TF_DISCONNECT</b> flag was not set. This error is also returned if
///    the offset specified in the OVERLAPPED structure pointed to by the <i>lpOverlapped</i> is not within the file.
///    This error is also returned if the <i>nNumberOfBytesToWrite</i> parameter is set to a value greater than
///    2,147,483,646, the maximum value for a 32-bit integer minus 1. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETDOWN</b></dt> </dl> </td> <td width="60%"> A socket operation encountered a dead network.This error
///    is returned if the network subsystem has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENETRESET</b></dt> </dl> </td> <td width="60%"> The connection has been broken due to keep-alive
///    activity detecting a failure while the operation was in progress. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> An operation on a socket could not be performed because
///    the system lacked sufficient buffer space or because a queue was full. This error is also returned if the Windows
///    Sockets provider reports a buffer deadlock. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTCONN</b></dt>
///    </dl> </td> <td width="60%"> A request to send or receive data was disallowed because the socket is not
///    connected. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> An
///    operation was attempted on something that is not a socket. This error is returned if the <i>hSocket</i> parameter
///    is not a socket. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAESHUTDOWN</b></dt> </dl> </td> <td width="60%">
///    A request to send or receive data was disallowed because the socket had already been shut down in that direction
///    with a previous shutdown call. This error is returned if the socket has been shut down for sending. It is not
///    possible to call TransmitFile on a socket after the shutdown function has been called on the socket with the
///    <i>how</i> parameter set to <b>SD_SEND</b> or <b>SD_BOTH</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> Either the application has not called the
///    WSAStartup function, or <b>WSAStartup</b> failed. A successful <b>WSAStartup</b> call must occur before using the
///    TransmitFile function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_IO_PENDING</b></dt> </dl> </td> <td
///    width="60%"> An overlapped I/O operation is in progress. This value is returned if an overlapped I/O operation
///    was successfully initiated and indicates that completion will be indicated at a later time. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_OPERATION_ABORTED</b></dt> </dl> </td> <td width="60%"> The I/O operation has been
///    aborted because of either a thread exit or an application request. This error is returned if the overlapped
///    operation has been canceled due to the closure of the socket, the execution of the "SIO_FLUSH" command in
///    WSAIoctl, or the thread that initiated the overlapped request exited before the operation completed. <div
///    class="alert"><b>Note</b> All I/O initiated by a given thread is canceled when that thread exits. For overlapped
///    sockets, pending asynchronous operations can fail if the thread is closed before the asynchronous operations
///    complete. For more information, see ExitThread.</div> <div> </div> </td> </tr> </table>
///    
@DllImport("MSWSOCK")
BOOL TransmitFile(size_t hSocket, HANDLE hFile, uint nNumberOfBytesToWrite, uint nNumberOfBytesPerSend, 
                  OVERLAPPED* lpOverlapped, TRANSMIT_FILE_BUFFERS* lpTransmitBuffers, uint dwReserved);

///The <b>AcceptEx</b> function accepts a new connection, returns the local and remote address, and receives the first
///block of data sent by the client application. <div class="alert"><b>Note</b> This function is a Microsoft-specific
///extension to the Windows Sockets specification.</div> <div> </div>
///Params:
///    sListenSocket = A descriptor identifying a socket that has already been called with the listen function. A server application
///                    waits for attempts to connect on this socket.
///    sAcceptSocket = A descriptor identifying a socket on which to accept an incoming connection. This socket must not be bound or
///                    connected.
///    lpOutputBuffer = A pointer to a buffer that receives the first block of data sent on a new connection, the local address of the
///                     server, and the remote address of the client. The receive data is written to the first part of the buffer
///                     starting at offset zero, while the addresses are written to the latter part of the buffer. This parameter must be
///                     specified.
///    dwReceiveDataLength = The number of bytes in <i>lpOutputBuffer</i> that will be used for actual receive data at the beginning of the
///                          buffer. This size should not include the size of the local address of the server, nor the remote address of the
///                          client; they are appended to the output buffer. If <i>dwReceiveDataLength</i> is zero, accepting the connection
///                          will not result in a receive operation. Instead, <b>AcceptEx</b> completes as soon as a connection arrives,
///                          without waiting for any data.
///    dwLocalAddressLength = The number of bytes reserved for the local address information. This value must be at least 16 bytes more than
///                           the maximum address length for the transport protocol in use.
///    dwRemoteAddressLength = The number of bytes reserved for the remote address information. This value must be at least 16 bytes more than
///                            the maximum address length for the transport protocol in use. Cannot be zero.
///    lpdwBytesReceived = A pointer to a <b>DWORD</b> that receives the count of bytes received. This parameter is set only if the
///                        operation completes synchronously. If it returns ERROR_IO_PENDING and is completed later, then this <b>DWORD</b>
///                        is never set and you must obtain the number of bytes read from the completion notification mechanism.
///    lpOverlapped = An OVERLAPPED structure that is used to process the request. This parameter must be specified; it cannot be
///                   <b>NULL</b>.
///Returns:
///    If no error occurs, the <b>AcceptEx</b> function completed successfully and a value of <b>TRUE</b> is returned.
///    If the function fails, <b>AcceptEx</b> returns <b>FALSE</b>. The WSAGetLastError function can then be called to
///    return extended error information. If <b>WSAGetLastError</b> returns <b>ERROR_IO_PENDING</b>, then the operation
///    was successfully initiated and is still in progress. If the error is WSAECONNRESET, an incoming connection was
///    indicated, but was subsequently terminated by the remote peer prior to accepting the call.
///    
@DllImport("MSWSOCK")
BOOL AcceptEx(size_t sListenSocket, size_t sAcceptSocket, char* lpOutputBuffer, uint dwReceiveDataLength, 
              uint dwLocalAddressLength, uint dwRemoteAddressLength, uint* lpdwBytesReceived, 
              OVERLAPPED* lpOverlapped);

///The <b>GetAcceptExSockaddrs</b> function parses the data obtained from a call to the AcceptEx function and passes the
///local and remote addresses to a sockaddr structure.<div class="alert"><b>Note</b> This function is a
///Microsoft-specific extension to the Windows Sockets specification.</div> <div> </div>
///Params:
///    lpOutputBuffer = A pointer to a buffer that receives the first block of data sent on a connection resulting from an AcceptEx call.
///                     Must be the same <i>lpOutputBuffer</i> parameter that was passed to the <b>AcceptEx</b>function.
///    dwReceiveDataLength = The number of bytes in the buffer used for receiving the first data. This value must be equal to the
///                          <i>dwReceiveDataLength</i> parameter that was passed to the AcceptExfunction.
///    dwLocalAddressLength = The number of bytes reserved for the local address information. This value must be equal to the
///                           <i>dwLocalAddressLength</i> parameter that was passed to the AcceptEx function.
///    dwRemoteAddressLength = The number of bytes reserved for the remote address information. This value must be equal to the
///                            <i>dwRemoteAddressLength</i> parameter that was passed to the AcceptEx function.
///    LocalSockaddr = A pointer to the sockaddr structure that receives the local address of the connection (the same information that
///                    would be returned by the getsockname function). This parameter must be specified.
///    LocalSockaddrLength = The size, in bytes, of the local address. This parameter must be specified.
///    RemoteSockaddr = A pointer to the sockaddr structure that receives the remote address of the connection (the same information that
///                     would be returned by the getpeername function). This parameter must be specified.
///    RemoteSockaddrLength = The size, in bytes, of the local address. This parameter must be specified.
@DllImport("MSWSOCK")
void GetAcceptExSockaddrs(char* lpOutputBuffer, uint dwReceiveDataLength, uint dwLocalAddressLength, 
                          uint dwRemoteAddressLength, SOCKADDR** LocalSockaddr, int* LocalSockaddrLength, 
                          SOCKADDR** RemoteSockaddr, int* RemoteSockaddrLength);

///The **WSCEnumProtocols** function retrieves information about available transport protocols.
///Params:
///    lpiProtocols = A **NULL**-terminated array of <i>iProtocol</i> values. This parameter is optional; if <i>lpiProtocols</i> is
///                   NULL, information on all available protocols is returned. Otherwise, information is retrieved only for those
///                   protocols listed in the array.
///    lpProtocolBuffer = A pointer to a buffer that is filled with WSAPROTOCOL_INFOW structures.
///    lpdwBufferLength = On input, size of the <i>lpProtocolBuffer</i> buffer passed to **WSCEnumProtocols**, in bytes. On output, the
///                       minimum buffer size, in bytes, that can be passed to **WSCEnumProtocols** to retrieve all the requested
///                       information.
///    lpErrno = A pointer to the error code.
///Returns:
///    If no error occurs, **WSCEnumProtocols** returns the number of protocols to be reported on. Otherwise, a value of
///    SOCKET_ERROR is returned and a specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td
///    width="60%"> One of more of the arguments is not in a valid part of the user address space. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> Indicates that one of the specified
///    parameters was invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOBUFS</b></dl> </dl> </td> <td
///    width="60%"> Buffer length was too small to receive all the relevant WSAProtocol_Info structures and associated
///    information. Pass in a buffer at least as large as the value returned in <i>lpdwBufferLength</i>. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
int WSCEnumProtocols(int* lpiProtocols, char* lpProtocolBuffer, uint* lpdwBufferLength, int* lpErrno);

///The **WSCDeinstallProvider** function removes the specified transport provider from the system configuration
///database.
///Params:
///    lpProviderId = A pointer to a globally unique identifier (GUID) for the provider. This value is stored within each
///                   WSAProtocol_Info structure.
///    lpErrno = A pointer to the error code if the function fails.
///Returns:
///    If no error occurs, **WSCDeinstallProvider** returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific
///    error code is available in <i>lpErrno</i>. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> The <i>lpProviderId</i> parameter does
///    not specify a valid provider. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td
///    width="60%"> The <i>lpErrno</i> parameter is not in a valid part of the user address space. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dl> </dl> </td> <td width="60%"> A nonrecoverable error occurred.
///    This error is returned under several conditions including the following: the user lacks the administrative
///    privileges required to write to the Windows Sockets registry, or a failure occurred when opening a catalog entry.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%">
///    Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new
///    catalog entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCDeinstallProvider(GUID* lpProviderId, int* lpErrno);

///<div class="alert">**Note** Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server
///2012, use Windows Filtering Platform.</div><div> </div>The **WSCInstallProvider** function installs the specified
///transport provider into the system configuration database.
///Params:
///    lpProviderId = A pointer to a globally unique identifier (GUID) for the provider.
///    lpszProviderDllPath = A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual
///                          rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such
///                          environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an
///                          application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to
///                          the LoadLibrary function which loads the provider into memory. For more information, see **LoadLibrary**.
///    lpProtocolInfoList = A pointer to an array of WSAProtocol_Info structures. Each structure defines a protocol, address family, and
///                         socket type supported by the provider.
///    dwNumberOfEntries = The number of entries in the <i>lpProtocolInfoList</i> array.
///    lpErrno = A pointer to the error code if the function fails.
///Returns:
///    If **WSCInstallProvider** succeeds, it returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific error
///    code is returned in the <i>lpErrno</i> parameter. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> One or more of the arguments is not
///    in a valid part of the user address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl>
///    </td> <td width="60%"> One or more of the arguments are invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dl> </dl> </td> <td width="60%"> Memory cannot be allocated for buffers. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dl> </dl> </td> <td width="60%"> A nonrecoverable error
///    occurred. This error is returned under several conditions including the following: the provider is already
///    installed, the user lacks the administrative privileges required to write to the Winsock registry, or a failure
///    occurred when creating or installing a catalog entry. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSASYSCALLFAILURE</b></dl> </dl> </td> <td width="60%"> A system call that should never fail has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%">
///    Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new
///    catalog entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCInstallProvider(GUID* lpProviderId, const(wchar)* lpszProviderDllPath, char* lpProtocolInfoList, 
                       uint dwNumberOfEntries, int* lpErrno);

///The **WSCGetProviderPath** function retrieves the DLL path for the specified provider.
///Params:
///    lpProviderId = A pointer to a globally unique identifier (GUID) for the provider. This value is obtained by using
///                   WSCEnumProtocols.
///    lpszProviderDllPath = A pointer to a buffer into which the provider DLL's path string is returned. The path is a null-terminated string
///                          and any embedded environment strings, such as %SystemRoot%, have not been expanded.
///    lpProviderDllPathLen = The size, in characters, of the buffer pointed to by the <i>lpszProviderDllPath</i> parameter.
///    lpErrno = A pointer to the error code if the function fails.
///Returns:
///    If no error occurs, **WSCGetProviderPath** returns zero. Otherwise, it returns SOCKET_ERROR. The specific error
///    code is available in <i>lpErrno</i>. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> The <i>lpProviderId</i> parameter does
///    not specify a valid provider. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td
///    width="60%"> The <i>lpszProviderDllPath</i> or <i>lpErrno</i> parameter is not in a valid part of the user
///    address space, or <i>lpProviderDllPathLen</i> is too small. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCGetProviderPath(GUID* lpProviderId, char* lpszProviderDllPath, int* lpProviderDllPathLen, int* lpErrno);

///The **WSCUpdateProvider** function modifies the specified transport provider in the system configuration database.
///Params:
///    lpProviderId = A pointer to a globally unique identifier (GUID) for the provider.
///    lpszProviderDllPath = A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the
///                          usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such
///                          environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an
///                          application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to
///                          the LoadLibrary function which loads the provider into memory. For more information, see **LoadLibrary**.
///    lpProtocolInfoList = A pointer to an array of WSAProtocol_Info structures. Each structure specifies or modifies a protocol, address
///                         family, and socket type supported by the provider.
///    dwNumberOfEntries = The number of entries in the <i>lpProtocolInfoList</i> array.
///    lpErrno = A pointer to the error code if the function fails.
///Returns:
///    If no error occurs, **WSCUpdateProvider** returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific
///    error code is returned in the <i>lpErrno</i> parameter. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> One or more of the arguments
///    are not in a valid part of the user address space. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> One or more of the arguments are invalid. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dl> </dl> </td> <td width="60%"> A nonrecoverable error
///    occurred. This error is returned under several conditions including the following: the user lacks the
///    administrative privileges required to write to the Winsock registry, or a failure occurred when opening or
///    writing a catalog entry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td>
///    <td width="60%"> Insufficient memory was available. This error is returned when there is insufficient memory to
///    allocate a new catalog entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCUpdateProvider(GUID* lpProviderId, const(wchar)* lpszProviderDllPath, char* lpProtocolInfoList, 
                      uint dwNumberOfEntries, int* lpErrno);

///<div class="alert">**Note** Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server
///2012, use Windows Filtering Platform.</div><div> </div>The **WSCSetProviderInfo** function sets the data value for
///the specified information class for a layered service provider (LSP).
///Params:
///    lpProviderId = A pointer to a globally unique identifier (GUID) for the provider.
///    InfoType = The information class to be set for this LSP protocol entry.
///    Info = A pointer to a buffer that contains the information class data to set for the LSP protocol entry.
///    InfoSize = The size, in bytes, of the buffer pointed to by the <i>Info </i>parameter.
///    Flags = The flags used to modify the behavior of the **WSCSetProviderInfo** function call.
///    lpErrno = A pointer to the error code if the function fails.
///Returns:
///    If no error occurs, **WSCSetProviderInfo** returns **ERROR_SUCCESS** (zero). Otherwise, it returns
///    **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dl> </dl>
///    </td> <td width="60%"> The call is not implemented. This error is returned if **ProviderInfoAudit** is specified
///    in the <i>InfoType</i> parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td>
///    <td width="60%"> One or more of the arguments is not in a valid part of the user address space. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> One or more of the arguments are
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dl> </dl> </td> <td width="60%"> A
///    nonrecoverable error occurred. This error is returned under several conditions including the following: the user
///    lacks the administrative privileges required to write to the Winsock registry, or a failure occurred when opening
///    a Winsock catalog entry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td>
///    <td width="60%"> Insufficient memory was available. This error is returned when there is insufficient memory to
///    allocate a new catalog entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCSetProviderInfo(GUID* lpProviderId, WSC_PROVIDER_INFO_TYPE InfoType, char* Info, size_t InfoSize, 
                       uint Flags, int* lpErrno);

///<div class="alert">**Note** Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server
///2012, use Windows Filtering Platform.</div><div> </div>The **WSCGetProviderInfo** function retrieves the data
///associated with an information class for a layered service provider (LSP).
///Params:
///    lpProviderId = A pointer to a globally unique identifier (GUID) for the provider.
///    InfoType = The information class that is requested for this LSP protocol entry.
///    Info = A pointer to a buffer to receive the information class data for the requested LSP protocol entry. If this
///           parameter is **NULL**, then **WSCGetProviderInfo** returns failure and the size required for this buffer is
///           returned in the <i>InfoSize</i> parameter.
///    InfoSize = The size, in bytes, of the buffer pointed to by the <i>Info </i>parameter. If the Info parameter is **NULL**,
///               then **WSCGetProviderInfo** returns failure and the <i>InfoSize</i> parameter will receive the size of the
///               required buffer.
///    Flags = The flags used to modify the behavior of the **WSCGetProviderInfo** function call.
///    lpErrno = A pointer to the error code if the function fails.
///Returns:
///    If no error occurs, **WSCGetProviderInfo** returns **ERROR_SUCCESS** (zero). Otherwise, it returns
///    **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dl> </dl>
///    </td> <td width="60%"> The call is not implemented. This error is returned if **ProviderInfoAudit** is specified
///    in the <i>InfoType</i> parameter. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td>
///    <td width="60%"> One or more of the arguments is not in a valid part of the user address space. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> One or more of the arguments are
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVALIDPROVIDER</b></dl> </dl> </td> <td width="60%">
///    The protocol entry could not be found for the specified <i>lpProviderId</i>. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSANO_RECOVERY</b></dl> </dl> </td> <td width="60%"> A nonrecoverable error occurred. This error is
///    returned under several conditions including the following: the user lacks the administrative privileges required
///    to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> Insufficient memory was
///    available. This error is returned when there is insufficient memory to allocate a new catalog entry. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
int WSCGetProviderInfo(GUID* lpProviderId, WSC_PROVIDER_INFO_TYPE InfoType, char* Info, size_t* InfoSize, 
                       uint Flags, int* lpErrno);

///<div class="alert">**Note** Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server
///2012, use Windows Filtering Platform.</div><div> </div>The **WSCSetApplicationCategory** function sets the permitted
///layered service provider (LSP) categories associated with an application.
///Params:
///    Path = A pointer to a Unicode string that contains the load path to the executable image for the application. This
///           string observes the usual rules for path resolution and can contain embedded environment strings (such as
///           <i>%SystemRoot%</i>).
///    PathLength = The length, in characters, of the <i>Path</i> parameter. This length does not include the terminating **NULL**.
///    Extra = A pointer to a Unicode string which represents the command line arguments used when starting the application
///            specified in the <i>Path</i> parameter. The <i>Extra</i> parameter is used to distinguish between multiple,
///            distinct instances of an application when launched with a consistent command line. This is to support different
///            application categorizations for different instances of Svchost.exe or Rundll32.exe. If only the <i>Path</i>
///            parameter is required and no command line arguments are needed to further distinguish between instances of an
///            application, then the <i>Extra</i> parameter should be set to **NULL**.
///    ExtraLength = The length, in characters, of the <i>Extra</i> parameter. This length does not include the terminating **NULL**.
///    PermittedLspCategories = A DWORD value of the LSP categories which are permitted for all instances of this application. The application is
///                             identified by the combination of the values of the <i>Path</i> and <i>Extra</i> parameters.
///    pPrevPermLspCat = A pointer to receive the previous set of permitted LSP categories which were permitted for all instances of this
///                      application. This parameter is optional can be **NULL**.
///    lpErrno = A pointer to the error code if the function fails.
///Returns:
///    If no error occurs, **WSCSetApplicationCategory** returns **ERROR_SUCCESS** (zero). Otherwise, it returns
///    **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td
///    width="60%"> One or more of the arguments is not in a valid part of the user address space. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> One or more of the arguments are
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dl> </dl> </td> <td width="60%"> A
///    nonrecoverable error occurred. This error is returned under several conditions including the following: the user
///    lacks the administrative privileges required to access the Winsock registry, or a failure occurred when opening a
///    Winsock catalog entry or an application ID entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCSetApplicationCategory(const(wchar)* Path, uint PathLength, const(wchar)* Extra, uint ExtraLength, 
                              uint PermittedLspCategories, uint* pPrevPermLspCat, int* lpErrno);

///<div class="alert">**Note** Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server
///2012, use Windows Filtering Platform.</div><div> </div>The **WSCGetApplicationCategory** function retrieves the
///layered service provider (LSP) categories associated with an application.
///Params:
///    Path = A pointer to a Unicode string that contains the load path to the executable image for the application. This
///           string observes the usual rules for path resolution and can contain embedded environment strings (such as
///           <i>%SystemRoot%</i>).
///    PathLength = The length, in characters, of the <i>Path</i> parameter. This length does not include the terminating **NULL**.
///    Extra = A pointer to a Unicode string which represents the command line arguments used when starting the application
///            specified in the <i>Path</i> parameter. The <i>Extra</i> parameter is used to distinguish between multiple,
///            distinct instances of an application when launched with a consistent command line. This is to support different
///            application categorizations for different instances of Svchost.exe or Rundll32.exe. If only the <i>Path</i>
///            parameter is required and no command line arguments are needed to further distinguish between instances of an
///            application, then the <i>Extra</i> parameter should be set to **NULL**.
///    ExtraLength = The length, in characters, of the <i>Extra</i> parameter. This length does not include the terminating **NULL**.
///    pPermittedLspCategories = A pointer to a DWORD value of permitted LSP categories which are permitted for all instances of this application.
///                              The application is identified by the combination of the values of the <i>Path</i> and <i>Extra</i> parameters.
///    lpErrno = A pointer to the error code if the function fails.
///Returns:
///    If no error occurs, **WSCGetApplicationCategory** returns **ERROR_SUCCESS** (zero). Otherwise, it returns
///    **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td
///    width="60%"> One or more of the arguments is not in a valid part of the user address space. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> One or more of the arguments are
///    invalid. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSASERVICE_NOT_FOUND</b></dl> </dl> </td> <td width="60%">
///    The service could not be found based on the <i>Path</i> and <i>Extra</i> parameters. The error can also be
///    returned if the application you are querying does not exist in the registry. In this case, the error indicates
///    that the application is not currently categorized. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_RECOVERY</b></dl> </dl> </td> <td width="60%"> A nonrecoverable error occurred. This error is
///    returned under several conditions including the following: the user lacks the administrative privileges required
///    to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry or an application ID
///    entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCGetApplicationCategory(const(wchar)* Path, uint PathLength, const(wchar)* Extra, uint ExtraLength, 
                              uint* pPermittedLspCategories, int* lpErrno);

///The **WPUCompleteOverlappedRequest** function performs overlapped I/O completion notification for overlapped I/O
///operations.
///Params:
///    s = The service provider socket created by WPUCreateSocketHandle.
///    lpOverlapped = A pointer to a WSAOVERLAPPED structure associated with the overlapped I/O operation whose completion is to be
///                   notified.
///    dwError = The completion status of the overlapped I/O operation whose completion is to be notified.
///    cbTransferred = The number of bytes transferred to or from client buffers (the direction of the transfer depends on the send or
///                    receive nature of the overlapped I/O operation whose completion is to be notified).
///    lpErrno = A pointer to the error code resulting from execution of this function.
///Returns:
///    If no error occurs, **WPUCompleteOverlappedRequest** returns zero and notifies completion of the overlapped I/O
///    operation according to the mechanism selected by the client (signals an event found in the WSAOVERLAPPED
///    structure referenced by <i>lpOverlapped</i> and/or queues a completion status report to the completion port
///    associated with the socket if a completion port is associated). Otherwise, **WPUCompleteOverlappedRequest**
///    returns SOCKET_ERROR, and a specific error code is available in <i>lpErrno</i>. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> The
///    socket passed in the <i>s</i> parameter is not a socket created by WPUCreateSocketHandle. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WPUCompleteOverlappedRequest(size_t s, OVERLAPPED* lpOverlapped, uint dwError, uint cbTransferred, 
                                 int* lpErrno);

///The **WSCInstallNameSpace** function installs a namespace provider. For providers that are able to support multiple
///namespaces, this function must be called for each namespace supported, and a unique provider identifier must be
///supplied each time.
///Params:
///    lpszIdentifier = A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed
///                     in the <i>lpProviderId</i> parameter.
///    lpszPathName = A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual
///                   rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such
///                   environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an
///                   application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to
///                   the LoadLibrary function which loads the provider into memory. For more information, see **LoadLibrary**.
///    dwNameSpace = The namespace supported by this provider.
///    dwVersion = The version number of the provider.
///    lpProviderId = A pointer to a GUID for the provider. This GUID should be generated by Uuidgen.exe.
///Returns:
///    If no error occurs, the **WSCInstallNameSpace** function returns **NO_ERROR** (zero). Otherwise, it returns
///    **SOCKET_ERROR** if the function fails, and you must retrieve the appropriate error code using the
///    WSAGetLastError function. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEACCES</b></dl> </dl> </td> <td width="60%"> The calling routine does not have sufficient privileges to
///    install a namespace. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> One or more of the arguments are invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_RECOVERY</b></dl> </dl> </td> <td width="60%"> A nonrecoverable error occurred. This error is
///    returned under several conditions including the following: the provider is already installed, the user lacks the
///    administrative privileges required to write to the Winsock registry, or a failure occurred when creating or
///    installing a catalog entry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSASYSCALLFAILURE</b></dl> </dl> </td>
///    <td width="60%"> A system call that should never fail has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> Insufficient memory was available. This error
///    is returned when there is insufficient memory to allocate a new catalog entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCInstallNameSpace(const(wchar)* lpszIdentifier, const(wchar)* lpszPathName, uint dwNameSpace, uint dwVersion, 
                        GUID* lpProviderId);

///The **WSCUnInstallNameSpace** function uninstalls the indicated name-space provider.
///Params:
///    lpProviderId = A pointer to a globally unique identifier (GUID) for the name-space provider to be uninstalled.
///Returns:
///    If no error occurs, **WSCUnInstallNameSpace** returns **NO_ERROR** (zero). Otherwise, it returns **SOCKET_ERROR**
///    if the function fails, and you must retrieve the appropriate error code using the WSAGetLastError function.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl>
///    </dl> </td> <td width="60%"> The <i>lpProviderId</i> parameter points to memory that is not in a valid part of
///    the user address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> The specified namespace–provider identifier is invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSASYSCALLFAILURE</b></dl> </dl> </td> <td width="60%"> A system call that should never fail has failed.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%">
///    Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new
///    catalog entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCUnInstallNameSpace(GUID* lpProviderId);

///The **WSCInstallNameSpaceEx** function installs a namespace provider. For providers that are able to support multiple
///namespaces, this function must be called for each namespace supported, and a unique provider identifier must be
///supplied each time.
///Params:
///    lpszIdentifier = A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed
///                     in the <i>lpProviderId</i> parameter.
///    lpszPathName = A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual
///                   rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such
///                   environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an
///                   application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to
///                   the LoadLibrary function which loads the provider into memory. For more information, see **LoadLibrary**.
///    dwNameSpace = The namespace supported by this provider.
///    dwVersion = The version number of the provider.
///    lpProviderId = A pointer to a GUID for the provider. This GUID should be generated by Uuidgen.exe.
///    lpProviderSpecific = A provider-specific data blob associated with namespace entry.
///Returns:
///    If no error occurs, the **WSCInstallNameSpaceEx** function returns **NO_ERROR** (zero). Otherwise, it returns
///    **SOCKET_ERROR** if the function fails, and you must retrieve the appropriate error code using the
///    WSAGetLastError function. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEACCES</b></dl> </dl> </td> <td width="60%"> The calling routine does not have sufficient privileges to
///    install a namespace. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> One or more of the arguments are invalid. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_RECOVERY</b></dl> </dl> </td> <td width="60%"> A nonrecoverable error occurred. This error is
///    returned under several conditions including the following: the provider is already installed, the user lacks the
///    administrative privileges required to write to the Winsock registry, or a failure occurred when creating or
///    installing a catalog entry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSASYSCALLFAILURE</b></dl> </dl> </td>
///    <td width="60%"> A system call that should never fail has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> Insufficient memory was available. This error
///    is returned when there is insufficient memory to allocate a new catalog entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCInstallNameSpaceEx(const(wchar)* lpszIdentifier, const(wchar)* lpszPathName, uint dwNameSpace, 
                          uint dwVersion, GUID* lpProviderId, BLOB* lpProviderSpecific);

///The **WSCEnableNSProvider** function changes the state of a given namespace provider. It is intended to give the
///end-user the ability to change the state of the namespace providers.
///Params:
///    lpProviderId = A pointer to a globally unique identifier (GUID) for the namespace provider.
///    fEnable = A Boolean value that, if **TRUE**, the provider is set to the active state. If **FALSE**, the provider is
///              disabled and will not be available for query operations or service registration.
///Returns:
///    If no error occurs, the **WSCEnableNSProvider** function returns **NO_ERROR** (zero). Otherwise, it returns
///    **SOCKET_ERROR** if the function fails, and you must retrieve the appropriate error code using the
///    WSAGetLastError function. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> The <i>lpProviderId</i> parameter points to memory that is
///    not in a valid part of the user address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl>
///    </dl> </td> <td width="60%"> The specified namespace provider identifier is invalid. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSASYSCALLFAILURE</b></dl> </dl> </td> <td width="60%"> A system call that should never
///    fail has failed. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td
///    width="60%"> Insufficient memory was available. This error is returned when there is insufficient memory to
///    allocate a new catalog entry. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCEnableNSProvider(GUID* lpProviderId, BOOL fEnable);

///The **WSAAdvertiseProvider** function makes a specific namespace version-2 provider available for all eligible
///clients.
///Params:
///    puuidProviderId = A pointer to the provider ID of the namespace provider to be advertised.
///    pNSPv2Routine = A pointer to a **NSPV2_ROUTINE** structure with the namespace service provider version-2 entry points supported
///                    by the provider.
///Returns:
///    If no error occurs, WSAProviderCompleteAsyncCall returns zero. If the function fails, the return value is
///    SOCKET_ERROR. To get extended error information, call WSAGetLastError, which returns one of the following
///    extended error values. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> An
///    internal error occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> A parameter was not valid. This error is returned if the <i>puuidProviderId</i> or
///    <i>pNSPv2Routine</i> parameters were **NULL**. This error is also returned if the **NSPv2LookupServiceBegin**,
///    **NSPv2LookupServiceNextEx**, or **NSPv2LookupServiceEnd** members of the **NSPV2_ROUTINE** structure pointed to
///    by the <i>pNSPv2Routine</i> parameter are **NULL**. A namespace version-2 provider must at least support name
///    resolution which this minimum set of functions. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVALIDPROVIDER</b></dl> </dl> </td> <td width="60%"> The namespace provider could not be found for
///    the specified <i>puuidProviderId</i> parameter. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANOTINITIALISED</b></dl> </dl> </td> <td width="60%"> The <i>Ws2_32.dll</i> has not been initialized.
///    The application must first call WSAStartup before calling any Windows Sockets functions. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAAdvertiseProvider(const(GUID)* puuidProviderId, const(NSPV2_ROUTINE)* pNSPv2Routine);

///The **WSAUnadvertiseProvider** function makes a specific namespace version-2 provider no longer available for
///clients.
///Params:
///    puuidProviderId = A pointer to the provider ID of the namespace provider.
///Returns:
///    If no error occurs, **WSAUnadvertiseProvider** returns zero. Otherwise, it returns **SOCKET_ERROR**, and a
///    specific error code is available by calling WSAGetLastError. <table> <tr> <th>Error code</th> <th>Meaning</th>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td width="60%"> A parameter was not
///    valid. This error is returned if the <i>puuidProviderId</i> parameter was **NULL**. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAUnadvertiseProvider(const(GUID)* puuidProviderId);

///The **WSAProviderCompleteAsyncCall** function notifies a client when an asynchronous call to a namespace version-2
///provider is completed.
///Params:
///    hAsyncCall = The handle passed to the asynchronous call being completed. This handle is passed by the client to the namespace
///                 version-2 provider in the asynchronous function call.
///    iRetCode = The return code for the asynchronous call to the namespace version-2 provider.
///Returns:
///    If no error occurs, **WSAProviderCompleteAsyncCall** returns zero. If the function fails, the return value is
///    SOCKET_ERROR. To get extended error information, call WSAGetLastError, which returns one of the following
///    extended error values. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dl> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dl> </dl> </td> <td width="60%"> An
///    internal error occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dl> </dl> </td> <td
///    width="60%"> A parameter was not valid. This error is returned if the <i>hAsyncCall</i> parameter was **NULL**.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dl> </dl> </td> <td width="60%"> The
///    <i>Ws2_32.dll</i> has not been initialized. The application must first call WSAStartup before calling any Windows
///    Sockets functions. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSAProviderCompleteAsyncCall(HANDLE hAsyncCall, int iRetCode);

///The <b>EnumProtocols</b> function retrieves information about a specified set of network protocols that are active on
///a local host. <div class="alert"><b>Note</b> The <b>EnumProtocols</b> function is a Microsoft-specific extension to
///the Windows Sockets 1.1 specification. This function is obsolete. For the convenience of Windows Sockets 1.1
///developers, the reference material is included. The WSAEnumProtocols function provides equivalent functionality in
///Windows Sockets 2.</div> <div> </div>
///Params:
///    lpiProtocols = A pointer to a <b>null</b>-terminated array of protocol identifiers. The <b>EnumProtocols</b> function retrieves
///                   information about the protocols specified by this array. If <i>lpiProtocols</i> is <b>NULL</b>, the function
///                   retrieves information about all available protocols. The following protocol identifier values are defined.
///                   <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_TCP"></a><a
///                   id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> </dl> </td> <td width="60%"> The Transmission Control
///                   Protocol (TCP), a connection-oriented stream protocol. </td> </tr> <tr> <td width="40%"><a
///                   id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> </dl> </td> <td width="60%"> The
///                   User Datagram Protocol (UDP), a connectionless datagram protocol. </td> </tr> <tr> <td width="40%"><a
///                   id="ISOPROTO_TP4"></a><a id="isoproto_tp4"></a><dl> <dt><b>ISOPROTO_TP4</b></dt> </dl> </td> <td width="60%"> The
///                   ISO connection-oriented transport protocol. </td> </tr> <tr> <td width="40%"><a id="NSPROTO_IPX"></a><a
///                   id="nsproto_ipx"></a><dl> <dt><b>NSPROTO_IPX</b></dt> </dl> </td> <td width="60%"> The Internet Packet Exchange
///                   (IPX) protocol, a connectionless datagram protocol. </td> </tr> <tr> <td width="40%"><a id="NSPROTO_SPX"></a><a
///                   id="nsproto_spx"></a><dl> <dt><b>NSPROTO_SPX</b></dt> </dl> </td> <td width="60%"> The Sequenced Packet Exchange
///                   (SPX) protocol, a connection-oriented stream protocol. </td> </tr> <tr> <td width="40%"><a
///                   id="NSPROTO_SPXII"></a><a id="nsproto_spxii"></a><dl> <dt><b>NSPROTO_SPXII</b></dt> </dl> </td> <td width="60%">
///                   The Sequenced Packet Exchange (SPX) protocol version 2, a connection-oriented stream protocol. </td> </tr>
///                   </table>
///    lpProtocolBuffer = A pointer to a buffer that the function fills with an array of PROTOCOL_INFO data structures.
///    lpdwBufferLength = A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by
///                       <i>lpProtocolBuffer</i>. On output, the function sets this variable to the minimum buffer size needed to retrieve
///                       all of the requested information. For the function to succeed, the buffer must be at least this size.
///Returns:
///    If the function succeeds, the return value is the number of PROTOCOL_INFO data structures written to the buffer
///    pointed to by <i>lpProtocolBuffer</i>. If the function fails, the return value is SOCKET_ERROR(–1). To get
///    extended error information, call GetLastError, which returns the following extended error code. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
///    </dl> </td> <td width="60%"> The buffer pointed to by <i>lpProtocolBuffer</i> was too small to receive all of the
///    relevant PROTOCOL_INFO structures. Call the function with a buffer at least as large as the value returned in
///    *<i>lpdwBufferLength</i>. </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int EnumProtocolsA(int* lpiProtocols, char* lpProtocolBuffer, uint* lpdwBufferLength);

///The <b>EnumProtocols</b> function retrieves information about a specified set of network protocols that are active on
///a local host. <div class="alert"><b>Note</b> The <b>EnumProtocols</b> function is a Microsoft-specific extension to
///the Windows Sockets 1.1 specification. This function is obsolete. For the convenience of Windows Sockets 1.1
///developers, the reference material is included. The WSAEnumProtocols function provides equivalent functionality in
///Windows Sockets 2.</div> <div> </div>
///Params:
///    lpiProtocols = A pointer to a <b>null</b>-terminated array of protocol identifiers. The <b>EnumProtocols</b> function retrieves
///                   information about the protocols specified by this array. If <i>lpiProtocols</i> is <b>NULL</b>, the function
///                   retrieves information about all available protocols. The following protocol identifier values are defined.
///                   <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="IPPROTO_TCP"></a><a
///                   id="ipproto_tcp"></a><dl> <dt><b>IPPROTO_TCP</b></dt> </dl> </td> <td width="60%"> The Transmission Control
///                   Protocol (TCP), a connection-oriented stream protocol. </td> </tr> <tr> <td width="40%"><a
///                   id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl> <dt><b>IPPROTO_UDP</b></dt> </dl> </td> <td width="60%"> The
///                   User Datagram Protocol (UDP), a connectionless datagram protocol. </td> </tr> <tr> <td width="40%"><a
///                   id="ISOPROTO_TP4"></a><a id="isoproto_tp4"></a><dl> <dt><b>ISOPROTO_TP4</b></dt> </dl> </td> <td width="60%"> The
///                   ISO connection-oriented transport protocol. </td> </tr> <tr> <td width="40%"><a id="NSPROTO_IPX"></a><a
///                   id="nsproto_ipx"></a><dl> <dt><b>NSPROTO_IPX</b></dt> </dl> </td> <td width="60%"> The Internet Packet Exchange
///                   (IPX) protocol, a connectionless datagram protocol. </td> </tr> <tr> <td width="40%"><a id="NSPROTO_SPX"></a><a
///                   id="nsproto_spx"></a><dl> <dt><b>NSPROTO_SPX</b></dt> </dl> </td> <td width="60%"> The Sequenced Packet Exchange
///                   (SPX) protocol, a connection-oriented stream protocol. </td> </tr> <tr> <td width="40%"><a
///                   id="NSPROTO_SPXII"></a><a id="nsproto_spxii"></a><dl> <dt><b>NSPROTO_SPXII</b></dt> </dl> </td> <td width="60%">
///                   The Sequenced Packet Exchange (SPX) protocol version 2, a connection-oriented stream protocol. </td> </tr>
///                   </table>
///    lpProtocolBuffer = A pointer to a buffer that the function fills with an array of PROTOCOL_INFO data structures.
///    lpdwBufferLength = A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by
///                       <i>lpProtocolBuffer</i>. On output, the function sets this variable to the minimum buffer size needed to retrieve
///                       all of the requested information. For the function to succeed, the buffer must be at least this size.
///Returns:
///    If the function succeeds, the return value is the number of PROTOCOL_INFO data structures written to the buffer
///    pointed to by <i>lpProtocolBuffer</i>. If the function fails, the return value is SOCKET_ERROR(–1). To get
///    extended error information, call GetLastError, which returns the following extended error code. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
///    </dl> </td> <td width="60%"> The buffer pointed to by <i>lpProtocolBuffer</i> was too small to receive all of the
///    relevant PROTOCOL_INFO structures. Call the function with a buffer at least as large as the value returned in
///    *<i>lpdwBufferLength</i>. </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int EnumProtocolsW(int* lpiProtocols, char* lpProtocolBuffer, uint* lpdwBufferLength);

///<p class="CCE_Message">[<b>GetAddressByName</b> is no longer available for use as of Windows Sockets 2. Instead, use
///the functions detailed in Protocol-Independent Name Resolution.] The <b>GetAddressByName</b> function queries a
///namespace, or a set of default namespaces, to retrieve network address information for a specified network service.
///This process is known as service name resolution. A network service can also use the function to obtain local address
///information that it can use with the bind function.
///Params:
///    dwNameSpace = The namespace, or set of default namespaces, that the operating system should query for network address
///                  information. Use one of the following constants to specify a namespace. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
///                  <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td width="60%"> A set of default namespaces. The function queries each
///                  namespace within this set. The set of default namespaces typically includes all the namespaces installed on the
///                  system. System administrators, however, can exclude particular namespaces from the set. This is the value that
///                  most applications should use for <i>dwNameSpace</i>. </td> </tr> <tr> <td width="40%"><a id="NS_DNS"></a><a
///                  id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The Domain Name System (DNS) used in the
///                  Internet for host name resolution. </td> </tr> <tr> <td width="40%"><a id="NS_NETBT"></a><a
///                  id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%"> The NetBIOS over TCP/IP layer. All
///                  operating systems register their computer names with NetBIOS. This namespace is used to convert a computer name
///                  to an IP address that uses this registration. Note that NS_NETBT can access a WINS server to perform the
///                  resolution. </td> </tr> <tr> <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl> <dt><b>NS_SAP</b></dt>
///                  </dl> </td> <td width="60%"> The NetWare Service Advertising Protocol. This can access the NetWare bindery if
///                  appropriate. NS_SAP is a dynamic namespace that allows registration of services. </td> </tr> <tr> <td
///                  width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl> <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td>
///                  <td width="60%"> Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\hosts file. </td> </tr> <tr> <td
///                  width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl> <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td>
///                  <td width="60%"> Local TCP/IP name resolution mechanisms, including comparisons against the local host name and
///                  looks up host names and IP addresses in cache of host to IP address mappings. </td> </tr> </table> Most calls to
///                  <b>GetAddressByName</b> should use the special value NS_DEFAULT. This lets a client get by with no knowledge of
///                  which namespaces are available on an internetwork. The system administrator determines namespace access.
///                  Namespaces can come and go without the client having to be aware of the changes.
///    lpServiceType = A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h
///                    header file includes definitions of several GUID service types, and macros for working with them. The Svcguid.h
///                    header file is not automatically included by the Winsock2.h header file.
///    lpServiceName = A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER".
///                    Setting <i>lpServiceName</i> to <b>NULL</b> is the equivalent of setting <i>dwResolution</i> to RES_SERVICE. The
///                    function operates in its second mode, obtaining the local address to which a service of the specified type should
///                    bind. The function stores the local address within the <b>LocalAddr</b> member of the CSADDR_INFO structures
///                    stored into *<i>lpCsaddrBuffer</i>. If <i>dwResolution</i> is set to RES_SERVICE, the function ignores the
///                    <i>lpServiceName</i> parameter. If <i>dwNameSpace</i> is set to NS_DNS, *<i>lpServiceName</i> is the name of the
///                    host.
///    lpiProtocols = A pointer to a zero-terminated array of protocol identifiers. The function restricts a name resolution attempt to
///                   namespace providers that offer these protocols. This lets the caller limit the scope of the search. If
///                   <i>lpiProtocols</i> is set to <b>NULL</b>, the function retrieves information on all available protocols.
///    dwResolution = A set of bit flags that specify aspects of the service name resolution process. The following bit flags are
///                   defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="RES_SERVICE"></a><a
///                   id="res_service"></a><dl> <dt><b>RES_SERVICE</b></dt> </dl> </td> <td width="60%"> If set, the function retrieves
///                   the address to which a service of the specified type should bind. This is the equivalent to setting the
///                   <i>lpServiceName</i> parameter to <b>NULL</b>. If this flag is clear, normal name resolution occurs. </td> </tr>
///                   <tr> <td width="40%"><a id="RES_FIND_MULTIPLE"></a><a id="res_find_multiple"></a><dl>
///                   <dt><b>RES_FIND_MULTIPLE</b></dt> </dl> </td> <td width="60%"> If this flag is set, the operating system performs
///                   an extensive search of all namespaces for the service. It asks every appropriate namespace to resolve the service
///                   name. If this flag is clear, the operating system stops looking for service addresses as soon as one is found.
///                   </td> </tr> <tr> <td width="40%"><a id="RES_SOFT_SEARCH"></a><a id="res_soft_search"></a><dl>
///                   <dt><b>RES_SOFT_SEARCH</b></dt> </dl> </td> <td width="60%"> This flag is valid if the namespace supports
///                   multiple levels of searching. If this flag is valid and set, the operating system performs a simple and quick
///                   search of the namespace. This is useful if an application only needs to obtain easy-to-find addresses for the
///                   service. If this flag is valid and clear, the operating system performs a more extensive search of the namespace.
///                   </td> </tr> </table>
///    lpServiceAsyncInfo = Reserved for future use; must be set to <b>NULL</b>.
///    lpCsaddrBuffer = A pointer to a buffer to receive one or more CSADDR_INFO data structures. The number of structures written to the
///                     buffer depends on the amount of information found in the resolution attempt. You should assume that multiple
///                     structures will be written, although in many cases there will only be one.
///    lpdwBufferLength = A pointer to a variable that, upon input, specifies the size, in bytes, of the buffer pointed to by
///                       <i>lpCsaddrBuffer</i>. Upon output, this variable contains the total number of bytes required to store the array
///                       of CSADDR_INFO structures. If this value is less than or equal to the input value of *<i>lpdwBufferLength</i>,
///                       and the function is successful, this is the number of bytes actually stored in the buffer. If this value is
///                       greater than the input value of *<i>lpdwBufferLength</i>, the buffer was too small, and the output value of
///                       *<i>lpdwBufferLength</i> is the minimal required buffer size.
///    lpAliasBuffer = A pointer to a buffer to receive alias information for the network service. If a namespace supports aliases, the
///                    function stores an array of zero-terminated name strings into the buffer pointed to by <i>lpAliasBuffer</i>.
///                    There is a double zero-terminator at the end of the list. The first name in the array is the service's primary
///                    name. Names that follow are aliases. An example of a namespace that supports aliases is DNS. If a namespace does
///                    not support aliases, it stores a double zero-terminator into the buffer. This parameter is optional, and can be
///                    set to <b>NULL</b>.
///    lpdwAliasBufferLength = A pointer to a variable that, upon input, specifies the size, in elements (characters), of the buffer pointed to
///                            by <i>lpAliasBuffer</i>. Upon output, this variable contains the total number of elements (characters) required
///                            to store the array of name strings. If this value is less than or equal to the input value of
///                            *<i>lpdwAliasBufferLength</i>, and the function is successful, this is the number of elements actually stored in
///                            the buffer. If this value is greater than the input value of *<i>lpdwAliasBufferLength</i>, the buffer was too
///                            small, and the output value of *<i>lpdwAliasBufferLength</i> is the minimal required buffer size. If
///                            <i>lpAliasBuffer</i> is <b>NULL</b>, <i>lpdwAliasBufferLength</i> is meaningless and can also be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is the number of CSADDR_INFO data structures written to the buffer
///    pointed to by <i>lpCsaddrBuffer</i>. If the function fails, the return value is SOCKET_ERROR( –1). To get
///    extended error information, call GetLastError, which returns the following extended error value. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
///    </dl> </td> <td width="60%"> The buffer pointed to by <i>lpCsaddrBuffer</i> was too small to receive all of the
///    relevant CSADDR_INFO structures. Call the function with a buffer at least as large as the value returned in
///    *<i>lpdwBufferLength</i>. </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int GetAddressByNameA(uint dwNameSpace, GUID* lpServiceType, const(char)* lpServiceName, int* lpiProtocols, 
                      uint dwResolution, SERVICE_ASYNC_INFO* lpServiceAsyncInfo, char* lpCsaddrBuffer, 
                      uint* lpdwBufferLength, const(char)* lpAliasBuffer, uint* lpdwAliasBufferLength);

///<p class="CCE_Message">[<b>GetAddressByName</b> is no longer available for use as of Windows Sockets 2. Instead, use
///the functions detailed in Protocol-Independent Name Resolution.] The <b>GetAddressByName</b> function queries a
///namespace, or a set of default namespaces, to retrieve network address information for a specified network service.
///This process is known as service name resolution. A network service can also use the function to obtain local address
///information that it can use with the bind function.
///Params:
///    dwNameSpace = The namespace, or set of default namespaces, that the operating system should query for network address
///                  information. Use one of the following constants to specify a namespace. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
///                  <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td width="60%"> A set of default namespaces. The function queries each
///                  namespace within this set. The set of default namespaces typically includes all the namespaces installed on the
///                  system. System administrators, however, can exclude particular namespaces from the set. This is the value that
///                  most applications should use for <i>dwNameSpace</i>. </td> </tr> <tr> <td width="40%"><a id="NS_DNS"></a><a
///                  id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The Domain Name System (DNS) used in the
///                  Internet for host name resolution. </td> </tr> <tr> <td width="40%"><a id="NS_NETBT"></a><a
///                  id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%"> The NetBIOS over TCP/IP layer. All
///                  operating systems register their computer names with NetBIOS. This namespace is used to convert a computer name
///                  to an IP address that uses this registration. Note that NS_NETBT can access a WINS server to perform the
///                  resolution. </td> </tr> <tr> <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl> <dt><b>NS_SAP</b></dt>
///                  </dl> </td> <td width="60%"> The NetWare Service Advertising Protocol. This can access the NetWare bindery if
///                  appropriate. NS_SAP is a dynamic namespace that allows registration of services. </td> </tr> <tr> <td
///                  width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl> <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td>
///                  <td width="60%"> Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\hosts file. </td> </tr> <tr> <td
///                  width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl> <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td>
///                  <td width="60%"> Local TCP/IP name resolution mechanisms, including comparisons against the local host name and
///                  looks up host names and IP addresses in cache of host to IP address mappings. </td> </tr> </table> Most calls to
///                  <b>GetAddressByName</b> should use the special value NS_DEFAULT. This lets a client get by with no knowledge of
///                  which namespaces are available on an internetwork. The system administrator determines namespace access.
///                  Namespaces can come and go without the client having to be aware of the changes.
///    lpServiceType = A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h
///                    header file includes definitions of several GUID service types, and macros for working with them. The Svcguid.h
///                    header file is not automatically included by the Winsock2.h header file.
///    lpServiceName = A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER".
///                    Setting <i>lpServiceName</i> to <b>NULL</b> is the equivalent of setting <i>dwResolution</i> to RES_SERVICE. The
///                    function operates in its second mode, obtaining the local address to which a service of the specified type should
///                    bind. The function stores the local address within the <b>LocalAddr</b> member of the CSADDR_INFO structures
///                    stored into *<i>lpCsaddrBuffer</i>. If <i>dwResolution</i> is set to RES_SERVICE, the function ignores the
///                    <i>lpServiceName</i> parameter. If <i>dwNameSpace</i> is set to NS_DNS, *<i>lpServiceName</i> is the name of the
///                    host.
///    lpiProtocols = A pointer to a zero-terminated array of protocol identifiers. The function restricts a name resolution attempt to
///                   namespace providers that offer these protocols. This lets the caller limit the scope of the search. If
///                   <i>lpiProtocols</i> is set to <b>NULL</b>, the function retrieves information on all available protocols.
///    dwResolution = A set of bit flags that specify aspects of the service name resolution process. The following bit flags are
///                   defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="RES_SERVICE"></a><a
///                   id="res_service"></a><dl> <dt><b>RES_SERVICE</b></dt> </dl> </td> <td width="60%"> If set, the function retrieves
///                   the address to which a service of the specified type should bind. This is the equivalent to setting the
///                   <i>lpServiceName</i> parameter to <b>NULL</b>. If this flag is clear, normal name resolution occurs. </td> </tr>
///                   <tr> <td width="40%"><a id="RES_FIND_MULTIPLE"></a><a id="res_find_multiple"></a><dl>
///                   <dt><b>RES_FIND_MULTIPLE</b></dt> </dl> </td> <td width="60%"> If this flag is set, the operating system performs
///                   an extensive search of all namespaces for the service. It asks every appropriate namespace to resolve the service
///                   name. If this flag is clear, the operating system stops looking for service addresses as soon as one is found.
///                   </td> </tr> <tr> <td width="40%"><a id="RES_SOFT_SEARCH"></a><a id="res_soft_search"></a><dl>
///                   <dt><b>RES_SOFT_SEARCH</b></dt> </dl> </td> <td width="60%"> This flag is valid if the namespace supports
///                   multiple levels of searching. If this flag is valid and set, the operating system performs a simple and quick
///                   search of the namespace. This is useful if an application only needs to obtain easy-to-find addresses for the
///                   service. If this flag is valid and clear, the operating system performs a more extensive search of the namespace.
///                   </td> </tr> </table>
///    lpServiceAsyncInfo = Reserved for future use; must be set to <b>NULL</b>.
///    lpCsaddrBuffer = A pointer to a buffer to receive one or more CSADDR_INFO data structures. The number of structures written to the
///                     buffer depends on the amount of information found in the resolution attempt. You should assume that multiple
///                     structures will be written, although in many cases there will only be one.
///    lpdwBufferLength = A pointer to a variable that, upon input, specifies the size, in bytes, of the buffer pointed to by
///                       <i>lpCsaddrBuffer</i>. Upon output, this variable contains the total number of bytes required to store the array
///                       of CSADDR_INFO structures. If this value is less than or equal to the input value of *<i>lpdwBufferLength</i>,
///                       and the function is successful, this is the number of bytes actually stored in the buffer. If this value is
///                       greater than the input value of *<i>lpdwBufferLength</i>, the buffer was too small, and the output value of
///                       *<i>lpdwBufferLength</i> is the minimal required buffer size.
///    lpAliasBuffer = A pointer to a buffer to receive alias information for the network service. If a namespace supports aliases, the
///                    function stores an array of zero-terminated name strings into the buffer pointed to by <i>lpAliasBuffer</i>.
///                    There is a double zero-terminator at the end of the list. The first name in the array is the service's primary
///                    name. Names that follow are aliases. An example of a namespace that supports aliases is DNS. If a namespace does
///                    not support aliases, it stores a double zero-terminator into the buffer. This parameter is optional, and can be
///                    set to <b>NULL</b>.
///    lpdwAliasBufferLength = A pointer to a variable that, upon input, specifies the size, in elements (characters), of the buffer pointed to
///                            by <i>lpAliasBuffer</i>. Upon output, this variable contains the total number of elements (characters) required
///                            to store the array of name strings. If this value is less than or equal to the input value of
///                            *<i>lpdwAliasBufferLength</i>, and the function is successful, this is the number of elements actually stored in
///                            the buffer. If this value is greater than the input value of *<i>lpdwAliasBufferLength</i>, the buffer was too
///                            small, and the output value of *<i>lpdwAliasBufferLength</i> is the minimal required buffer size. If
///                            <i>lpAliasBuffer</i> is <b>NULL</b>, <i>lpdwAliasBufferLength</i> is meaningless and can also be <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is the number of CSADDR_INFO data structures written to the buffer
///    pointed to by <i>lpCsaddrBuffer</i>. If the function fails, the return value is SOCKET_ERROR( –1). To get
///    extended error information, call GetLastError, which returns the following extended error value. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
///    </dl> </td> <td width="60%"> The buffer pointed to by <i>lpCsaddrBuffer</i> was too small to receive all of the
///    relevant CSADDR_INFO structures. Call the function with a buffer at least as large as the value returned in
///    *<i>lpdwBufferLength</i>. </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int GetAddressByNameW(uint dwNameSpace, GUID* lpServiceType, const(wchar)* lpServiceName, int* lpiProtocols, 
                      uint dwResolution, SERVICE_ASYNC_INFO* lpServiceAsyncInfo, char* lpCsaddrBuffer, 
                      uint* lpdwBufferLength, const(wchar)* lpAliasBuffer, uint* lpdwAliasBufferLength);

///The <b>GetTypeByName</b> function retrieves a service type <b>GUID</b> for a network service specified by name. <div
///class="alert"><b>Note</b> The <b>GetTypeByName</b> function is a Microsoft-specific extension to the Windows Sockets
///1.1 specification. This function is obsolete. For the convenience of Windows Sockets 1.1 developers, this reference
///material is included. The functions detailed in Protocol-Independent Name Resolution provide equivalent functionality
///in Windows Sockets 2.</div> <div> </div>
///Params:
///    lpServiceName = A pointer to a zero-terminated string that uniquely represents the name of the service. For example, "MY SNA
///                    SERVER."
///    lpServiceType = A pointer to a variable to receive a globally unique identifier (<b>GUID</b>) that specifies the type of the
///                    network service. The <i>Svcguid.h</i> header file includes definitions of several <b>GUID</b> service types and
///                    macros for working with them. The <i>Svcguid.h</i> header file is not automatically included by the
///                    <i>Winsock2.h</i> header file.
///Returns:
///    If the function succeeds, the return value is zero. If the function fails, the return value is SOCKET_ERROR( –
///    1). To get extended error information, call GetLastError, which returns the following extended error value.
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SERVICE_DOES_NOT_EXIST</b></dt> </dl> </td> <td width="60%"> The specified service type is unknown.
///    </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int GetTypeByNameA(const(char)* lpServiceName, GUID* lpServiceType);

///The <b>GetTypeByName</b> function retrieves a service type <b>GUID</b> for a network service specified by name. <div
///class="alert"><b>Note</b> The <b>GetTypeByName</b> function is a Microsoft-specific extension to the Windows Sockets
///1.1 specification. This function is obsolete. For the convenience of Windows Sockets 1.1 developers, this reference
///material is included. The functions detailed in Protocol-Independent Name Resolution provide equivalent functionality
///in Windows Sockets 2.</div> <div> </div>
///Params:
///    lpServiceName = A pointer to a zero-terminated string that uniquely represents the name of the service. For example, "MY SNA
///                    SERVER."
///    lpServiceType = A pointer to a variable to receive a globally unique identifier (<b>GUID</b>) that specifies the type of the
///                    network service. The <i>Svcguid.h</i> header file includes definitions of several <b>GUID</b> service types and
///                    macros for working with them. The <i>Svcguid.h</i> header file is not automatically included by the
///                    <i>Winsock2.h</i> header file.
///Returns:
///    If the function succeeds, the return value is zero. If the function fails, the return value is SOCKET_ERROR( –
///    1). To get extended error information, call GetLastError, which returns the following extended error value.
///    <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SERVICE_DOES_NOT_EXIST</b></dt> </dl> </td> <td width="60%"> The specified service type is unknown.
///    </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int GetTypeByNameW(const(wchar)* lpServiceName, GUID* lpServiceType);

///The <b>GetNameByType</b> function retrieves the name of a network service for the specified service type. <div
///class="alert"><b>Note</b> The <b>GetNameByType</b> function is a Microsoft-specific extension to the Windows Sockets
///1.1 specification. This function is obsolete. For the convenience of Windows Sockets 1.1 developers, the reference
///material is as follows.</div> <div> </div> <div class="alert"><b>Note</b> The functions detailed in
///Protocol-Independent Name Resolution provide equivalent functionality in Windows Sockets 2.</div> <div> </div>
///Params:
///    lpServiceType = A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The
///                    <i>Svcguid.h</i> header file includes definitions of several GUID service types, and macros for working with
///                    them. The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
///    lpServiceName = A pointer to a buffer to receive a zero-terminated string that uniquely represents the name of the network
///                    service.
///    dwNameLength = A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by
///                   <i>lpServiceName</i>. On output, the variable contains the actual size of the service name string, in bytes.
///Returns:
///    If the function succeeds, the return value is not SOCKET_ERROR (–1). If the function fails, the return value is
///    SOCKET_ERROR (–1). To get extended error information, call GetLastError.
///    
@DllImport("MSWSOCK")
int GetNameByTypeA(GUID* lpServiceType, const(char)* lpServiceName, uint dwNameLength);

///The <b>GetNameByType</b> function retrieves the name of a network service for the specified service type. <div
///class="alert"><b>Note</b> The <b>GetNameByType</b> function is a Microsoft-specific extension to the Windows Sockets
///1.1 specification. This function is obsolete. For the convenience of Windows Sockets 1.1 developers, the reference
///material is as follows.</div> <div> </div> <div class="alert"><b>Note</b> The functions detailed in
///Protocol-Independent Name Resolution provide equivalent functionality in Windows Sockets 2.</div> <div> </div>
///Params:
///    lpServiceType = A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The
///                    <i>Svcguid.h</i> header file includes definitions of several GUID service types, and macros for working with
///                    them. The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
///    lpServiceName = A pointer to a buffer to receive a zero-terminated string that uniquely represents the name of the network
///                    service.
///    dwNameLength = A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by
///                   <i>lpServiceName</i>. On output, the variable contains the actual size of the service name string, in bytes.
///Returns:
///    If the function succeeds, the return value is not SOCKET_ERROR (–1). If the function fails, the return value is
///    SOCKET_ERROR (–1). To get extended error information, call GetLastError.
///    
@DllImport("MSWSOCK")
int GetNameByTypeW(GUID* lpServiceType, const(wchar)* lpServiceName, uint dwNameLength);

///The <b>SetService</b> function registers or removes from the registry a network service within one or more
///namespaces. The function can also add or remove a network service type within one or more namespaces. <div
///class="alert"><b>Note</b> The <b>SetService</b> function is obsolete. The functions detailed in Protocol-Independent
///Name Resolution provide equivalent functionality in Windows Sockets 2. For the convenience of Windows Sockets 1.1
///developers, the reference material is as follows.</div><div> </div>
///Params:
///    dwNameSpace = The namespace, or a set of default namespaces, within which the function will operate. Use one of the following
///                  constants to specify a namespace. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="NS_DEFAULT"></a><a id="ns_default"></a><dl> <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td width="60%"> A set of
///                  default namespaces. The function queries each namespace within this set. The set of default namespaces typically
///                  includes all the namespaces installed on the system. System administrators, however, can exclude particular
///                  namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>. </td>
///                  </tr> <tr> <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td
///                  width="60%"> The Domain Name System used in the Internet to resolve the name of the host. </td> </tr> <tr> <td
///                  width="40%"><a id="NS_NDS"></a><a id="ns_nds"></a><dl> <dt><b>NS_NDS</b></dt> </dl> </td> <td width="60%"> The
///                  NetWare 4 provider. </td> </tr> <tr> <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
///                  <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%"> The NetBIOS over TCP/IP layer. All Windows systems register
///                  their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses
///                  this registration. </td> </tr> <tr> <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
///                  <dt><b>NS_SAP</b></dt> </dl> </td> <td width="60%"> The NetWare Service Advertising Protocol. This can access the
///                  NetWare bindery, if appropriate. NS_SAP is a dynamic namespace that enables the registration of services. </td>
///                  </tr> <tr> <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
///                  <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td> <td width="60%"> Lookup value in the
///                  &lt;systemroot&gt;\system32\drivers\etc\posts file. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl> <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td> <td
///                  width="60%"> Local TCP/IP name resolution mechanisms, including comparisons against the local host name and
///                  lookup value in the cache of host to IP address mappings. </td> </tr> </table>
///    dwOperation = The operation that the function will perform. Use one of the following values to specify an operation: <table>
///                  <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SERVICE_REGISTER"></a><a
///                  id="service_register"></a><dl> <dt><b>SERVICE_REGISTER</b></dt> </dl> </td> <td width="60%"> Register the network
///                  service with the namespace. This operation can be used with the SERVICE_FLAG_DEFER and SERVICE_FLAG_HARD bit
///                  flags. </td> </tr> <tr> <td width="40%"><a id="SERVICE_DEREGISTER"></a><a id="service_deregister"></a><dl>
///                  <dt><b>SERVICE_DEREGISTER</b></dt> </dl> </td> <td width="60%"> Remove from the registry the network service from
///                  the namespace. This operation can be used with the SERVICE_FLAG_DEFER and SERVICE_FLAG_HARD bit flags. </td>
///                  </tr> <tr> <td width="40%"><a id="SERVICE_FLUSH"></a><a id="service_flush"></a><dl> <dt><b>SERVICE_FLUSH</b></dt>
///                  </dl> </td> <td width="60%"> Perform any operation that was called with the SERVICE_FLAG_DEFER bit flag set to
///                  one. </td> </tr> <tr> <td width="40%"><a id="SERVICE_ADD_TYPE"></a><a id="service_add_type"></a><dl>
///                  <dt><b>SERVICE_ADD_TYPE</b></dt> </dl> </td> <td width="60%"> Add a service type to the namespace. For this
///                  operation, use the <b>ServiceSpecificInfo</b> member of the SERVICE_INFO structure pointed to by
///                  <i>lpServiceInfo</i> to pass a SERVICE_TYPE_INFO_ABS structure. You must also set the <b>ServiceType</b> member
///                  of the <b>SERVICE_INFO</b> structure. Other <b>SERVICE_INFO</b> members are ignored. </td> </tr> <tr> <td
///                  width="40%"><a id="SERVICE_DELETE_TYPE"></a><a id="service_delete_type"></a><dl>
///                  <dt><b>SERVICE_DELETE_TYPE</b></dt> </dl> </td> <td width="60%"> Remove a service type, added by a previous call
///                  specifying the SERVICE_ADD_TYPE operation, from the namespace. </td> </tr> </table>
///    dwFlags = A set of bit flags that modify the function's operation. You can set one or more of the following bit flags:
///              <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SERVICE_FLAG_DEFER"></a><a
///              id="service_flag_defer"></a><dl> <dt><b>SERVICE_FLAG_DEFER</b></dt> </dl> </td> <td width="60%"> This bit flag is
///              valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. If this bit flag is one, and it is valid,
///              the namespace provider should defer the registration or deregistration operation until a SERVICE_FLUSH operation
///              is requested. </td> </tr> <tr> <td width="40%"><a id="SERVICE_FLAG_HARD"></a><a id="service_flag_hard"></a><dl>
///              <dt><b>SERVICE_FLAG_HARD</b></dt> </dl> </td> <td width="60%"> This bit flag is valid only if the operation is
///              SERVICE_REGISTER or SERVICE_DEREGISTER. If this bit flag is one, and it is valid, the namespace provider updates
///              any relevant persistent store information when the operation is performed. For example: If the operation involves
///              deregistration in a namespace that uses a persistent store, the namespace provider would remove the relevant
///              persistent store information. </td> </tr> </table>
///    lpServiceInfo = A pointer to a SERVICE_INFO structure that contains information about the network service or service type.
///    lpServiceAsyncInfo = Reserved for future use. Must be set to <b>NULL</b>.
///    lpdwStatusFlags = A set of bit flags that receive function status information. The following bit flag is defined: <table> <tr>
///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SET_SERVICE__PARTIAL_SUCCESS"></a><a
///                      id="set_service__partial_success"></a><dl> <dt><b>SET_SERVICE_ PARTIAL_SUCCESS</b></dt> </dl> </td> <td
///                      width="60%"> One or more namespace providers were unable to successfully perform the requested operation. </td>
///                      </tr> </table>
///Returns:
///    If the function fails, the return value is SOCKET_ERROR. To get extended error information, call GetLastError.
///    <b>GetLastError</b> can return the following extended error value. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_ REGISTERED</b></dt> </dl> </td> <td
///    width="60%"> The function tried to register a service that was already registered. </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int SetServiceA(uint dwNameSpace, uint dwOperation, uint dwFlags, SERVICE_INFOA* lpServiceInfo, 
                SERVICE_ASYNC_INFO* lpServiceAsyncInfo, uint* lpdwStatusFlags);

///The <b>SetService</b> function registers or removes from the registry a network service within one or more
///namespaces. The function can also add or remove a network service type within one or more namespaces. <div
///class="alert"><b>Note</b> The <b>SetService</b> function is obsolete. The functions detailed in Protocol-Independent
///Name Resolution provide equivalent functionality in Windows Sockets 2. For the convenience of Windows Sockets 1.1
///developers, the reference material is as follows.</div><div> </div>
///Params:
///    dwNameSpace = The namespace, or a set of default namespaces, within which the function will operate. Use one of the following
///                  constants to specify a namespace. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///                  id="NS_DEFAULT"></a><a id="ns_default"></a><dl> <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td width="60%"> A set of
///                  default namespaces. The function queries each namespace within this set. The set of default namespaces typically
///                  includes all the namespaces installed on the system. System administrators, however, can exclude particular
///                  namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>. </td>
///                  </tr> <tr> <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td
///                  width="60%"> The Domain Name System used in the Internet to resolve the name of the host. </td> </tr> <tr> <td
///                  width="40%"><a id="NS_NDS"></a><a id="ns_nds"></a><dl> <dt><b>NS_NDS</b></dt> </dl> </td> <td width="60%"> The
///                  NetWare 4 provider. </td> </tr> <tr> <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
///                  <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%"> The NetBIOS over TCP/IP layer. All Windows systems register
///                  their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses
///                  this registration. </td> </tr> <tr> <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
///                  <dt><b>NS_SAP</b></dt> </dl> </td> <td width="60%"> The NetWare Service Advertising Protocol. This can access the
///                  NetWare bindery, if appropriate. NS_SAP is a dynamic namespace that enables the registration of services. </td>
///                  </tr> <tr> <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
///                  <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td> <td width="60%"> Lookup value in the
///                  &lt;systemroot&gt;\system32\drivers\etc\posts file. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl> <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td> <td
///                  width="60%"> Local TCP/IP name resolution mechanisms, including comparisons against the local host name and
///                  lookup value in the cache of host to IP address mappings. </td> </tr> </table>
///    dwOperation = The operation that the function will perform. Use one of the following values to specify an operation: <table>
///                  <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SERVICE_REGISTER"></a><a
///                  id="service_register"></a><dl> <dt><b>SERVICE_REGISTER</b></dt> </dl> </td> <td width="60%"> Register the network
///                  service with the namespace. This operation can be used with the SERVICE_FLAG_DEFER and SERVICE_FLAG_HARD bit
///                  flags. </td> </tr> <tr> <td width="40%"><a id="SERVICE_DEREGISTER"></a><a id="service_deregister"></a><dl>
///                  <dt><b>SERVICE_DEREGISTER</b></dt> </dl> </td> <td width="60%"> Remove from the registry the network service from
///                  the namespace. This operation can be used with the SERVICE_FLAG_DEFER and SERVICE_FLAG_HARD bit flags. </td>
///                  </tr> <tr> <td width="40%"><a id="SERVICE_FLUSH"></a><a id="service_flush"></a><dl> <dt><b>SERVICE_FLUSH</b></dt>
///                  </dl> </td> <td width="60%"> Perform any operation that was called with the SERVICE_FLAG_DEFER bit flag set to
///                  one. </td> </tr> <tr> <td width="40%"><a id="SERVICE_ADD_TYPE"></a><a id="service_add_type"></a><dl>
///                  <dt><b>SERVICE_ADD_TYPE</b></dt> </dl> </td> <td width="60%"> Add a service type to the namespace. For this
///                  operation, use the <b>ServiceSpecificInfo</b> member of the SERVICE_INFO structure pointed to by
///                  <i>lpServiceInfo</i> to pass a SERVICE_TYPE_INFO_ABS structure. You must also set the <b>ServiceType</b> member
///                  of the <b>SERVICE_INFO</b> structure. Other <b>SERVICE_INFO</b> members are ignored. </td> </tr> <tr> <td
///                  width="40%"><a id="SERVICE_DELETE_TYPE"></a><a id="service_delete_type"></a><dl>
///                  <dt><b>SERVICE_DELETE_TYPE</b></dt> </dl> </td> <td width="60%"> Remove a service type, added by a previous call
///                  specifying the SERVICE_ADD_TYPE operation, from the namespace. </td> </tr> </table>
///    dwFlags = A set of bit flags that modify the function's operation. You can set one or more of the following bit flags:
///              <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SERVICE_FLAG_DEFER"></a><a
///              id="service_flag_defer"></a><dl> <dt><b>SERVICE_FLAG_DEFER</b></dt> </dl> </td> <td width="60%"> This bit flag is
///              valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. If this bit flag is one, and it is valid,
///              the namespace provider should defer the registration or deregistration operation until a SERVICE_FLUSH operation
///              is requested. </td> </tr> <tr> <td width="40%"><a id="SERVICE_FLAG_HARD"></a><a id="service_flag_hard"></a><dl>
///              <dt><b>SERVICE_FLAG_HARD</b></dt> </dl> </td> <td width="60%"> This bit flag is valid only if the operation is
///              SERVICE_REGISTER or SERVICE_DEREGISTER. If this bit flag is one, and it is valid, the namespace provider updates
///              any relevant persistent store information when the operation is performed. For example: If the operation involves
///              deregistration in a namespace that uses a persistent store, the namespace provider would remove the relevant
///              persistent store information. </td> </tr> </table>
///    lpServiceInfo = A pointer to a SERVICE_INFO structure that contains information about the network service or service type.
///    lpServiceAsyncInfo = Reserved for future use. Must be set to <b>NULL</b>.
///    lpdwStatusFlags = A set of bit flags that receive function status information. The following bit flag is defined: <table> <tr>
///                      <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="SET_SERVICE__PARTIAL_SUCCESS"></a><a
///                      id="set_service__partial_success"></a><dl> <dt><b>SET_SERVICE_ PARTIAL_SUCCESS</b></dt> </dl> </td> <td
///                      width="60%"> One or more namespace providers were unable to successfully perform the requested operation. </td>
///                      </tr> </table>
///Returns:
///    If the function fails, the return value is SOCKET_ERROR. To get extended error information, call GetLastError.
///    <b>GetLastError</b> can return the following extended error value. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>ERROR_ALREADY_ REGISTERED</b></dt> </dl> </td> <td
///    width="60%"> The function tried to register a service that was already registered. </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int SetServiceW(uint dwNameSpace, uint dwOperation, uint dwFlags, SERVICE_INFOW* lpServiceInfo, 
                SERVICE_ASYNC_INFO* lpServiceAsyncInfo, uint* lpdwStatusFlags);

///The <b>GetService</b> function retrieves information about a network service in the context of a set of default
///namespaces or a specified namespace. The network service is specified by its type and name. The information about the
///service is obtained as a set of NS_SERVICE_INFO data structures. <div class="alert"><b>Note</b> The <b>GetService</b>
///function is a Microsoft-specific extension to the Windows Sockets 1.1 specification. This function is obsolete. For
///the convenience of Windows Sockets 1.1 developers, this reference material is included.</div> <div> </div> <div
///class="alert"><b>Note</b> The functions detailed in Protocol-Independent Name Resolution provide equivalent
///functionality in Windows Sockets 2.</div> <div> </div>
///Params:
///    dwNameSpace = The namespace, or a set of default namespaces, that the operating system should query for information about the
///                  specified network service. Use one of the following constants to specify a namespace. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
///                  <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td width="60%"> A set of default namespaces. The operating system queries
///                  each namespace within this set. The set of default namespaces typically includes all the namespaces installed on
///                  the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the
///                  value that most applications should use for <i>dwNameSpace</i>. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The Domain Name
///                  System used in the Internet for host name resolution. </td> </tr> <tr> <td width="40%"><a id="NS_NETBT"></a><a
///                  id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%"> The NetBIOS over TCP/IP layer. All
///                  operating systems register their computer names with NetBIOS. This namespace is used to resolve a computer name
///                  into an IP address using this registration. Note that NS_NETBT can access a WINS server to perform the
///                  resolution. </td> </tr> <tr> <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl> <dt><b>NS_SAP</b></dt>
///                  </dl> </td> <td width="60%"> The NetWare Service Advertising Protocol. This can access the NetWare bindery if
///                  appropriate. NS_SAP is a dynamic namespace that allows registration of services. </td> </tr> <tr> <td
///                  width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl> <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td>
///                  <td width="60%"> Looks up host names and IP addresses in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
///                  </td> </tr> <tr> <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
///                  <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td> <td width="60%"> Local TCP/IP name resolution mechanisms, including
///                  comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address
///                  mappings. </td> </tr> </table> Most calls to <b>GetService</b> should use the special value NS_DEFAULT. This lets
///                  a client get by without knowing available namespaces on an internetwork. The system administrator determines
///                  namespace access. Namespaces can come and go without the client having to be aware of the changes.
///    lpGuid = A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The
///             <i>Svcguid.h</i> header file includes GUID service types from many well-known services within the DNS and SAP
///             namespaces. The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
///    lpServiceName = A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER."
///    dwProperties = A set of bit flags that specify the service information that the function retrieves. Each of these bit flag
///                   constants, other than PROP_ALL, corresponds to a particular member of the SERVICE_INFO data structure. If the
///                   flag is set, the function puts information into the corresponding member of the data structures stored in
///                   *<i>lpBuffer</i>. The following bit flags are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                   <td width="40%"><a id="PROP_COMMENT"></a><a id="prop_comment"></a><dl> <dt><b>PROP_COMMENT</b></dt> </dl> </td>
///                   <td width="60%"> If this flag is set, the function stores data in the <b>lpComment</b> member of the data
///                   structures stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td width="40%"><a id="PROP_LOCALE"></a><a
///                   id="prop_locale"></a><dl> <dt><b>PROP_LOCALE</b></dt> </dl> </td> <td width="60%"> If this flag is set, the
///                   function stores data in the <b>lpLocale</b> member of the data structures stored in *<i>lpBuffer</i>. </td> </tr>
///                   <tr> <td width="40%"><a id="PROP_DISPLAY_HINT"></a><a id="prop_display_hint"></a><dl>
///                   <dt><b>PROP_DISPLAY_HINT</b></dt> </dl> </td> <td width="60%"> If this flag is set, the function stores data in
///                   the <b>dwDisplayHint</b> member of the data structures stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td
///                   width="40%"><a id="PROP_VERSION"></a><a id="prop_version"></a><dl> <dt><b>PROP_VERSION</b></dt> </dl> </td> <td
///                   width="60%"> If this flag is set, the function stores data in the <b>dwVersion</b> member of the data structures
///                   stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td width="40%"><a id="PROP_START_TIME"></a><a
///                   id="prop_start_time"></a><dl> <dt><b>PROP_START_TIME</b></dt> </dl> </td> <td width="60%"> If this flag is set,
///                   the function stores data in the <b>dwTime</b> member of the data structures stored in *<i>lpBuffer</i>. </td>
///                   </tr> <tr> <td width="40%"><a id="PROP_MACHINE"></a><a id="prop_machine"></a><dl> <dt><b>PROP_MACHINE</b></dt>
///                   </dl> </td> <td width="60%"> If this flag is set, the function stores data in the <b>lpMachineName</b> member of
///                   the data structures stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td width="40%"><a id="PROP_ADDRESSES"></a><a
///                   id="prop_addresses"></a><dl> <dt><b>PROP_ADDRESSES</b></dt> </dl> </td> <td width="60%"> If this flag is set, the
///                   function stores data in the <b>lpServiceAddress</b> member of the data structures stored in *<i>lpBuffer</i>.
///                   </td> </tr> <tr> <td width="40%"><a id="PROP_SD"></a><a id="prop_sd"></a><dl> <dt><b>PROP_SD</b></dt> </dl> </td>
///                   <td width="60%"> If this flag is set, the function stores data in the <b>ServiceSpecificInfo</b> member of the
///                   data structures stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td width="40%"><a id="PROP_ALL"></a><a
///                   id="prop_all"></a><dl> <dt><b>PROP_ALL</b></dt> </dl> </td> <td width="60%"> If this flag is set, the function
///                   stores data in all of the members of the data structures stored in *<i>lpBuffer</i>. </td> </tr> </table>
///    lpBuffer = A pointer to a buffer to receive an array of NS_SERVICE_INFO structures and associated service information. Each
///               <b>NS_SERVICE_INFO</b> structure contains service information in the context of a particular namespace. Note that
///               if <i>dwNameSpace</i> is NS_DEFAULT, the function stores more than one structure into the buffer; otherwise, just
///               one structure is stored. Each NS_SERVICE_INFO structure contains a SERVICE_INFO structure. The members of these
///               <b>SERVICE_INFO</b> structures will contain valid data based on the bit flags that are set in the
///               <i>dwProperties</i> parameter. If a member's corresponding bit flag is not set in <i>dwProperties</i>, the
///               member's value is undefined. The function stores the NS_SERVICE_INFO structures in a consecutive array, starting
///               at the beginning of the buffer. The pointers in the contained SERVICE_INFO structures point to information that
///               is stored in the buffer between the end of the <b>NS_SERVICE_INFO</b> structures and the end of the buffer.
///    lpdwBufferSize = A pointer to a variable that, on input, contains the size, in bytes, of the buffer pointed to by <i>lpBuffer</i>.
///                     On output, this variable contains the number of bytes required to store the requested information. If this output
///                     value is greater than the input value, the function has failed due to insufficient buffer size.
///    lpServiceAsyncInfo = Reserved for future use. Must be set to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is the number of NS_SERVICE_INFO structures stored in
///    *<i>lpBuffer</i>. Zero indicates that no structures were stored. If the function fails, the return value is
///    SOCKET_ERROR ( – 1). To get extended error information, call GetLastError, which returns one of the following
///    extended error values. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> The buffer pointed to by <i>lpBuffer</i>
///    is too small to receive all of the requested information. Call the function with a buffer at least as large as
///    the value returned in *<i>lpdwBufferSize</i>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SERVICE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified service was not found, or the
///    specified namespace is not in use. The function return value is zero in this case. </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int GetServiceA(uint dwNameSpace, GUID* lpGuid, const(char)* lpServiceName, uint dwProperties, char* lpBuffer, 
                uint* lpdwBufferSize, SERVICE_ASYNC_INFO* lpServiceAsyncInfo);

///The <b>GetService</b> function retrieves information about a network service in the context of a set of default
///namespaces or a specified namespace. The network service is specified by its type and name. The information about the
///service is obtained as a set of NS_SERVICE_INFO data structures. <div class="alert"><b>Note</b> The <b>GetService</b>
///function is a Microsoft-specific extension to the Windows Sockets 1.1 specification. This function is obsolete. For
///the convenience of Windows Sockets 1.1 developers, this reference material is included.</div> <div> </div> <div
///class="alert"><b>Note</b> The functions detailed in Protocol-Independent Name Resolution provide equivalent
///functionality in Windows Sockets 2.</div> <div> </div>
///Params:
///    dwNameSpace = The namespace, or a set of default namespaces, that the operating system should query for information about the
///                  specified network service. Use one of the following constants to specify a namespace. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
///                  <dt><b>NS_DEFAULT</b></dt> </dl> </td> <td width="60%"> A set of default namespaces. The operating system queries
///                  each namespace within this set. The set of default namespaces typically includes all the namespaces installed on
///                  the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the
///                  value that most applications should use for <i>dwNameSpace</i>. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td> <td width="60%"> The Domain Name
///                  System used in the Internet for host name resolution. </td> </tr> <tr> <td width="40%"><a id="NS_NETBT"></a><a
///                  id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> </dl> </td> <td width="60%"> The NetBIOS over TCP/IP layer. All
///                  operating systems register their computer names with NetBIOS. This namespace is used to resolve a computer name
///                  into an IP address using this registration. Note that NS_NETBT can access a WINS server to perform the
///                  resolution. </td> </tr> <tr> <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl> <dt><b>NS_SAP</b></dt>
///                  </dl> </td> <td width="60%"> The NetWare Service Advertising Protocol. This can access the NetWare bindery if
///                  appropriate. NS_SAP is a dynamic namespace that allows registration of services. </td> </tr> <tr> <td
///                  width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl> <dt><b>NS_TCPIP_HOSTS</b></dt> </dl> </td>
///                  <td width="60%"> Looks up host names and IP addresses in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
///                  </td> </tr> <tr> <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
///                  <dt><b>NS_TCPIP_LOCAL</b></dt> </dl> </td> <td width="60%"> Local TCP/IP name resolution mechanisms, including
///                  comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address
///                  mappings. </td> </tr> </table> Most calls to <b>GetService</b> should use the special value NS_DEFAULT. This lets
///                  a client get by without knowing available namespaces on an internetwork. The system administrator determines
///                  namespace access. Namespaces can come and go without the client having to be aware of the changes.
///    lpGuid = A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The
///             <i>Svcguid.h</i> header file includes GUID service types from many well-known services within the DNS and SAP
///             namespaces. The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
///    lpServiceName = A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER."
///    dwProperties = A set of bit flags that specify the service information that the function retrieves. Each of these bit flag
///                   constants, other than PROP_ALL, corresponds to a particular member of the SERVICE_INFO data structure. If the
///                   flag is set, the function puts information into the corresponding member of the data structures stored in
///                   *<i>lpBuffer</i>. The following bit flags are defined. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr>
///                   <td width="40%"><a id="PROP_COMMENT"></a><a id="prop_comment"></a><dl> <dt><b>PROP_COMMENT</b></dt> </dl> </td>
///                   <td width="60%"> If this flag is set, the function stores data in the <b>lpComment</b> member of the data
///                   structures stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td width="40%"><a id="PROP_LOCALE"></a><a
///                   id="prop_locale"></a><dl> <dt><b>PROP_LOCALE</b></dt> </dl> </td> <td width="60%"> If this flag is set, the
///                   function stores data in the <b>lpLocale</b> member of the data structures stored in *<i>lpBuffer</i>. </td> </tr>
///                   <tr> <td width="40%"><a id="PROP_DISPLAY_HINT"></a><a id="prop_display_hint"></a><dl>
///                   <dt><b>PROP_DISPLAY_HINT</b></dt> </dl> </td> <td width="60%"> If this flag is set, the function stores data in
///                   the <b>dwDisplayHint</b> member of the data structures stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td
///                   width="40%"><a id="PROP_VERSION"></a><a id="prop_version"></a><dl> <dt><b>PROP_VERSION</b></dt> </dl> </td> <td
///                   width="60%"> If this flag is set, the function stores data in the <b>dwVersion</b> member of the data structures
///                   stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td width="40%"><a id="PROP_START_TIME"></a><a
///                   id="prop_start_time"></a><dl> <dt><b>PROP_START_TIME</b></dt> </dl> </td> <td width="60%"> If this flag is set,
///                   the function stores data in the <b>dwTime</b> member of the data structures stored in *<i>lpBuffer</i>. </td>
///                   </tr> <tr> <td width="40%"><a id="PROP_MACHINE"></a><a id="prop_machine"></a><dl> <dt><b>PROP_MACHINE</b></dt>
///                   </dl> </td> <td width="60%"> If this flag is set, the function stores data in the <b>lpMachineName</b> member of
///                   the data structures stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td width="40%"><a id="PROP_ADDRESSES"></a><a
///                   id="prop_addresses"></a><dl> <dt><b>PROP_ADDRESSES</b></dt> </dl> </td> <td width="60%"> If this flag is set, the
///                   function stores data in the <b>lpServiceAddress</b> member of the data structures stored in *<i>lpBuffer</i>.
///                   </td> </tr> <tr> <td width="40%"><a id="PROP_SD"></a><a id="prop_sd"></a><dl> <dt><b>PROP_SD</b></dt> </dl> </td>
///                   <td width="60%"> If this flag is set, the function stores data in the <b>ServiceSpecificInfo</b> member of the
///                   data structures stored in *<i>lpBuffer</i>. </td> </tr> <tr> <td width="40%"><a id="PROP_ALL"></a><a
///                   id="prop_all"></a><dl> <dt><b>PROP_ALL</b></dt> </dl> </td> <td width="60%"> If this flag is set, the function
///                   stores data in all of the members of the data structures stored in *<i>lpBuffer</i>. </td> </tr> </table>
///    lpBuffer = A pointer to a buffer to receive an array of NS_SERVICE_INFO structures and associated service information. Each
///               <b>NS_SERVICE_INFO</b> structure contains service information in the context of a particular namespace. Note that
///               if <i>dwNameSpace</i> is NS_DEFAULT, the function stores more than one structure into the buffer; otherwise, just
///               one structure is stored. Each NS_SERVICE_INFO structure contains a SERVICE_INFO structure. The members of these
///               <b>SERVICE_INFO</b> structures will contain valid data based on the bit flags that are set in the
///               <i>dwProperties</i> parameter. If a member's corresponding bit flag is not set in <i>dwProperties</i>, the
///               member's value is undefined. The function stores the NS_SERVICE_INFO structures in a consecutive array, starting
///               at the beginning of the buffer. The pointers in the contained SERVICE_INFO structures point to information that
///               is stored in the buffer between the end of the <b>NS_SERVICE_INFO</b> structures and the end of the buffer.
///    lpdwBufferSize = A pointer to a variable that, on input, contains the size, in bytes, of the buffer pointed to by <i>lpBuffer</i>.
///                     On output, this variable contains the number of bytes required to store the requested information. If this output
///                     value is greater than the input value, the function has failed due to insufficient buffer size.
///    lpServiceAsyncInfo = Reserved for future use. Must be set to <b>NULL</b>.
///Returns:
///    If the function succeeds, the return value is the number of NS_SERVICE_INFO structures stored in
///    *<i>lpBuffer</i>. Zero indicates that no structures were stored. If the function fails, the return value is
///    SOCKET_ERROR ( – 1). To get extended error information, call GetLastError, which returns one of the following
///    extended error values. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt> </dl> </td> <td width="60%"> The buffer pointed to by <i>lpBuffer</i>
///    is too small to receive all of the requested information. Call the function with a buffer at least as large as
///    the value returned in *<i>lpdwBufferSize</i>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>ERROR_SERVICE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified service was not found, or the
///    specified namespace is not in use. The function return value is zero in this case. </td> </tr> </table>
///    
@DllImport("MSWSOCK")
int GetServiceW(uint dwNameSpace, GUID* lpGuid, const(wchar)* lpServiceName, uint dwProperties, char* lpBuffer, 
                uint* lpdwBufferSize, SERVICE_ASYNC_INFO* lpServiceAsyncInfo);

///The <b>getaddrinfo</b> function provides protocol-independent translation from an ANSI host name to an address.
///Params:
///    pNodeName = A pointer to a <b>NULL</b>-terminated ANSI string that contains a host (node) name or a numeric host address
///                string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6
///                hex address.
///    pServiceName = A pointer to a <b>NULL</b>-terminated ANSI string that contains either a service name or port number represented
///                   as a string. A service name is a string alias for a port number. For example, “http” is an alias for port 80
///                   defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP
///                   protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are listed in
///                   the following file: <code>%WINDIR%\system32\drivers\etc\services</code>
///    pHints = A pointer to an addrinfo structure that provides hints about the type of socket the caller supports. The
///             <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the addrinfo structure
///             pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the GetAddrInfoEx function will
///             fail with WSANO_RECOVERY. See the Remarks for more details.
///    ppResult = A pointer to a linked list of one or more addrinfo structures that contains response information about the host.
///Returns:
///    Success returns zero. Failure returns a nonzero Windows Sockets error code, as found in the Windows Sockets Error
///    Codes. Most nonzero error codes returned by the <b>getaddrinfo</b> function map to the set of errors outlined by
///    Internet Engineering Task Force (IETF) recommendations. The following table lists these error codes and their WSA
///    equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error
///    information for Winsock programmers. <table> <tr> <th>Error value</th> <th>WSA equivalent</th>
///    <th>Description</th> </tr> <tr> <td>EAI_AGAIN</td> <td>WSATRY_AGAIN</td> <td>A temporary failure in name
///    resolution occurred.</td> </tr> <tr> <td>EAI_BADFLAGS</td> <td>WSAEINVAL</td> <td>An invalid value was provided
///    for the <b>ai_flags</b> member of the <i>pHints</i> parameter.</td> </tr> <tr> <td>EAI_FAIL</td>
///    <td>WSANO_RECOVERY</td> <td>A nonrecoverable failure in name resolution occurred.</td> </tr> <tr>
///    <td>EAI_FAMILY</td> <td>WSAEAFNOSUPPORT</td> <td>The <b>ai_family</b> member of the <i>pHints</i> parameter is
///    not supported.</td> </tr> <tr> <td>EAI_MEMORY</td> <td>WSA_NOT_ENOUGH_MEMORY</td> <td>A memory allocation failure
///    occurred.</td> </tr> <tr> <td>EAI_NONAME</td> <td>WSAHOST_NOT_FOUND</td> <td>The name does not resolve for the
///    supplied parameters or the <i>pNodeName</i> and <i>pServiceName</i> parameters were not provided.</td> </tr> <tr>
///    <td>EAI_SERVICE</td> <td>WSATYPE_NOT_FOUND</td> <td>The <i>pServiceName</i> parameter is not supported for the
///    specified <b>ai_socktype</b> member of the <i>pHints</i> parameter.</td> </tr> <tr> <td>EAI_SOCKTYPE</td>
///    <td>WSAESOCKTNOSUPPORT</td> <td>The <b>ai_socktype</b> member of the <i>pHints</i> parameter is not
///    supported.</td> </tr> </table> Use the gai_strerror function to print error messages based on the EAI codes
///    returned by the <b>getaddrinfo</b> function. The <b>gai_strerror</b> function is provided for compliance with
///    IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as
///    WSAGetLastError is recommended. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform
///    the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td
///    width="60%"> An address incompatible with the requested protocol was used. This error is returned if the
///    <b>ai_family</b> member of the addrinfostructure pointed to by the <i>pHints</i> parameter is not supported.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid argument
///    was supplied. This error is returned if an invalid value was provided for the <b>ai_flags</b> member of the
///    addrinfostructure pointed to by the <i>pHints</i> parameter. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAESOCKTNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The support for the specified socket type does
///    not exist in this address family. This error is returned if the <b>ai_socktype</b> member of the
///    addrinfostructure pointed to by the <i>pHints</i> parameter is not supported. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No such host is known. This error is returned
///    if the name does not resolve for the supplied parameters or the <i>pNodeName</i> and <i>pServiceName</i>
///    parameters were not provided. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td
///    width="60%"> The requested name is valid, but no data of the requested type was found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> A nonrecoverable error occurred
///    during a database lookup. This error is returned if nonrecoverable error in name resolution occurred. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup
///    call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt>
///    </dl> </td> <td width="60%"> This is usually a temporary error during hostname resolution and means that the
///    local server did not receive a response from an authoritative server. This error is returned when a temporary
///    failure in name resolution occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATYPE_NOT_FOUND</b></dt>
///    </dl> </td> <td width="60%"> The specified class was not found. The <i>pServiceName</i> parameter is not
///    supported for the specified <b>ai_socktype</b> member of the addrinfostructure pointed to by the <i>pHints</i>
///    parameter. </td> </tr> </table>
///    
@DllImport("WS2_32")
int getaddrinfo(const(char)* pNodeName, const(char)* pServiceName, const(ADDRINFOA)* pHints, ADDRINFOA** ppResult);

///The <b>GetAddrInfoW</b> function provides protocol-independent translation from a Unicode host name to an address.
///Params:
///    pNodeName = A pointer to a <b>NULL</b>-terminated Unicode string that contains a host (node) name or a numeric host address
///                string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6
///                hex address.
///    pServiceName = A pointer to a <b>NULL</b>-terminated Unicode string that contains either a service name or port number
///                   represented as a string. A service name is a string alias for a port number. For example, “http” is an alias
///                   for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the
///                   HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are
///                   listed in the following file: <code>%WINDIR%\system32\drivers\etc\services</code>
///    pHints = A pointer to an addrinfoW structure that provides hints about the type of socket the caller supports. The
///             <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the addrinfoW structure
///             pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the GetAddrInfoEx function will
///             fail with WSANO_RECOVERY. See the Remarks for more details.
///    ppResult = A pointer to a linked list of one or more addrinfoW structures that contains response information about the host.
///Returns:
///    Success returns zero. Failure returns a nonzero Windows Sockets error code, as found in the Windows Sockets Error
///    Codes. Most nonzero error codes returned by the <b>GetAddrInfoW</b> function map to the set of errors outlined by
///    Internet Engineering Task Force (IETF) recommendations. The following table lists these error codes and their WSA
///    equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error
///    information for Winsock programmers. <table> <tr> <th>Error value</th> <th>WSA equivalent</th>
///    <th>Description</th> </tr> <tr> <td>EAI_AGAIN</td> <td>WSATRY_AGAIN</td> <td>A temporary failure in name
///    resolution occurred.</td> </tr> <tr> <td>EAI_BADFLAGS</td> <td>WSAEINVAL</td> <td>An invalid value was provided
///    for the <b>ai_flags</b> member of the <i>pHints</i> parameter.</td> </tr> <tr> <td>EAI_FAIL</td>
///    <td>WSANO_RECOVERY</td> <td>A nonrecoverable failure in name resolution occurred.</td> </tr> <tr>
///    <td>EAI_FAMILY</td> <td>WSAEAFNOSUPPORT</td> <td>The <b>ai_family</b> member of the <i>pHints</i> parameter is
///    not supported.</td> </tr> <tr> <td>EAI_MEMORY</td> <td>WSA_NOT_ENOUGH_MEMORY</td> <td>A memory allocation failure
///    occurred.</td> </tr> <tr> <td>EAI_NONAME</td> <td>WSAHOST_NOT_FOUND</td> <td>The name does not resolve for the
///    supplied parameters or the <i>pNodeName</i> and <i>pServiceName</i> parameters were not provided.</td> </tr> <tr>
///    <td>EAI_SERVICE</td> <td>WSATYPE_NOT_FOUND</td> <td>The <i>pServiceName</i> parameter is not supported for the
///    specified <b>ai_socktype</b> member of the <i>pHints</i> parameter.</td> </tr> <tr> <td>EAI_SOCKTYPE</td>
///    <td>WSAESOCKTNOSUPPORT</td> <td>The <b>ai_socktype</b> member of the <i>pHints</i> parameter is not
///    supported.</td> </tr> </table> Use the gai_strerror function to print error messages based on the EAI_* codes
///    returned by the <b>GetAddrInfoW</b> function. The <b>gai_strerror</b> function is provided for compliance with
///    IETF recommendations, but it is not thread safe. Therefore, use of a traditional Windows Sockets function, such
///    as WSAGetLastError, is recommended. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform
///    the operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td
///    width="60%"> An address incompatible with the requested protocol was used. This error is returned if the
///    <b>ai_family</b> member of the addrinfoWstructure pointed to by the <i>hints</i> parameter is not supported.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid argument
///    was supplied. This error is returned if an invalid value was provided for the <b>ai_flags</b> member of the
///    addrinfoWstructure pointed to by the <i>hints</i> parameter. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAESOCKTNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The support for the specified socket type does
///    not exist in this address family. This error is returned if the <b>ai_socktype</b> member of the
///    addrinfoWstructure pointed to by the <i>hints</i> parameter is not supported. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No such host is known. This error is returned
///    if the name does not resolve for the supplied parameters or the <i>pNodename</i> and <i>pServicename</i>
///    parameters were not provided. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td
///    width="60%"> The requested name is valid, but no data of the requested type was found. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> A nonrecoverable error occurred
///    during a database lookup. This error is returned if nonrecoverable error in name resolution occurred. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup
///    call must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt>
///    </dl> </td> <td width="60%"> This is usually a temporary error during hostname resolution and means that the
///    local server did not receive a response from an authoritative server. This error is returned when a temporary
///    failure in name resolution occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATYPE_NOT_FOUND</b></dt>
///    </dl> </td> <td width="60%"> The specified class was not found. The <i>pServiceName</i> parameter is not
///    supported for the specified <b>ai_socktype</b> member of the addrinfoWstructure pointed to by the <i>hints</i>
///    parameter. </td> </tr> </table>
///    
@DllImport("WS2_32")
int GetAddrInfoW(const(wchar)* pNodeName, const(wchar)* pServiceName, const(addrinfoW)* pHints, 
                 addrinfoW** ppResult);

///The <b>GetAddrInfoEx</b> function provides protocol-independent name resolution with additional parameters to qualify
///which namespace providers should handle the request.
///Params:
///    pName = A pointer to a <b>NULL</b>-terminated string containing a host (node) name or a numeric host address string. For
///            the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
///    pServiceName = A pointer to an optional <b>NULL</b>-terminated string that contains either a service name or port number
///                   represented as a string. A service name is a string alias for a port number. For example, “http” is an alias
///                   for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the
///                   HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are
///                   listed in the following file: <code>%WINDIR%\system32\drivers\etc\services</code>
///    dwNameSpace = An optional namespace identifier that determines which namespace providers are queried. Passing a specific
///                  namespace identifier will result in only namespace providers that support the specified namespace being queried.
///                  Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried. Options for
///                  the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers
///                  are added on Windows Vista and later. Other namespace providers can be installed, so the following possible
///                  values are only those commonly available. Many other values are possible. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl> <dt><b>NS_ALL</b></dt>
///                  <dt>0</dt> </dl> </td> <td width="60%"> All installed and active namespaces. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> <dt>12</dt> </dl> </td> <td width="60%"> The
///                  domain name system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_NETBT"></a><a
///                  id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> <dt>13</dt> </dl> </td> <td width="60%"> The NetBIOS over TCP/IP
///                  (NETBT) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_WINS"></a><a id="ns_wins"></a><dl>
///                  <dt><b>NS_WINS</b></dt> <dt>14</dt> </dl> </td> <td width="60%"> The Windows Internet Naming Service (NS_WINS)
///                  namespace. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl> <dt><b>NS_NLA</b></dt>
///                  <dt>15</dt> </dl> </td> <td width="60%"> The network location awareness (NLA) namespace. This namespace
///                  identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a id="NS_BTH"></a><a
///                  id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> The Bluetooth namespace.
///                  This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_NTDS"></a><a id="ns_ntds"></a><dl> <dt><b>NS_NTDS</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The
///                  Windows NT Directory Services (NS_NTDS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a
///                  id="ns_email"></a><dl> <dt><b>NS_EMAIL</b></dt> <dt>37</dt> </dl> </td> <td width="60%"> The email namespace.
///                  This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> <dt>38</dt> </dl> </td> <td
///                  width="60%"> The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on
///                  Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
///                  <dt><b>NS_PNRPCLOUD</b></dt> <dt>39</dt> </dl> </td> <td width="60%"> The peer-to-peer namespace for a collection
///                  of peer names. This namespace identifier is supported on Windows Vista and later. </td> </tr> </table>
///    lpNspId = A pointer to an optional GUID of a specific namespace provider to query in the case where multiple namespace
///              providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for specific namespace
///              provider will result in only the specified namespace provider being queried. The WSAEnumNameSpaceProviders
///              function can be called to retrieve the GUID for a namespace provider.
///    hints = A pointer to an addrinfoex structure that provides hints about the type of socket the caller supports. The
///            <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the addrinfoex structure
///            pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <b>GetAddrInfoEx</b>
///            function will fail with WSANO_RECOVERY. See the Remarks for more details.
///    ppResult = A pointer to a linked list of one or more addrinfoex structures that contains response information about the
///               host.
///    timeout = An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider
///              before aborting the call. This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has
///              been defined in the sources before calling the <b>GetAddrInfoEx</b> function. Otherwise, this parameter is
///              currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
///    lpOverlapped = An optional pointer to an overlapped structure used for asynchronous operation. This parameter is only supported
///                   when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the
///                   <b>GetAddrInfoEx</b> function. On Windows 8 and Windows Server 2012, if no <i>lpCompletionRoutine</i> parameter
///                   is specified, the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure must be set to a manual-reset event to
///                   be called upon completion of an asynchronous call. If a completion routine has been specified, the <b>hEvent</b>
///                   member must be NULL. When the event specified by <b>hEvent</b> has been set, the result of the operation can be
///                   retrieved by calling GetAddrInfoExOverlappedResult function. On Windows 8 and Windows Server 2012 whenever the
///                   <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined, this parameter is currently reserved and must be set to
///                   <b>NULL</b>. On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be
///                   set to <b>NULL</b> since asynchronous operations are not supported.
///    lpCompletionRoutine = An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This
///                          parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources
///                          before calling the <b>GetAddrInfoEx</b> function. On Windows 8 and Windows Server 2012, if this parameter is
///                          specified, it must be a pointer to a function with the following signature: ```cpp typedef void (CALLBACK *
///                          LPLOOKUPSERVICE_COMPLETION_ROUTINE)( __in DWORD dwError, __in DWORD dwBytes, __in LPWSAOVERLAPPED lpOverlapped );
///                          ``` When the asynchronous operation has completed, the completion routine will be invoked with
///                          <i>lpOverlapped</i> parameter set to the value of <i>lpOverlapped</i> parameter passed to <b>GetAddrInfoEx</b>.
///                          The <b>Pointer</b> member of the OVERLAPPED structure will be set to the value of the <i>ppResult</i> parameter
///                          of the original call. If the <b>Pointer</b> member points to a non-NULL pointer to the addrinfoex structure, it
///                          is the caller’s responsibility to call FreeAddrInfoEx to free the <b>addrinfoex</b> structure. The
///                          <i>dwError</i> parameter passed to the completion routine will be set to a Winsock error code. The <i>dwBytes</i>
///                          parameter is reserved for future use and must be ignored. On Windows 8 and Windows Server 2012 whenever the
///                          <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined, this parameter is currently reserved and must be set to
///                          <b>NULL</b>. On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be
///                          set to <b>NULL</b> since asynchronous operations are not supported.
///    lpNameHandle = An optional pointer used only for asynchronous operations. This parameter is only supported when the
///                   <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b>
///                   function. On Windows 8 and Windows Server 2012, if the <b>GetAddrInfoEx</b> function will complete
///                   asynchronously, the pointer returned in this field may be used with the <b>GetAddrInfoExCancel</b> function. The
///                   handle returned is valid when <b>GetAddrInfoEx</b> returns until the completion routine is called, the event is
///                   triggered, or GetAddrInfoExCancel function is called with this handle. On Windows 8 and Windows Server 2012
///                   whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined, this parameter is currently reserved and
///                   must be set to <b>NULL</b>. On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently
///                   reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
///Returns:
///    On success, <b>GetAddrInfoEx</b> returns <b>NO_ERROR</b> (0). Failure returns a nonzero Windows Sockets error
///    code, as found in the Windows Sockets Error Codes. Most nonzero error codes returned by the <b>GetAddrInfoEx</b>
///    function map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The
///    following table shows these error codes and their WSA equivalents. It is recommended that the WSA error codes be
///    used, as they offer familiar and comprehensive error information for Winsock programmers. <table> <tr> <th>Error
///    value</th> <th>WSA equivalent</th> <th>Description</th> </tr> <tr> <td>EAI_AGAIN</td> <td>WSATRY_AGAIN</td> <td>A
///    temporary failure in name resolution occurred.</td> </tr> <tr> <td>EAI_BADFLAGS</td> <td>WSAEINVAL</td> <td>An
///    invalid parameter was provided. This error is returned if any of the reserved parameters are not <b>NULL</b>.
///    This error is also returned if an invalid value was provided for the <b>ai_flags</b> member of the <i>pHints</i>
///    parameter.</td> </tr> <tr> <td>EAI_FAIL</td> <td>WSANO_RECOVERY</td> <td>A nonrecoverable failure in name
///    resolution occurred.</td> </tr> <tr> <td>EAI_FAMILY</td> <td>WSAEAFNOSUPPORT</td> <td>The <b>ai_family</b> member
///    of the <i>pHints</i> parameter is not supported.</td> </tr> <tr> <td>EAI_MEMORY</td>
///    <td>WSA_NOT_ENOUGH_MEMORY</td> <td>A memory allocation failure occurred.</td> </tr> <tr> <td>EAI_NONAME</td>
///    <td>WSAHOST_NOT_FOUND</td> <td>The name does not resolve for the supplied parameters or the <i>pName</i> and
///    <i>pServiceName</i> parameters were not provided.</td> </tr> <tr> <td>EAI_SERVICE</td> <td>WSATYPE_NOT_FOUND</td>
///    <td>The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the
///    <i>pHints</i> parameter.</td> </tr> <tr> <td>EAI_SOCKTYPE</td> <td>WSAESOCKTNOSUPPORT</td> <td>The
///    <b>ai_socktype</b> member of the <i>pHints</i> parameter is not supported.</td> </tr> </table> Use the
///    gai_strerror function to print error messages based on the EAI codes returned by the <b>GetAddrInfoEx</b>
///    function. The <b>gai_strerror</b> function is provided for compliance with IETF recommendations, but it is not
///    thread safe. Therefore, use of traditional Windows Sockets functions such as WSAGetLastError is recommended.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> An
///    address incompatible with the requested protocol was used. This error is returned if the <b>ai_family</b> member
///    of the addrinfoexstructure pointed to by the <i>pHints</i> parameter is not supported. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid argument was supplied. This
///    error is returned if an invalid value was provided for the <b>ai_flags</b> member of the addrinfoex structure
///    pointed to by the <i>pHints</i> parameter. This error is also returned when the <i>dwNameSpace</i> parameter is
///    NS_PNRPNAME or NS_PNRPCLOUD and the peer-to-peer name service is not operating. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAESOCKTNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The support for the specified socket type
///    does not exist in this address family. This error is returned if the <b>ai_socktype</b> member of the addrinfoex
///    structure pointed to by the <i>pHints</i> parameter is not supported. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No such host is known. This error is returned if
///    the name does not resolve for the supplied parameters or the <i>pName</i> and <i>pServiceName</i> parameters were
///    not provided. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> The
///    requested name is valid, but no data of the requested type was found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> A nonrecoverable error occurred during a database
///    lookup. This error is returned if nonrecoverable error in name resolution occurred. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSASERVICE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No such service is known. The service cannot be
///    found in the specified name space. This error is returned if the <i>pName</i> or <i>pServiceName</i> parameter is
///    not found for the namespace specified in the <i>dwNameSpace</i> parameter or the namespace specified in the
///    <i>dwNameSpace</i> parameter is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSATRY_AGAIN</b></dt> </dl> </td> <td width="60%"> This is usually a temporary error during hostname
///    resolution and means that the local server did not receive a response from an authoritative server. This error is
///    returned when a temporary failure in name resolution occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSATYPE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified class was not found. The
///    <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the
///    addrinfoexstructure pointed to by the <i>pHints</i> parameter. </td> </tr> </table>
///    
@DllImport("WS2_32")
int GetAddrInfoExA(const(char)* pName, const(char)* pServiceName, uint dwNameSpace, GUID* lpNspId, 
                   const(addrinfoexA)* hints, addrinfoexA** ppResult, timeval* timeout, OVERLAPPED* lpOverlapped, 
                   LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, ptrdiff_t* lpNameHandle);

///The <b>GetAddrInfoEx</b> function provides protocol-independent name resolution with additional parameters to qualify
///which namespace providers should handle the request.
///Params:
///    pName = A pointer to a <b>NULL</b>-terminated string containing a host (node) name or a numeric host address string. For
///            the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
///    pServiceName = A pointer to an optional <b>NULL</b>-terminated string that contains either a service name or port number
///                   represented as a string. A service name is a string alias for a port number. For example, “http” is an alias
///                   for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the
///                   HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are
///                   listed in the following file: <code>%WINDIR%\system32\drivers\etc\services</code>
///    dwNameSpace = An optional namespace identifier that determines which namespace providers are queried. Passing a specific
///                  namespace identifier will result in only namespace providers that support the specified namespace being queried.
///                  Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried. Options for
///                  the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers
///                  are added on Windows Vista and later. Other namespace providers can be installed, so the following possible
///                  values are only those commonly available. Many other values are possible. <table> <tr> <th>Value</th>
///                  <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl> <dt><b>NS_ALL</b></dt>
///                  <dt>0</dt> </dl> </td> <td width="60%"> All installed and active namespaces. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> <dt>12</dt> </dl> </td> <td width="60%"> The
///                  domain name system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_NETBT"></a><a
///                  id="ns_netbt"></a><dl> <dt><b>NS_NETBT</b></dt> <dt>13</dt> </dl> </td> <td width="60%"> The NetBIOS over TCP/IP
///                  (NETBT) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_WINS"></a><a id="ns_wins"></a><dl>
///                  <dt><b>NS_WINS</b></dt> <dt>14</dt> </dl> </td> <td width="60%"> The Windows Internet Naming Service (NS_WINS)
///                  namespace. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl> <dt><b>NS_NLA</b></dt>
///                  <dt>15</dt> </dl> </td> <td width="60%"> The network location awareness (NLA) namespace. This namespace
///                  identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a id="NS_BTH"></a><a
///                  id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> <dt>16</dt> </dl> </td> <td width="60%"> The Bluetooth namespace.
///                  This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_NTDS"></a><a id="ns_ntds"></a><dl> <dt><b>NS_NTDS</b></dt> <dt>32</dt> </dl> </td> <td width="60%"> The
///                  Windows NT Directory Services (NS_NTDS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a
///                  id="ns_email"></a><dl> <dt><b>NS_EMAIL</b></dt> <dt>37</dt> </dl> </td> <td width="60%"> The email namespace.
///                  This namespace identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> <dt>38</dt> </dl> </td> <td
///                  width="60%"> The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on
///                  Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
///                  <dt><b>NS_PNRPCLOUD</b></dt> <dt>39</dt> </dl> </td> <td width="60%"> The peer-to-peer namespace for a collection
///                  of peer names. This namespace identifier is supported on Windows Vista and later. </td> </tr> </table>
///    lpNspId = A pointer to an optional GUID of a specific namespace provider to query in the case where multiple namespace
///              providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for specific namespace
///              provider will result in only the specified namespace provider being queried. The WSAEnumNameSpaceProviders
///              function can be called to retrieve the GUID for a namespace provider.
///    hints = A pointer to an addrinfoex structure that provides hints about the type of socket the caller supports. The
///            <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the addrinfoex structure
///            pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <b>GetAddrInfoEx</b>
///            function will fail with WSANO_RECOVERY. See the Remarks for more details.
///    ppResult = A pointer to a linked list of one or more addrinfoex structures that contains response information about the
///               host.
///    timeout = An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider
///              before aborting the call. This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has
///              been defined in the sources before calling the <b>GetAddrInfoEx</b> function. Otherwise, this parameter is
///              currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
///    lpOverlapped = An optional pointer to an overlapped structure used for asynchronous operation. This parameter is only supported
///                   when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the
///                   <b>GetAddrInfoEx</b> function. On Windows 8 and Windows Server 2012, if no <i>lpCompletionRoutine</i> parameter
///                   is specified, the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure must be set to a manual-reset event to
///                   be called upon completion of an asynchronous call. If a completion routine has been specified, the <b>hEvent</b>
///                   member must be NULL. When the event specified by <b>hEvent</b> has been set, the result of the operation can be
///                   retrieved by calling GetAddrInfoExOverlappedResult function. On Windows 8 and Windows Server 2012 whenever the
///                   <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined, this parameter is currently reserved and must be set to
///                   <b>NULL</b>. On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be
///                   set to <b>NULL</b> since asynchronous operations are not supported.
///    lpCompletionRoutine = Type: \_In_opt\_
///                          [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](../winsock2/nc-winsock2-lpwsaoverlapped_completion_routine.md) An
///                          optional pointer to a function to be invoked upon successful completion for asynchronous operations. This
///                          parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources
///                          before calling the <b>GetAddrInfoEx</b> function. On Windows 8 and Windows Server 2012, if this parameter is
///                          specified, it must be a pointer to a function with the following signature: ```cpp typedef void (CALLBACK *
///                          LPLOOKUPSERVICE_COMPLETION_ROUTINE)( __in DWORD dwError, __in DWORD dwBytes, __in LPWSAOVERLAPPED lpOverlapped );
///                          ``` When the asynchronous operation has completed, the completion routine will be invoked with
///                          <i>lpOverlapped</i> parameter set to the value of <i>lpOverlapped</i> parameter passed to <b>GetAddrInfoEx</b>.
///                          The <b>Pointer</b> member of the OVERLAPPED structure will be set to the value of the <i>ppResult</i> parameter
///                          of the original call. If the <b>Pointer</b> member points to a non-NULL pointer to the addrinfoex structure, it
///                          is the caller’s responsibility to call FreeAddrInfoEx to free the <b>addrinfoex</b> structure. The
///                          <i>dwError</i> parameter passed to the completion routine will be set to a Winsock error code. The <i>dwBytes</i>
///                          parameter is reserved for future use and must be ignored. On Windows 8 and Windows Server 2012 whenever the
///                          <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined, this parameter is currently reserved and must be set to
///                          <b>NULL</b>. On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be
///                          set to <b>NULL</b> since asynchronous operations are not supported.
///    lpHandle = TBD
///Returns:
///    On success, <b>GetAddrInfoEx</b> returns <b>NO_ERROR</b> (0). Failure returns a nonzero Windows Sockets error
///    code, as found in the Windows Sockets Error Codes. Most nonzero error codes returned by the <b>GetAddrInfoEx</b>
///    function map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The
///    following table shows these error codes and their WSA equivalents. It is recommended that the WSA error codes be
///    used, as they offer familiar and comprehensive error information for Winsock programmers. <table> <tr> <th>Error
///    value</th> <th>WSA equivalent</th> <th>Description</th> </tr> <tr> <td>EAI_AGAIN</td> <td>WSATRY_AGAIN</td> <td>A
///    temporary failure in name resolution occurred.</td> </tr> <tr> <td>EAI_BADFLAGS</td> <td>WSAEINVAL</td> <td>An
///    invalid parameter was provided. This error is returned if any of the reserved parameters are not <b>NULL</b>.
///    This error is also returned if an invalid value was provided for the <b>ai_flags</b> member of the <i>pHints</i>
///    parameter.</td> </tr> <tr> <td>EAI_FAIL</td> <td>WSANO_RECOVERY</td> <td>A nonrecoverable failure in name
///    resolution occurred.</td> </tr> <tr> <td>EAI_FAMILY</td> <td>WSAEAFNOSUPPORT</td> <td>The <b>ai_family</b> member
///    of the <i>pHints</i> parameter is not supported.</td> </tr> <tr> <td>EAI_MEMORY</td>
///    <td>WSA_NOT_ENOUGH_MEMORY</td> <td>A memory allocation failure occurred.</td> </tr> <tr> <td>EAI_NONAME</td>
///    <td>WSAHOST_NOT_FOUND</td> <td>The name does not resolve for the supplied parameters or the <i>pName</i> and
///    <i>pServiceName</i> parameters were not provided.</td> </tr> <tr> <td>EAI_SERVICE</td> <td>WSATYPE_NOT_FOUND</td>
///    <td>The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the
///    <i>pHints</i> parameter.</td> </tr> <tr> <td>EAI_SOCKTYPE</td> <td>WSAESOCKTNOSUPPORT</td> <td>The
///    <b>ai_socktype</b> member of the <i>pHints</i> parameter is not supported.</td> </tr> </table> Use the
///    gai_strerror function to print error messages based on the EAI codes returned by the <b>GetAddrInfoEx</b>
///    function. The <b>gai_strerror</b> function is provided for compliance with IETF recommendations, but it is not
///    thread safe. Therefore, use of traditional Windows Sockets functions such as WSAGetLastError is recommended.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%"> There was insufficient memory to perform the
///    operation. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> An
///    address incompatible with the requested protocol was used. This error is returned if the <b>ai_family</b> member
///    of the addrinfoexstructure pointed to by the <i>pHints</i> parameter is not supported. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid argument was supplied. This
///    error is returned if an invalid value was provided for the <b>ai_flags</b> member of the addrinfoex structure
///    pointed to by the <i>pHints</i> parameter. This error is also returned when the <i>dwNameSpace</i> parameter is
///    NS_PNRPNAME or NS_PNRPCLOUD and the peer-to-peer name service is not operating. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAESOCKTNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The support for the specified socket type
///    does not exist in this address family. This error is returned if the <b>ai_socktype</b> member of the addrinfoex
///    structure pointed to by the <i>pHints</i> parameter is not supported. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAHOST_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No such host is known. This error is returned if
///    the name does not resolve for the supplied parameters or the <i>pName</i> and <i>pServiceName</i> parameters were
///    not provided. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_DATA</b></dt> </dl> </td> <td width="60%"> The
///    requested name is valid, but no data of the requested type was found. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> A nonrecoverable error occurred during a database
///    lookup. This error is returned if nonrecoverable error in name resolution occurred. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSASERVICE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> No such service is known. The service cannot be
///    found in the specified name space. This error is returned if the <i>pName</i> or <i>pServiceName</i> parameter is
///    not found for the namespace specified in the <i>dwNameSpace</i> parameter or the namespace specified in the
///    <i>dwNameSpace</i> parameter is not installed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSATRY_AGAIN</b></dt> </dl> </td> <td width="60%"> This is usually a temporary error during hostname
///    resolution and means that the local server did not receive a response from an authoritative server. This error is
///    returned when a temporary failure in name resolution occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSATYPE_NOT_FOUND</b></dt> </dl> </td> <td width="60%"> The specified class was not found. The
///    <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the
///    addrinfoexstructure pointed to by the <i>pHints</i> parameter. </td> </tr> </table>
///    
@DllImport("WS2_32")
int GetAddrInfoExW(const(wchar)* pName, const(wchar)* pServiceName, uint dwNameSpace, GUID* lpNspId, 
                   const(addrinfoexW)* hints, addrinfoexW** ppResult, timeval* timeout, OVERLAPPED* lpOverlapped, 
                   LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, ptrdiff_t* lpHandle);

///The <b>GetAddrInfoExCancel</b> function cancels an asynchronous operation by the GetAddrInfoEx function.
///Params:
///    lpHandle = The handle of the asynchronous operation to cancel. This is the handle returned in the <i>lpNameHandle</i>
///               parameter by the GetAddrInfoEx function.
///Returns:
///    On success, <b>GetAddrInfoExCancel</b> returns <b>NO_ERROR</b> (0). Failure returns a nonzero Windows Sockets
///    error code, as found in the Windows Sockets Error Codes.
///    
@DllImport("WS2_32")
int GetAddrInfoExCancel(ptrdiff_t* lpHandle);

///The <b>GetAddrInfoExOverlappedResult</b> function gets the return code for an <b>OVERLAPPED</b> structure used by an
///asynchronous operation for the GetAddrInfoEx function.
///Params:
///    lpOverlapped = A pointer to an <b>OVERLAPPED</b> structure for the asynchronous operation.
///Returns:
///    On success, the <b>GetAddrInfoExOverlappedResult</b> function returns <b>NO_ERROR</b> (0). When the underlying
///    operation hasn't yet completed, the <b>GetAddrInfoExOverlappedResult</b> function returns <b>WSAEINPROGRESS</b>.
///    On failure, the <b>GetAddrInfoExOverlappedResult</b> function returns <b>WSAEINVAL</b>.
///    
@DllImport("WS2_32")
int GetAddrInfoExOverlappedResult(OVERLAPPED* lpOverlapped);

///The <b>SetAddrInfoEx</b> function registers or deregisters a name, a service name, and associated addresses with a
///specific namespace provider.
///Params:
///    pName = A pointer to a <b>NULL</b>-terminated string containing a name under which addresses are to be registered or
///            deregistered. The interpretation of this parameter specific to the namespace provider.
///    pServiceName = A pointer to an optional <b>NULL</b>-terminated string that contains the service name associated with the name
///                   being registered. The interpretation of this parameter is specific to the namespace provider.
///    pAddresses = A pointer to an optional list of addresses to register with the namespace provider.
///    dwAddressCount = The number of addresses passed in <i>pAddresses</i> parameter. If this parameter is zero, the <i>pName</i>
///                     parameter is deregistered from the namespace provider.
///    lpBlob = An optional pointer to data that is used to set provider-specific namespace information that is associated with
///             the <i>pName</i> parameter beyond a list of addresses. Any information that cannot be passed in the
///             <i>pAddresses</i> parameter can be passed in the <i>lpBlob</i> parameter. The format of this information is
///             specific to the namespace provider.
///    dwFlags = A set of flags controlling how the <i>pName</i> and <i>pServiceName</i> parameters are to be registered with the
///              namespace provider. The interpretation of this information is specific to the namespace provider.
///    dwNameSpace = A namespace identifier that determines which namespace provider to register this information with. Passing a
///                  specific namespace identifier will result in registering this information only with the namespace providers that
///                  support the specified namespace. Specifying NS_ALL will result in registering the information with all installed
///                  and active namespace providers. Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i>
///                  include file. Several namespace providers are included with Windows Vista and later. Other namespace providers
///                  can be installed, so the following possible values are only those commonly available. Many others are possible.
///                  <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_ALL"></a><a
///                  id="ns_all"></a><dl> <dt><b>NS_ALL</b></dt> </dl> </td> <td width="60%"> All installed and active namespaces.
///                  </td> </tr> <tr> <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td>
///                  <td width="60%"> The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.
///                  </td> </tr> <tr> <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td>
///                  <td width="60%"> The domain name system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a
///                  id="ns_email"></a><dl> <dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace
///                  identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a
///                  id="ns_nla"></a><dl> <dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA)
///                  namespace. This namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The
///                  peer-to-peer namespace for a specific peer name. This namespace identifier is supported on Windows Vista and
///                  later. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
///                  <dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td width="60%"> The peer-to-peer namespace for a collection of peer
///                  names. This namespace identifier is supported on Windows Vista and later. </td> </tr> </table>
///    lpNspId = A pointer to an optional GUID of a specific namespace provider to register this information with in the case
///              where multiple namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for a
///              specific namespace provider will result in the information being registered with only the specified namespace
///              provider. The WSAEnumNameSpaceProviders function can be called to retrieve the GUID for a namespace provider.
///    timeout = An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider
///              before aborting the call. This parameter is currently reserved and must be set to <b>NULL</b> since a
///              <i>timeout</i> option is not supported.
///    lpOverlapped = An optional pointer to an overlapped structure used for asynchronous operation. This parameter is currently
///                   reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
///    lpCompletionRoutine = An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This
///                          parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
///    lpNameHandle = An optional pointer used only for asynchronous operations. This parameter is currently reserved and must be set
///                   to <b>NULL</b> since asynchronous operations are not supported.
///Returns:
///    On success, <b>SetAddrInfoEx</b> returns NO_ERROR (0). Failure returns a nonzero Windows Sockets error code, as
///    found in the Windows Sockets Error Codes. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt> </dl>
///    </td> <td width="60%"> A temporary failure in name resolution occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was provided. This error is returned
///    if any of the reserved parameters are not <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> Insufficient buffer space is available. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> A nonrecoverable failure in
///    name resolution occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl>
///    </td> <td width="60%"> A memory allocation failure occurred. </td> </tr> </table>
///    
@DllImport("WS2_32")
int SetAddrInfoExA(const(char)* pName, const(char)* pServiceName, SOCKET_ADDRESS* pAddresses, uint dwAddressCount, 
                   BLOB* lpBlob, uint dwFlags, uint dwNameSpace, GUID* lpNspId, timeval* timeout, 
                   OVERLAPPED* lpOverlapped, LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, 
                   ptrdiff_t* lpNameHandle);

///The <b>SetAddrInfoEx</b> function registers or deregisters a name, a service name, and associated addresses with a
///specific namespace provider.
///Params:
///    pName = A pointer to a <b>NULL</b>-terminated string containing a name under which addresses are to be registered or
///            deregistered. The interpretation of this parameter specific to the namespace provider.
///    pServiceName = A pointer to an optional <b>NULL</b>-terminated string that contains the service name associated with the name
///                   being registered. The interpretation of this parameter is specific to the namespace provider.
///    pAddresses = A pointer to an optional list of addresses to register with the namespace provider.
///    dwAddressCount = The number of addresses passed in <i>pAddresses</i> parameter. If this parameter is zero, the <i>pName</i>
///                     parameter is deregistered from the namespace provider.
///    lpBlob = An optional pointer to data that is used to set provider-specific namespace information that is associated with
///             the <i>pName</i> parameter beyond a list of addresses. Any information that cannot be passed in the
///             <i>pAddresses</i> parameter can be passed in the <i>lpBlob</i> parameter. The format of this information is
///             specific to the namespace provider.
///    dwFlags = A set of flags controlling how the <i>pName</i> and <i>pServiceName</i> parameters are to be registered with the
///              namespace provider. The interpretation of this information is specific to the namespace provider.
///    dwNameSpace = A namespace identifier that determines which namespace provider to register this information with. Passing a
///                  specific namespace identifier will result in registering this information only with the namespace providers that
///                  support the specified namespace. Specifying NS_ALL will result in registering the information with all installed
///                  and active namespace providers. Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i>
///                  include file. Several namespace providers are included with Windows Vista and later. Other namespace providers
///                  can be installed, so the following possible values are only those commonly available. Many others are possible.
///                  <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a id="NS_ALL"></a><a
///                  id="ns_all"></a><dl> <dt><b>NS_ALL</b></dt> </dl> </td> <td width="60%"> All installed and active namespaces.
///                  </td> </tr> <tr> <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl> <dt><b>NS_BTH</b></dt> </dl> </td>
///                  <td width="60%"> The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.
///                  </td> </tr> <tr> <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl> <dt><b>NS_DNS</b></dt> </dl> </td>
///                  <td width="60%"> The domain name system (DNS) namespace. </td> </tr> <tr> <td width="40%"><a id="NS_EMAIL"></a><a
///                  id="ns_email"></a><dl> <dt><b>NS_EMAIL</b></dt> </dl> </td> <td width="60%"> The email namespace. This namespace
///                  identifier is supported on Windows Vista and later. </td> </tr> <tr> <td width="40%"><a id="NS_NLA"></a><a
///                  id="ns_nla"></a><dl> <dt><b>NS_NLA</b></dt> </dl> </td> <td width="60%"> The network location awareness (NLA)
///                  namespace. This namespace identifier is supported on Windows XP and later. </td> </tr> <tr> <td width="40%"><a
///                  id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl> <dt><b>NS_PNRPNAME</b></dt> </dl> </td> <td width="60%"> The
///                  peer-to-peer namespace for a specific peer name. This namespace identifier is supported on Windows Vista and
///                  later. </td> </tr> <tr> <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
///                  <dt><b>NS_PNRPCLOUD</b></dt> </dl> </td> <td width="60%"> The peer-to-peer namespace for a collection of peer
///                  names. This namespace identifier is supported on Windows Vista and later. </td> </tr> </table>
///    lpNspId = A pointer to an optional GUID of a specific namespace provider to register this information with in the case
///              where multiple namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for a
///              specific namespace provider will result in the information being registered with only the specified namespace
///              provider. The WSAEnumNameSpaceProviders function can be called to retrieve the GUID for a namespace provider.
///    timeout = An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider
///              before aborting the call. This parameter is currently reserved and must be set to <b>NULL</b> since a
///              <i>timeout</i> option is not supported.
///    lpOverlapped = An optional pointer to an overlapped structure used for asynchronous operation. This parameter is currently
///                   reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
///    lpCompletionRoutine = An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This
///                          parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
///    lpNameHandle = An optional pointer used only for asynchronous operations. This parameter is currently reserved and must be set
///                   to <b>NULL</b> since asynchronous operations are not supported.
///Returns:
///    On success, <b>SetAddrInfoEx</b> returns NO_ERROR (0). Failure returns a nonzero Windows Sockets error code, as
///    found in the Windows Sockets Error Codes. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSANOTINITIALISED</b></dt> </dl> </td> <td width="60%"> A successful WSAStartup call
///    must occur before using this function. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSATRY_AGAIN</b></dt> </dl>
///    </td> <td width="60%"> A temporary failure in name resolution occurred. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was provided. This error is returned
///    if any of the reserved parameters are not <b>NULL</b>. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOBUFS</b></dt> </dl> </td> <td width="60%"> Insufficient buffer space is available. </td> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> A nonrecoverable failure in
///    name resolution occurred. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl>
///    </td> <td width="60%"> A memory allocation failure occurred. </td> </tr> </table>
///    
@DllImport("WS2_32")
int SetAddrInfoExW(const(wchar)* pName, const(wchar)* pServiceName, SOCKET_ADDRESS* pAddresses, 
                   uint dwAddressCount, BLOB* lpBlob, uint dwFlags, uint dwNameSpace, GUID* lpNspId, 
                   timeval* timeout, OVERLAPPED* lpOverlapped, 
                   LPLOOKUPSERVICE_COMPLETION_ROUTINE lpCompletionRoutine, ptrdiff_t* lpNameHandle);

///The <b>freeaddrinfo</b> function frees address information that the getaddrinfo function dynamically allocates in
///addrinfo structures.
///Params:
///    pAddrInfo = A pointer to the addrinfo structure or linked list of <b>addrinfo</b> structures to be freed. All dynamic storage
///                pointed to within the <b>addrinfo</b> structure or structures is also freed.
///Returns:
///    This function does not return a value.
///    
@DllImport("WS2_32")
void freeaddrinfo(ADDRINFOA* pAddrInfo);

///The <b>FreeAddrInfoW</b> function frees address information that the GetAddrInfoW function dynamically allocates in
///addrinfoW structures.
///Params:
///    pAddrInfo = A pointer to the addrinfoW structure or linked list of <b>addrinfoW</b> structures to be freed. All dynamic
///                storage pointed to within the <b>addrinfoW</b> structure or structures is also freed.
///Returns:
///    This function does not return a value.
///    
@DllImport("WS2_32")
void FreeAddrInfoW(addrinfoW* pAddrInfo);

///The <b>FreeAddrInfoEx</b> function frees address information that the GetAddrInfoEx function dynamically allocates in
///addrinfoex structures.
///Params:
///    pAddrInfoEx = A pointer to the addrinfoex structure or linked list of <b>addrinfoex</b> structures to be freed. All dynamic
///                  storage pointed to within the <b>addrinfoex</b> structure or structures is also freed.
///Returns:
///    This function does not return a value.
///    
@DllImport("WS2_32")
void FreeAddrInfoEx(addrinfoexA* pAddrInfoEx);

///The <b>FreeAddrInfoEx</b> function frees address information that the GetAddrInfoEx function dynamically allocates in
///addrinfoex structures.
///Params:
///    pAddrInfoEx = A pointer to the addrinfoex structure or linked list of <b>addrinfoex</b> structures to be freed. All dynamic
///                  storage pointed to within the <b>addrinfoex</b> structure or structures is also freed.
///Returns:
///    This function does not return a value.
///    
@DllImport("WS2_32")
void FreeAddrInfoExW(addrinfoexW* pAddrInfoEx);

///The <b>getnameinfo</b> function provides protocol-independent name resolution from an address to an ANSI host name
///and from a port number to the ANSI service name.
///Params:
///    pSockaddr = A pointer to a socket address structure that contains the address and port number of the socket. For IPv4, the
///                <i>sa</i> parameter points to a sockaddr_in structure. For IPv6, the <i>sa</i> parameter points to a
///                <b>sockaddr_in6</b> structure.
///    SockaddrLength = The length, in bytes, of the structure pointed to by the <i>sa</i> parameter.
///    pNodeBuffer = A pointer to an ANSI string used to hold the host name. On success, the host name is returned as a Fully
///                  Qualified Domain Name (FQDN) by default. If the <i>host</i> parameter is <b>NULL</b>, this indicates the caller
///                  does not want to receive a host name string.
///    NodeBufferSize = The length, in bytes, of the buffer pointed to by the <i>host</i> parameter. The caller must provide a buffer
///                     large enough to hold the host name, including the terminating <b>NULL</b> character.
///    pServiceBuffer = A pointer to an ANSI string to hold the service name. On success, an ANSI string that represents the service name
///                     associated with the port number is returned. If the <i>serv</i> parameter is <b>NULL</b>, this indicates the
///                     caller does not want to receive a service name string.
///    ServiceBufferSize = The length, in bytes, of the buffer pointed to by the <i>serv</i> parameter. The caller must provide a buffer
///                        large enough to hold the service name, including the terminating <b>NULL</b> character.
///    Flags = A value used to customize processing of the <b>getnameinfo</b> function. See the Remarks section.
///Returns:
///    On success, <b>getnameinfo</b> returns zero. Any nonzero return value indicates failure and a specific error code
///    can be retrieved by calling WSAGetLastError. Nonzero error codes returned by the <b>getnameinfo</b> function also
///    map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table
///    lists these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they
///    offer familiar and comprehensive error information for Winsock programmers. <table> <tr> <th>Error value</th>
///    <th>WSA equivalent</th> <th>Description</th> </tr> <tr> <td>EAI_AGAIN</td> <td>WSATRY_AGAIN</td> <td>A temporary
///    failure in name resolution occurred.</td> </tr> <tr> <td>EAI_BADFLAGS</td> <td>WSAEINVAL</td> <td>One or more
///    invalid parameters was passed to the <b>getnameinfo</b> function. This error is returned if a host name was
///    requested but the <i>hostlen</i> parameter was zero or if a service name was requested, but the <i>servlen</i>
///    parameter was zero. </td> </tr> <tr> <td>EAI_FAIL</td> <td>WSANO_RECOVERY</td> <td>A nonrecoverable failure in
///    name resolution occurred.</td> </tr> <tr> <td>EAI_FAMILY</td> <td>WSAEAFNOSUPPORT</td> <td>The <b>sa_family</b>
///    member of socket address structure pointed to by the <i>sa</i> parameter is not supported. </td> </tr> <tr>
///    <td>EAI_MEMORY</td> <td>WSA_NOT_ENOUGH_MEMORY</td> <td>A memory allocation failure occurred.</td> </tr> <tr>
///    <td>EAI_NONAME</td> <td>WSAHOST_NOT_FOUND</td> <td>A service name was requested, but no port number was found in
///    the structure pointed to by the <i>sa</i> parameter or no service name matching the port number was found.
///    NI_NAMEREQD is set and the host name cannot be located, or both the <i>host</i> and <i>serv</i> parameters were
///    <b>NULL</b>. </td> </tr> </table> Use the gai_strerror function to print error messages based on the EAI codes
///    returned by the <b>getnameinfo</b> function. The <b>gai_strerror</b> function is provided for compliance with
///    IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as
///    WSAGetLastError is recommended. In addition, the following error codes can be returned. <table> <tr> <th>Error
///    code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> This error is returned if the <i>sa</i> parameter is <b>NULL</b> or the <i>salen</i> parameter is
///    less than the length required for the size of sockaddr_in structure for IPv4 or the <b>sockaddr_in6</b> structure
///    for IPv6. </td> </tr> </table>
///    
@DllImport("WS2_32")
int getnameinfo(char* pSockaddr, int SockaddrLength, const(char)* pNodeBuffer, uint NodeBufferSize, 
                const(char)* pServiceBuffer, uint ServiceBufferSize, int Flags);

///The <b>GetNameInfoW</b> function provides protocol-independent name resolution from an address to a Unicode host name
///and from a port number to the Unicode service name.
///Params:
///    pSockaddr = A pointer to a socket address structure containing the IP address and port number of the socket. For IPv4, the
///                <i>pSockaddr</i> parameter points to a sockaddr_in structure. For IPv6, the <i>pSockaddr</i> parameter points to
///                a <b>sockaddr_in6</b> structure.
///    SockaddrLength = The length, in bytes, of the structure pointed to by the <i>pSockaddr</i> parameter.
///    pNodeBuffer = A pointer to a Unicode string to hold the host name. On success, a pointer to the Unicode host name is returned
///                  as a Fully Qualified Domain Name (FQDN) by default. If the <i>pNodeBuffer</i> parameter is <b>NULL</b>, this
///                  indicates the caller does not want to receive a host name string.
///    NodeBufferSize = The number of <b>WCHAR</b> characters in the buffer pointed to by the <i>pNodeBuffer</i> parameter. The caller
///                     must provide a buffer large enough to hold the Unicode host name, including the terminating <b>NULL</b>
///                     character.
///    pServiceBuffer = A pointer to a Unicode string to hold the service name. On success, a pointer is returned to a Unicode string
///                     representing the service name associated with the port number. If the <i>pServiceBuffer</i> parameter is
///                     <b>NULL</b>, this indicates the caller does not want to receive a service name string.
///    ServiceBufferSize = The number of <b>WCHAR</b> characters in the buffer pointed to by the <i>pServiceBuffer</i> parameter. The caller
///                        must provide a buffer large enough to hold the Unicode service name, including the terminating <b>NULL</b>
///                        character.
///    Flags = A value used to customize processing of the <b>GetNameInfoW</b> function. See the Remarks section.
///Returns:
///    On success, <b>GetNameInfoW</b> returns zero. Any nonzero return value indicates failure and a specific error
///    code can be retrieved by calling WSAGetLastError. Nonzero error codes returned by the <b>GetNameInfoW</b>
///    function also map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The
///    following table shows these error codes and their WSA equivalents. It is recommended that the WSA error codes be
///    used, as they offer familiar and comprehensive error information for Winsock programmers. <table> <tr> <th>Error
///    value</th> <th>WSA equivalent</th> <th>Description</th> </tr> <tr> <td>EAI_AGAIN</td> <td>WSATRY_AGAIN</td> <td>A
///    temporary failure in name resolution occurred.</td> </tr> <tr> <td>EAI_BADFLAGS</td> <td>WSAEINVAL</td> <td>One
///    or more invalid parameters was passed to the <b>GetNameInfoW</b> function. This error is returned if a host name
///    was requested but the <i>NodeBufferSize</i> parameter was zero or if a service name was requested but the
///    <i>ServiceBufferSize</i> parameter was zero. </td> </tr> <tr> <td>EAI_FAIL</td> <td>WSANO_RECOVERY</td> <td>A
///    nonrecoverable failure in name resolution occurred.</td> </tr> <tr> <td>EAI_FAMILY</td> <td>WSAEAFNOSUPPORT</td>
///    <td>The <b>sa_family</b> member of socket address structure pointed to by the <i>pSockaddr</i> parameter is not
///    supported. </td> </tr> <tr> <td>EAI_MEMORY</td> <td>WSA_NOT_ENOUGH_MEMORY</td> <td>A memory allocation failure
///    occurred.</td> </tr> <tr> <td>EAI_NONAME</td> <td>WSAHOST_NOT_FOUND</td> <td>A service name was requested, but no
///    port number was found in the structure pointed to by the <i>pSockaddr</i> parameter or no service name matching
///    the port number was found. NI_NAMEREQD is set and the host's name cannot be located, or both the
///    <i>pNodeBuffer</i> and <i>pServiceBuffer</i> parameters were <b>NULL</b>. </td> </tr> </table> You can use the
///    gai_strerror function to print error messages based on the EAI codes returned by the <b>GetNameInfoW</b>
///    function. The <b>gai_strerror</b> function is provided for compliance with IETF recommendations, but it is not
///    thread safe. Therefore, use of traditional Windows Sockets functions such as WSAGetLastError is recommended. In
///    addition, the following error codes can be returned. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr>
///    <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> This error is returned if the
///    <i>pSockaddr</i> parameter is <b>NULL</b> or the <i>SockaddrLength</i> parameter is less than the length needed
///    for the size of sockaddr_in structure for IPv4 or the <b>sockaddr_in6</b> structure for IPv6. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
int GetNameInfoW(char* pSockaddr, int SockaddrLength, const(wchar)* pNodeBuffer, uint NodeBufferSize, 
                 const(wchar)* pServiceBuffer, uint ServiceBufferSize, int Flags);

///The <b>InetPton</b> function converts an IPv4 or IPv6 Internet network address in its standard text presentation form
///into its numeric binary form. The ANSI version of this function is <b>inet_pton</b>.
///Params:
///    Family = The address family. Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note
///             that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
///             directly. Note that the values for the AF_ address family and PF_ protocol family constants are identical (for
///             example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used. The values currently supported are
///             <b>AF_INET</b> and <b>AF_INET6</b>. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="AF_INET"></a><a id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The
///             Internet Protocol version 4 (IPv4) address family. When this parameter is specified, the <i>pszAddrString</i>
///             parameter must point to a text representation of an IPv4 address and the <i>pAddrBuf</i> parameter returns a
///             pointer to an IN_ADDR structure that represents the IPv4 address. </td> </tr> <tr> <td width="40%"><a
///             id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl> </td> <td width="60%"> The
///             Internet Protocol version 6 (IPv6) address family. When this parameter is specified, the <i>pszAddrString</i>
///             parameter must point to a text representation of an IPv6 address and the <i>pAddrBuf</i> parameter returns a
///             pointer to an IN6_ADDR structure that represents the IPv6 address. </td> </tr> </table>
///    pszAddrString = A pointer to the <b>NULL</b>-terminated string that contains the text representation of the IP address to convert
///                    to numeric binary form. When the <i>Family</i> parameter is <b>AF_INET</b>, then the <i>pszAddrString</i>
///                    parameter must point to a text representation of an IPv4 address in standard dotted-decimal notation. When the
///                    <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pszAddrString</i> parameter must point to a text
///                    representation of an IPv6 address in standard notation.
///    pAddrBuf = A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is
///               returned in network byte order. When the <i>Family</i> parameter is <b>AF_INET</b>, this buffer should be large
///               enough to hold an IN_ADDR structure. When the <i>Family</i> parameter is <b>AF_INET6</b>, this buffer should be
///               large enough to hold an IN6_ADDR structure.
///Returns:
///    If no error occurs, the <b>InetPton</b> function returns a value of 1 and the buffer pointed to by the
///    <i>pAddrBuf</i> parameter contains the binary numeric IP address in network byte order. The <b>InetPton</b>
///    function returns a value of 0 if the <i>pAddrBuf</i> parameter points to a string that is not a valid IPv4
///    dotted-decimal string or a valid IPv6 address string. Otherwise, a value of -1 is returned, and a specific error
///    code can be retrieved by calling the WSAGetLastError for extended error information. If the function has an
///    error, the extended error code returned by WSAGetLastError can be one of the following values. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td>
///    <td width="60%"> The address family specified in the <i>Family</i> parameter is not supported. This error is
///    returned if the <i>Family</i> parameter specified was not <b>AF_INET</b> or <b>AF_INET6</b>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>pszAddrString</i> or
///    <i>pAddrBuf</i> parameters are <b>NULL</b> or are not part of the user address space. </td> </tr> </table>
///    
@DllImport("WS2_32")
int inet_pton(int Family, const(char)* pszAddrString, char* pAddrBuf);

///The <b>InetPton</b> function converts an IPv4 or IPv6 Internet network address in its standard text presentation form
///into its numeric binary form. The ANSI version of this function is <b>inet_pton</b>.
///Params:
///    Family = The address family. Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note
///             that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
///             directly. Note that the values for the AF_ address family and PF_ protocol family constants are identical (for
///             example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used. The values currently supported are
///             <b>AF_INET</b> and <b>AF_INET6</b>. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="AF_INET"></a><a id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The
///             Internet Protocol version 4 (IPv4) address family. When this parameter is specified, the <i>pszAddrString</i>
///             parameter must point to a text representation of an IPv4 address and the <i>pAddrBuf</i> parameter returns a
///             pointer to an IN_ADDR structure that represents the IPv4 address. </td> </tr> <tr> <td width="40%"><a
///             id="AF_INET6"></a><a id="af_inet6"></a><dl> <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl> </td> <td width="60%"> The
///             Internet Protocol version 6 (IPv6) address family. When this parameter is specified, the <i>pszAddrString</i>
///             parameter must point to a text representation of an IPv6 address and the <i>pAddrBuf</i> parameter returns a
///             pointer to an IN6_ADDR structure that represents the IPv6 address. </td> </tr> </table>
///    pszAddrString = A pointer to the <b>NULL</b>-terminated string that contains the text representation of the IP address to convert
///                    to numeric binary form. When the <i>Family</i> parameter is <b>AF_INET</b>, then the <i>pszAddrString</i>
///                    parameter must point to a text representation of an IPv4 address in standard dotted-decimal notation. When the
///                    <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pszAddrString</i> parameter must point to a text
///                    representation of an IPv6 address in standard notation.
///    pAddrBuf = A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is
///               returned in network byte order. When the <i>Family</i> parameter is <b>AF_INET</b>, this buffer should be large
///               enough to hold an IN_ADDR structure. When the <i>Family</i> parameter is <b>AF_INET6</b>, this buffer should be
///               large enough to hold an IN6_ADDR structure.
///Returns:
///    If no error occurs, the <b>InetPton</b> function returns a value of 1 and the buffer pointed to by the
///    <i>pAddrBuf</i> parameter contains the binary numeric IP address in network byte order. The <b>InetPton</b>
///    function returns a value of 0 if the <i>pAddrBuf</i> parameter points to a string that is not a valid IPv4
///    dotted-decimal string or a valid IPv6 address string. Otherwise, a value of -1 is returned, and a specific error
///    code can be retrieved by calling the WSAGetLastError for extended error information. If the function has an
///    error, the extended error code returned by WSAGetLastError can be one of the following values. <table> <tr>
///    <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td>
///    <td width="60%"> The address family specified in the <i>Family</i> parameter is not supported. This error is
///    returned if the <i>Family</i> parameter specified was not <b>AF_INET</b> or <b>AF_INET6</b>. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <i>pszAddrString</i> or
///    <i>pAddrBuf</i> parameters are <b>NULL</b> or are not part of the user address space. </td> </tr> </table>
///    
@DllImport("WS2_32")
int InetPtonW(int Family, const(wchar)* pszAddrString, char* pAddrBuf);

///The <b>InetNtop</b> function converts an IPv4 or IPv6 Internet network address into a string in Internet standard
///format. The ANSI version of this function is <b>inet_ntop</b>.
///Params:
///    Family = The address family. Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note
///             that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
///             directly. Note that the values for the AF_ address family and PF_ protocol family constants are identical (for
///             example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used. The values currently supported are
///             <b>AF_INET</b> and <b>AF_INET6</b>. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="AF_INET"></a><a id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The
///             Internet Protocol version 4 (IPv4) address family. When this parameter is specified, this function returns an
///             IPv4 address string. </td> </tr> <tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
///             <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl> </td> <td width="60%"> The Internet Protocol version 6 (IPv6) address
///             family. When this parameter is specified, this function returns an IPv6 address string. </td> </tr> </table>
///    pAddr = A pointer to the IP address in network byte to convert to a string. When the <i>Family</i> parameter is
///            <b>AF_INET</b>, then the <i>pAddr</i> parameter must point to an IN_ADDR structure with the IPv4 address to
///            convert. When the <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pAddr</i> parameter must point to an
///            IN6_ADDR structure with the IPv6 address to convert.
///    pStringBuf = A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IP address. For
///                 an IPv4 address, this buffer should be large enough to hold at least 16 characters. For an IPv6 address, this
///                 buffer should be large enough to hold at least 46 characters.
///    StringBufSize = On input, the length, in characters, of the buffer pointed to by the <i>pStringBuf</i> parameter.
///Returns:
///    If no error occurs, <b>InetNtop</b> function returns a pointer to a buffer containing the string representation
///    of IP address in standard format. Otherwise, a value of <b>NULL</b> is returned, and a specific error code can be
///    retrieved by calling the WSAGetLastError for extended error information. If the function fails, the extended
///    error code returned by WSAGetLastError can be one of the following values. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%">
///    The address family specified in the <i>Family</i> parameter is not supported. This error is returned if the
///    <i>Family</i> parameter specified was not <b>AF_INET</b> or <b>AF_INET6</b>. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pStringBuf</i> or the
///    <i>StringBufSize</i> parameter is zero. This error is also returned if the length of the buffer pointed to by the
///    <i>pStringBuf</i> parameter is not large enough to receive the string representation of the IP address. </td>
///    </tr> </table>
///    
@DllImport("WS2_32")
byte* inet_ntop(int Family, const(void)* pAddr, const(char)* pStringBuf, size_t StringBufSize);

///The <b>InetNtop</b> function converts an IPv4 or IPv6 Internet network address into a string in Internet standard
///format. The ANSI version of this function is <b>inet_ntop</b>.
///Params:
///    Family = The address family. Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note
///             that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used
///             directly. Note that the values for the AF_ address family and PF_ protocol family constants are identical (for
///             example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used. The values currently supported are
///             <b>AF_INET</b> and <b>AF_INET6</b>. <table> <tr> <th>Value</th> <th>Meaning</th> </tr> <tr> <td width="40%"><a
///             id="AF_INET"></a><a id="af_inet"></a><dl> <dt><b>AF_INET</b></dt> <dt>2</dt> </dl> </td> <td width="60%"> The
///             Internet Protocol version 4 (IPv4) address family. When this parameter is specified, this function returns an
///             IPv4 address string. </td> </tr> <tr> <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
///             <dt><b>AF_INET6</b></dt> <dt>23</dt> </dl> </td> <td width="60%"> The Internet Protocol version 6 (IPv6) address
///             family. When this parameter is specified, this function returns an IPv6 address string. </td> </tr> </table>
///    pAddr = A pointer to the IP address in network byte to convert to a string. When the <i>Family</i> parameter is
///            <b>AF_INET</b>, then the <i>pAddr</i> parameter must point to an IN_ADDR structure with the IPv4 address to
///            convert. When the <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pAddr</i> parameter must point to an
///            IN6_ADDR structure with the IPv6 address to convert.
///    pStringBuf = A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IP address. For
///                 an IPv4 address, this buffer should be large enough to hold at least 16 characters. For an IPv6 address, this
///                 buffer should be large enough to hold at least 46 characters.
///    StringBufSize = On input, the length, in characters, of the buffer pointed to by the <i>pStringBuf</i> parameter.
///Returns:
///    If no error occurs, <b>InetNtop</b> function returns a pointer to a buffer containing the string representation
///    of IP address in standard format. Otherwise, a value of <b>NULL</b> is returned, and a specific error code can be
///    retrieved by calling the WSAGetLastError for extended error information. If the function fails, the extended
///    error code returned by WSAGetLastError can be one of the following values. <table> <tr> <th>Error code</th>
///    <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%">
///    The address family specified in the <i>Family</i> parameter is not supported. This error is returned if the
///    <i>Family</i> parameter specified was not <b>AF_INET</b> or <b>AF_INET6</b>. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>ERROR_INVALID_PARAMETER</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed to the
///    function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pStringBuf</i> or the
///    <i>StringBufSize</i> parameter is zero. This error is also returned if the length of the buffer pointed to by the
///    <i>pStringBuf</i> parameter is not large enough to receive the string representation of the IP address. </td>
///    </tr> </table>
///    
@DllImport("WS2_32")
ushort* InetNtopW(int Family, const(void)* pAddr, const(wchar)* pStringBuf, size_t StringBufSize);

///The <b>WSASetSocketSecurity</b> function enables and applies security for a socket.
///Params:
///    Socket = A descriptor that identifies a socket on which security settings are being applied.
///    SecuritySettings = A pointer to a SOCKET_SECURITY_SETTINGS structure that specifies the security settings to be applied to the
///                       socket's traffic. If this parameter is <b>NULL</b>, default settings will be applied to the socket.
///    SecuritySettingsLen = The size, in bytes, of the <i>SecuritySettings</i> parameter.
///    Overlapped = A pointer to a WSAOVERLAPPED structure. This parameter is ignored for non-overlapped sockets.
///    CompletionRoutine = A pointer to the completion routine called when the operation has been completed. This parameter is ignored for
///                        non-overlapped sockets.
///Returns:
///    If the function succeeds, the return value is zero. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. Some possible error codes are listed below.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified address family is not supported. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was
///    passed. This error is returned if the socket passed in the <i>Socket</i> parameter was not created with an
///    address family of the <b>AF_INET</b> or <b>AF_INET6</b> and a socket type of <b>SOCK_DGRAM</b> or
///    <b>SOCK_STREAM</b>. This error is also returned if the SOCKET_SECURITY_SETTINGS structure pointed to by the
///    <i>SecuritySettings</i> parameter has an incorrect value. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEISCONN</b></dt> </dl> </td> <td width="60%"> The socket is connected. This function is not permitted
///    with a connected socket, whether the socket is connection oriented or connectionless. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> A buffer passed was too small. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor passed
///    in the <i>Socket</i> parameter is not a valid socket. </td> </tr> </table>
///    
@DllImport("fwpuclnt")
int WSASetSocketSecurity(size_t Socket, char* SecuritySettings, uint SecuritySettingsLen, OVERLAPPED* Overlapped, 
                         LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine);

///The <b>WSAQuerySocketSecurity</b> function queries information about the security applied to a connection on a
///socket.
///Params:
///    Socket = A descriptor identifying a socket for which security information is being queried.
///    SecurityQueryTemplate = A pointer to a SOCKET_SECURITY_QUERY_TEMPLATE structure that specifies the type of query information to return. A
///                            SOCKET_SECURITY_QUERY_TEMPLATE structure pointed to by this parameter may contain zeroes for all members to
///                            request default security information. On successful return, only the <b>Flags</b> member in the
///                            SOCKET_SECURITY_QUERY_INFO will be set in the returned <i>SecurityQueryInfo</i> parameter. This parameter may be
///                            a <b>NULL</b> pointer if the <i>Socket</i> parameter was created with a protocol of <b>IPPROTO_TCP</b>. In this
///                            case, the information returned is the same as if a SOCKET_SECURITY_QUERY_TEMPLATE structure with all values set
///                            to zero was passed. This parameter should be specified for a socket with protocol of <b>IPPROTO_TCP</b> if more
///                            than the default security information is required. If the SOCKET_SECURITY_QUERY_TEMPLATE structure is specified
///                            with the <b>PeerTokenAccessMask</b> member not specified (set to zero), then the <b>WSAQuerySocketSecurity</b>
///                            function will not return the <b>PeerApplicationAccessTokenHandle</b> and <b>PeerMachineAccessTokenHandle</b>
///                            members in the SOCKET_SECURITY_QUERY_INFO structure. If a <i>Socket</i> parameter was created with a protocol not
///                            equal to <b>IPPROTO_TCP</b>, the <i>SecurityQueryTemplate</i> parameter must be specified. In these cases, the
///                            <b>PeerAddress</b> member of the SOCKET_SECURITY_QUERY_TEMPLATE structure must specify an address family of
///                            AF_INET or AF_INET6 along with peer IP address and port number.
///    SecurityQueryTemplateLen = The size, in bytes, of the <i>SecurityQueryTemplate</i> parameter. This parameter may be a zero if the
///                               <i>Socket</i> parameter was created with a protocol of <b>IPPROTO_TCP</b>. Otherwise, this parameter must be the
///                               size of a SOCKET_SECURITY_QUERY_TEMPLATE structure.
///    SecurityQueryInfo = A pointer to a buffer that will receive a SOCKET_SECURITY_QUERY_INFO structure containing the information
///                        queried. This value can be set to <b>NULL</b> to query the size of the output buffer.
///    SecurityQueryInfoLen = On input, a pointer to the size, in bytes, of the <i>SecurityQueryInfo</i> parameter. If the buffer is too small
///                           to receive the queried information, the call will return SOCKET_ERROR, and the number of bytes needed to return
///                           the queried information will be set in the value pointed to by this parameter. On a successful call, the number
///                           of bytes copied is returned.
///    Overlapped = A pointer to a WSAOVERLAPPED structure. This parameter is ignored for non-overlapped sockets.
///    CompletionRoutine = A pointer to the completion routine called when the operation has been completed. This parameter is ignored for
///                        non-overlapped sockets.
///Returns:
///    If the function succeeds, the return value is zero. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. Some possible error codes are listed below.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified address family is not supported. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAECONNRESET</b></dt> </dl> </td> <td width="60%"> For a stream socket,
///    the virtual circuit was reset by the remote side. The application should close the socket as it is no longer
///    usable. For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP
///    "Port Unreachable" message. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td
///    width="60%"> The system detected an invalid pointer address in attempting to use a parameter. This error is
///    returned if the <i>SecurityQueryInfoLen</i> parameter was a <b>NULL</b> pointer. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed. This
///    error is returned if the socket passed in the <i>Socket</i> parameter was not created with an address family of
///    the <b>AF_INET</b> or <b>AF_INET6</b> and a socket type of <b>SOCK_DGRAM</b> or <b>SOCK_STREAM</b>. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> A buffer passed was too
///    small. This error is returned for a <i>Socket</i> parameter when the protocol was not <b>IPPROTO_TCP</b> if the
///    <i>SecurityQueryInfo</i> parameter is a <b>NULL</b> pointer or the <i>SecurityQueryTemplateLen</i> parameter is
///    less than the size of a SOCKET_SECURITY_QUERY_TEMPLATE structure. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor passed in the <i>Socket</i> parameter is
///    not a valid socket. </td> </tr> </table>
///    
@DllImport("fwpuclnt")
int WSAQuerySocketSecurity(size_t Socket, char* SecurityQueryTemplate, uint SecurityQueryTemplateLen, 
                           char* SecurityQueryInfo, uint* SecurityQueryInfoLen, OVERLAPPED* Overlapped, 
                           LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine);

///The <b>WSASetSocketPeerTargetName</b> function is used to specify the peer target name (SPN) that corresponds to a
///peer IP address. This target name is meant to be specified by client applications to securely identify the peer that
///should be authenticated.
///Params:
///    Socket = A descriptor identifying a socket on which the peer target name is being assigned.
///    PeerTargetName = A pointer to a SOCKET_PEER_TARGET_NAME structure that defines the peer target name.
///    PeerTargetNameLen = The size, in bytes, of the <i>PeerTargetName</i> parameter.
///    Overlapped = A pointer to a WSAOVERLAPPED structure. This parameter is ignored for non-overlapped sockets.
///    CompletionRoutine = A pointer to the completion routine called when the operation has been completed. This parameter is ignored for
///                        non-overlapped sockets.
///Returns:
///    If the function succeeds, the return value is zero. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. Some possible error codes are listed below.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified address family is not supported. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The system detected an
///    invalid address pointer in attempting to use a pointer argument of a call. This error is returned if the
///    <i>PeerTargetName</i> parameter was a <b>NULL</b> pointer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed. This error is returned if
///    the socket passed in the <i>Socket</i> parameter was not created with an address family of the <b>AF_INET</b> or
///    <b>AF_INET6</b> and a socket type of <b>SOCK_DGRAM</b> or <b>SOCK_STREAM</b>. This error is also returned for a
///    connectionless socket if the IP address and port are zero in the <b>PeerAddress</b> member of the
///    SOCKET_PEER_TARGET_NAME structure pointed to by the <i>PeerTargetName</i> parameter. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAEISCONN</b></dt> </dl> </td> <td width="60%"> The socket is connected. This function
///    is not permitted with a connected socket, whether the socket is connection oriented or connectionless. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> A buffer passed was too
///    small. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The
///    descriptor passed in the <i>Socket</i> parameter is not a valid socket. </td> </tr> </table>
///    
@DllImport("fwpuclnt")
int WSASetSocketPeerTargetName(size_t Socket, char* PeerTargetName, uint PeerTargetNameLen, OVERLAPPED* Overlapped, 
                               LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine);

///The <b>WSADeleteSocketPeerTargetName</b> function removes the association between a peer target name and an IP
///address for a socket. After a successful return, there will be no future association between the IP address and the
///target name.
///Params:
///    Socket = A descriptor identifying a socket on which the peer target name is being deleted.
///    PeerAddr = The IP address of the peer for which the target name is being deleted.
///    PeerAddrLen = The size, in bytes, of the <i>PeerAddr</i> parameter.
///    Overlapped = A pointer to a WSAOVERLAPPED structure. This parameter is ignored for non-overlapped sockets.
///    CompletionRoutine = A pointer to the completion routine called when the operation has been completed. This parameter is ignored for
///                        non-overlapped sockets.
///Returns:
///    If the function succeeds, the return value is 0. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. Some possible error codes are listed below.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified address family is not supported. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The system detected an
///    invalid address pointer in attempting to use a pointer argument of a call. This error is returned if the
///    <i>PeerAddr</i> parameter was a <b>NULL</b> pointer. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> An invalid parameter was passed. This error is returned if
///    the socket passed in the <i>Socket</i> parameter was not created with an address family of the <b>AF_INET</b> or
///    <b>AF_INET6</b> and a socket type of <b>SOCK_DGRAM</b> or <b>SOCK_STREAM</b>. </td> </tr> <tr> <td width="40%">
///    <dl> <dt><b>WSAEMSGSIZE</b></dt> </dl> </td> <td width="60%"> A buffer passed was too small. </td> </tr> <tr> <td
///    width="40%"> <dl> <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor passed in the
///    <i>Socket</i> parameter is not a valid socket. </td> </tr> </table>
///    
@DllImport("fwpuclnt")
int WSADeleteSocketPeerTargetName(size_t Socket, char* PeerAddr, uint PeerAddrLen, OVERLAPPED* Overlapped, 
                                  LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine);

///The <b>WSAImpersonateSocketPeer</b> function is used to impersonate the security principal corresponding to a socket
///peer in order to perform application-level authorization.
///Params:
///    Socket = Identifies the application socket.
///    PeerAddr = The IP address of the peer to be impersonated. For connection-oriented sockets, the connected socket uniquely
///               identifies a peer. In this case, this parameter is ignored.
///    PeerAddrLen = The size, in bytes, of the <i>PeerAddress</i> parameter.
///Returns:
///    If the function succeeds, the return value is 0. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. Some possible error codes are listed below.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEFAULT</b></dt>
///    </dl> </td> <td width="60%"> The system detected an invalid address pointer in attempting to use a pointer
///    argument of a call. This error is returned if the <i>PeerAddr</i> parameter was a <b>NULL</b> pointer. </td>
///    </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEAFNOSUPPORT</b></dt> </dl> </td> <td width="60%"> The specified
///    address family is not supported. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEMSGSIZE</b></dt> </dl> </td>
///    <td width="60%"> A buffer passed was too small. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAENOTSOCK</b></dt> </dl> </td> <td width="60%"> The descriptor passed in the <i>Socket</i> parameter is
///    not a valid socket. </td> </tr> </table>
///    
@DllImport("fwpuclnt")
int WSAImpersonateSocketPeer(size_t Socket, char* PeerAddr, uint PeerAddrLen);

///The <b>WSARevertImpersonation</b> function terminates the impersonation of a socket peer. This must be called after
///calling WSAImpersonateSocketPeer and finishing any access checks.
///Returns:
///    If the function succeeds, the return value is zero. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a
///    specific error code can be retrieved by calling WSAGetLastError. Some possible error codes are listed below.
///    <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSASYSCALLFAILURE</b></dt> </dl> </td> <td width="60%"> A system call that should never fail has failed.
///    </td> </tr> </table>
///    
@DllImport("fwpuclnt")
int WSARevertImpersonation();

///The <b>SetSocketMediaStreamingMode</b> function indicates whether the network is to be used for transferring
///streaming media that requires quality of service.
///Params:
///    value = Indicates whether the network is to be used for transferring streaming media that requires quality of service.
///            This ensures that sockets opened as low latency will get the right quality of service over 802.11 wireless
///            networks.
///Returns:
///    If no error occurs, <b>SetSocketMediaStreamingMode</b> returns S_OK. Otherwise, an error code is returned as an
///    HRESULT.
///    
@DllImport("Windows")
HRESULT SetSocketMediaStreamingMode(BOOL value);

///The <b>WSCWriteProviderOrder</b> function is used to reorder the available transport providers. The order of the
///protocols determines the priority of a protocol when being enumerated or selected for use.
///Params:
///    lpwdCatalogEntryId = A pointer to an array of <b>CatalogEntryId</b> elements found in the WSAPROTOCOL_INFO structure. The order of the
///                         <b>CatalogEntryId</b> elements is the new priority ordering for the protocols.
///    dwNumberOfEntries = The number of elements in the <i>lpwdCatalogEntryId</i> array.
///Returns:
///    The function returns <b>ERROR_SUCCESS</b> (zero) if the routine is successful. Otherwise, it returns a specific
///    error code. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEINVAL</b></dt> </dl> </td> <td width="60%"> One or more of the arguments are invalid, no action was
///    taken. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> A
///    nonrecoverable error occurred. This error is returned under several conditions including the following: the user
///    lacks the administrative privileges required to write to the Winsock registry, or a failure occurred when opening
///    or writing a catalog entry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl>
///    </td> <td width="60%"> Insufficient memory was available. This error is returned when there is insufficient
///    memory to allocate a new catalog entry. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>(other)</b></dt> </dl>
///    </td> <td width="60%"> The routine may return any registry error code. </td> </tr> </table>
///    
@DllImport("WS2_32")
int WSCWriteProviderOrder(uint* lpwdCatalogEntryId, uint dwNumberOfEntries);

///The <b>WSCWriteNameSpaceOrder</b> function changes the order of available Windows Sockets (Winsock) 2 namespace
///providers. The order of the namespace providers determines the priority of the namespace when enumerated or queried
///for name resolution.
///Params:
///    lpProviderId = An array of <b>NSProviderId</b> elements as found in the WSANAMESPACE_INFOstructure. The order of the
///                   <b>NSProviderId</b> elements is the new priority ordering for the namespace providers.
///    dwNumberOfEntries = The number of elements in the <b>NSProviderId</b> array.
///Returns:
///    The function returns <b>ERROR_SUCCESS</b> (zero) if the routine is successful. Otherwise, it returns a specific
///    error code. <table> <tr> <th>Error code</th> <th>Meaning</th> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>WSAEFAULT</b></dt> </dl> </td> <td width="60%"> The <b>NSProviderId</b> array is not fully contained
///    within process address space. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSAEINVAL</b></dt> </dl> </td> <td
///    width="60%"> One or more of the arguments are input parameters were invalid, no action was taken. </td> </tr>
///    <tr> <td width="40%"> <dl> <dt><b>WSANO_RECOVERY</b></dt> </dl> </td> <td width="60%"> A nonrecoverable error
///    occurred. This error is returned under several conditions including the following: the user lacks the
///    administrative privileges required to write to the Winsock registry or another application is currently writing
///    to the namespace provider catalog. </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSASYSCALLFAILURE</b></dt> </dl>
///    </td> <td width="60%"> A system call that should never fail has failed. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b> WSATRY_AGAIN</b></dt> </dl> </td> <td width="60%"> The function is called by another thread or process.
///    </td> </tr> <tr> <td width="40%"> <dl> <dt><b>WSA_NOT_ENOUGH_MEMORY</b></dt> </dl> </td> <td width="60%">
///    Insufficient memory was available to perform the operation. </td> </tr> <tr> <td width="40%"> <dl>
///    <dt><b>(other)</b></dt> </dl> </td> <td width="60%"> The function may return any registry error code. </td> </tr>
///    </table>
///    
@DllImport("WS2_32")
int WSCWriteNameSpaceOrder(GUID* lpProviderId, uint dwNumberOfEntries);


